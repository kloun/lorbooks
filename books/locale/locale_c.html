<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>Locale &quot;AS IT IS&quot; - Chars</title>
</head>

<body bgcolor="#FFFFFF">

<h1>Языки, символы и кодировки.</h1>

<p align="right"><i>Here is the whole set! a character dead at every word. </i><br>
- Richard Brinsley Sheridan, The School for Scandal,&nbsp;&nbsp;&nbsp;&nbsp; <br>
Act 2, scene 2&nbsp;&nbsp;&nbsp;&nbsp; </p>

<ol>
  <li><a href="locale_c.html#lang">Language</a></li>
  <li><a href="locale_c.html#char">Character</a></li>
  <li><a href="locale_c.html#enc">Encoding</a></li>
  <li><a href="locale_c.html#sets">CharSet</a></li>
  <li><a href="locale_c.html#std">Standarts</a></li>
  <li><a href="locale_c.html#posix">POSIX</a></li>
</ol>

<hr>

<h2><a name="lang"></a>Language</h2>

<p>&nbsp;&nbsp;&nbsp; Информация, полученная из
&quot;человеческого&quot; мира и предназначенная для
машинной обработки, как правило имеет
специальный арибут&nbsp; : <strong>язык</strong> или<strong> <strong>language
(lang)</strong></strong>. Причем, не только текстовая, но
например <strong>audio</strong> :</p>

<pre>Content-Description: Russian Argo audio sample :-)
Content-Type: audio/basic
Content-Language: ru</pre>

<p>(<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1766.html">RFC-1766</a>, <a href="http://www.unicode.org/unicode/onlinedat/languages.html">ISO-639</a>)</p>

<p>&nbsp;&nbsp;&nbsp; Однако нас инересует именно <strong>текстовая</strong>
информация.</p>

<p>&nbsp;&nbsp;&nbsp; Большинство языков мира имеют <strong>письменнось</strong>,
а некоторые языки даже несколько (например
кириллица и глаголица для славянских языков или
kana и kanji в японском и т.д.). Определенная <strong>система
письменности</strong> называется <strong>script</strong>.
Системы письменности существуют самые
разнообразные (например узелковое :-), но
большинство письменностей - это <strong>изображение</strong>
последовательности специальных <strong>символов</strong>
(<strong>character</strong>).</p>

<hr>

<p>* ПРИМЕЧАНИЕ : Объяснение концепции <strong>символа</strong>
выходит далеко за рамки данного документа. Мы не
будем вдаваться в филологические и философские
подробности, а рассмотрим лишь узкий аспект --
способы представления <strong>символов</strong>
(национального) языка для автоматической
(машинной) обработки. Тогда термин <strong>&quot;символ&quot;
(character</strong>) можно определить как <strong>&quot;единицу
текстовой информации&quot; (unit of textual information), </strong>которая
передается письменно и участвует в машинной
обрабоке. Очень важно четко представлять себе,
что речь идет об<strong> &quot;абстрактном&quot;</strong>
символе.</p>

<hr>

<h2><a name="char"></a>Character</h2>

<p>&nbsp;&nbsp;&nbsp; Каждый &quot;абстрактный&quot; символ
имеет изображение -- <strong>glyph</strong>. Считается, что
каждый символ имеет &quot;каноническое&quot;
изображение , то есть такое, которое позволяет <strong>однозначно</strong>
идентифицировать данный символ, то есть
распознать и отличить его от других. Таким
образом, в модели <strong>POSIX</strong> и <strong>UNICODE</strong> не
уделяется <strong>никакого</strong> внимания <strong>вариантам
начертания</strong> символа, то есть шрифтам (<strong>fonts</strong>)
во всем их многообразии, . Поэтому все, что
изображено на примере ниже, будет одним и тем же
&quot;абстрактным&quot; символом&nbsp; :<br>
ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА А&nbsp;&nbsp;&nbsp; (LATIN CAPITAL
LETTER A):</p>

<p align="center"><img src="http://www.linux.org.ru/books/images/a-chars.gif" width="300" height="50" alt="A a A a A a" border="0"></p>

<p>&nbsp;&nbsp;&nbsp; В стандарте <strong>UNICODE</strong> каждому
определенному символу присвоено определенное <strong>имя</strong>
и <strong>номер</strong> :</p>

<table border="1" width="581">
  <tr>
    <th width="86">&nbsp;</th>
    <th width="145">UNICODE</th>
    <th width="619">Character Name</th>
  </tr>
  <tr>
    <td width="86" align="center">A</td>
    <td width="145" align="center">U+0041</td>
    <td width="619">LATIN CAPITAL LETTER A</td>
  </tr>
  <tr>
    <td width="86" align="center">a</td>
    <td width="145"><p align="center">U+0061</td>
    <td width="619">LATIN SMALL LETTER A</td>
  </tr>
  <tr>
    <td width="86" align="center">Ю</td>
    <td width="145"><p align="center">U+042E</td>
    <td width="619">CYRILLIC CAPITAL LETTER YU</td>
  </tr>
  <tr>
    <td width="86" align="center">1</td>
    <td width="145"><p align="center">U+0031</td>
    <td width="619">DIGIT ONE</td>
  </tr>
  <tr>
    <td width="86" align="center">+</td>
    <td width="145"><p align="center">U+002B</td>
    <td width="619">PLUS SIGN</td>
  </tr>
  <tr>
    <td width="86" align="center"><img src="http://www.linux.org.ru/books/images/ku.gif" width="16" height="16" alt="O" border="0"></td>
    <td width="145"><p align="center">U+03A9</td>
    <td width="619">GREEK CAPITAL LETTER OMEGA</td>
  </tr>
  <tr>
    <td width="86"><p align="center"><img src="http://www.linux.org.ru/books/images/boxd.gif" width="16" height="16" alt="boxd.gif (862 bytes)"></td>
    <td width="145"><p align="center">U+2569</td>
    <td width="619">BOX DRAWINGS DOUBLE UP AND HORIZONTAL</td>
  </tr>
  <tr>
    <td width="86">&nbsp;</td>
    <td width="145">&nbsp;</td>
    <td width="619">и так далее.</td>
  </tr>
</table>

<p>&nbsp;&nbsp;&nbsp; В настоящее время в стандарт <strong><a href="http://www.linux.org.ru/books/unicode/index.html">UNICODE</a></strong>, входят практчески
все употребимые символы (~40.000), и им
соответственно присвоены стандартные имена.
Последнее значительное изменение -- введение
символа валюты EURO в сентябре 1998 г.</p>

<p>&nbsp;&nbsp;&nbsp; Посмотреть набор символов <strong>UNICODE</strong>
можно здесь : <a href="http://charts.unicode.org/">http://charts.unicode.org/</a>
.</p>

<p>&nbsp;&nbsp;&nbsp; Таким образом, для нас <strong>символ</strong>
(<strong>character</strong>) - это единица тектовой
информации, имеющая определенное изображение и
определенное имя.</p>

<hr>

<h2><a name="enc"></a>Encoding.</h2>

<p>&nbsp;&nbsp;&nbsp; Наиболее важным понятием при
обработке символов является понятие <strong>Coded
Character Set</strong> (<strong>CCS</strong>).</p>

<p>&nbsp;&nbsp;&nbsp; Давайте попробуем разобраться, что
это такое.</p>

<p>&nbsp;&nbsp;&nbsp; Как мы уже ранее выяснили, существуют
определенные &quot;наборы символов&quot; для каждого
конкретного языка (алфавит). Набор таких
&quot;абстрактных&quot; символов называется <strong>character
repertoire</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; Для автоматической обработки,
хранения и передачи символов необходимо каждый
&quot;абстрактный&quot; символ перевести в числовую
форму для размещения в ячейках ЭВМ.</p>

<p>&nbsp; C &quot;программистской&quot; точки зрения это
задача совершенно тривиальна. Нужно просто
присвоить каждому <strong>символу</strong>
(абстрактному !) определенное <strong>число</strong>,
которое и хранить в памяти ЭВМ, то есть <strong>закодировать</strong>
символ. Другими словами, определить схему
кодирования : <strong>CES &quot;character encoding scheme&quot;</strong>.
Например, условимся, что символу 'A' - LATIN CAPITAL LETTER A
соответствует число (код) 61. И наоборот, условимся
, что число (integer) 61 будет означать ни что иное, как
символ 'A'. Таким образом образуется <strong>пара</strong>
(61, 'A') код - символ. И наоборот, символ - код.
Соответствие однозначное.</p>

<p>&nbsp;&nbsp;&nbsp; Пусть у нас теперь есть <strong>набор</strong>
символов : <strong>character repertoire</strong> {'A','B','C'} (это
маленькое подмножество символов латинского
алфавита). Продолжим кодирование. Тогда из этого
множества {'A','B','C'} у нас образуется <strong>множество
пар</strong> : {(61,'A'),(62,'B'),(63,'C')}.</p>

<p>&nbsp;&nbsp;&nbsp; А теперь внимание ! Вот это самое
пресловутое &quot;множество пар&quot; имеет
колоссальное значение ! Формально оно называется
<strong>CCS : coded character set</strong>. Именно ему присваивается
<strong>имя</strong> : <strong>ASCII</strong>, <strong>ISO_8859-5</strong> или <strong>KOI8-R</strong>
! Перечитать еще раз !</p>

<p>&nbsp;&nbsp;&nbsp; Давайте рассмотрим подробнее. Итак :</p>

<table border="1">
  <tr>
    <td>'A'</td>
    <td>- это абстрактный символ, &quot;character&quot;</td>
  </tr>
  <tr>
    <td>набор символов {'A','B','C'}</td>
    <td>- &quot;character repertoire&quot;</td>
  </tr>
  <tr>
    <td>соответствие : символ 'A' &lt;--&gt; число 61 </td>
    <td>- это <strong>CES &quot;character encoding scheme</strong>&quot;, или
    просто <strong>encoding</strong></td>
  </tr>
  <tr>
    <td>число 61</td>
    <td>- это &quot;code point&quot;.</td>
  </tr>
  <tr>
    <td>набор чисел {61,62,63}</td>
    <td>- это &quot;codeset&quot; или &quot;code space&quot;.</td>
  </tr>
  <tr>
    <td>набор пар {(61,'A'),(62,'B'),(63,'C')}</td>
    <td>- это <strong>CCS</strong> &quot;<strong>coded character set</strong>&quot;, или
    сокращенно <strong>charset.</strong></td>
  </tr>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Что собой представляет <strong>CCS</strong>
?</p>

<p>&nbsp;&nbsp;&nbsp; Фактически, <strong>CCS</strong> можно
рассматривать как <strong>базу данных</strong>, в
которой хранятся a)<strong>символы</strong>, b)<strong>коды</strong>
и c)<strong>схема</strong> <strong>соответствия</strong>
символов и кодов (<strong>CES</strong> - <strong>character encoding scheme</strong>)
например в виде обычной таблицы - map (<strong>charmap</strong>).
Тогда допустимы операции :</p>

<pre>CES('A')=61
CES(61)='A'</pre>

<p>&nbsp;&nbsp;&nbsp; Фактически это будет обозначать
операции выборки из &quot;базы&quot; :</p>

<pre>SELECT CODE FROM CCS WHERE CHAR='A'
SELECT CHAR FROM CCS WHERE CODE=61</pre>

<p>&nbsp;&nbsp;&nbsp; Естественно, <strong>CCS</strong>-ов
существует огромное множество : <strong>ASCII</strong>, <strong>KOI8-R</strong>,
<strong>ISO_8859-1</strong> или даже <strong>UNICODE</strong>. И конечно
же каждому <strong>CCS</strong> соответствует его
специфицеская <strong>CES</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; Как работает <strong>CCS</strong> ?</p>

<p>&nbsp;&nbsp;&nbsp; Очень просто. Пусть у нас есть <strong>поток
символов</strong> (&quot;абстрактных&quot;) : &quot;ABBACABCC&quot;.
Тогда применение <strong>CCS</strong> к этому потоку
(тексту) &quot;ABBACABCC&quot; будет равно применению его <strong>CES</strong>
к <u><strong>каждому</strong></u> символу в потоке :<br>
CES('A') CES('B') CES('B') CES('A')...<br>
и мы получим <strong>поток чисел</strong> (кодов) : 61 62 62 61
63 61 62 63 63.<br>
Аналогично, применение <strong>CCS</strong> к потоку кодов
даст поток &quot;абстрактных символов&quot;.</p>

<p>&nbsp;&nbsp;&nbsp; Отсюда следует один очень простой
вывод : при хранении текста (потока символов) мы <u><strong>должны</strong></u>
также хранить <strong>CCS</strong> ! А вот где его хранить -
это вопрос. Можно в том же потоке ( &quot;In-band&quot; или
&quot;MARK-UP&quot; способ). Можно где-то снаружи потока
(&quot;Out-band&quot; способ). Можно хранить лишь имя
(ссылку на) <strong>CCS</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; К сожалению, в стандартном <strong>POSIX</strong>
(например на <strong>stdin/stdout</strong>) мы имеем <u><strong>только</strong></u>
потоки кодов. А вся информация о <strong>CCS</strong>
потеряна. Подробнее про это можно прочитать в&nbsp; <a href="locale_io.html">статье</a> о локализации <strong>POSIX</strong>.</p>

<hr>

<h2><a name="sets"></a>СharSets</h2>

<p>&nbsp;&nbsp;&nbsp; Давайте теперь рассмотрим
собственно наборы символов (<strong>character set</strong>).
Первое что мы должны сделать - это обратить
внимание на терминологию. Если мы говорим о
наборе &quot;абстрактных&quot; символов, то
употребляется термин <strong>character repertoire</strong>. Если
же мы говорим о наборе <strong>символов</strong> вместе с
их <strong>кодами</strong> и <strong>схемой преобразования</strong>
символ&lt;--&gt;код, то речь идет о <strong>CCS</strong> : <strong>coded
character set</strong>. Именно этому набору : <strong>coded character set</strong>
и присваивается <strong>имя</strong> : <strong>KOI8-R</strong>,<strong>
ISO_8859-1</strong>,<strong> ASCII</strong>. Иногда термин <strong>CCS</strong>
сокращают до <strong>сharset</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; Так например в стандарте <strong>MIME</strong>
употребляется термин <strong>сharset</strong>, хотя
подразумевается конечно же <strong>CCS</strong>:<strong><br>
Content-Type: text/plain; charset=koi8-r<br>
Content-Type: text/plain; charset=Windows-1251</strong><br>
<strong>Content-Type: text/plain; charset=ibm-866</strong></p>

<p>&nbsp;&nbsp;&nbsp; Как определяется <strong>character repertoire</strong>
для определенного <strong>charset</strong> ?</p>

<p>&nbsp;&nbsp;&nbsp; Чаще всего набор символов
определяется из <strong>языка</strong> (<strong>lang</strong>) и
соответствующей ему системы письменности (<strong>script</strong>).
Иногда рассматривается набор символов,
воспризводимый конкретной аппаратурой (
например DEC VT-100 Character Set).</p>

<p>&nbsp;&nbsp;&nbsp; Иногда конкретный набор символов
является <strong>подмножеством</strong> другого, более
обширного набора символов или же <strong>комбинацией</strong>
нескольких наборов (или их частей). Например,
широко распространенный набор символов для
представления русского языка : <strong>KOI8-R</strong>,
содержит в себе символы из наборов LATIN, CYRILLIC, BOX
DRAWING, BLOCK ELEMENT и т.д.. А конкурирующий с ним <strong>charset</strong>
- <a href="other/win1251.html">Windows-1251</a> содержит больше
символов из набора CYRILLIC (русские, украинские,
белорусские), но меньше - из BOX и BLOCK. Кроме того в <strong>KOI8-R</strong>
нет например символа EURO.</p>

<p align="center"><img src="http://www.linux.org.ru/books/images/koi8-r.gif" width="464" height="245" alt="koi8-r.gif (8338 bytes)"><br>
Старшая половина <strong>charset</strong> (<strong>CCS</strong>) <a href="other/koi8-r.html">KOI8-R</a> и <strong>code points</strong> символов.<br>
Младшая половина совпадает с US-ASCII.<br>
(см. также описние <a href="other/koi8-r.html">KOI8-R</a> в формате
POSIX.)</p>

<p>&nbsp;&nbsp;&nbsp; Существует<strong> минимальный</strong>
(переносимый) (<strong>POSIX</strong>)<strong> <a href="http://www.linux.org.ru/books/man/man_b/p_charset.html">Portable Charset</a></strong> - набор
символов, который должны поддерживать любые
информационные системы (определен в стандарте <strong>ISO
646</strong>) (он же <a href="http://czyborra.com/charsets/iso646.html">ASCII</a>). С
другой стороны, существует также
&quot;универсальный&quot; <strong>Universal Character Set</strong> (UCS, <a href="http://www.linux.org.ru/books/unicode/index.html">UNICODE</a>) включающий в себя <strong>все</strong>
возможные символы человеческих языков,
технические, картографические и т.д. символы (~40.000
символов) (<strong>ISO 10646</strong>). Также, для примера,
можно упомянуть один из довольно широко
распространенных наборов символов : <a href="other/latin1.html">LATIN-1</a> (Czyborra <a href="http://czyborra.com/charsets/iso8859.html">ISO 8859-1</a>).</p>

<p>&nbsp;&nbsp;&nbsp; Каждый <strong>charset</strong> имеет
определенное <a href="other/charsets.html"><strong>имя</strong></a>.</p>

<p>&nbsp;&nbsp;&nbsp; Теперь насчет <strong>кодирования</strong>.
Каким образом выбирается <strong>CES</strong> ?</p>

<p>&nbsp;&nbsp;&nbsp; Выполнить &quot;кодирование&quot; (encoding)
довольно легко как для латинских так и для всех (?)
индоевропейских языков (фонетическое письмо).
Действительно, закодировать 26 латинских (<strong><strong>ASCII</strong></strong>)
или 33 <a href="http://www.linux.org.ru/books/lang/russian/index.html">русских</a> буквы не
составляет труда (даже в варианте заглавных и
прописных, плюс цифры, плюс знаки препинания).
Количество символов (<strong>character repertoire</strong>) мало,
соответственно не велико и <strong>code space</strong> и
получается меньше <strong>256 сode points</strong>, что
позволяет уместить их в один <strong>байт</strong> (<strong>2^8=256</strong>
различных кодовых позиций).</p>

<p>&nbsp;&nbsp; Для языков, чья письменность построена
по идеографическому (иероглифическому) принципу,
ситуация несколько сложнее. Например в
современном <a href="http://www.iae.nsk.su/~koles/jap/">японском</a> <strong>1850</strong>
&quot;официальных&quot; иероглифов, тогда как в
китайском их число доходит до <strong>5000</strong>. Одного
байта мало. Необходимы обширные <strong>CCS</strong>,
например <strong>EUC-JP</strong> или <strong>UNICODE</strong>. Для
поддержки таких языков в <strong>POSIX</strong> введены
механизмы <strong>Multibyte</strong> и <strong>Wide Class chars</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; В настоящее время в подавляющем
большинстве <strong>charset</strong>-ов применяется 8-ми
битное (байтовое) кодирование. Все настолько к
этому привыкли, что <strong>charset</strong>-ы c большим
количеством символов (&gt;256) иногда называют <strong>large
charset</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; Проблемы могут возникнуть лишь при
необходимости создания <strong>многоязычных</strong>
текстов, например русско-японско-английских, или
содержащих русский и иврит, e.t.c. В этом случае -
практически единственное решение : <a href="http://www.linux.org.ru/books/unicode/index.html">UNICODE</a>.</p>

<p>&nbsp;&nbsp;&nbsp; Также проблемы возникают в том
случае, если заранее <strong>неизвестна</strong>
кодировка текста (потеряна <strong>CES</strong>), так как в <strong>UNIX</strong>,
да и в других OS <a href="locale_io.html#file">файл</a> не имеет
никаких дополнительных атрибутов. Это также
актуально для <strong>HTTP</strong>, в том случае, если
кодировка (<strong>CES</strong>) файла .HTML неизвестна. Это
довольно неудобно, поскольку часто единственный
способ - это <strong>подбор</strong> подходящей
кодировки... Вывод : указывать кодировку <font color="#FF0080"><strong>необходимо</strong></font>.</p>

<hr>

<h2><a name="std"></a>Standarts</h2>

<p>&nbsp;&nbsp;&nbsp; Существует несколько стандартов
описания <strong>сharset</strong> и способов их кодирования
: 

<ul>
  <li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1345.html">RFC-1345</a> Character
    Mnemonics &amp; Character Sets</li>
  <li><a href="http://www.linux.org.ru/books/man/man_b/charset.html"><strong>POSIX</strong> Character Set Definition File</a></li>
  <li>ISO 2022</li>
  <li><strong>ISO</strong> 9945-2</li>
  <li><strong>UNICODE</strong> (ISO10646) UCS-2, UTF-7, UTF-8</li>
  <li>(???)</li>
</ul>

<p>&nbsp;&nbsp;&nbsp; Описание наборов символов <a href="other/koi8-r.html">KOI8-R</a>, <a href="other/win1251.html">CP1251</a>, <a href="other/ibm866.html">IBM866</a> в формате <strong>POSIX</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; Что касается <strong>имен</strong>
зарегистрированных <strong>Charset</strong>-ов, то смотри <a href="other/charsets.html">здесь</a>.</p>

<hr>

<h2><a name="posix"></a>POSIX</h2>

<p>&nbsp;&nbsp;&nbsp; Сначала - немного <a href="locale_p.html#critique">критики</a>...&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp; Теперь по делу.</p>

<p>&nbsp;&nbsp;&nbsp; Кроме установки разных значений
локализации <strong>en_US</strong> или <strong>ru_RU</strong> в
системе <strong>POSIX</strong> могут употребляться и
разничные значения <strong>Charset</strong>-а, например <strong>ru_RU.KOI8-R</strong>
и <strong>ru_RU.ISO8859-5</strong>.</p>

<p>&nbsp;&nbsp;&nbsp; Для установки в <strong>POSIX</strong>-системе
новой <strong>locale</strong> c другим набором символов (<strong>charset</strong>)
применяется утилита <em><a href="http://www.linux.org.ru/books/man/man1/localedef.html">localedef</a>
</em>для&nbsp; компиляции Файла Описания Локализации
и Файла Описания Набора Символов (<a href="http://www.linux.org.ru/books/man/man_b/charset.html">Character Set Description File</a>).</p>

<pre><strong>$ localedef -c -i ru_RU -f KOI8-R ru_RU.KOI8-R</strong></pre>

<p>&nbsp;&nbsp;&nbsp; Для проверки установленных в <strong>POSIX</strong>-системе
<strong>charset</strong>-ов применяется утилита<a href="http://www.linux.org.ru/books/man/man1/locale.html"><em> locale</em></a> :</p>

<pre><strong>$ locale -m
$ locale charmap</strong></pre>

<p>&nbsp;&nbsp;&nbsp; Для преобразования потока символов
из одного <strong>charset</strong> в другой, в стандарте <strong>POSIX</strong>
существуют утилита <em><a href="http://www.linux.org.ru/books/man/man1/iconv.html">iconv</a></em>&nbsp;и&nbsp;функция
<a href="http://www.linux.org.ru/books/man/man3/iconv.html"><em>iconv()</em></a>.</p>

<p>&nbsp;&nbsp;&nbsp; В системе <a href="http://plan9.bell-labs.com/plan9/">Plan 9</a>
существует утилита <strong>tcs</strong>.</p>

<hr>

<p>&nbsp;&nbsp;&nbsp; <a href="locale_i.html#chars">Дополнительная
информация.</a></p>

<hr>

<p>Содержание <a href="http://www.sensi.org/~alec/locale/index.html#toc">&quot;Locale
AS IT IS&quot;</a> </p>

<hr>

<h6><em>Last change : <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d-%m-%Y" startspan -->13-11-2000<!--webbot bot="Timestamp" endspan i-checksum="12435" --></em></h6>
</body>
</html>
