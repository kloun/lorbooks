<title>Дополнительные возможности</title>
<?php include("/home/maxcom/linux_html/books/head.php3") ?>
<h1>5 <a name="s5"> Дополнительные возможности </h1>
<p> <a href="lig.html#toc5"> Содержимое этого раздела</a></p>

<p>Эта глава познакомит вас с некоторыми из наиболее интересных
возможностей Linux.
Это предполагает, что вы имеете как минимум начальные знания UNIX
и поняли информацию, содержащуюся в предыдущих разделах.</p>
<p></p>
<p>Наиболее важным аспектом Linux, который отличает его от других
реализаций UNIX является его открытая концепция разработки.</p>
<p>Linux не разрабатывался небольшой группой программистов, возглавляемой
коммерческой структурой с целью получения прибыли.</p>
<p>Он разрабатывался постоянно растущей группой хакеров,
вносящих то что им нравится в домашнее варево UNIX.</p>
<p>Linux включает в себя огромное количество разнообразного
как по типу так и по способам разработки программного
обеспечения.
Некоторым не нравится недостаток единобразия, некоторые считают
его основным преимуществом Linux.</p>
<p></p>
<p></p>
<h2>5.1 <A Name="ss5.1"> X Window </h2>

<p>X-Window является большой, мощной (и отчасти сложной)
графической средой для UNIX систем.
Система X-Window была разработана в Массачусетстком
технологическом институте (MIT), которая стала затем
стандартом для всех UNIX систем.
Практически каждая рабочая станция UNIX в мире работает
на одном из вариантов X-Window.</p>
<p></p>
<p>Группа программистов, возглавляемая Дэвидом Вексельблатом
(David Wexelblat ),
<sl>(Вы можете связаться с Девидом
по E-Mail: dwex@XFree86.org
)</sl>

произвела перенос  MIT  X Window  System
версия 11, релиз 6 (X11R6) для 80386/80486/Pentium UNIX систем
как свободно распространяемого программного продукта.
Эта версия, известная как XFree86 <F>TM</F>,
<sl>(XFree86 является торговой маркой XFree86 Project, Inc.)</sl>

доступна для
System V/386, 386BSD и других реализаций UNIX для процессоров x86,
включая Linux. Она включает в себя все требуемые выполняемые коды,
конфигурационные файлы, библиотеки и инструментарий.</p>
<p></p>
<p>Полная настройка и использование X Window выходит за пределы этой книги.
Вам следует обратиться к книге :
<em>The X Window System: A User's Guide </em>(см. Приложение A)
В этой главе мы опишем шаг за шагом установку и настройку XFree86 для
Linux. Для более детального ознакомления вы можете обратиться
к документации, поставляемой вместе с XFree86 (она обсуждается ниже).
Другим полезным источником информации является
<em>THE LINUX XFree86 HOWTO</em>.</p>
<p></p>
<p></p>
<h2>5.1.1 <A Name="ss5.1.1"> Требования к аппаратуре </h2>

<p>XFree86 версии 3.1, вышедшая в сентябре 1994, года поддерживает
следующие микросхемы видеоадаптеров.
(Прежде чем устанавливать XFree86 вам надо выяснить тип
микросхемы вашего видеоадаптера.)</p>
<p>Документация, поставляемая
вместе с видеоадаптером, как правило указывает тип используемых
микросхем. Если вы приобрели новую видеокарту или новый
компьютер, попросите поставщика уточнить изготовителя,
модель и тип микросхем видеокарты. Как правило поставщики
охотно дадут вам эту информацию. Большинство из них
сообщит, что видеокарта является стандартной SVGA картой
и будет работать в вашей операционной системе.
Об'ясните им, что ваше программное обеспечение (Linux и XFree86)
не поддерживает всех видеокарт и вам требуется дополнительная информация.</p>
<p></p>
<p>Вы можете также определить тип микросхемы, вызвав команду
<code>SuperProbe</code>, входящую в состав XFree86. Это будет описано ниже.</p>
<p></p>
<p></p>
<p>XFree86 версии 3.1, вышедшая в сентябре 1994 года поддерживает
следующие типы микросхем:
<ul>
<li>Tseng ET3000, ET4000AX, ET4000/W32
</li>
<li>Western Digital/Paradise PVGA1
</li>
<li>Western Digital  WD90C00, WD90C10, WD90C11,WD90C24,WD90C30, WD90C31, WD90C33
</li>
<li>Genoa GVGA
</li>
<li>Trident TVGA8800CS,  TVGA8900B, TVGA8900C,  TVGA8900CL,  TVGA9000,
TVGA9000i, TVGA9100B, TVGA9200CX, TVGA9320, TVGA9400CX, TVGA9420
</li>
<li>ATI 18800, 18800-1, 28800-2,  28800-4, 28800-5, 28800-6,  68800-3,
68800-6, 68800AX, 68800LX, 88800
</li>
<li>NCR 77C22, 77C22E, 77C22E+
</li>
<li>Cirrus Logic  CLGD5420, CLGD5422,  CLGD5424,  CLGD5426,  CLGD5428,
CLGD5429,  CLGD5430,  CLGD5434,   CLGD6205,  CLGD6215,   CLGD6225,
CLGD6235, CLGD6420
</li>
<li>Compaq AVGA
</li>
<li>OAK OTI067, OTI077
</li>
<li>Avance Logic AL2101
</li>
<li>MX MX68000, MX680010
</li>
<li>Video 7/Headland Technologies HT216-32</li>
</ul>
</p>
<p>Поддерживаются также следующие адаптеры с графическими ускорителями:
<ul>
<li>8514/A (and true clones)
</li>
<li>ATI Mach8, Mach32
</li>
<li>Cirrus CLGD5420, CLGD5422, CLGD5424, CLGD5426, CLGD5428, CLGD5429,
CLGD5430, CLGD5434, CLGD6205, CLGD6215, CLGD6225, CLGD6235
</li>
<li>S3 86C911, 86C924, 86C801, 86C805, 86C805i, 86C928, 86C864, 86C964
</li>
<li>Western Digital WD90C31, WD90C33
</li>
<li>Weitek P9000
</li>
<li>IIT AGX-014, AGX-015, AGX-016
</li>
<li>Tseng ET4000/W32, ET4000/W32i, ET4000/W32p</li>
</ul>
</p>
<p></p>
<p>Видеокарты с этими микросхемами поддерживаются для всех системных шин,
включая VLB и PCI.</p>
<p></p>
<p>Все вышеперечисленные карты поддерживаются как в режиме 256 цветов,
так и в монохромном режиме, за исключением Avance Logic, MX and Video 7
микросхем, которые поддерживаются только в режиме 256 цветов.
Если на вашей видеокарте установлено достаточно видеопамяти,
многие из микросхем поддерживются в режиме 16 и 32 бита на точку
(65 тысяч и 4 млн цветов) (некоторые из Msch32, P9000, S3 и Cirrus
видеокарт).
Обычно видеокарты используются в режиме 8 бит на точку (256 цветов).</p>
<p></p>
<p>Монохромный сервер поддерживает основные карты VGA,
монохромные карты Hercules, Hyundai  HGC1280, Sigma LaserView
иу Apoll.
На карте Compaq  AVGA в монохромном режиме поддерживается только
64Кб видеопамяти и
работа карты GVGA с памятью более 64Кб не проверена
в настоящее время.</p>
<p></p>
<p>Этот список несомненно расширится со временем.
Полный список поддерживаемых карт вы найдете в замечаниях
к текущей версии XFree86.</p>
<p></p>
<p>Одной из проблем, с которой столкнулись разработчики,
являлся нестандартный механизм определения частоты,
используемый для управления картой.
Некоторые производители либо не описывали способ
программирования карты, либо требовали подписания дополнительного
соглашения о нераспространении полученной информации.
Это очевидно ограничило бы свободное распространение
XFree86, чего естественно не могли допустить разработчики.
Долгое время данная проблема была с видеокартами,
производимыми фирмой Diamond, но начиная с версии 3.1 XFree86,
Diamond начала сотрудничество с разработчиками с целью
выпуска драйвера для этой карты.</p>
<p></p>
<p>Предполагаемая конфигурация компьютера для установки XFree86
под Linux включает в себя как минимум 8 мегабайт оперативной
памяти и видеокарту с одной из вышеперечисленных микросхем.
Для оптимальной работы мы советуем использовать
видеокарту с графическим ускорителем, например S3.</p>
<p>Перед покупкой дорогостоящей видеокарты вам следует
просмотреть документацию по XFree и убедиться, что выбранная вами
карта поддерживается.
Сравнительные тесты Benchmark для различных видеокарт под XFree86
периодически выставляются в конференции
<code>comp.windows.x.i386unix</code> и <code>comp.os.linux.misc</code>.</p>
<p></p>
<p>Замечу, что мой персональный компьютер с Linux содержит
486DX2-66,  20 мегабайт RAM, и имеет
VLB S3-864  видеоадаптер с 2 мегабайтами оперативной памяти.
Я протестировал X benchmarks на этой машине и на рабочей станции
Sun Sparc IPX.
Linux где-то раз в 7 быстрее, чем Sparc IPX (для любопытных,
XFree86-3.1 под Linux обеспечил скорость 171,000 xstones;
Sparc IPX - около 24000).
Обычно, XFree86 под Linux с графическим ускорителем
показывает существенно  большую производительность
чем коммерческие рабочие станции (которые обычно используют
неэффективные алгоритмы обработки графической информации).</p>
<p></p>
<p>Для вашей машины требуется как минимум 4 мегабайта оперативной памяти
и 16 мегабайт виртуальной (например, 8 мегабайт оперативной памяти
и 8 мегабайт своппинга).
Имейте в виду, что чем больше физической оперативной памяти вы имеете,
тем меньше операционная система использует своппинг.
Так как операция своппинга исходно медленная (доступ к диску намного
медленнее, чем к памяти), для комфортабельной работы вам следует
иметь 8 или более мегабайт.
Система с 4-мя мегабайтами работает намного (в десятки раз)
медленнее чем с 8-ю мегабайтами.</p>
<p></p>
<p></p>
<h2>5.1.1.1 <A Name="ss5.1.1.1"> Установка XFree86 </h2>

<p>Дистрибутив Xfree86 в выполняемых кодах можно найти на целом ряде
FTP-серверов. На <code>sunsite.unc.edu</code> он находится в каталоге
<code>/pub/Linux/X11</code>. (На момент написания текущая версия была 3.1;
периодически появляются новые версии).</p>
<p>Вполне возможно, что вы имеете XFree86 как часть дистрибутива Linux,
в этом случае в перекачке XFree86 нет необходимости.</p>
<p>Если же вы собираетесь скачать XFree с FTP-сервера,
следующая таблица содержит список файлов в дистрибутиве  XFree86-3.1.</p>
<p>Вам потребуется один из серверов:
<blockquote><code>
<pre>
     Файл                    Описание

     XF86-3.1-8514.tar.gz    Сервер для 8514 видеокарт.
     XF86-3.1-AGX.tar.gz     Сервер для AGX видеокарт.
     XF86-3.1-Mach32.tar.gz  Сервер для Mach32 видеокарт.
     XF86-3.1-Mach8.tar.gz   Сервер для Mach8 видеокарт.
     XF86-3.1-Mono.tar.gz    Сервер для монохромного режима.
     XF86-3.1-P9000.tar.gz   Сервер для P9000 видеокарт.
     XF86-3.1-S3.tar.gz      Сервер для S3 видеокарт.
     XF86-3.1-SVGA.tar.gz    Сервер для Super VGA видеокарт.
     XF86-3.1-VGA16.tar.gz   Сервер для VGA/EGA видеокарт.
     XF86-3.1-W32.tar.gz     Сервер для ET4000/W32 видеокарт.

  все нижеперечисленные файлы:

     Файл                    Описание

     XF86-3.1-bin.tar.gz     Остальные программы X11R6.
     XF86-3.1-cfg.tar.gz     Конфигурационные файлы для xdm, xinit и fs.
     XF86-3.1-doc.tar.gz     Документация и руководства.
     XF86-3.1-inc.tar.gz     Include файлы. (?)
     XF86-3.1-lib.tar.gz     Разделяемые библиотеки.
     XF86-3.1-fnt.tar.gz     Основные фонты.

  следующие файлы не являются обязательными:

     Файл                    Описание

    XF86-3.1-ctrb.tar.gz     Выбранные дополнительные программы (?).
    XF86-3.1-extra.tar.gz    Дополнительные сервера для XFree86.
    XF86-3.1-lkit.tar.gz     Инструментарий для компиляции серверов.
    XF86-3.1-fnt75.tar.gz    Фонты 75-dpi.
    XF86-3.1-fnt100.tar.gz   Фонты 100-dpi.
    XF86-3.1-fntbig.tar.gz   Large Kanji и другие фонты.
    XF86-3.1-fntscl.tar.gz   Масштабируемые фонты (Speedo, Type1).
    XF86-3.1-man.tar.gz      Руководства.
    XF86-3.1-pex.tar.gz      Выполняемые файлы, include-файлы, библиотеки для PEX.
    XF86-3.1-slib.tar.gz     Статические библиотеки.
    XF86-3.1-usrbin.tar.gz   Программы-демоны, размещающиеся в /usr/bin.
    XF86-3.1-xdmshdw.tar.gz  Версия программы xdm с поддержкой теневых паролей.
</pre>
</code></blockquote>
</p>
<p></p>
<p>Каталог XFree должен содержать файлы <code>README</code> и замечания
по инсталляции текущей версии.</p>
<p></p>
<p>Все что вам требуется для инсталляции XFree86, это получить
указанные файлы, создать каталог <code>/usr/X11R6</code>
(пользователем <code>root</code>),
перейти в этот каталог и распаковать файлы.
Например:
<blockquote><code>
<pre>
    # gzip -dc XF86-3.1-bin.tar.gz | tar xfB -
</pre>
</code></blockquote>
</p>
<p></p>
<p>Имейте в виду, что эти файлы упакованы относительно каталога
<code>/usr/X11R6</code>, так что необходимо распаковывать их
находясь в этом каталоге.</p>
<p></p>
<p></p>
<p>После распаковки файлов, вам необходимо связать файл <code>/usr/X11R6/bin/X</code>
с тем сервером, который вы намереваетесь использовать.
Например, если вы желаете работать с SVGA сервером,
файл <code>/usr/bin/X11/X</code>  необходимо связать с файлом
<code>/usr/X11R6/bin/XF86_SVGA</code>.
Если же вы собираетесь использовать монохромный сервер,
переустановите связь командой:
<blockquote><code>
<pre>
    # ln -sf /usr/X11R6/bin/XF86_MONO  /usr/X11R6/bin/X
</pre>
</code></blockquote>
</p>
<p></p>
<p>Это же справедливо и для серверов других видеокарт.</p>
<p>Если вы не уверены какой сервер использовать, или не знаете
какую микросхему содержит ваша видеокарта, вы можете
запустить команду <code>SuperProbe</code> (включенную в XF86-3.1-bin).
Эта программа попытается определить тип микросхемы вашей видеокарты
и другую полезную информацию.</p>
<p></p>
<p>Вам следует убедиться, что каталог <code>/usr/bin/X11R6</code>
находится в переменной среды PATH.
Это может быть сделано редактированием файлов /etc/profile или
<code>/etc/csh.login</code> (в зависимости от оболочек (shell) которые
вы или другие пользователи используют).
Вы также можете просто добавить этот каталог с вашей переменной <code>PATH</code>,
корректируя в вашем домашнем каталоге файлы <code>.bashrc</code> или <code>.cshrc</code>,
в зависимости от типа вашей оболочки.</p>
<p></p>
<p>Вам также необходимо обеспечить загрузку динамических библиотек.
Для этого добавьте строку:
<blockquote><code>
<pre>
    /usr/X11R6/lib
</pre>
</code></blockquote>

в файл <code>/etc/ld.so.conf</code>  и запустите команду
<code>/sbin/ldconfig</code> как суперпользователь.</p>
<p></p>
<p></p>


<h2>5.1.2 <A Name="ss5.1.2"> Настройка XFree86 </h2>

<p>В большинстве случаев установка XFree не представляет проблем.
Однако, если вы желаете использовать видеокарту для которой
драйвер находится в процессе разработки или добиться лучших
разрешения или производительности от карты с графическим акселератором,
то вам потребуется определенное время для настройки XFree.</p>
<p></p>
<p>В этой главе мы опишем как создать и отредактировать
<code>XF86Config</code> файл, который настраивает XFree86 сервер.</p>
<p></p>
<p>В большинстве случаев лучше всего начать с ``основной'' XFree86
конфигурации, которая использует низкое разрешение , например
640x480, поддерживаемого всеми видеокартами и мониторами.
Однажды настроив XFree на стандартное разрешение,
вы можете затем подстроить файл конфигурации для
для того, чтобы использовать все возможности,
предоставляемые вашей аппаратурой.</p>
<p></p>
<p>В дополнение к информации приведенной здесь, вам следует ознакомиться
со следующей документацией:
<ul>
<li>Документация по XFree в каталоге <code>/usr/X11R6/lib/X11/doc</code>
(включенного в пакет XFree86-3.1-doc).
Вам следует особенно обратить внимане на файл
<code>README.Config</code>.</li>
<li> Многие видео микросхемы имеют отдельный справочный файл
<code>README</code> (например <code>README.Cirrus</code>, <code>README.S3</code>).
Прочитайте их, если вы имеете такую видеокарту.</li>
<li>Руководства (man pages) для XFree86.</li>
<li>Руководство (man) на <code>XF86Config</code>.</li>
<li>Руководство (man) на конкретный, используемый вами сервер
(например
<code>XF86_SVGA</code> или <code>XF86_S3</code>).</li>
</ul>
</p>
<p></p>
<p>Основным файлом настройки XFree86 является файл
<code>/usr/X11R6/lib/X11/XF86Config</code>.
Этот файл содержит информацию о вашей мыши, параметрах видеокарты
и т п.  В качестве примера дистрибутив XFree86 содержит файл
<code>XF86Config.eg</code>. Скопируйте его в файл <code>XF86Config</code> и отредактируйте.</p>
<p><code>XF86Config</code> man page подробно об'ясняет формат этого файла.
Прочитайте данный документ , если вы еще это не сделали.
Далее мы собираемся просмотреть файл <code>XF86Config</code> участок за участком.
Этот файл может выглядеть не совсем так, как файл в вашем дистрибутиве
XFree86, но структура их совпадает.</p>
<p><b>!Заметьте,</b> что формат файла <code>XF86Config</code> может изменяться
с каждой версией XFree86; эта информация может быть верной только для
XFree86 версии 3.1.</p>
<p></p>
<p><b>!Имейте также в виду,</b>
что не следует просто копировать конфигурационный файл,
приведенный здесь и пытаться использовать его.
Попытка использовать конфигурационный файл, не соответствующий вашему
оборудованию, может заставить ваш монитор работать со слишком высокой
для него частотой; были сообщения о выходе из строя мониторов
(особенно мониторов с фиксированной частотой) при использовании
неверных <code>XF86Config</code> файлов.</p>
<p></p>
<p>Каждая секция файла <code>XF86Config</code> определяется парой строк
Section <code>"&lt;section-name&gt;" ... EndSection</code>.
Первая секция файла называется <code>Files</code>, и выглядит следующим образом:
<blockquote><code>
<pre>
       Section "Files"
             RgbPath     "/usr/X11R6/lib/X11/rgb"
             FontPath    "/usr/X11R6/lib/X11/fonts/misc/"
             FontPath    "/usr/X11R6/lib/X11/fonts/75dpi/"
       EndSection
</pre>
</code></blockquote>
</p>
<p>Строка <code>RgbPath</code> указывает местоположение базы данных цветов,
а каждая строка <code>FontPath</code> определяет каталог, содержащий
фонты.
Как правило, вам не следует изменять эти строки,
вам следует только убедиться, что все каталоги фонтов
присутствуют.</p>
<p>Следующая секция имеет имя <code>ServerFlags</code> и определяет несколько
глобальных параметров для сервера.
Как правило эта секция пуста.</p>
<p>
<blockquote><code>
<pre>
  Section "ServerFlags"
  # Uncomment this to cause a core dump at the spot where a signal is
  # received. This may leave the console in an unusable state, but may
  # provide a better stack trace in the core dump to aid in debugging
  #    NoTrapSignals
  # ncomment this to disable the &lt;Crtl&gt;&lt;Alt&gt;&lt;BS&gt; server abort sequence
  #    DontZap
  EndSection
</pre>
</code></blockquote>
</p>
<p>Все строки данной секции закомментированы.</p>
<p></p>
<p>Следуюшая секция <code>Keyboard</code>.
Она определяет работу клавиатуры.
<blockquote><code>
<pre>
    Section "Keyboard"
          Protocol    "Standard"
          AutoRepeat  500 5
          ServerNumLock
    EndSection
</pre>
</code></blockquote>

Доступны также и другие режимы. Описанные выше опции работают на
большинстве клавиатур.</p>
<p></p>
<p>Следующая секция - <code>Pointer</code> определяет параметры мыши.
<blockquote><code>
<pre>
    Section "Pointer"

          Protocol    "MouseSystems"
          Device      "/dev/mouse"

    # Baudrate and SampleRate are only for some Logitech mice
    #    BaudRate   9600
    #    SampleRate 150

    # Emulate3Buttons is an option for 2-button Microsoft mice
    #    Emulate3Buttons

    # ChordMiddle is an option for some 3-button Logitech mice
    #    ChordMiddle

    EndSection
</pre>
</code></blockquote>
</p>
<p></p>
<p>Единственными опциями, на которые стоит обратить внимание
являются <code>Protocol</code> и <code>Device</code>. <code>Protocol</code> определяет протокол,
который использует ваша мышь.
Возможными типами (для Linux - есть другие опции,
доступными для других ОС) являются:
<ul>
<li>BusMouse</li>
<li>Logitech
</li>
<li>Microsoft
</li>
<li>MMSeries
</li>
<li>Mouseman
</li>
<li>MouseSystems
</li>
<li>PS/2
</li>
<li>MMHitTab</li>
</ul>
</p>
<p></p>
<p>Для Logitech busmouse следует использовать протокол BusMouse.
Заметьте, что для старых мышей Logitech необходимо использовать протокол
<code>Logitech</code>, а для новых или <code>Microsoft</code>, или <code>Mouseman</code> протокол.</p>
<p></p>
<p></p>
<p>Строка <code>Device</code> определяет устройство к которому подключена мышь.
На большинстве систем Linux это <code>/dev/mouse</code>.
<code>/dev/mouse</code> обычно
связано с соответствующим серийным портом (например <code>/dev/cua0</code> - COM1
или <code>/dev/cua1</code> - COM2) или с портом <code>busmouse</code>.
В любом случае убедитесь, что указанное устройство есть
в каталоге <code>/dev</code> и работоспособно.</p>
<p></p>
<p></p>
<p>Следующая секция - <code>Monitor</code>, определяет характеристики вашего монитора.
Файл <code>XF86Config</code> может содержать не одну, а несколько секций <code>Monitor</code>
(это справедливо и для других секций).
Это полезно в том случае, когда вы подключили к системе
несколько мониторов или используете один и тот же
<code>XF86Config</code> файл для различных конфигураций.
<blockquote><code>
<pre>
 Section "Monitor"

   Identifier  "CTX 5468 NI"

   # These values are for a CTX 5468NI only! Don't attempt to use
   # them with your monitor (unless you have this model)

   Bandwidth    60
   HorizSync    30-38,47-50
   VertRefresh  50-90

   # Modes:  Name   dotclock    horiz                vert

   ModeLine "640x480"  25       640 664 760 800      480 491 493 525

   ModeLine "800x600"  36       800 824 896 1024     600 601 603 625
   ModeLine "1024x768" 65       1024 1088 1200 1328  768 783 789 818

 EndSection
</pre>
</code></blockquote>
</p>
<p></p>
<p>Строка <code>Identifier</code> используется для именования текущего описания
монитора. Это может быть любая строка, на которую вы в дальнейшем
ссылаться в файле <code>XF86Config</code>.</p>
<p></p>
<p><code> HorizSync</code> определяет возможные скорости горизонтальной развертки
для вашего монитора в Килогерцах.
Если у вас многочастотный (multisync) монитор, вы можете указать
интервал значений (или несколько интервалов, разделенных запятой),
как показано выше.
Если у вас монитор с фиксированной частотой, то вам надо указать
список фиксированных значений. Например:
<blockquote><code>
<pre>
          HorizSync    31.5, 35.2, 37.9, 35.5, 48.95
</pre>
</code></blockquote>
</p>
<p></p>
<p>В руководстве на ваш монитор эти значения должны быть описаны.
Если вы не имеете этой информации, вам следует связаться с производителем
или продавцом вашего монитора.</p>
<p></p>
<p>Строка <code>VertRefresh</code> описывает возможные значения частоты вертикальной
развертки для вашего монитора в герцах.
Как и для <code>HorizSync</code> вы можете указать интервал или список
дискретных значений. Ваше руководство на монитор должно содержать эту
информацию.</p>
<p></p>
<p> Сервер использует значения <code>HorizSync</code> и <code>VertRefresh</code>
только для того,
чтобы убедиться что вы верно определили разрешение монитора.
Это исключает возможность разрушения монитора
при попытке работы с ним на частоте превышающей максимально
допустимую.</p>
<p></p>
<p>Строка <code>ModeLine</code> определяет один из режимов разрешения вашего монитора.
Ее формат:</p>
<p>
<blockquote><code>
<pre>
    ModeLine &lt;name&gt; &lt;clock&gt; &lt;horiz-values&gt; &lt;vert-values&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p><code>&lt;name&gt;</code> - строка, которую вы можете использовать в этом файле в
дальнейшем для указания разрешения.
<code>&lt;dot-clock&gt;</code>  определяет частоту задающего генератора адаптера
для этого разрешения.
Обычно частота указывается в мегагерцах.
Она определяет скорость с которой видеокарта должна посылать
значения точек экрана на монитор при указанном разрешении.
<code>&lt;horiz-values&gt;</code> и <code>&lt;vert-values&gt;</code>
состоят из 4-х цифр каждая.
Эти значения определяют, когда электронная пушка монитора
во время развертки должна включиться и когда должны проходить
импульсы горизонтальной и вертикальной синхронизации
во время развертки луча.</p>
<p></p>
<p>Как описать строку <code>ModeLine</code> для вашего монитора?
Файл <code>VideoModes.doc</code>, включенный в дистрибутив XFree86,
детально описывает как определить эти значения для
каждого разрешения, которое поддерживает ваш монитор.
Значение <code>clock</code> должно соответствовать частотам, которые
поддерживает ваша видеокарта.
Далее в файле <code>XF86Config</code> вы определите эти значения.</p>
<p></p>
<p>Существует два файла <code>modeDB.txt</code> и <code>Monitors</code>
в дистрибутиве XFree, которые могут содержать
данные <code>ModeLine</code> для вашего монитора.
Эти файлы располагаются в каталоге <code>/usr/X11R6/lib/X11/doc</code>.</p>
<p></p>
<p>Вы можете начать со значений <code>ModeLine</code> для мониторов стандарта VESA.
Этот режим поддерживается большинством мониторов.
Файл <code>modeDB.txt</code> включает описания синхронизации
для стандартного разрешения VESA.
В этом файле вы найдете такие строки:
<blockquote><code>
<pre>
    # 640x480@60Hz Non-Interlaced mode
    # Horizontal Sync = 31.5kHz
    # Timing: H=(0.95us, 3.81us, 1.59us), V=(0.35ms, 0.064ms, 1.02ms)
    #
    # name      clock   horizontal timing     vertical timing    flags
    "640x480"   25.175  640  664  760  800    480  491  493  525
</pre>
</code></blockquote>
</p>
<p></p>
<p>Это стандартная строка синхронизации для разрешения 640x480 точек.
Она устанавливает частоту 25.175 Mhz,
которая должна поддерживаться большинством мониторов
(более подробно об этом позже).
В вашем файле эта строка должна выглядеть так:
<blockquote><code>
<pre>
    ModeLine "640x480" 25.175  640 664 760 800  480 491 493 525
</pre>
</code></blockquote>
</p>
<p>Заметим, что аргумент name в строке <code>ModeLine</code>
(в нашем случае "640x480") может быть любой строкой,
которая описывает для вас разрешение монитора.</p>
<p>Для каждой строки <code>ModeLine</code> сервер проверяет, попадают ли указанные
значения в интервал указанных значений <code>Bandwidth</code>, <code>HorizSync</code> и
<code>VertRefresh</code>.
Если нет, то сервер выдаст предупреждение при начале работы.</p>
<p></p>
<p>Если стандартные значения синхронизации VESA не работают у вас,
то просмотрите другие значения в файлах <code>modeDB.txt</code> и  <code>Monitors</code>
для других типов мониторов.
Заметим, что многие 14 и 15 дюймовые мониторы не могут поддерживать
разрешений 1024x768 точек из-за низкого значения <code>Bandwidth</code>.
То есть, если вы не нашли описание режима высокого разрешения
для вашего монитора, то не исключено, что ваш монитор не
поддерживает такое разрешение.</p>
<p></p>
<p>Если вы потерпели неудачу с подбором строки ModeLine,
изучите инструкцию описанную в файле <code>VideoModes.doc</code>
вашего дистрибутива.
По этой инструкции вы сможете описать
строку <code>ModeLine</code> по спецификациям, описанным в вашем руководстве
на монитор.</p>
<p>В конце концов, если вы не можете подобрать правильные значения строки <code>ModeLine</code>,
то вы можете просто слегка изменить
эти значения для достижения требуемого результата.
Например, если изображение на экране слегка
уходит влево или вверх, вы можете по инструкции из файла
<code>VideoModes.doc</code> настроить значения синхронизации.
Проверьте также наличие управляющих клавиш на вашем мониторе!
Частенько бывает достаточным изменить горизонтальный и вертикальный
размер изображения во время работы XFree чтобы добиться
желаемой центровки и размера изображения.
Наличие этих клавиш на монитора значительно упрощает жизнь.</p>
<p></p>
<p>Следующая секция <code>Device</code> описывает параметры вашей видеокарты.
Например:</p>
<p>
<blockquote><code>
<pre>
       Section "Device"
                 Identifier "#9 GXE 64"

                 # Nothing yet; we fill in these values later.

       EndSection
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эта секция описывает возможности вашей карты.
<code>Identifier</code> определяет имя этого описания для ссылки на него в
дальнейшем.</p>
<p>Первоначально вам не стоит заполнять эту секцию, за исключением
поля <code>Identifier</code>.
X-сервер можно использовать в режиме определения параметров
установленной видеокарты.
После определения этих параметров вы занесете их в эту секцию.
X-сервер способен определить тип микросхемы
видеокарты, поддерживаемый интервал частот,
наличие RAMDAC и размер установленной памяти на видеоадаптере.</p>
<p></p>
<p>Прежде чем мы это сделаем, нам следует закончить описание
файла <code>XF86Config</code>.</p>
<p>Следующая секция - <code>Screen</code> описывает возможные
режимы работы X-сервера с видеокартой и монитором.</p>
<p>
<blockquote><code>
<pre>
          Section "Screen"
              Driver     "Accel"
              Device     "#9 GXE 64"
              Monitor    "CTX 5468 NI"
              Subsection "Display"
                    Depth      16
                    Modes      "1024x768" "800x600" "640x480"
               ViewPort   0 0
               Virtual    1024 768
           EndSubsection
     EndSection
</pre>
</code></blockquote>
</p>
<p></p>
<p>Строка <code>Driver</code> определяет тип сервера, который вы будете использовать.
Вы можете использовать следующие сервера:
<dl>
<dt><b>Accel:</b><dd><p>Для XF86_S3,   XF86_Mach32,   XF86_Mach8,  XF86_8514,
XF86_P9000, XF86_AGX, and XF86_W32 серверов;</p>
<p></p>
<dt><b>SVGA:</b><dd><p>Для XF86_SVGA сервера;</p>
<p></p>
<dt><b>VGA16</b><dd><p>:  Для XF86_VGA16 сервера;</p>
<p></p>
<dt><b>VGA2</b><dd><p>:  Для XF86_Mono сервера;</p>
<p></p>
<dt><b>Mono</b><dd><p>:   Для non-VGA монохромного драйвера в  XF86_Mono и XF86_VGA16
серверах.</p>
</dl>
</p>
<p></p>
<p>Убедитесь, что  файл <code>/usr/X11R6/bin/X</code>
является символьной ссылкой на используемый вами сервер.</p>
<p>Строка Device определяет идентификатор секции <code>Device</code>,
описывающей установленную видеокарту.
Выше мы описали секцию <code>Device</code> с идентификатором:
<blockquote><code>
<pre>
    Identifier "#9 GXE 64"
</pre>
</code></blockquote>
</p>
<p>Следовательно, здесь мы используем "<code>#9 GXE 64</code>" в строке <code>Device</code>.</p>
<p>Точно так же строка <code>Monitor</code> определяет имя секции <code>Monitor</code>
для данного сервера, в данном примере "<code>CTX 5468  NI</code>".</p>
<p></p>
<p>Подсекция Display определяет режим работы сервера при выводе информации
на экран. Файл <code>XF86Config</code> детально описывает эти режимы.
Режимы, которые вам необходимо знать:
<ul>
<li> <code>Depth</code>. Опеделяет число битов на точку. Обычно <code>Depth</code>
принимает значение 8 (256 цветов). Для сервера VGA16 вам следует
установить значение <code>Depth</code> 4 и для монохромного сервера - 1.
Если вы используете видеокарту с ускорителем и имеете достаточно
памяти для поддержки большего числа бит на точку, Вы можете
установить <code>Depth</code> 16 , 24 или 32.
Если с этими значения появились проблемы
вернитесь к значению 8 и попытайтесь решить проблему позже.
</li>
<li> <code>Modes</code>. Указывает список видеорежимов, описанных
в секции ModeLines.
Выше мы описали режимы Modelines названные
"<code>1024x768</code>", "<code>800x600</code>" и "<code>640x480</code>".
Следовательно строка Modes будет выглядеть:
<blockquote><code>
<pre>
                     Modes    "1024x768" "800x600" "640x480"
</pre>
</code></blockquote>


Первый режим, перечисленный в этой строке устанавливается по умолчанию
после начала работы сервера.
Далее вы можете переключать режимы разрешения изображения,
использую клавиши
<F>ctrl</F>-<F>alt</F>-<F>numeric +</F> и <F>ctrl</F>-<F>alt</F>-<F>numeric -</F>.

<p>Лучше всего при начальном конфигурации XFree86
использовать минимальное разрешение, например 640x480,
которое работает на большинстве систем.
И после настройки этого режима настроить <code>XF86Config</code>
на работу с большими разрешениями.</p>
<p></p>
</li>
<li> <code>Virtual</code>. Устанавливает виртуальный размер экрана.
XFree86 имеет возможность использовать дополнительнуб память на
вашей видеокарте для расширения вашего рабочего поля.

Когда указатель мыши доходит до края экрана, ваше рабочее поле сдвигается
показывая новые части вашего рабочего поля.
Следовательно, даже если вы работаете на мониторе
с низким разрешением (например 800x600 точек),
вы можете установить размер виртуального экрана насколько
вам позволяет память видеоплаты (1 Мегабайтная плата
может хранить рабочее поле 1024x768 с 256 цветами,
2-х Мегабайтная плата - 1280x1024 с 256 цветами или
1024x768 с 16384 цветами и т д).
Конечно, вы не сможете увидеть сразу все поле на вашем мониторе,
но вы можете легко просмотреть любую его часть.

<p><code>Virtual</code> предоставляет вам прекрасную возможность
использовать всю память вашего адаптера, но
она довольно ограничена.
Если вы желаете еще расширить возможности работы
с экраном, вам следует использовать <code>fvwm</code>, <code>openwin</code>
или другой подобный менеджер окон.
<code>fvwm</code> и <code>openwin</code> позволяет вам иметь намного больший
виртуальный экран (используя механизм спрятанных окон,
вместо сохранения всего экрана в видеопамяти).
Ваше виртуальное рабочее поле может состоять из
16x16 реальных экранов и более.
Обратитесь к руководству по указанным командам.
Большинство дистрибутивов XFree используют по
умолчанию менеджер окон <code>fvwm</code>.</p>
<p></p>
</li>
<li> <code>ViewPort</code>.
Если вы использовали опцию <code>Virtual</code>, описанную выше,
ViewPort устанавливает координаты левого верхнего угла
виртуального экрана после начала работы сервера.
Часто используют значение  <code>Virtual 0  0</code>.
Если вы не установили этого значения сервер центрирует
виртуальный экран на мониторе (что может быть не всегда желательно).</li>
</ul>

Существуют и другие опции для данной секции (см. руководство
для файла <code>XF86Config</code>). На практике же другие опции
не обязательны для начальной установки сервера.</p>
<p></p>

<h2>5.1.3 <A Name="ss5.1.3"> Заполнение информации о видеокарте </h2>

<p>Теперь ваш файл <code>XF86Config</code> готов к использованию.
Единственное, что мы не сделали - не заполнили информацию о видеокарте.
Сейчас нам следует запустить X сервер
в режиме определения видеокарты и дооформить <code>XF86Config</code> файл.</p>
<p></p>
<p>Эту информацию вы можете найти и в файлах
<code>modeDB.txt</code>, <code>AccelCards</code> и  <code>Devices</code> (все эти файлы находятся
в каталоге <code>/usr/X11R6/lib/X11/doc</code>).
Кроме этого существуют различные файлы <code>README</code> для
конкретных микросхем.
Вам следует просмотреть эти файлы и используя эту информацию
(частоты, тип микросхем и другие режимы) доопределить
файл <code>XF86Config</code>.
Если какой то информации не хватает, вы можете определить ее
путем описанным ниже.</p>
<p></p>
<p>В этом примере мы опишем настройку видеокарты <code>#9 GXE 64</code>,
используюшую микросхему S3.
Эта карта одна из тех, с которыми работает автор,
но все описанное ниже справедливо и для другой видеокарты.</p>
<p>Перво-наперво вам надо определить тип микросхемы,
используемой видеокартой.
Команда <code>SuperProbe</code> (располагающаяся в каталоге
/usr/X11R6/bin) сообщит вам эту информацию,
но вам необходимо знать под каким именем
известна данная микросхема X серверу.</p>
<p></p>
<p>Чтобы определить это запустите команду:
<blockquote><code>
<pre>
    X -showconfig
</pre>
</code></blockquote>
</p>
<p>Сервер сообщит вам имена микросхем, с которыми он работает
(руководство на X сервер также содержит эту информацию).
Например, сервер XF86_S3 сообщит:
<blockquote><code>
<pre>
    XFree86 Version 3.1 / X Window System
    (protocol Version 11, revision 0, vendor release 6000)
    Operating System: Linux
    Configured drivers:
      S3: accelerated server for S3 graphics adaptors (Patchlevel 0)
            mmio_928, s3_generic
</pre>
</code></blockquote>
</p>
<p></p>
<p>То есть сервер работает с микросхемами <code>mmio_928</code> и <code>s3_generic</code>.
Руководство на сервер XF86_S3 описывает эти микросхемы
и видеокарты, использующие их.
В нашем случае видеокарта <code>#9  GXE 64</code>
использует микросхему <code>mmio_928</code>.</p>
<p></p>
<p>Если вы не знаете какая микросхема стоит на видеокарте,
X сервер может это определить. Запустите:</p>
<p>
<blockquote><code>
<pre>
    X -probeonly &gt; /tmp/x.out 2&gt;&1
</pre>
</code></blockquote>
</p>
<p>если вы работаете в оболочке shell. Если вы используете csh запустите:</p>
<p>
<blockquote><code>
<pre>
    X -probeonly &&gt; /tmp/x.out
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эту команду следует запускать при низкой загрузке компьютера.
Эта команда определяет также частоту видеоадаптера
и большая загрузка системы может исказить эти данные.</p>
<p></p>
<p></p>
<p>Выходная информация в файле <code>/tmp/x.out</code> будет содержать
следующие строки:
<blockquote><code>
<pre>
    XFree86 Version 3.1 / X Window System
    (protocol Version 11, revision 0, vendor release 6000)
    Operating System: Linux
    Configured drivers:
      S3: accelerated server for S3 graphics adaptors (Patch level 0)
            mmio_928, s3_generic
    Several lines deleted...
    (--) S3: card type: 386/486 localbus
    (--) S3: chipset:   864 rev. 0
    (--) S3: chipset driver: mmio_928
</pre>
</code></blockquote>
</p>
<p></p>
<p>Мы видим, что сервер (XF86_S3) может работать с микросхемами
<code>mmio_928</code> и <code>s3_generic</code>. Сервер протестировал видеокарту и
опознал микросхему <code>mmio_928</code>.
Следовательно, в секцию Device вам следует добавить строку,
содержащую имя микросхемы, найденное сервером.</p>
<p>
<blockquote><code>
<pre>
    Section "Device"
              # We already had Identifier here...
              Identifier "#9 GXE 64"
              # Add this line:
              Chipset "mmio_928"
    EndSection
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь нам требуется определить частоты, поддерживаемые
видеокартой.
Как мы уже видели, каждый режим разрешения на мониторе требует
определенной передачи точек от видеокарты.
Нам необходимо определить какие частоты может обеспечить видеокарта.</p>
<p></p>
<p>Сначала следует просмотреть справочные файлы (<code>modeDB.txt</code>,  и т п)
описанные выше и определить, нет ли там описания частот вашей карты.
Частоты, как правило представлены списком из 8 или 16-ти значений
частот в Мегагерцах.
Например в файле <code>modeDB.txt</code> можно найти строку описания видеокарты
Cardinal ET4000:</p>
<p>
<blockquote><code>
<pre>
 chip     ram   virtual   clocks                           default-mode  flags
 ET4000   1024  1024 768   25  28  38  36  40  45  32   0  "1024x768"
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как вы видите, данная карта поддерживает частоты:
25, 28, 38, 36,  40, 45, 32, and 0 MHz.</p>
<p>В секции <code>Device</code> файла <code>XF86Config</code>, вам следует добавить
строку <code>Clocks</code> со списком частот. В нашем случае мы добавляем строку:</p>
<p>
<blockquote><code>
<pre>
              Clocks 25 28 38 36 40 45 32 0
</pre>
</code></blockquote>
</p>
<p>к секции <code>Device</code>, после описания <code>Chipset</code>.
Заметьте, что порядок частот важен! Вам не следует дублировать или
изменять порядок частот.</p>
<p></p>
<p>Если вы не можете найти список частот для вашей карты, X сервер может
также определить и эти значения.
После вызова команды <code>X -probeonly</code>, описанного выше,
вы увидите строку :</p>
<p>
<blockquote><code>
<pre>
    (--
    ) S3: clocks:  25.18  28.32  38.02  36.15  40.33  45.32  32.00  00.00
</pre>
</code></blockquote>
</p>
<p>Теперь вам осталось лишь добавить строку <code>Clocks</code>,
перечислив указанные значения.
Так как часто список содержит 8 и более значений
и не помещается в одной строке, вы можете продолжить
список в следующих строках, только не
забывайте сохранять порядок указанных сначений.</p>
<p>Перед запуском <code>X -probeonly</code>, уделитесь что в секции <code>Devices</code>
нет строк описания <code>Clocks</code> или они закомментированы.
Если эти значения уже есть, X сервер не будет
проверять поддерживаемые платой частоты, а возьмет указанные
в строке <code>Clocks</code>.</p>
<p></p>
<p>Заметьте, что некоторые видеокарты с акселератором используют
микросхему с программируемой частотой (Смотрите руководство
XF86_Accel; это в основном относится к картам
S3, AGX и XGA-2  boards.)
Эти микросхемы позволяют X-серверу сообщать карте
какую использовать частоту.
В этом случае мы вполне вероятно не сможем найти
в вышеперечисленных файлах список частот для карты.
Или список частот, выдаваемых командой
<code>X -probeonly</code> будет содержать одно два значения
с остальными дублированными или нулевыми значениями.</p>
<p></p>
<p>Для видеоплат, использующих микросхему программирования частоты,
вам вместо строки <code>Clocks</code> следует использовать строку <code>ClockChip</code>.
Эта строка задает имя микросхемы программирования частоты, установленной
на карте.
Руководства для каждого сервера описывает их имена.
Например, в файле <code>README.S3</code> мы определили, что несколько
S3-864 видеокарт используют микросхему ``<code>ICD2061A</code>''.
Следовательно, нам следует использовать строку:</p>
<p>
<blockquote><code>
<pre>
              ClockChip "icd2061a"
</pre>
</code></blockquote>
</p>
<p>вместо строки <code>Clocks</code>.
Так же как и строка <code>Clocks</code>, строка  <code>ClockChip</code>
должна быть в секции <code>Devices</code> после строки <code>Chipset</code>.</p>
<p></p>
<p>Некоторые карты с акселератором требуют определения
в файле <code>XF86Config</code> строки <code>Ramdac</code>, описывающей тип используемой
микросхемы RAMDAC.
Руководство на сервер <code>XF86_Accel</code> описывает подробно опции
этой строки.
Как правило, X сервер верно определяет тип используемой микросхемы RAMDAC.</p>
<p></p>
<p>Некоторые видеокарты требуют определения нескольких
дополнительных опций в секции <code>Devices</code>.
Эти опции описаны как в руководствах на ваш X сервер,
так и в справочных файлах (например <code>README.cirrus</code> или <code>README.S3</code>).
Эти опции устанавливаются строкой <code>Options</code>.
Например, видеокарта <code>#9 GXE 64</code> требует
установку двух опций:</p>
<p>
<blockquote><code>
<pre>
              Option "number_nine"
              Option "dac_8_bit"
</pre>
</code></blockquote>
</p>
<p></p>
<p></p>
<p>Обычно X сервер работает и без этих  опций, но
с ними X сервер обеспечивает большую производительность.
Существует слишком много всевозможных опций,
чтобы из все здесь перечислить.
Эти опции зависят от типа установленной видеокарты.
Если вы вынуждены использовать эти опции - не волнуйтесь,
руководства на X сервера и справочные файлы в каталоге
<code>/usr/X11R6/lib/X11/doc/</code> об'яснят вам что они значат.</p>
<p></p>
<p>Итак, когда вы закончите, не забудьте завершить
строкой <code>EndSection</code> секцию <code>Device</code>,
которая будет выглядеть следующим образом:</p>
<p>
<blockquote><code>
<pre>
    Section "Device"
              # Device section for the #9 GXE 64 only !
              Identifier "#9 GXE 64"
              Chipset "mmio_928"
              ClockChip "icd2061a"
              Option "number_nine"
              Option "dac_8_bit"
    EndSection
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как уже сказано выше,
большинство видеокарт требуют строку <code>Clocks</code> вместо строки <code>ClockChip</code>.
Вышеприведенный пример применим только к конкретной видеокарте
<code>#9 GXE 64</code>.</p>
<p></p>
<p></p>

<h2>5.1.4 <A Name="ss5.1.4"> Запуск X-Windows </h2>

<p>Как только вы закончите описание файла <code>XF86Config</code>,
вы готовы запустить X сервер и начать работу.
Сначала убедитесь, что каталог
<code>/usr/X11R6/bin</code> включен в ваш путь (переменную <code>PATH</code>).</p>
<p></p>
<p>Для запуска X Window наберите команду:</p>
<p>
<blockquote><code>
<pre>
    startx
</pre>
</code></blockquote>
</p>
<p>Это "оболочка" для команды <code>xinit</code> (если вы использовали <code>xinit</code>
в других UNIX-системах).</p>
<p></p>
<p>Эта команда запускает X сервер и выполняет команды,
найденные в файле <code>.xinitrc</code> в вашем домашнем каталоге.
Если данного файла не существует, используется системный файл
<code>/usr/X11R6/lib/X11/xinit/xinitrc</code>.</p>
<p></p>
<p>Стандартный <code>xinitrc</code> файл выглядит подобным образом:</p>
<p>
<blockquote><code>
<pre>
    #!/bin/sh

    xterm -fn 7x13bold -geometry 80x32+10+50 &
    xterm -fn 9x15bold -geometry 80x34+30-10 &
    oclock -geometry 70x70-7+7 &
    xsetroot -solid midnightblue &
    exec twm
</pre>
</code></blockquote>
</p>
<p></p>
<p>Этот расчет запускает два клиента <code>xterm</code> (эмулятор терминала),
<code>oclock</code> (часы) и устанавливает темно-синий цвет экрана.
Затем он запускает <code>twm</code> - оконный менеджер.
Заметьте, что twm запускается через оператор exec.
Оболочка /bin/sh, выполняющая этот расчет
замещается командой <code>twm</code> и при окончании работы процесса <code>twm</code>,
X-сервер также завершает свою работу.
Вы можете выйти из <code>twm</code>, используя основное меню.
Нажмите левую кнопку мыши, находясь на свободном месте экрана.
На экране появится меню, которое позволит вам за выйти из <code>twm</code>,
выбрав пункт <code>Exit Twm</code>.</p>
<p></p>
<p>Убедитесь, что последняя команда в файле <code>.xinitrc</code>
запускается через exec и не запускается в фоне
(нет символа <code>&amp;</code> в конце строки).
Иначе X сервер завершит свою работу, как только
он запустит клиента из файла <code>.xinitrc</code>.</p>
<p></p>
<p>Кроме этого, вы можете выйти из X-а, нажав клавиши
<F>ctrl</F>-<F>alt</F>-<F>backspace</F> одновременно.</p>
<p></p>
<p>Описанная выше конфигурация файла <code>.xinitrc</code> является очень простой.
Если вы с ним немного поработаете вы можете получить
множество отличных программ и конфигураций окон на экране.
Например, оконный менеджер fvwm поддерживает виртуальные экраны,
вы можете подобрать различные фонты, цвета, размеры окон, их позиции
и так далее, все что вы пожелаете.
Хотя система X Window может на первый взляд показаться простой,
она чрезвычайно мощна и богата различными возможностями.</p>
<p></p>
<p>Если вы новичок в среде X Window, мы настоятельно рекомендуем
вам приобрести книгу типа <em>The X Window System: A User's Guide</em>.
Использование и настройка X-а довольно большая задача для того,
чтобы описать ее в этой книге.
В качестве дальнейших шагов посмотрите руководства для команд
xterm, oclock, twm и т п.</p>
<p></p>

<h2>5.1.5 <A Name="ss5.1.5"> Проблемы </h2>

<p>Частенько случается, что у вас что-то не получается.
Как правило, это связано с ошибками описания вашего файла
<code>XF86Config</code>.
Обычно, неверно указывают временные интервалы синхронизации
монитора или частоты видеоплаты.
Если у вас изображение на экране сдвинуто или его границы размыты,
это точный показатель, что эти значения установлены неверно.
Проверьте также, верно ли определили тип микросхемы видеокарты
и другие опции в секции Device файла <code>XF86Config</code>.
Убедитесь также, что вы используете необходимый X сервер
и что файл <code>/usr/X11R6/bin/X</code>
является символьной ссылкой на этот сервер.</p>
<p></p>
<p>Если это не поможет, попробуйте запустить X напрямую,
используя команду:</p>
<p>
<blockquote><code>
<pre>
    X &gt; /tmp/x.out 2&gt;&1
</pre>
</code></blockquote>
</p>
<p>Затем остановите X сервер (нажав одновременно клавиши
<F>ctrl</F>-<F>alt</F>-<F>backspace</F>) и проверьте содержимое файла <code>/tmp/x.out</code>.
X сервер сообщит все предупреждения и ошибки,
например о том, что ваша видеокартра на поддерживает необходимую
для вашего монитора частоту.</p>
<p>Файл <code>VideoModes.doc</code>, включенный в дистрибутив XFree,
содержит много советов по настройке вашего файла <code>XF86Config</code>.</p>
<p>Не забудьте, что вы можете использовать комбинации клавиш
<F>ctrl</F>-<F>alt</F>-<F>numeric +</F> и  <F>ctrl</F>-<F>alt</F>-<F>numeric  -</F>
для переключения режимов разрешения монитора,
перечисленых в секции Screen файла <code>XF86Config</code>.
Если режим с высоким разрешением не работает,
попытайтесь установить на меньшее разрешение.
Это, по крайней мере, поможет определить вам
ошибочные и правильные настройки вашего конфигурационного файла.</p>
<p>Попытайтесь также аппаратно подстроить
ваш монитор, используя клавиши управления на мониторе.</p>
<p>Для обсуждения вопросов по XFree86 предназначены группа
<code>comp.windows.x.i386unix</code> USENET.
Неплохая идея - подписаться на эту конференцию
и описать интересующие вас проблемы - может быть
кто-то имеет такие же проблемы.</p>
<p></p>
<p></p>


<h2>5.2 <A Name="ss5.2"> Доступ к файлам MS-DOS </h2>

<p>Если, по какой-нибудь необ'яснимой прихоти,
вам необходимо обеспечить доступ к файлам MS-DOS,
вы можете это легко сделать.</p>
<p>Обычно для получения доступа к файлам MSDOS, вам достаточно
примонтировать MS-DOS раздел или дискету
и обращаться к фалам через файловую систему Linux.
Например, если вы вставите дискету MS-DOS
в устройство <code>/dev/fd0</code> (A: в нотации MS/DOS),
команда</p>
<p>
<blockquote><code>
<pre>
    # mount -t msdos /dev/fd0 /mnt
</pre>
</code></blockquote>
</p>
<p>примонтирует эту дискету к каталогу <code>/mnt</code>.
Просмотрите секцию 4.6.2 для получения дополнительной информации
о монтировании флоппи-дисков.</p>
<p></p>
<p>Точно также, вы можете примонтировать MS-DOS раздел на вашем винчестере.
Если вы, например, имеете MS-DOS раздел на <code>/dev/hda1</code>, команда</p>
<p>
<blockquote><code>
<pre>
    # mount -t msdos /dev/hda1 /mnt
</pre>
</code></blockquote>
</p>
<p>примонтирует ее. Не забудьте размонтировать DOS-раздел после
окончания работы с ней.
Вы можете монтировать раздел MS-DOS автоматически во время
загрузки системы, если добавите строку в файл <code>/etc/fstab</code> (см.
секцию 4.8). Например, следующая строка в файле <code>/etc/fstab</code>
монтирует DOS раздел <code>/dev/hda1</code> на каталог <code>/dos</code>.</p>
<p>
<blockquote><code>
<pre>
    /dev/hda1     /dos     msdos      defaults
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы можете также получить доступ к файлам MS-DOS, используя
пакет Mtools. Команды <code>mcd</code>, <code>mdir</code> и <code>mcopy</code> этого пакеты
работают точно также как команды MS-DOS <code>cd</code>, <code>dir</code>, <code>copy</code>.
Если вы установили пакет Mtools, то он должен содержать и руководства на
эти команды.</p>
<p></p>
<p>Доступ к файлам MS-DOS и
выполнение  программ MS-DOS - это две большие разницы.
В настоящее время в процессе разработки находится эмулятор
программ MS-DOS.  Он широко распространен и даже входит
в состав дистрибутива SLS.
Доступен он также и по FTP с многих серверов (см. приложение C).
Эмулятор MS-DOS достаточно полон для выполнения большинства DOS
программ, включая Wordperfect. Однако Linux и MS-DOS совершенно
разные операционые системы и полнота любого MS-DOS эмулятора
в любой UNIX-системе всегда ограничена.</p>
<p></p>
<p>Кроме этого, в настоящее время разрабатывается
в среде X Window эмулятор Microsoft Windows.
Для получения дополнительной информации обратитесь
к соответствующим группам новостей и FTP серверам.</p>
<p></p>

<h2>5.3 <A Name="ss5.3"> Сетевая работа по протоколу TCP/IP </h2>

<p>Linux  поддерживает  полный  набор сетевых протоколов TCP/IP
(Transport   Control  Protocol/Internet  Protocol).  TCP/IP  стал
наиболее  успешно  используемым  механизмом работы в компьютерных
сетях  всего  мира.  С  помощью  Linux  и карт Ethernet вы можете
связать  в  локальную  сеть  ваши  машины или (при соответствующем
подключении) к Internet - всемирной сети TCP/IP.</p>
<p></p>
<p>Сцепить  несколько  UNIX-машин  в  небольшую  локальную сеть
(LAN)  просто.  Для  этого требуется контроллер Ethernet в
каждой    машине,   соответствующие   кабели   и   еще   некоторое
сопутствующее  оборудование. Или, если ваша фирма или университет
имеют  выход в Internet, вы можете просто к этой сети подцепиться
со своей Linux-машиной.</p>
<p></p>
<p>Текущая  реализация  TCP/IP  и  соответствующие протоколы для
Linux   называются  ``NET-2''.  Это  не  имеет  отношения  к  так
называемому  релизу  NET-2  для  BSD  UNIX.  В  данном  контексте
``NET-2'' означает вторую реализацию TCP/IP для Linux.</p>
<p></p>
<p>Linux  NET-2  также  поддерживает протокол SLIP (Serial Line
Internet Protocol). SLIP позволяет вам получить вход в Internet с
помощью  модема.  Если  ваша фирма или университет имеет выход по
SLIP,  вы  можете  выйти на SLIP-сервер и войти со своей машины в
Internet  по  телефонной  линии. И наоборот, если ваша Linux-машина
имеет  подключение  по  Ethernet  к  Internet,  ваш  Linux может
исполнять функции SLIP-сервера.</p>
<p></p>
<p>Для  получения  более  полной информации по установке TCP/IP
под  Linux,  мы  настоятельно  советуем  прочитать
<em>Linux  NET-2 HOWTO</em>,
которое   можно   получить   через     FTP   с
<code>sunsite.unc.edu</code>.  <em>NET-2  HOWTO</em>  -  это  полное  руководство  по
конфигурированию  TCP/IP,  включая  связи  по Ethernet и SLIP под
Linux.
<code>The  Linux  Ethernet  HOWTO</code>  описывает конфигурирование
(настройку)  различных  драйверов  карт Ethernet для Linux. Можно
также  воспользоваться
<code>The Linux Network Administrator's Guide</code>
из  проекта  по  документированию Linux - LDP (Linux Documentation
Project).  Более подробно про эти документы смотрите в Приложении
A.</p>
<p></p>
<p>Интересна также книга: Craig Hunt
<code>TCP</code>IP Network  Administration/.
Она содержит исчерпывающую информацию по использованию и настройке
TCP/IP для систем UNIX.</p>
<p></p>
<h2>5.3.1 <A Name="ss5.3.1"> Требования к аппаратуре </h2>

<p>Вы   можете   использовать  в  Linux  TCP/IP  без  какого-то
дополнительного   оборудования  режим
``loopback'',   позволяющий  разговаривать  с  самим  собой.  Это
необходимо  для  ряда  приложений  и  игр,  использующих механизм
``loopback''.</p>
<p></p>
<p>Но если вы хотите использовать Linux с сетевой работой через
Ethernet  по  TCP/IP  ,  вы  должны  иметь  одну из следующих карт
Ethernet:  3com  3c503,  3c503/16; Novell NE1000, NE2000; Western
Digital   WD8003,   WD8013;  Hewlett  Packard  HP27245,  HP27247,
HP27250.</p>
<p></p>
<p>Имеется  информация,  что  и следующие клоны работают: WD-80x3
clones:  LANNET  LEC-45;  NE2000  clones:  Alta  Combo,  Artisoft
LANtastic  AE-2,  Asante  Etherpak 2001/2003, D-Link Ethernet II,
LTC  E-NET/16  P/N 8300-200-002, Network Solutions HE-203, SVEC 4
Dimension  Ethernet, 4-Dimension FD0490 EtherBoard 16, and D-Link
DE-600, SMC Elite 16.</p>
<p></p>
<p>Дополнительную   информацию   по   совместимости  аппаратуры
Ethernet в Linux можно найти в "Linux Ethernet HOWTO".</p>
<p></p>
<p>Linux    также    поддерживает   SLIP,   который   позволяет
использовать  модем  для выхода в Internet по телефонной линии. В
этом  случае вам нужен модем, совместимый с вашим SLIP-сервером -
большинство  серверов  требует модемы на 14.4bps, V.32bis.
<sl>(прим.
переводчика:  прогресс  в  модемах  быстрее,  чем  в компьютерах,
поэтому  данные  стареют  еще быстрее; сейчас чаще можно услышать
про 28.8bps и V.34, что тоже быстро устаревает).</sl>

</p>
<p></p>

<h2>5.3.2 <A Name="ss5.3.2"> Настройка  TCP/IP на вашей системе </h2>

<p>В этом разделе мы обсудим, как настраивать связь
Ethernet   -   TCP/IP  на  вашей  системе.  Имейте  в  виду,  что
описываемый   метод  (предполагается,  что)  работает  на  многих
системах,  но,  разумеется,  не  на всех. Этого обсуждения должно
быть  достаточно,  чтобы  указать вам правильный путь в настройке
параметров  сети на вашей машине. Но существует множество заковык
и милых деталей, которые мы здесь даже не упоминаем. Мы, все-таки
ориентируем  вас  на
<em>Linux  Network  Administrators' Guide</em> и
NET-2-HOWTO.</p>
<p></p>
<p>Прежде   всего,  мы  предполагаем,  что у вас  есть  Linux  с
инсталлированным  TCP/IP.  Это  включает основных клиентов, таких
как  <code>telnet</code>  и  <code>ftp</code>, команды системного администратора, такие как
<code>ifconfig</code>   и   <code>route</code>
(обычно  находящиеся  в  <code>/etc</code>),  и  сетевые
настроечные  файлы (такие как <code>/etc/hosts</code>). Другие, относящиеся к
Linux   сетевые  документы,  указанные  выше,  рассказывают,  как
инсталлировать  сетевые  программы  Linux,  если  это еще не было
сделано.</p>
<p></p>
<p>Мы  также  предполагаем,  что  ваше  ядро  было  настроено и
скомпилировано  с  поддержкой  TCP/IP.  Смотрите  Раздел  4.7. по
поводу компиляции ядра.</p>
<p></p>
<p>Когда  это сделано, вы должны модифицировать ряд настроечных
файлов,   используемых   NET-2.   Для   большинства  это  простая
процедура.   К   сожалению,  существует  большое  различие  между
дистрибутивами  Linux  относительно  того, где должны размещаться
различные   конфигурационные   файлы   TCP/IP   и  поддерживающие
программы.  Чаще  они  могут  быть обнаружены в <code>/etc</code>, но в других
случаях  их можно отыскать в <code>/usr/etc</code>, <code>/usr/etc/inet</code>,
<code>/sbin</code>
или в других
неожиданных   местах.</p>
<p>В   худшем  случае  вы  будете  вынуждены
использовать  команду  <code>find</code>  для  определения их местоположения в
вашей  системе.  Имейте  также  в  виду,  что не все дистрибутивы
хранят  программы и файлы описания для NET-2 в одном месте - они
могут быть разнесены по нескольким каталогам.</p>
<p></p>
<p>Следующая  информация  относится в первую очередь к связи по
Ethernet.  Если  вы планируете использовать SLIP, прочитайте этот
раздел,   чтобы   понять   концепции,   а   затем   обратитесь  к
специфическим для SLIP рекомендациям из последующего раздел.</p>
<p></p>
<h2>5.3.2.1 <A Name="ss5.3.2.1"> Описание вашей сети </h2>

<p>Прежде,  чем  вы  сможете  описать  (настроить)  TCP/IP, вам
необходимо  определиться  со  следующуей информацией относительно
установки сети.</p>
<p>
<ul>
<li>IP адрес. Это уникальный адрес машины в точечно-десятичном
формате.     Например,    128.253.153.54.    Ваши    сетевые
администраторы снабдят вас таким номером.

<p>Если  вы  настраиваете только режим loopback (т.е. без SLIP,
без  карт  Ethernet,  только  связь  по  TCP/IP внутри вашей
машины) то ваш IP адрес будет 127.0.0.1.</p>
<p></p>
</li>
<li>Маска  вашей  сети  (``netmask'').  Это "точкосодержащий"
квартет,  похожий  на IP адрес, определяющий, какая часть IP
адреса  относится  к  подсети,  а  какая  относится  к  host
(главной  машине)  этой  подсети.  (Если  вас  шокирует  эта
сетевая TCP/IP терминология - советуем почитать материалы по
управлению сетями).
<p>Сетевая  маска  есть набор бит, который, будучи наложеным на
адрес  вашей  сети,  сообщит, к какой подсети относится этот
адрес.  Это  очень  важно для для маршрутизации (routing), и
если   вы  обнаружите,  например,  что  вы  можете  свободно
общаться  с  людьми за пределами вашей сети, но не со своими
соратниками  внутри  собственной  сети,  высока  вероятность
того, что вы неправильно задали маску.</p>
<p>Администраторы  вашей  сети должны выбрать сетевую маску при
проектировании   сети,   поэтому   они  могут  сообщить  вам
правильную  маску.  Большинство  сетей  принадлежит классу C
подсетей,  которые  используют  сетевую маску 255.255.255.0.
Другой  класс  сетей  -  B использует 255.255.0.0. Программы
NET-2  автоматически  выберут  маску,  которая  предполагает
отсутствие  подсетей  по умолчанию, поскольку  иное
вы не указали явно.</p>
<p></p>
<p>Это  применимо также к порту loopback. Поскольку адрес порта
loopback  всегда  127.0.0.1,  сетевая  маска для этого порта
всегда   255.0.0.0.  Вы  можете задавать это явно или
полагаться на умолчание.</p>
<p></p>
</li>
<li>Адрес вашей сети. Это ваш IP адрес с наложенной побитовой
сетевой   маской.   Например,   если   ваша   сетевая  маска
255.255.255.0,  а  ваш  IP  адрес - 128.253.154.32, то адрес
вашей  сети  -  128.253.154.0. А с сетевой маской 255.255.0.0
адрес вашей сети будет 128.253.0.0.

<p>Если вы используете только loopback, у вас нет адреса сети.</p>
<p></p>
</li>
<li>Ваш  бродкаст  (broadcast  -  широковещательный)  адрес.
Бродкаст  адрес используется для раздачи бродкаст пакетов на
все  машины вашей подсети. Поэтому, если хост-номера машинам вашей
подсети даны по последним байтам IP-адресов
(сетевая  маска  255.255.255.0),  ваш  бродкаст  адрес будет
получен  из  вашего  сетевого  адреса  наложением 0.0.0.255.
Например,  если  ваш  IP адрес 128.253.154.32 и ваша сетевая
маска 255.255.255.0, то ваш бродкаст адрес 128.253.154.255.

<p>Чисто исторически сложилось, что некоторые сети настроены на
использование  сетевых  адресов как бродкаст адресов. Если у
вас   возникнут   сомнения,   пообщайтесь  с  вашим  сетевым
администратором.   (Во   многих  случаях  бывает  достаточно
продублировать   сетевую  настройку  других  машин  в  вашей
подсети, заменяя, разумеется IP адреса).</p>
<p></p>
<p>Если только вы используете loopback, у вас не будет бродкаст
адреса.</p>
<p></p>
</li>
<li>Ваш  шлюзовой  (<em>gateway</em>) адрес. Это адрес машины, которая
для  вас  является  "шлюзом"  во  внешний  мир (т.е. к
машинам не вашей подсети). Во многих случаях шлюзовая машина
имеет  IP  адрес,  идентичный вашему, но с ``.1'' в качестве
хост-адреса;  т.е.,  если  ваш  IP адрес 128.253.154.32, ваш
шлюз  может  быть 128.253.154.1. Ваш системный администратор
даст вам IP адрес вашего шлюза.

<p>На  самом  деле, вы можете иметь несколько шлюзов. <em>Шлюз</em> - это
просто  машина,  которая живет одновременно в двух различных
сетях  (имеет IP адреса различных подсетей) и маршрутизирует
пакеты  между  ними.  Многие  сети имеют по одному шлюзу "во
внешний    мир"    (к    сети,   непосредственно   с   вашей
состыкованной),  но  в  некоторых  случаях  у вас может быть
несколько шлюзов в смежные сети.</p>
<p></p>
<p>Если  только  вы  пользуетесь  loopback, у вас нет шлюзового
адреса.  То  же  самое имеет место, если у вас изолированная
сеть.</p>
<p></p>
</li>
<li>Адрес вашего сервера имен (nameserver). Большинство машин
в  сети имеют серверы имен, которые переводят имена хостов в
IP  адреса.  Администратор  вашей  сети  скажет адрес вашего
сервера имен.
Вы можете держать сервер на своей машине, используя <code>named</code>, в
этом  случае  адрес  сервера  имен будет 127.0.0.1. Заводить
сервер  имен  следует,  только  если у вас нет выбора, иначе
выберите  кого-то  другого в сети, кто может это обеспечить.
Настройка  <code>named</code> это совсем другая песня; нам кажется, что
вам  на  этом  этапе  лучше пообщаться с сетью. С именами вы
можете разобраться позже.

<p>Если  вы  единственный  имеете  loopback,  у  вас нет адреса
сервера имен.</p>
</li>
</ul>
</p>
<p></p>
<p>Пользователи  SLIP:  Вышеприведенная  информация  может  вам
потребоваться,  а  может  и  не  потребоваться.  Разве  что адрес
сервера   имен.  При  использовании  SLIP, ваш  IP  адрес  обычно
определяется  одним  из двух способов: (a) У вас "статический" IP
адрес, который не меняется в любое время выхода в сеть; (b) У вас
"динамический"  адрес, который берется из пула доступных адресов,
когда   вы   связываетесь   с   сервером.  В  следующем  разделе,
посвященном настройке SLIP, это рассматривается более детально.</p>
<p></p>
<p>NET-2  поддерживает  полную  маршрутизацию,  множественность
маршрутов,   обслуживание подсети (на этом этапе
только  в  пределах  байта).  Выше описывались основные настройки
TCP/IP.  Ваши  могут  быть  совсем  другими:  если есть сомнения,
проконсультируйтесь у местных гуру из соседних сетей и посмотрите
страницы    Руководства   про   route   и   ifconfig.   Настройка
TCP/IP выходит  далеко  за  рамки этой книги; вышенаписанного может
быть достаточно большинству людей для начала.</p>
<p></p>

<h2>5.3.2.2 <A Name="ss5.3.2.2"> rc-файлы в сети </h2>

<p><code>rc</code>-файлы широко используемые в системе сценарии, выполняемые
во  время  загрузки  программой  by  <code>init</code>, которая запускает всех
основных  системных  демонов (таких как <code>sendmail</code>, <code>cron</code>, и т.п.) и
настраивает такие вещи, как сетевые параметры, системное хост-имя
и  т.п.  rc-файлы  обычно  находятся в каталоге <code>/etc/rc.d</code>, но в
других системах они могут быть в <code>/etc</code>.</p>
<p></p>
<p>Здесь  мы  собираемся  описать  rc-файлы,  используемые  при
настройке  TCP/IP.  Файлов  два:  <code>rc.inet1</code>  и  <code>rc.inet2</code>.
<code>rc.inet1</code>
используется  для настройки базовых сетевых параметров (таких как
IP  адреса  и  маршрутизация) и <code>rc.inet2</code> запускает TCP/IP демонов
(<code>telnetd</code>, <code>tftpd</code> и т.д.).</p>
<p></p>
<p>Многие  системы  об'единяют  оба  этих  файла в один, обычно
называемый <code>rc.inet</code> или <code>rc.net</code>. Имена, данные вашим rc-файлам роли
не  играют, лишь бы они выполняли нужные функции и выполнялись во
время  загрузки  программой <code>init</code>. Чтобы это обеспечить, возможно
вам  потребуется  подредактировать <code>/etc/inittab </code>, чтобы
выполнить  соответствующие  rc-файлы. В худшем случае вам придется
создать <code>rc.inet1</code> и <code>rc.inet2</code> файлы заново и добавить информацию из
<code>/etc/inittab</code>.</p>
<p></p>
<p>Как   мы  говорили,  <code>rc.inet1</code>  настраивает  базовый  сетевой
интерфейс.  Это  включает  ваше  IP,  сетевой  адрес  и таблицу
маршрутизации   (routing   table)   для   вашей   сети.   Таблицы
маршрутизации используются для маршрутизации входящих и исходящих
сетевых дейтаграм (datagrams) на другие машины. Во многих простых
настройках  вы  имеете  три  маршрута:  один - для посылки пакетов
своей  собственной машине, другой - для посылки пакетов на другие
машины  вашей  сети,  третий  -  для  посылки  пакетов на машины,
находящиеся за пределами вашей сети (через шлюзовую машину). Есть
две  программы  для  настройки этих параметров: <code>ifconfig</code> и <code>route</code>.
Обе обычно находятся в <code>/etc</code> или <code>/sbin</code>.</p>
<p></p>
<p><code>ifconfig</code>  используется  для  настройки  интерфейса устройств
сети с необходимыми для функций параметрами, такими как IP адрес,
маска сети, бродкаст адрес и т п. <code>route</code>
используется для создания и модификации таблицы маршрутизации.</p>
<p></p>
<p>Для  многих  случаев  файл  <code>rc.inet1</code>  подойдет в том виде, в
каком   он   здесь   приведен.   Вы,   разумеется,  должны  будете
отредактировать   его   под  свою  систему.  Не  используйте  без
изменения  IP  и  сетевой  адреса,  приведенные  здесь в качестве
примера, они соответствуют действительной машине в Internet.
<blockquote><code>
<pre>

  #!/bin/sh
  # This is /etc/rc.d/rc.inet1 -- Configure the TCP/IP interfaces

  # First, configure the loopback device

  HOSTNAME=`hostname`

  /etc/ifconfig lo 127.0.0.1 # uses default netmask 255.0.0.0
  /etc/route add 127.0.0.1 # a route to point to the loopback device

  # Next, configure the ethernet device. If you're only  using
  # loopback or SLIP, comment out the rest of these lines.

  # Edit for your setup.
  IPADDR="128.253.154.32"     # REPLACE with YOUR IP address
  NETMASK="255.255.255.0"     # REPLACE with YOUR netmask
  NETWORK="128.253.154.0"     # REPLACE  with  YOUR  network address
  BROADCAST="128.253.154.255" # REPLACE with YOUR  broadcast address,
                                    # if you have one. If not, leave blank
                                    # and edit below.
  GATEWAY="128.253.154.1"     # REPLACE with  YOUR  gateway address!

  /etc/ifconfig eth0 ${IPADDR} netmask ${NETMASK} broadcast ${BROADCAST}

  # If you don't have a broadcast address, change the above line to:
  # /etc/ifconfig eth0 ${IPADDR} netmask ${NETMASK}

  /etc/route add ${NETWORK}

  # The following is only necessary if you have a gateway; that is,
  # your network is connected to the outside world.
  /etc/route add default gw ${GATEWAY} metric 1

  # End of Ethernet Configuration
</pre>
</code></blockquote>
</p>
<p></p>
<p>Может  вам  придется  немного  поковырять  этот  файл, чтобы
заставить  работать. Этот сценарий должен подходить для настройки
большинства простых сетей, но, разумеется, не для всех.</p>
<p></p>
<p><code>rc.inet2</code>  запускает  различные сервера, используемые TCP/IP.
Наиболее  важный  среди  них  -  <code>inetd</code>.  <code>inetd</code>  сидит  в  фоне  и
присматривает   за  различными  сетевыми  портами.  Когда  машина
пытается  связаться  с  конкретным  портом  (например, со входным
портом  telnet), <code>inetd</code> создает новую копию соответствующего демона
для   этого   порта   (в  случае  порта  telnet <code>inetd</code>  запускает
<code>in.telnetd</code>).  Это  проще, чем выполнять много независимых демонов
(т.е.   индивидуальных  копий  <code>telnetd</code>,  <code>ftpd</code>  и  т.п.)
-  <code>inetd</code>
запускает демонов только при возникновении необходимости.</p>
<p></p>
<p><code>syslogd</code>  -  это  системный  демон  входа  -  он аккумулирует
сообщения  о  входе  от  различных  источников  и  помещает  их в
log-файлы, зависящие от настройки <code>/etc/syslogd.conf</code>.
<code>routed</code> - это
сервер  используемый для сопровождения динамической информации по
маршрутизации. Когда ваша система пытается послать пакет в другую
сеть,  это  может  потребовать  дополнительных  записей в таблицу
маршрутизации,   чтобы   это   выполнить.   <code>routed</code>  заботится  о
сопровождении    таблицы    маршрутизации    без    необходимости
вмешательства человека.</p>
<p></p>
<p>Приведенный   ниже  пример <code>rc.inet2</code> запускает  лишь  самый
минимум  серверов.  Есть   и  другие  серверы  - многие из
которых  обслуживают  настройки NFS. Пытаясь установить TCP/IP на
вашей   системе,   обычно   лучше   всего  начать  с  минимальной
конфигурации  и  добавлять более сложные куски, (такие, как NFS),
когда у вас уже что-то работает.</p>
<p></p>
<p>Обратите   внимание,   что   в   нижеприведенном   файле  мы
предполагаем,  что  все сетевые демоны находятся в <code>/etc</code>. Ну и как
обычно отредактируйте этот файл под свою конфигурацию.</p>
<p>
<blockquote><code>
<pre>
    #! /bin/sh
    # Sample /etc/rc.d/rc.inet2

    # Start syslogd
    if [ -f /etc/syslogd ]
    then
            /etc/syslogd
    fi

    # Start inetd
    if [ -f /etc/inetd ]
    then
            /etc/inetd
    fi

    # Start routed
    if [ -f /etc/routed ]
    then
            /etc/routed -q
    fi

    # Done!
</pre>
</code></blockquote>
</p>
<p></p>
<p>Среди  многих  дополнительных  серверов,  которые  вы можете
запустить  в <code>rc.inet2</code> - <code>named</code>. <code>named</code> -
это сервер имен.
Он отвечает за перевод (локальных) IP адресов в имена и наоборот.
Если  у вас где-нибудь в сети нет сервера имен или вы сами хотите
снабжать  локальными  именами  машин другие машины вашего домена,
использование  named необходимо. (Но для большинства случаев в
этом нет необходимости).  Настройка  named достаточно сложна и
требует     предварительного     планирования.     Мы    отсылаем
заинтересованных читателей к хорошим книгам по TCP/IP.</p>
<p></p>

<h2>5.3.2.3 <A Name="ss5.3.2.3"> /etc/hosts </h2>

<p><code>/etc/hosts</code>  содержит  перечень  IP  адресов  и  имен хостов,
которым  они  соответствуют.  В  общем, <code>/etc/hosts</code> содержат только
записи  для  вашей  локальной  машины  и,  возможно, других
"важных"  машин  (таких  как сервер имен или шлюз).
Перевод имя - адрес для других машин сети обеспечивает сервер имен.</p>
<p></p>
<p>Например,если  ваша  машина  называется  <code>loomer.vpizza.com</code> и
имеет  IP  адрес  128.253.154.32,  ваш <code>/etc/hosts</code> будет выглядеть
как:</p>
<p>
<blockquote><code>
<pre>
    127.0.0.1               localhost
    128.253.154.32          loomer.vpizza.com loomer
</pre>
</code></blockquote>
</p>
<p></p>
<p>Если  вы  используете только loopback, единственная строка в
<code>/etc/hosts</code>  должна  быть  для  127.0.0.1  с  именами <code>localhost</code>
и хост-именем вашей машины.</p>
<p></p>

<h2>5.3.2.4 <A Name="ss5.3.2.4"> /etc/networks </h2>

<p>Файл  /etc/networks  содержит  ваши  имена и адреса, а также
других   сетей.   Он  используется  командой  route  и  позволяет
описывать сеть именами, если вы это захотите.</p>
<p></p>
<p>Всякая  сеть,  которую  вы хотите добавить в маршрутизацию с
использованием  команды  route  (обычно  вызываемой  из <code>rc.inet1</code>)
должна иметь запись в <code>/etc/networks</code>.</p>
<p>
<blockquote><code>
<pre>
     Пример.

    default 0.0.0.0 # default route    - mandatory
    loopnet 127.0.0.0 # loopback network - mandatory
    mynet 128.253.154.0 # Modify for your own network address
</pre>
</code></blockquote>
</p>
<p></p>

<h2>5.3.2.5 <A Name="ss5.3.2.5"> /etc/host.conf </h2>

<p>Чтобы обратиться к машине по домену, система должна
определить ее физический адрес (IP-адрес).
Система делает это либо находя соответствующий домен
в файле <code>/etc/hosts</code> (см. руководство), либо
обращаясь к специальным серверам, называемым серверами имен (nameserver).
Файл <code>/etc/host.conf</code> задает
Этот  файл  используется  для  описания  порядка
просмотра этих возможностей.</p>
<p>
<blockquote><code>
<pre>
    order hosts,bind
    multi on
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эти строки указывают библиотекам разрешения вначале искать в
файле  <code>/etc/hosts</code>  требуемый домен,  а  потом обратиться к
серверу  имен  (если  таковой  имеется).  Строка <code>multi</code> допускает
множество IP адресов для одного имени машины в <code>/etc/hosts</code>.</p>
<p></p>

<h2>5.3.2.6 <A Name="ss5.3.2.6"> /etc/resolv.conf </h2>

<p>Этот  файл  настраивает  программы определения
физического IP-адреса по домену машины,
указывая  IP-адрес вашего сервера имен  и имя вашего домена.
Имя вашего  домена,  это доменный адрес вашей машины в сети,
с  отброшенным  именем машины. Так
например,  если  ваше  полное  хост-имя <code>loomer.vpizza.com</code>, то имя
вашего домена просто <code>vpizza.com</code>.</p>
<p></p>
<p>Например, если ваша машина <code>goober.norelco.com</code> и имеет сервер
имен   с   адресом   128.253.154.5,  ваш  <code>/etc/resolv.conf</code>  будет
выглядеть:</p>
<p>
<blockquote><code>
<pre>
    domain      norelco.com
    nameserver  127.253.154.5
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы  можете описать более одного сервера имен - каждый должен
иметь свою строку в <code>resolv.conf</code>.</p>
<p></p>

<h2>5.3.2.7 <A Name="ss5.3.2.7"> Установка хост-имени (hostname) </h2>

<p>Хост-имя  устанавливается  с  помощью  команды <code>hostname</code>. Она
обычно вызывается из <code>/etc/rc</code> или <code>/etc/rc.local</code>; просто просмотрите
свои  системные  rc-файлы, откуда вызывается. Например, если ваше
(полное)      хост-имя      loomer.vpizza.com,     отредактируйте
соответствующий rc-файл, выполнив команду:</p>
<p></p>
<p>/bin/hostname loomer.vpizza.com</p>
<p></p>
<p>Обратите внимание, что команды <code>hostname</code> может не оказаться в
/bin.</p>
<p></p>

<h2>5.3.2.8 <A Name="ss5.3.2.8"> Попытка не пытка </h2>

<p>После  того, как вы установили все эти файлы, вы должны быть
готовы   перезагрузить   новое  ядро  и  попытаться  обрадоваться
работающей сети. Правда, существует слишком много мест,
где могут спрятаться ошибки,
так что разумным будет проверить отдельные аспекты настройки сети
(например,  не  самая  хорошая  идея  для тестирования сети сразу
шарахнуть по ней  с помощью Mosaic
с X-протоколом поверх IP).
<sl>(прим. переводчика: сегодня бы
автор вспомнил про Netscape)</sl>

</p>
<p></p>
<p>Вы  можете  использовать  команду  <code>netstat</code>, чтобы посмотреть
таблицы    маршрутизации;   это   обычно   источник   большинства
неприятностей.  Руководство по <code>netstat</code> описывает точный синтаксис
этой  команды  в деталях. Для того, чтобы проверить связи в сети,
мы  предлагаем  использовать  клиента,  такого, как <code>telnet</code>, чтобы
связать  машины  вашей  локальной  подсети  и  внешней  сети. Это
позволит  локализовать  ошибки.  (Например,  если  вы  не  можете
связаться  с локальной машиной, но связываетесь с машинами других
сетей,  скорее  всего есть проблема с сетевой маской и настройкой
таблицы  маршрутизации).  Вы  можете  также  прямо вызвать команду
<code>route</code>   (под  <code>root</code>)   поэкспериментировать  с  записями  таблицы
маршрутизации.</p>
<p></p>
<p>Вам  следует  также проверить связи в сети прямо указывая IP
адреса  вместо  хост-имен.  Например,  если у вас есть проблемы с
командой</p>
<p>
<blockquote><code>
<pre>
    $ telnet shoop.vpizza.com
</pre>
</code></blockquote>
</p>
<p></p>
<p>Причина  может  быть  в некорректной настройке сервера имен.
Попытайтесь использовать физический IP адрес машины; если это
поможет,  тогда  вы  будете  знать,  что  ваши  основные  сетевые
установки  (скорее  всего)  правильны и проблема лежит в описании
адреса сервера имен.</p>
<p></p>
<p>Отладка  сетевых настроек может быть трудной задачей и мы не
можем  здесь  втягиваться  в  ее  обсуждение.  Если  вы не можете
получить помощь от местных гуру, мы очень вам советуем почитать
<em>Linux Network Administrators' Guide</em> из LDP.</p>
<p></p>


<h2>5.3.3 <A Name="ss5.3.3"> Настройка SLIP </h2>

<p>SLIP  (Serial Line Internet Protocol) позволяет использовать
TCP/IP  на последовательных  линиях,  будь  то  коммутируемая
телефонная  линия  с  модемом  или  выделенная асинхронная линия.
Разумеется,   для  использования  SLIP  вам  необходим  доступ  к
SLIP-серверу. Многие университеты и фирмы за умеренную плату
предоставляют SLIP-вход.</p>
<p></p>
<p>Есть  две  основные  программы,  использующие  SLIP: <code>dip</code>  и
<code>slattach</code>.   Обе   эти  программы  используются  для  установления
SLIP-соединения  через  последовательные  устройства.  Необходимо
использовать  одну  из  этих программ, чтобы активизировать SLIP,
недостаточно   просто  дозвониться  до  SLIP-сервера  (с  помощью
коммуникационной  программы  вроде  <code>kermit</code>)  и  запустить команды
<code>ifconfig</code>  и  <code>route</code>, так как  <code>dip</code>  и <code>slattach</code> формируют
специальный системный вызов <code>ioctl()</code>, чтобы перехватить управление
последовательным устройством для реализации SLIP-интерфейса.</p>
<p></p>
<p>Dip   может произвести дозвонку  до  SLIP-сервера,
обеспечить  соединение  (handshaking)  и войти на сервер (указав
например,  имя и пароль), а затем инициировать SLIP-соединение по
последовательной  линии.
slattach же не делает ничего,
кроме  захвата  устройства  для  использования его SLIP. Это
полезно,  если  вы имеете постоянную линию для SLIP-сервера и нет
необходимости  в  дозвонке и соединении для обеспечения связи. Но
большинство пользователей предпочитает использовать <code>dip</code>.</p>
<p></p>
<p>Dip  можно  также  использовать  для настройки вашей системы
Linux   в  качестве  SLIP-сервера,  когда  другие  машины  к  вам
дозваниваются  и  выходят  в  сеть через вторичное соединение по
Ethernet  на  вашей  машине.  Дополнительную  информацию  по этой
процедуре смотрите в Руководстве на dip.</p>
<p></p>
<p>SLIP  весьма отличается от Ethernet, в нем только две машины
в  "сети"  SLIP-хост (это вы) и SLIP-сервер. По этой причине SLIP
часто  воспринимается  как  связь ``point-to-point'' (от точки до
точки).  Обобщение  этой  идеи, известное как PPP (Point to Point
Protocol) также реализовано в Linux.</p>
<p></p>
<p>Когда  вы  инициируете  связь  со SLIP-сервером, SLIP-сервер
даст  вам IP адрес. Некоторые
SLIP-серверы  выдают  "статические" IP адреса - в этом случае ваш
IP  адрес  будет  тот  же  самый  всегда, когда вы связываетесь с
сервером.  Но  большинство  SLIP-серверов выдают IP адреса динамически,
когда  при  каждой  связи  вы  получаете IP адрес заново. В общем
случае  SLIP-сервер  сообщит  вам  при  установлении связи ваш IP
адрес  и  адрес шлюза. dip способен читать эти значения при входе
на SLIP-сервер и использовать их для настройки самого SLIP.</p>
<p></p>
<p>Существенное  замечание.  Настройка  связи по SLIP похожа на
настройку  loopback  или  ethernet.  Основные отличия обсуждаются
ниже.  Прочитайте  предыдущий раздел про настройку базовых файлов
TCP/IP, и выполните изменения, описанные ниже.</p>
<p></p>
<h2>5.3.3.1 <A Name="ss5.3.3.1"> Соединение по dip при статическом IP адресе </h2>

<p>Если  вы  используете  SLIP-сервер,  выдающий статические IP
адреса,  вы  можете  включить записи о ваших IP адресе и
хост-имени в <code>/etc/hosts</code>. А также настроить файлы, перечисленные в
предыдущем  разделе:  <code>rc.inet2</code>,  <code>host.conf</code> и <code>resolv.conf</code>.
Также
настроить <code>rc.inet1</code>, как описано выше.
Если  вы  используете  для  связи  со  SLIP-сервером <code>dip</code>,
то в файле <code>rc.inet1</code> для последовательного порта
команды <code>ifconfig</code> и <code>route</code> вызывать не надо,
<code>dip</code> вызовет эти команды после установления соединения.
(Если же
вы, используете <code>slattach</code>, вам будет необходимо включить
команды <code>ifconfig</code> и route в <code>rc.inet1</code> для SLIP - смотрите ниже).</p>
<p></p>
<p><code>dip</code>  должен   настраивать  соответствующим  образом  таблицы
маршрутизации  для SLIP когда вы связываетесь. Однако, в некоторых
случаях  поведение <code>dip</code> может быть неправильным для ваших настроек
и вам надо будет вручную выполнять команды <code>ifconfig</code>
или <code>route</code> после
того,  как  <code>dip</code>  свяжется  с сервером (это легче всего сделать из
сценария   shell,   который  содержит  вызов  <code>dip</code>,  и  немедленно
выполнить  соответствующие  команды  настройки).  Ваш  шлюз, это в
большинстве  случаев  адрес  SLIP-сервера.  Вы  можете знать этот
адрес  заранее  или  адрес  шлюза будет выведен SLIP-сервером при
установлении  связи.  Сценарий  работы <code>dip</code> (описанный ниже) может
также получать эту информацию от SLIP-сервера.</p>
<p></p>
<p>ifconfig может потребовать аргумента "pointopoint", если <code>dip</code>
не  настроил  правильно  интерфейс.  Например,  если адрес вашего
SLIP-сервера  128.253.154.2,  а  ваш IP-адрес 128.253.154.32, вам
может потребоваться выполнить команду под root</p>
<p>
<blockquote><code>
<pre>
    ifconfig sl0 128.253.154.32 pointopoint 128.253.154.2
</pre>
</code></blockquote>
</p>
<p>после связи по dip.</p>
<p></p>
<p>Обратите  внимание,  что  имена SLIP-устройств, используемые
командами <code>ifconfig</code> и <code>route</code> - <code>sl0</code>, <code>sl1</code>
и т.д.</p>
<p></p>
<p>В  Разделе  5.3.4 мы об'ясним, как настраивать <code>dip</code> для связи
со SLIP-сервером.</p>
<p></p>

<h2>5.3.3.2 <A Name="ss5.3.3.2"> Соединение по slattach при статическом IP адресе </h2>

<p>Если  у  вас  выделенная  линия  или  кабель, идущий прямо к
SLIP-серверу,   то   нет   необходимости   использовать  <code>dip</code>  для
инициализации связи. Вместо этого может быть использована команда
<code>slattach</code>.  В  этом случае ваш файл <code>/etc/rc.inet1</code> должен выглядеть
примерно так:</p>
<p>
<blockquote><code>
<pre>
    #!/bin/sh
    IPADDR="128.253.154.32"         # Replace with your IP address
    REMADDR="128.253.154.2" # Replace with your SLIP server address

    # Modify the following for the appropriate serial device for
    # the SLIP connection:
    slattach -p cslip -s 19200 /dev/ttyS0
    /etc/ifconfig sl0 $IPADDR pointopoint $REMADDR up
    /etc/route add default gw $REMADDR
</pre>
</code></blockquote>
</p>
<p></p>
<p><code>slattach</code>  выделяет  первое  свободное  SLIP-устройство (<code>sl0</code>,
<code>sl1</code>, и т.д.) определенной последовательной линии.</p>
<p></p>
<p>Обратите  внимание,  что  первый параметр команды <code>slattach</code> -
это  используемый SLIP-протокол. В настоящее время возможны только
значения  <code>slip</code>  и  <code>cslip</code>.  <code>slip</code> - это  обычный  SLIP, как и
следовало  ожидать,  а  <code>cslip</code> - это SLIP с компрессией заголовков
дейтаграмм. В большинстве случаев вам следует использовать <code>cslip</code>;
однако, если у вас с ним возникают проблемы, попробуйте <code>slip</code>.</p>
<p></p>
<p>Если у вас более одного SLIP-интерфейса, то вы должны
принять  решения  относительно  маршрутизации.  Вы должны решить,
какие  маршруты добавить, и эти решения могут быть сделаны только
на  базе  действительного  протокола связей вашей сети. Здесь вам
могут помочь, как книга по TCP/IP, так и Руководство.</p>
<p></p>

<h2>5.3.3.3 <A Name="ss5.3.3.3"> Соединение по dip при динамическом IP адресе </h2>

<p>Если  ваш  SLIP-сервер  выдает IP адреса динамически, то вы,
разумеется,  не  знаете  заранее свой адрес, поэтому вы не можете
включить  его  в <code>/etc/hosts</code>. (Между тем вы должны включить запись
для  своего  хоста  с  адресом  обратной  связи (loopback address)
127.0.0.1.)</p>
<p></p>
<p>Многие  SLIP-сервера  выдают ваш IP адрес (также как и адрес
сервера)  во  время  соединения.  Например, один тип SLIP-сервера
выдает такое сообщение:</p>
<p>
<blockquote><code>
<pre>
    Your IP address is 128.253.154.44.
    Server address is 128.253.154.2.
</pre>
</code></blockquote>
</p>
<p></p>
<p><code>dip</code>   может  перехватить  эти  номера  с  выхода  сервера  и
использовать  их для настройки SLIP-устройств.</p>
<p></p>
<p>Смотрите  выше  Раздел  5.3.3.1  относительно  информации по
настройке  различных  файлов  для  TCP/IP при использовании SLIP.
Ниже   мы   об'ясняем,   как   настраивать  <code>dip</code>   для  связи  со
SLIP-сервером.</p>
<p></p>
<p></p>


<h2>5.3.4 <A Name="ss5.3.4"> Использование dip </h2>

<p><code>dip</code>  может  упростить  процесс  соединения со SLIP-сервером,
войти   и   настроить  SLIP-устройства.  Если  только  у  вас  не
выделенная линия для SLIP-сервера, <code>dip</code> - это то, что вам надо.</p>
<p></p>
<p>Для  использования  <code>dip</code>  вы должны написать "сценарий болтовни"
(``chat script''), который содержит перечень команд, используемых
для связи со SLIP-сервером при входе в систему. Эти команды могут
автоматически  посылать ваши имя/пароль серверу, а также получать
информацию о вашем IP адресе с сервера.</p>
<p></p>
<p>Вот  пример  такого  сценария  для  использования с сервером
динамических IP адресов. Для статических серверов вам потребуется
в начале сценария установить значения переменных <code>$local</code>
и <code>$remote</code>.
В  соответствии  с  вашими локальным IP адресом и адресом сервера
соответственно.  Более  детальную  информацию  можно  получить  в
Руководстве на <code>dip</code>.</p>
<p>
<blockquote><code>
<pre>
    main:
      # Set Maximum Transfer Unit. This is the maximum size of packets
      # transmitted on the SLIP device. Many SLIP servers use either
      # 1500 or 1006; check with your network admins when in doubt.
      get $mtu 1500

      # Make the SLIP route the default route on your system.
      default

      # Set the desired serial port and speed.
      port cua03
      speed 38400

      # Reset the modem and terminal line. If this causes trouble
      # for you, comment it out.
      reset

      # Prepare for dialing. Replace the following with your
      # modem initialization string.
      send AT&amp;C1&amp;D2\\N3&amp;Q5%M3%C1N1W1L1S48=7\r
      wait OK 2
      if $errlvl != 0 goto error
      # Dial the SLIP server
      dial 2546000
      if $errlvl != 0 goto error
      wait CONNECT 60
      if $errlvl != 0 goto error

      # We are connected.  Login to the system.
    login:
      sleep 3
      send \r\n\r\n
      # Wait for the login prompt
      wait login: 10
      if $errlvl != 0 goto error

      # Send your username
      send USERNAME\n

      # Wait for password prompt
      wait ord: 5
      if $errlvl != 0 goto error

      # Send password.
      send PASSWORD\n

      # Wait for SLIP server ready prompt
      wait annex: 30
      if $errlvl != 0 goto error

      # Send commands to SLIP server to initate connection.
      send slip\n
      wait Annex 30

      # Get the remote IP address from the SLIP server. The
      # `get...remote' command reads text in the form xxx.xxx.xxx.xxx,
      # and assigns it to the variable given as the second argument
      # (here, $remote).
      get $remote remote
      if $errlvl != 0 goto error
      wait Your 30

       # Get local IP address from SLIP server, assign to variable
       # $local.
      get $local remote
      if $errlvl != 0 goto error

      # Fire up the SLIP connection

    done:
      print CONNECTED to $remote at $rmtip
      print GATEWAY address $rmtip
      print LOCAL address $local
      mode SLIP
      goto exit
    error:
      print SLIP to $remote failed.

    exit:
</pre>
</code></blockquote>
</p>
<p></p>
<p><code>dip</code>   автоматически  выполняет  команды  <code>ifconfig</code>  и
<code>route</code>,
базирующиеся  на значениях переменных
<code>$local</code> и <code>$remote</code>. Здесь этим
переменным  присваиваются  значения  с  использованием  удаленных
команд   <code>get...</code>,  которые  получают  текст  со  SLIP-сервера  и
присваивают его названной переменной.</p>
<p></p>
<p>Если команды <code>ifconfig</code> и <code>route</code>, которые
выполняет для вас <code>dip</code>
не  работают,  вы  можете  либо  выполнить  правильные  команды в
сценарии  shell после выполнения <code>dip</code>, либо модифицировать исходник
для  самого  <code>dip</code>.  Выполнение  <code>dip</code>  с  опцией
<code>-v</code> будет выдавать
отладочную  информацию  в процессе установления связи, что должно
помочь  в  определении  ошибок  в работе. Теперь, для того, чтобы
выполнить  <code>dip</code>  и  открыть SLIP-соединение вы можете использовать
команду, вроде:</p>
<p>
<blockquote><code>
<pre>
    /etc/dip/dip -v /etc/dip/mychat 2&gt;&1
</pre>
</code></blockquote>
</p>
<p></p>
<p>Где   различные  dip-файлы  и  сценарий  болтовни  (<code>mychat.dip</code>)
помещены  в  <code>/etc/dip</code>.  Вышеприведенное  обсуждение  должно  быть
достаточным  для  вашего  хорошего самочувствия на славном пути в
сетевое   сообщество   через   Ethernet   или   SLIP.  И вновь  мы
настоятельно  рекомендуем  заглянуть в книгу по TCP/IP, особенно,
если  ваша сеть имеет специфику в маршрутизации, отличающую ее от
рассмотренных здесь.</p>
<p></p>


<h2>5.4 <A Name="ss5.4"> Сетевая работа с UUCP </h2>

<p>UUCP (UNIX-to-UNIX  Copy) - старейший механизм, используемый
для  передачи  информации между системами UNIX. При использовании
UUCP,  системы UNIX созваниваются друг с другом (используя модем)
и  передают  почтовые сообщения, новости, файлы и т.п. Если у вас
нет  TCP/IP  или SLIP доступа, вы можете использовать для связи с
миром   UUCP.  Большая  часть  программ,  связанных  с  почтой  и
новостями  (смотрите  Разделы  5.5 и 5.6) может быть настроена на
использование  UUCP  для  передачи  информации  на другие машины.
Действительно,  если  поблизости  есть  узел  Internet, вы можете
иметь доступ к почте Internet, получая ее с узла по UUCP.</p>
<p></p>
<p>Книга   <em>Linux   Network   Administrator's  Guide</em>  содержит
исчерпывающую  информацию  по  настройке и использованию UUCP под
Linux.  Кроме  того,  по  anonymous FTP <code>sunsite.unc.edu</code>, доступна
<em>Linux  UUCP  HOWTO</em>,  которая  может быть весьма полезна. Другой
источник  информации  по UUCP - книга Tim O'Reilly и Grace Todino
<em>Managing UUCP and USENET</em>. Дополнительно смотрите Приложение A.</p>
<p></p>
<p></p>

<h2>5.5 <A Name="ss5.5"> Электронная почта </h2>

<p>Как   и   множество   систем  UNIX,  Linux  имеет  несколько
программных  пакетов  для использования электронной почты. E-mail
(электронная  почта)  на  вашей системе может быть либо локальная
(то  есть  вы можете обмениваться почтой с другими пользователями
вашей системы) или сетевая (то есть вы посылаете почту, используя
либо  TCP/IP,  либо UUCP, другим пользователям). Программы e-mail
обычно  состоят  из двух частей: <em>мэйлер</em> и <em>транспорт</em>. Мэйлер -
это  программы пользовательского уровня, которые используются для
формирования  и  чтения  почтовых  сообщений.  Популярные мэйлеры
включают  <code>elm</code>  и  <code>mailx</code>.  Транспорт  -  это  программы системного
уровня,  которые отвечают за доставку почты, как локальной, так и
удаленной.  Пользователь  никогда не видит программы "транспорт";
они  взаимодействуют  только с мэйлером. Но, назвавшись системным
администратором,   человек  должен  понимать  концепции  программ
"транспорта" и как их настраивать.</p>
<p></p>
<p>Наиболее  популярная  транспортная программа для Linux - это
<code>Smail</code>.  Эту  программу  просто  настраивать.  Она  может посылать
e-mail,  локально  и  удаленно  по TCP/IP и по UUCP.
Yf
В большинстве систем UNIX используется более мощная программа
<code>sendmail</code>,
однако,  из-за сложного механизма установки, многие системы Linux
ее не используют.</p>
<p></p>
<p><em>Linux  Mail  HOWTO</em>  дает  больше  информации  относительно
доступных  почтовых программ для Linux и как их настраивать. Если
вы  планируете  послать  почту удаленному пользователю, вы должны
понимать  либо  TCP/IP  или  UUCP, в зависимости от того, каким образом
ваша  машина  подключена в сеть (смотри Разделы 5.3 и 5.4). Может
быть  полезной  документация  по  UUCP  и TCP/IP, перечисленная в
Приложении А.</p>
<p>Большинство  почтовых программ можно достать через anonymous
FTP с <code>sunsite.unc.edu</code> в каталоге <code>/pub/Linux/system/Mail</code>.</p>
<p></p>

<h2>5.6 <A Name="ss5.6"> Новости и USENET </h2>

<p>Linux  также  обеспечивает  ряд  возможностей  для  работы с
электронными новостями. При желании вы можете установить на вашей
системе  локальный сервер новостей, который позволит вам посылать
"статьи"    (``articles'')   в   различные   "группы   новостей"
(``newsgroups'')...  Удобная форма организации обсуждений. А если
вы  имеете  выход  по  TCP/IP  или UUCP в сеть, тогда вы будете в
состоянии участвовать в USENET - всемирной сети новостей.</p>
<p></p>
<p>Программы  новостей  состоят  из  двух  частей  -  <em>сервера</em> и
<em>клиента</em>.  <em>Сервер  новостей</em>  -  это  программа,  которая управляет
группами  новостей  и  занимается  доставкой писем другим машинам
(если  вы  в сети). Клиент новостей ( <em>newsreader</em>)
это  программа,  которая  связывает с сервером, который позволяет
пользователям получать и посылать новости.</p>
<p></p>
<p>Для  Linux  есть  несколько серверов новостей. Они все имеют
одни  базовые  протоколы  и  принципы. Две первые версии, это ``C
News'' и ``INN''. Существует также много типов "читалок" новостей
(newsreaders),  например  <code>rn</code>  и <code>tin</code>. Выбор читалки в той или иной
мере  дело  вкуса.  Все  читалки  работают одинаково с различными
версиями  серверных  программ.  Так  что  читалка  независима  от
сервера и наоборот.</p>
<p></p>
<p>Если  вы хотите лишь вести локальные новости (а не как часть
USENET),  то  вам  потребуется завести сервер на своей системе, а
также  инсталлировать  читалку для пользователей. Сервер новостей
будет    хранить    статьи    в   каталоге,   например
<code>/usr/spool/news</code>, а читалка будет их просматривать в поисках
поступивших новостей.</p>
<p></p>
<p>Если  вы захотите вести сетевые новости, вам предоставляется
несколько  возможностей. Новости, базирующиеся на сетевом TCP/IP,
используют   протокол,   известный   как   NNTP   (Network   News
Transmission  Protocol).  NNTP  позволяет  читалке читать новости
прямо  удаленно  по  сети. NNTP также позволяет серверам новостей
посылать  по  сети статьи друг другу,  это программа, на которой
базируется  USENET.  Большинство  фирм и университетов имеют один
или   более   NNTP-серверов, установленых  для  работы  со  всеми
новостями USENET данного узла. Каждая вторая машина на узле имеет
базирующуюся  на  NNTP  читалку  для чтения и посылки новостей по
сети  через  NNTP-  сервер.  Это означает, что только NNTP-сервер
действительно хранит новости на диске.</p>
<p></p>
<p>Далее следует несколько сценариев настройки новостей.</p>
<p>
<ul>
<li>Вы  ведете  новости  локально.  То  есть у вас нет в сеть
выхода  или  желания  возиться  с сетевыми новостями. В этом
случае  вам  надо выполнять C News или INN на вашей машине и
инсталлировать читалку для чтения местных новостей.
</li>
<li>У  вас есть выход по TCP/IP в сеть и на NNTP-сервер. Если
ваша  организация  имеет  NNTP-сервер  новостей,  вы  можете
читать  и  посылать новости с вашей Linux-машины, всего лишь
инсталлировав   у   себя   базирующуюся   на  NNTP  читалку.
(Большинство  доступных  читалок  может  быть настроено и на
локальные новости и на использование NNTP). В этом случае вы
не  нуждаетесь  в  инсталляции  сервера новостей или храните
новости  на  своей  системе. Читалка позаботится о чтении и
посылке   новостей  по  сети.  Разумеется,  вам  потребуется
настроенное TCP/IP и выход в сеть (смотрите Раздел 5.3).
</li>
<li>Вы имеете доступ к сети TCP/IP, но не имеете NNTP-сервера.
В этом случае вы можете использовать NNTP-сервер новостей на
своей   системе   Linux.   Вы   можете  инсталлировать  либо
локальную,  либо базирующуюся на NNTP читалку и сервер будет
помещать  новости  на  вашу систему. В дополнение, вы можете
настроить сервер для взаимодействия с другими NNTP-серверами
новостей для передачи статей.
</li>
<li>Вы  хотите  передать  новости, используя UUCP. Если у вас
есть  доступ  по  UUCP  (смотри Раздел 5.4), вы также можете
приобщиться  к  USENET.  Вам будет необходимо инсталлировать
(локальный)   сервер  новостей  и  программы  чтения  почты.
Дополнительно,  вам   необходимо   настроить  вашу  UUCP  на
периодическую    передачу   (прием)   новостей   на   другую
близлежащую  UUCP машину (известную как "источник новостей"
(``news  feed'')).  UUCP  не использует передачу новостей по
NNTP;  просто  у  UUCP  свой  собственный  механизм передачи
новостей.</li>
</ul>
</p>
<p></p>
<p>Темная   сторона   многих   серверов   новостей   и  читалок
заключается в том, что они должны собираться вручную. Большинство
программного  обеспечения новостей не использует файлы настройки.
Вместо этого опции настройки определяются при компиляции.</p>
<p></p>
<p>Большинство "стандартных" программ новостей (доступных через
anonymous  FTP с сервера <code>ftp.uu.net</code> каталог <code>/news</code>) -
готовые для
компиляции  полуфабрикаты.  Необходимые изменения (patches) можно
найти   на  <code>sunsite.unc.edu</code>  в  <code>/pub/Linux/system/Mail</code>
(который,
совершенно случайно, находится там же, где Linux). Другие бинарные
файлы  программ  новостей  для  Linux  можно  также  найти в этом
каталоге.</p>
<p></p>
<p>За  дополнительной  информацией  обращайтесь  к
<em>Linux News HOWTO</em>  на
<code>sunsite.unc.edu</code>  в <code>/pub/Linux/docs/HOWTO</code>. Кроме того,
входящий  в  проект  LDP
<em>Linux  Network  Administrator's  Guide</em>
содержит  исчерпывающую информацию по настройке программ новостей
для  Linux.  Книга Tim O'Reilly и Grace Todino
<em>Managing UUCP and Usenet</em>
замечательное  руководство  по установке UUCP и программ
новостей.  Представляет интерес и документ USENET
``How to become
a   USENET   site'',   доступный   на  <code>ftp.uu.net</code>,  в каталоге
<code>/usenet/news.announce.newusers</code>.</p>
<p></p>
<p></p>

<p><a href="lig-6.html"> След. </a> Глава, <a href="lig-4.html"> Пред. </a> Глава</p><p>Содержимое <a href="lig.html#toc5">этой главы</a>,
 Главное <a href="lig.html#toc">оглавление</a></p>
<p><a href="lig.html"> Начало </a> документа,
 <a href="lig-5.html#0"> Начало этой главы</a></p>