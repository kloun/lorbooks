<title>Знакомство с Linux</title>
<?php include("/home/maxcom/linux_html/books/head.php3") ?>
<h1>3 <a name="s3"> Знакомство с Linux </h1>
<p> <a href="lig.html#toc3"> Содержимое этого раздела</a></p>

<h2>3.1 <A Name="ss3.1"> Введение </h2>

<p>Новые  пользователи  UNIX  и  Linux  могут  быть  ошеломлены
размерами и очевидной сложностью системы, которая предстала перед
ними.  Существует  много  хороших  книг по использованию UNIX для
всех  уровней  подготовки:  от новичка до эксперта. Но ни одна из
этих  книг  не  обсуждает  особенности  Linux.  Хотя  95%  всего
связанного  с  использованием  Linux  абсолютно аналогично другим
UNIX-системам,  наиболее  прямой путь освоения этой системы - это
по  учебнику,  написанному применительно к Linux. Вот эта книга и
есть такой учебник.</p>
<p></p>
<p>Эта глава не заводит в дебри деталей и не обсуждает наиболее
сложные  <F>прим.  переводчика:  они  (и  уже у нас тоже) говорят -
продвинутые</F>   аспекты   Linux.  Вместо  этого  делается  попытка
поставить  новичка  крепко  на  ноги,  чтобы  он мог в дальнейшем
читать  и  более  общие  книги  по UNIX, понимая базовые различия
других UNIX-систем и Linux.</p>
<p></p>
<p>Здесь  не предполагается каких-то предварительных знаний, за
исключением первоначального знакомства с персональным компьютером
и  MS-DOS.  Но  даже  если  вы  не  успели побывать пользователем
MS-DOS,  вы  все  равно  все здесь поймете. На первый взгляд UNIX
очень  похож  на  MS-DOS  (в  конце-концов  фрагменты MS-DOS были
спроектированы  с  оглядкой на операционную систему CP/M, которая, в
свою  очередь,  проектировалась с оглядкой на UNIX). Но только при
очень  уж поверхностном взгляде можно говорить о похожести UNIX и
MS-DOS.   Если   вы   абсолютный   новичок  в  мире  персональных
компьютеров, этот учебник вам поможет.</p>
<p></p>
<p>И    прежде,    чем    начать,    призываем:
<em>не бойтесь экспериментировать</em>.
Система  вас  не  укусит.  Работая на ней вы
ничего не сможете сломать. UNIX имеет встроенные средства защиты,
чтобы  не  дать  "нормальным"  пользователям  (это  теперь  и вы)
возможность испортить важные для системы файлы. Самое плохое, что
вы  можете  натворить  -  это  уничтожить все свои файлы, а тогда,
может  быть  придется  и переинсталлировать заново систему <F>прим.
переводчика:    как    правило,    чтобы   довести   систему   до
переинсталляции,  надо  иметь  прав  больше,  чем у "нормального"
пользователя</F>.</p>
<p></p>

<h2>3.2 <A Name="ss3.2"> Базовые концепции UNIX </h2>

<p>UNIX  это  многозадачная, многопользовательская операционная
система.   Это  означает,  что  много  людей  может  одновременно
использовать один компьютер, выполняя много различных задач. (Это
существенное  отличие  от  MS-DOS,  где только один человек может
использовать  в  данный  момент  операционную  систему).  В  UNIX
пользователи  должны себя идентифицировать при входе, что состоит
из  двух  шагов: <b>ввода имени</b> (имя, по которому вас идентифицирует
система)  и <b> входной  пароль</b>,  который  является  вашим секретным
словом   для  открытия  вашего  счета  (регистрации  в  системе).
Поскольку только вы знаете пароль, никто не может войти в систему
под вашим именем.</p>
<p></p>
<p>В  традиционных UNIX-системах системный администратор присвоит
вам  имя  и начальный пароль при вашей регистрации в системе (при
заведении  в  системе нового пользователя). Но поскольку на своем
персональном  компьютере  вы и системный администратор, вы должны
себя  (как пользователя) зарегистрировать в системе, прежде чем в
нее  войдете  (смотрите Раздел 3.2.1 ниже). Для дальнейших разговоров
возьмем условное имя ``<code>larry</code>''.</p>
<p></p>
<p>Кроме  прочего,  каждая  система  UNIX  имеет приписанное ей
<b>hostname</b>  (хозяйское  имя).  Это хозяйское имя добавляет машине
характера  и  очарования. Hostname используется для идентификации
отдельных  машин  в сети, но даже если ваша машина не в сети, она
все  равно  должна  иметь  hostname. В Разделе 4.10.2 мы подробно
расскажем  об  установке  hostname  на вашей машине. Например, имя
машины, обсуждаемой ниже - ``<code>mousehouse</code>'' (мышинная норка).</p>
<p></p>
<h2>3.2.1 <A Name="ss3.2.1"> Регистрация в системе (открытие счета) </h2>

<p>Прежде,  чем  вы  сможете  использовать  систему,  вы должны
зарегистрировать  себя  в  системе.  Это  необходимо  потому, что
неразумно  использовать  имя суперпользователя (<code>root</code>) для обычных
нужд.  Пользователь  root  нужен для выполнения привилегированных
команд  и  сопровождения  системы,  как это описывается в Разделе
4.1.</p>
<p></p>
<p>Для  того, чтобы зарегистрировать себя, вам необходимо зайти
в  систему  под  именем  <code>root</code> и использовать команду <code>useradd</code> или
<code>adduser</code>. Об этой процедуре смотрите подробней в Разделе 4.4.</p>
<p></p>

<h2>3.2.2 <A Name="ss3.2.2"> Вход в систему </h2>

<p>При  входе  вы  увидите  на экране подсказку, например, такого
вида:
<blockquote><code>
<pre>
    mousehouse login:
</pre>
</code></blockquote>
</p>
<p></p>
<p>Введите свое имя и нажмите клавишу <F>Return</F>. Наш герой <code>larry</code>
напечатает следующее:
<blockquote><code>
<pre>
    mousehouse login:  larry
    Password:
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь  введите  ваш  пароль (password). При вводе пароль не
будет  отображаться  на  экране,  так что набирайте внимательнее.
Если   вы  неправильно  набрали  пароль,  то  увидите  на  экране
сообщение
<blockquote><code>
<pre>
    Login incorrect
</pre>
</code></blockquote>

и вам следует попытаться еще раз.</p>
<p></p>
<p>Когда  вы  наконец  правильно  введете  имя  пользователя  и
пароль,  вы  официально  будете допущены в систему и можете в ней
свободно путешествовать.</p>
<p></p>

<h2>3.2.3 <A Name="ss3.2.3"> Виртуальные консоли </h2>

<p>Системная  <b>консоль</b>  -  это  монитор  и клавиатура, связанные
непосредственно с системой. (Поскольку UNIX многопользовательская
система,  вы  можете  иметь  дополнительные  терминалы, связанные
через  последовательные  порты  с вашей системой, но они не будут
консолями).   Linux,   как   и   некоторые  другие  версии  UNIX,
обеспечивает  доступ  к  <b>виртуальным  консолям</b>  (или VC), которые
позволяют войти в систему под несколькими именами в одно время.</p>
<p></p>
<p>Для  демонстрации этого войдите в систему (как было показано
ранее).  Теперь нажмите <F>alt-F2</F>. Вы должны снова увидеть подсказку
<code>login: </code>,  то  есть  перед  вами  вторая виртуальная консоль, а вы
вошли  через  первую.  Чтобы  переключиться обратно на первую VC,
нажмите <F>alt-F1</F>. <em>Оп-ля!</em> Вы снова на первой консоли.</p>
<p></p>
<p>Свежеинсталлированный Linux возможно позволит вам работать с
четырьмя  первыми  VC,  используя  от  <F>alt-F1</F>  до  <F>alt-F4</F>. Но
возможно  обеспечить  работу  с  12-ю  VC  -  по  одной на каждую
функциональную  клавишу.  Как видите, использование VC
может  быть  очень эффективным - вы можете работать на нескольких
VC одновременно.</p>
<p></p>
<p>В   то   время,   как   использование  виртуальных  консолей
ограничено  (кроме  прочего,  в  каждый  момент времени вы можете
видеть   только   одну   виртуальную   консоль)   оно   дает  вам
представление  о многопользовательских возможностях UNIX. Пока вы
работаете  на  VC  #1,  вы можете переключиться на VC #2 и начать
работу над чем-то другим.</p>
<p></p>

<h2>3.2.4 <A Name="ss3.2.4"> Shells и команды </h2>

<p>В   большинстве  ваших  исследований  мира  UNIX  вы  будете
общаться   с  ним  через  оболочку  <b>shell</b>.  Shell  -  это  просто
программа,  которая  воспринимает  введенное пользователем, (т.е.
команды,  которые  вы  напечатаете)  и  транслирует это в команды
системе.  Это можно сравнить с программой <code>COMMAND.COM</code> под MS-DOS,
которая   делает   нечто  похожее.  Shell  -  это  лишь  один  из
интерфейсов  UNIX.  Существует много различных интерфейсов, таких
как   X   Window  System,  которая  позволяет  выполнять  команды
используя мышь и клавиатуру в сочетании.</p>
<p></p>
<p>Как только вы вошли, система запускает shell
и вы можете вводить для него команды.
Вот короткий пример.  Как раз  Larry вошел в систему
и система вновь выдала <b>подсказку</b>:</p>
<p>
<blockquote><code>
<pre>
    mousehouse login:  larry
    Password:  larry's password
    Welcome to Mousehouse!
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>``<code>/home/larry#</code>''  это  подсказка  shell,  показывающая, что он
готов  принимать  команды. (Подробнее про подсказкy
позже).    Давайте    попросим    систему    сделать   что-нибудь
интересненькое:
<blockquote><code>
<pre>
    /home/larry# make love
    make:  *** No way to make target `love'.  Stop.
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Хм,  как  оказалось, "make" - это имя существующей в системе
программы  и  shell  пытался  выполнить  эту  команду.  (Жаль, но
система отнеслась к просьбе недружественно).</p>
<p></p>
<p>Это  подводит  нас к жгучему вопросу: Что такое команды? Что
происходит,   когда   вы  вводите  ``<code>make  love</code>''?  Первое  слово
командной строки ``<code>make</code>'' это имя команды, которую предполагается
выполнить.  Все  остальное  в командной строке воспринимается как
аргументы команды.</p>
<p></p>
<p>Примеры:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# cp foo bar
</pre>
</code></blockquote>
</p>
<p></p>
<p>Здесь имя команды ``<code>cp</code>'', а аргументы ``<code>foo</code>'' и ``<code>bar</code>''.</p>
<p></p>
<p>Когда  вы  вводите  команду,  shell делает несколько вещей.
Во-первых,  смотрит на то, что может (должно) быть именем команды
и является ли это внутренней для shell командой. (Внутренняя, это
команда,  которую shell знает как выполнять. Существует ряд таких
команд,  мы  о  них  поговорим  позже). Shell также проверяет, не
является  ли  команда  синонимом другой или требуется подстановка
имени. Если этого не надо делать, shell ищет соответствующую этому
имени  программу на диске. Если shell находит такую программу, он
ее выполняет, передавая ей аргументы из командной строки.</p>
<p></p>
<p>В  нашем  примере  shell  ищет  программу  по имени <code>make</code> и
пытается  выполнить ее с аргументом <code>love</code>. <code>make</code> - это программа,
которая  часто  используется при компиляции больших программ, она
берет  в  качестве  аргумента  имя "целевого" файла компиляции. В
случае  ``<code>make  love</code>''  мы приказали команде make откомпилировать
love.  Поскольку  make  не  смог  найти  файла с таким именем, он
сообщил  (несколько  забавным  образом) о невозможности выполнить
команду и вернулся в подсказку.</p>
<p></p>
<p>Что  случится,  если  мы  введем  команду, а shell не сможет
найти программу с этой командой? Давайте попробуем:
<blockquote><code>
<pre>
    /home/larry# eat dirt
    eat:  command not found
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Все  очень  просто,  если  shell  не может найти программу с
именем  данным  в  командной  строке  (здесь  ``<code>eat</code>''), он выдает
сообщение  об  ошибке,  которое  об'ясняет  причину  невыполнения
команды.  Вы  часто  будете  видеть  это  сообщение,  если будете
вводить  имена  команд  с ошибками. (например, напечатаете
``<code>mkae love</code>'' вместо ``<code>make love</code>'').</p>
<p></p>

<h2>3.2.5 <A Name="ss3.2.5"> Выход из системы </h2>

<p>Прежде, чем идти дальше, мы расскажем, как выйти из системы.
При наличии подсказки shell используйте команду
<blockquote><code>
<pre>
    /home/larry# exit
</pre>
</code></blockquote>

для выхода. Есть другие способы выхода, но этот самый безопасный.</p>
<p></p>

<h2>3.2.6 <A Name="ss3.2.6"> Смена пароля </h2>

<p>Вы  также  должны  представлять,  как  можно  менять пароль.
Команда   "passwd"  <F>прим.  переводчика:  именно  с  пропущенными
буквами она и пишется</F> спросит вас про старый пароль и про новый.
Она попросит дважды ввести новый пороль для надежности. Внимание!
Не  забывайте  свой пароль, иначе вам придется просить системного
администратора  уничтожить его и установить новый (Если вы и есть
системный администратор, смотрите Раздел 4.4).</p>
<p></p>

<h2>3.2.7 <A Name="ss3.2.7"> Файлы и каталоги </h2>

<p>Во  многих  операционных  системах (включая UNIX) существует
концепция  <b>файла</b>,  по которой его можно рассматривать просто, как
набор  информации,  которому  дано  имя.  Примерами файлов будут:
программа,  которая  может  выполняться,  письмо,  полученное  по
электронной  почте,  написанная  вами статья. Существенно то, что
все, что хранится на диске, хранится в отдельных файлах.</p>
<p></p>
<p>Файлы идентифицируются по именам. Например, файл, содержащий
вашу  статью  может  быть сохранен под именем <code>my-paper</code>. Эти имена
обычно   каким-то  образом  отражают  содержание.  Не  существует
стандартного   формата   имен  файлов,  как  в  MS-DOS  и  других
операционных   системах;   в  общем  случае  имена  файлов  могут
содержать  любые  символы  (кроме  <code>/</code> - смотрите ниже обсуждение
формирования "путей") и ограничены 256 символами по длине.</p>
<p></p>
<p>Одновременно  с концепцией файла рассмотрим и концепцию
каталога.  <code>Каталог</code>  -  это  совокупность  файлов.  Его можно
рассматривать как "папку", содержащую множество различных файлов.
Каталоги  сами  по  себе также получают имена, по которым вы их
различаете. Каталоги организованы в древовидную структуру, т.е.
каталоги могут содержать другие каталоги.</p>
<p></p>
<p>К  файлу  можно  обращаться по <code>пути</code> (<code>pathname</code>),
формируемой из имени
файла,  которому  предшествует  имя  каталога, содержащего файл
Например,  скажем,  Larry  имеет  каталог, названный <code>papers</code>,
который  содержит  три  файла:  <code>history-final</code>,  <code>english-lit</code>,  и
<code>masters-thesis</code>. (Каждый из этих трех файлов содержит информацию о
проводимых  Larry  работах).  Для  того, чтобы обратиться к файлу
<code>english-lit</code>, Larry может указать маршрут:</p>
<p>
<blockquote><code>
<pre>
    papers/english-lit
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как  вы  видите,  имена  каталогов  и  файлов  разделяются
единичным  слэшем (/). Поэтому имена файлов сами по себе не могут
содержать  этот  символ.  Пользователи MS-DOS увидят в этом что-то
знакомое, поскольку в MS-DOS для этого используется бэкслэш (\).</p>
<p></p>
<p>Как уже говорилось, каталоги могут быть вставлены друг в друга.
Например,  пусть  Larry  в каталоге <code>papers</code> имеет другой
каталог с названием
<code>notes</code>.  Этот  каталог  содержит файлы с именами <code>math-notes</code> и
<code>cheat-sheet</code>. Путь файла <code>cheat-sheet</code> будет</p>
<p>
<blockquote><code>
<pre>
    papers/notes/cheat-sheet
</pre>
</code></blockquote>
</p>
<p></p>
<p>Поэтому  путь  -  это  маршрут,  который  надо проделать, чтобы
добраться   до   конкретного   файла.   Каталог  выше  данного
(под)каталога   называется   <b>родительским   каталогом</b>.  Здесь
каталог <code>papers</code> является родительским для каталога <code>notes</code>.</p>
<p></p>

<h2>3.2.8 <A Name="ss3.2.8"> Дерево каталогов </h2>

<p>Большинство   систем   UNIX   имеет   стандартную  структуру
каталогов,   что   облегчает   конкретную   установку  системы.
Структура представляет из себя дерево каталогов, начинающееся с
каталога ``<code>/</code>'', известного под названием "корневой каталог".
Каталоги  ниже  <code>/</code>  относятся  к числу важнейших подкаталогов:
среди них <code>/bin</code>, <code>/etc</code>, <code>/dev</code>, и <code>/usr</code>.
Эти каталоги в свою очередь
содержат    другие   каталоги,   которые   содержат   системные
конфигурационные  файлы,  программы  и  т.д.</p>
<p>В частности, каждый
пользователь  имеет  <b>домашний каталог</b>,  который  выделяется
пользователю  для  хранения его файлов. В вышеприведенном примере
все   файлы   Larry   (такие  как  <code>cheat-sheet</code> и  <code>history-final</code>)
содержались  в домашнем каталоге Larry. Обычно пользовательский
домашний  каталог находится под каталогом <code>/home</code> и называется
именем   пользователя.   Так   домашний  каталог  Larry  будет
<code>/home/larry</code>.</p>
<p></p>
<p>На  Рис.  3.2.8  представлено простое дерево каталогов. Оно
даст  вам  некоторое представление о том, как организуется дерево
каталогов в вашей системе.</p>
<p></p>

<h2>3.2.9 <A Name="ss3.2.9"> Текущий рабочий каталог </h2>

<p>Команды, которые вы даете shell, выдаются из вашего
<b>текущего каталога</b>.
Вы  можете  думать о вашем рабочем каталоге, как о
каталоге в котором вы находитесь. При начальном входе в систему
вашим   рабочим  каталогом  автоматически  становится  домашний
каталог (в нашем случае <code>/home/larry</code>). При обращении к файлу вы
можете  обращаться  к нему с учетом вашего местоположения, вместо
того, чтобы указывать полный путь.</p>
<p>
<blockquote><code>
<pre>
/_____bin
    |_dev
    |_etc
    |_home_____larry
    |        |_sam
    |_lib
    |_proc
    |_tmp
    |_usr__X386
         |_bin
         |_emacs
         |_etc
         |_g++-include
         |_include
         |_lib
         |_local_____bin
         |         |_emacs
         |         |_etc
         |         |_lib
         |_man
         |_spool
         |_src_____linux
         |_tmp



     Рис 3.1: Типичное (урезанное) дерево каталогов Unix
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вот  например,  у  Larry  есть  каталог  <code>papers</code>, а <code>papers</code>
содержит  файл  <code>history-final</code>.  Если  Larry хочет посмотреть этот
файл, он может использовать команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry# more /home/larry/papers/history-final
</pre>
</code></blockquote>
</p>
<p></p>
<p>Команда  more  просто  показывает  файл  на экране порциями.
Поскольку текущий рабочий каталог Larry <code>/home/larry</code>, он вместо
этого  может  обратиться  к  файлу  с  учетом  своего  текущего
местоположения. Команда будет</p>
<p>
<blockquote><code>
<pre>
    /home/larry# more papers/history-final
</pre>
</code></blockquote>
</p>
<p></p>
<p>Так   что   вы   можете   начинать  имя  файла  (такого  как
<code>papers/final</code>)    с   символа,   отличного   от   ``<code>/</code>'',
система
предполагает, что вы обращаетесь к файлу с учетом вашего текущего
рабочего  каталога. Это называют <b>относительным именем</b> (а полный
маршрут  - <b>полное (абсолютное) имя</b> - т.е. путь от корня до данного
имени).</p>
<p></p>

<h2>3.2.10 <A Name="ss3.2.10"> Обращение к домашнему каталогу </h2>

<p>Оболочки (shell), т.е. программы, которые читают и выполняют
команды  пользователя, могут использоваться (одновременно в одной
системе) разные. В большинстве систем Linux используются <code>tcsh</code> или
<code>bash</code> при начальной регистрации в системе. В <code>tcsh</code> и <code>bash</code>
вы можете
обратиться   к  своему  домашнему  каталогу,  используя  тильду
(``~''). Например, команда</p>
<p>
<blockquote><code>
<pre>
    /home/larry# more ~/papers/history-final
</pre>
</code></blockquote>
</p>
<p>эквивалентна</p>
<p>
<blockquote><code>
<pre>
    /home/larry# more /home/larry/papers/history-final
</pre>
</code></blockquote>
</p>
<p></p>
<p>Символ   ``~''   просто   заменяет   имя   вашего  домашнего
каталога.</p>
<p></p>
<p>Вы  также  можете обратиться к домашнему каталогу другого
пользователя   с  помощью  тильды.  Имя  ``~<code>karl/letters</code>''  будет
интерпретировано    shell,   как   ``<code>/home/karl/letters</code>''   (если
<code>/home/karl</code>   -   домашний   каталог  для  пользователя  karl).
Использование тильды упрощает обращение; не существует каталога
с  именем  ``~''  -  так  что  это просто "синтаксический сахар",
который имеется в распоряжении shell.</p>
<p></p>


<h2>3.3 <A Name="ss3.3"> Первые шаги в UNIX </h2>

<p>Перед  тем, как начать, важно заметить, что все имена файлов
и  команд  чувствительны  к  большим  и  малым буквам (чего нет в
системах типа MS-DOS). Например, команда <code>make</code> очень отличается от
<code>Make</code> или <code>MAKE</code>. То же относится и к именам каталогов.</p>
<p></p>
<h2>3.3.1 <A Name="ss3.3.1"> Первая прогулка </h2>

<p>Теперь  мы  можем войти в систему и узнать, как обращаться к
файлам и менять местоположение в файловой системе, чтобы упрощать
свою жизнь в ней. Команда для перемещения по дереву каталогов -
<code>cd</code>,  (``change  directory'').  Вы  скоро  обратите  внимание, что
многие часто используемые команды Unix состоят из двух-трех букв.
Формат команды <code>cd</code>:</p>
<p>
<blockquote><code>
<pre>
    cd &lt;directory&gt;
</pre>
</code></blockquote>

где  &lt;directory&gt;  -  имя  каталога,  в  который вы желаете
перейти.  Как  мы  уже  говорили,  когда вы входите в систему, вы
автоматически  оказываетесь  в  своем  домашнем  каталоге. Если
Larry  желает  двинуться  ниже  по дереву, он должен использовать
команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry# cd papers
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как  видите, изменилась подсказка, отразив изменение
местоположения (новый рабочий каталог). Теперь он в каталоге
<code>papers</code>  и  может  посмотреть на свой файл <code>history-final</code> с помощью
команды</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# more history-final
</pre>
</code></blockquote>
</p>
<p></p>
<p>Чтобы   вернуться   назад   из  подкаталога <code>papers</code>,  надо
использовать команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# cd ..
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>(Обратите  внимание на пробел между ``<code>cd</code>'' и ``<code>..</code>''). Каждый
каталог  содержит имя ``<code>..</code>'' , которое отсылает к родительскому
(для  данного  каталога)  каталогу.  Также  каждый каталог
имеет  имя  ``<code>.</code>'',  которое  ссылается  на  него  самого. Поэтому
команда</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# cd .
</pre>
</code></blockquote>
</p>
<p>никуда не переведет.</p>
<p></p>
<p>В  команде <code>cd</code> вы можете использовать маршруты. Чтобы перейти в
домашний каталог Карла, вы можете воспользоваться командой</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# cd /home/karl
    /home/karl#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Используя  команду <code>cd</code> без  аргументов  вы  из любого места
дерева вернетесь в свой домашний каталог.</p>
<p>
<blockquote><code>
<pre>
    /home/karl# cd
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>

<h2>3.3.2 <A Name="ss3.3.2"> Разглядывание содержимого каталогов </h2>

<p>Теперь  вы  знаете,  как  ходить-бродить  по каталогам, но
вероятно  возникает  вопрос:"Ну  и  что  с  того?"  Само  по себе
хождение  по каталогам бесполезно, давайте познакомимся с новой
командой  <code>ls</code>.  ls  (LiSt)  выдает  на  экран  перечень файлов и
каталогов (по умолчанию из текущего каталога). Например,</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls
    Mail
    letters
    papers
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Здесь  мы  видим,  что  у Larry три "единицы хранения" в его
текущем  каталоге:  <code>Mail</code>,  <code>letters</code>  и  <code>papers</code>.
Но это мало, что
говорит:  каталоги  это  или  файлы?  Можно  использовать опцию
<sl>(прим.  переводчика:  часто  в  документации по UNIX используют в
этом  контексте  слово  "флаг")</sl>

<code> -F</code>  в команде <code>ls</code>, чтобы получить
больше информации.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls -F
    Mail/
    letters/
    papers/
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Приписанные  справа к именам файлов / говорят о том, что это
(под)каталоги.</p>
<p></p>
<p>Использование  <code>ls  -F</code>  (обратите  внимание  "<code>-F</code>" пишется без
пробела)  может  дать  также ``<code>*</code>'' в конце некоторых имен файлов.
Это   будет  говорить  о  том,  что  это  <b>выполняемые</b>  файлы  или
программы.  Если,  при вызове <code>ls -F</code>, ничего справа не приписано к
имени,  то  это  "нормальный"  файл,  т.е.  не  каталог  и  не
выполняемый файл.</p>
<p></p>
<p>В  общем,  каждая команда UNIX может иметь несколько опций в
дополнение  к другим аргументам. Эти опции обычно записываются со
знаком  ``<code>-</code>'',  как  это было показано на примере <code>ls -F</code>.
Опция <code>-F</code>
сообщает   команде   <code>ls</code>,  что  необходимо  выдать  дополнительную
информацию о типе файлов.</p>
<p></p>
<p>Если  вы напишете в команде <code>ls</code> имя каталога, то она выдаст
содержимое указанного каталога.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls -F papers
    english-lit
    history-final
    masters-thesis
    notes/
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Или, чтобы было интереснее, давайте посмотрим, что имеется в
системном каталоге <code>/etc/</code>.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls /etc

Images       ftpusers     lpc          rc.new     shells
adm          getty        magic        rc0.d      startcons
bcheckrc     gettydefs    motd         rc1.d      swapoff
brc          group        mount        rc2.d      swapon
brc~         inet         mtab         rc3.d      syslog.conf
csh.cshrc    init         mtools       rc4.d      syslog.pid
csh.login    init.d       pac          rc5.d      syslogd.reload
default      initrunlvl   passwd       rmt        termcap
disktab      inittab      printcap     rpc        umount
fdprm        inittab.old  profile      rpcinfo    update
fstab        issue        psdatabase   securetty  utmp
ftpaccess    lilo         rc           services   wtmp
/home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p></p>
<p>(Для  вышедших  из  MS-DOS  пользователей  полезно  обратить
внимание,  что  имена  файлов  могут  быть  длиннее  8 символов и
содержать   точку  на  любой  позиции.  Можно  даже  использовать
несколько точек в одном имени).</p>
<p></p>
<p>Давайте  поднимемся  вверх по дереву
<sl>(прим. переводчика: так
уж  сложилось,  что  в  UNIX  начальной  вершиной дерева является
"корень  (root)")</sl>

, используя команду ``<code>cd ..</code>'', а затем спустимся
в другой каталог (<code>/usr/bin</code> ).</p>
<p>
<blockquote><code>
<pre>
    /home/larry# cd ..
    /home# cd ..
    /# cd usr
    /usr# cd bin
    /usr/bin#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы,  разумеется, можете передвигаться по каталогам большими
шагами, например, сразу выполнить <code>cd /usr/bin</code>.</p>
<p></p>
<p>Постарайтесь погулять по каталогам, используя команды ls и
cd.  В  некоторых  случаях  вы  можете напороться на раздражающее
сообщение  ``<code>Permission  denied</code>''(обращение запрещено). Это всего
лишь сработала система защиты UNIX, чтобы выполнять команды в тех
или  иных каталогах вы должны иметь на это разрешение. Подробнее
об этом поговорим в Разделе 3.9.</p>
<p></p>

<h2>3.3.3 <A Name="ss3.3.3"> Создание новых каталогов </h2>

<p>Пора  познакомиться  с  тем,  как  создавать каталоги. Это
связано с использованием команды <code>mkdir</code>. Попробуйте следующее:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# mkdir foo
    /home/larry# ls -F
    Mail/
    foo/
    letters/
    papers/
    /home/larry# cd foo
    /home/larry/foo# ls
    /home/larry/foo#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Наши   вам   поздравления!   Вы  только  что  создали  новый
каталог и зашли в него. Поскольку пока нет файлов в этом новом
каталоге, давайте познакомимся с тем, как копировать файлы.</p>
<p></p>

<h2>3.3.4 <A Name="ss3.3.4"> Копирование файлов </h2>

<p>Копирование файлов осуществляется командой <code>cp</code> (CoPy):</p>
<p>
<blockquote><code>
<pre>
       /home/larry/foo# cp /etc/termcap  .
       /home/larry/foo# cp /etc/shells  .
       /home/larry/foo# ls -F
       shells     termcap
       /home/larry/foo# cp shells bells
       /home/larry/foo# ls -F
       bells     shells     termcap
       /home/larry/foo#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Команда  <code>cp</code> копирует файлы, перечисленные в командной строке,
в  файл  или  каталог,  указанный последним аргументом.
<sl>(прим.  переводчика:  несколько  файлов  одной  командой cp можно
скопировать  только в каталог; в файл можно скопировать только
один файл).</sl>

Обратите внимание на то, как мы используем каталог
``<code>.</code>''для ссылки на текущий каталог.</p>
<p></p>

<h2>3.3.5 <A Name="ss3.3.5"> Перемещение файлов </h2>

<p>Новая команда с именем <code>mv</code> (MoVe) перемещает файлы вместо их
копирования. Синтаксис команды очевиден.</p>
<p>
<blockquote><code>
<pre>
       /home/larry/foo# mv termcap sells
       /home/larry/foo# ls -F
       bells     sells     shells
       /home/larry/foo#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Обратите  внимание,  что теперь termcap уже не существует, а
на   его   месте   файл   <code>sells</code>.   Это   можно  использовать  для
переименования  файлов,  что  мы  сейчас  и  сделали.  Но можно и
переносить  файлы в совсем другие каталоги.</p>
<p></p>
<p><b>Внимание!</b>  Команды  <code>mv</code>  и  <code>cp</code>  уничтожат  содержимое файла в
который  они  пишут  (если  он  существовал), не спрашивая вашего
разрешения. Будьте внимательны, когда вы переносите файл в другой
каталог:  там  уже может существовать файл с таким именем и вы
его затрете.</p>
<p></p>

<h2>3.3.6 <A Name="ss3.3.6"> Удаление файлов и каталогов </h2>

<p>Мы  тут  с вами "нарифмовали" ненужных файлов, изучая работу
команды <code>ls</code>. Для удаления файлов используется команда <code>rm</code> (ReMove).</p>
<p>
<blockquote><code>
<pre>
    /home/larry/foo# rm bells sells
    /home/larry/foo# ls -F
    shells
    /home/larry/foo#
</pre>
</code></blockquote>
</p>
<p></p>
<p>У  нас  ничего  не  осталось,  кроме  <code>shells</code>,  но  не  будем
переживать.  Обратите  внимание,  что  команда  <code>rm</code>  не  будет вас
переспрашивать перед удалением, так что будьте осторожны.</p>
<p></p>
<p>Родственная <code>rm</code>   команда   <code>rmdir</code>.   Эта   команда  удаляет
каталоги,  но  только  пустые  каталоги. Если в каталоге есть хоть
какие-нибудь файлы или подкаталоги, она распишется в бессилии.</p>
<p></p>

<h2>3.3.7 <A Name="ss3.3.7"> Рассматривание файлов </h2>

<p>Команды <code>more</code> и <code>cat</code> используются для просмотра содержимого
файлов.  <code>more</code> выдает файл на дисплей "поэкранно", в то время, как
cat  выдает  весь  файл  разом.
<sl>(прим.  переводчика:  если  файл
многострочный, то, при использовании команды cat файл промелькнет
и на экране останутся последние строки).</sl>

</p>
<p></p>
<p>Чтобы посмотреть файл <code>shells</code>, используем команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry/foo# more shells
</pre>
</code></blockquote>
</p>
<p></p>
<p>При  использовании команды <code>more</code> нажимайте клавишу <F>пробел</F>
для   перехода   к  следующей  странице  и  <F>b</F>  для  возврата  к
предыдущей. Нажав <F>q</F>, вы выйдете из more.</p>
<p></p>
<p>А теперь попробуйте команду <code>cat </code>etc/termcap/.  Текст
промелькнет  слишком быстро, чтобы успеть его прочитать. На самом
деле  команда  ``<code>cat</code>''  (conCATenate) в основном используется для
других  целей,  для  той же конкатенации нескольких файлов. Это в
дальнейшем будет обсуждаться.</p>
<p></p>
<p></p>

<h2>3.3.8 <A Name="ss3.3.8"> Получение оперативной помощи </h2>

<p>Практически   каждый   UNIX   имеет   то,   что   называется
"Руководство"  -  <code>man</code>  (  ``manual pages''). Эта команда <code>man</code>
содержит  документацию  на  различные  команды  системы, ресурсы,
конфигурационные файлы. Например, если вы хотите найти информацию
о других опциях команды <code>ls</code>, введите</p>
<p>
<blockquote><code>
<pre>
    /home/larry# man ls
</pre>
</code></blockquote>
</p>
<p>и вам на экран будут выведены страницы Руководства.</p>
<p></p>
<p>К  сожалению,  большинство  страниц  руководства написаны с
ориентацией  на  пользователей, имеющих некоторые представления о
работе  соответствующих  команд. Поэтому  страницы
Руководства  обычно  содержат справочные данные по командам, а не
учебный материал.</p>
<p></p>
<p>Но  Руководство  неоценимо  для  освежения  памяти,  если вы
забыли   синтаксис   команды.   Руководство   может  также  много
рассказать  вам  о  командах,  которые мы даже не упомянем в этой
книге.</p>
<p></p>
<p>Я предлагаю вам посмотреть в Руководстве те команды, которые
мы  уже  обсуждали  и  все,  с  которыми мы будем встречаться. Вы
обнаружите,   что  не  на  все  команды  есть  Руководство.  Тому
несколько причин. Одна - некоторые страницы Руководства еще просто
не   написаны   (<em>the Linux  Documentation  Project</em>  -  программа
подготовки  документации  для  Linux  как бы отвечает за решение
этой  проблемы.  Мы  уже  собрали  большую  часть  документации).
Во-вторых,  команда  может  быть  внутренней  командой  shell или
синонимом  (alias),  что обсуждалось в Разделе 3.2.4, в каждом из
этих случаев для них нет собственных страниц. Возьмем для примера
<code>cd</code>,  которая  является внутренней командой shell. Shell выполняет
эту  команду,  но  она  не имеет своей отдельной программы.</p>
<p></p>
<p></p>


<h2>3.4 <A Name="ss3.4"> Краткая информация о базовых командах </h2>

<p>Этот раздел представляет некоторые наиболее полезные базовые
команды  UNIX,  включая  те,  о  которых  говорили  в  предыдущем
разделе.</p>
<p></p>
<p>Обратите  внимание, что опции обычно начинаются с ``<code>-</code>'' и во
многих  случаях  несколько однобуквенных опций могут следовать за
одним  минусом, записанные слитно. Например, вместо использования
<code>ls -l -F</code>, можно использовать <code>ls -lF</code>.</p>
<p></p>
<p>Вместо  перечисления всех возможных опций каждой команды, мы
будем  говорить  только о тех, которые полезны или важны в данное
время.  Действительно,  большинство  из этих команд имеет большое
число  опций (большинство из которых никогда не используется). Вы
можете  для каждой команды с помощью man посмотреть все возможные
опции.</p>
<p></p>
<p>Обратите  также  внимание  на то, что многие из команд берут
список  файлов  или  каталогов, как аргументы, обозначенные как
``&lt;file1&gt;  ...  &lt;fileN&gt;''.
Например, команда <code>cp</code> берет в качестве
аргументов  список  файлов,  которые надо копировать, за которыми
следует  имя  целевого  файла  или  каталога.  При  копировании
нескольких  файлов  в  качестве  целевого  может выступать только
каталог.</p>
<p>
<dl>
<dt><b>cd</b><dd><p>Изменяет текущий рабочий каталог.<br>
Синтаксис: <code>cd &lt;directory&gt;</code>;<br>
<code>&lt;directory&gt;</code> - каталог, в который перейти (``.'' ссылается
на текуший каталог, ``..'' - на родительский каталог).<br>
Пример: <code>cd ../foo</code> переводит из текущего каталога
в <code>../foo</code>.</p>
<p></p>
<dt><b>ls</b><dd><p>Выдает информацию о файлах в каталоге.<br>
Синтаксис: <code>ls &lt;file1&gt; ... &lt;fileN&gt;</code><br>
Где  <code>&lt;file1&gt;  ...  &lt;fileN&gt;</code>  имена  файлов  или  каталогов,
информацию про которые надо выдать.<br>
Опции:  Здесь больше опций, чем вы думаете. Наиболее
часто  используемые: <code>-F</code> (для представления информации о типах
файлов),   и   <code>-l</code>   (выдает  в  длинном  (``long'')  формате
информацию  о  размерах файлов, владельцах, правах доступа и
т.д. В деталях это будет обсуждаться далее).<br>
Пример:  <code>ls  -lF  /home/larry</code>  выдаст  содержимое каталога
<code>/home/larry</code>.</p>
<p></p>
<dt><b>cp</b><dd><p>Копирует файл(ы) в файл или каталог.<br>
Синтаксис: <code>cp &lt;file1&gt; ... &lt;fileN&gt; &lt;destination&gt;</code><br>
Где   <code>&lt;file1&gt;   ...   &lt;fileN&gt;</code>
имена  копируемых  файлов,  а
<code>&lt;destination&gt;</code> файл или каталог, в который копируют.<br>
Пример:  <code>cp  ../frog  joe</code>  копирует  файл <code>../frog</code>
в файл или каталог <code>joe</code>.</p>
<p></p>
<dt><b>mv</b><dd><p>Перемещает файл(ы) в другой файл или каталог.
Эта   команда  не  эквивалентна  копированию  с  последующим
уничтожением  оригинала.  Она  может  быть  использована для
переименования файлов, как команда <code>RENAME</code> из MS-DOS.<br>
Синтаксис:  <code>mv &lt;file1&gt; ... &lt;fileN&gt; &lt;destination&gt;</code><br>
Где   <code>&lt;file1&gt;  ...  &lt;fileN&gt;</code>  имена  перемещаемых  файлов,  а
<code>&lt;destination&gt;</code>   имя   файла   или   каталога,   в  который
перемещают.<br>
Пример:  <code>mv ../frog joe</code> перемещает файл <code>../frog</code>
в файл или
каталог <code>joe</code>.</p>
<p></p>
<dt><b>rm</b><dd><p>Удаляет файлы.
Имейте   в   виду,   когда   в  UNIX  удаляются  файлы,  они
невосстановимы  (не как в MS-DOS, где вы можете "разудалить"
файл).<br>
Синтаксис: <code>rm &lt;file1&gt; ... &lt;fileN&gt;</code><br>
Где <code>&lt;file1&gt; ... &lt;fileN&gt;</code> имена удаляемых файлов.<br>
Опции:  <code>-i</code>  потребует  вашего  подтверждения перед удалением
файла.<br>
Пример: <code>rm -i /home/larry/joe /home/larry/frog</code> удаляет файлы
<code>joe</code> и <code>frog</code> в каталоге <code>/home/larry</code>.</p>
<p></p>
<dt><b>mkdir</b><dd><p>Создает новые каталоги.<br>
Синтаксис: <code>mkdir &lt;dir1&gt; ... &lt;dirN&gt;</code><br>
Где <code>&lt;dir1&gt; ... &lt;dirN&gt;</code> создаваемые каталоги.<br>
Пример:  <code>mkdir  /home/larry/test</code>  создает  каталог
<code>test</code> в
каталоге <code>/home/larry</code>.</p>
<p></p>
<dt><b>rmdir</b><dd><p>Эта команда удаляет пустые каталоги.
При  использовании  <code>rmdir</code>  ваш  текущий  рабочий  каталог
должен находиться вне удаляемого каталога.<br>
Синтаксис: <code>rmdir &lt;dir1&gt; ... &lt;dirN&gt;</code><br>
Где <code>&lt;dir1&gt; ... &lt;dirN&gt;</code> удаляемые каталоги.<br>
Пример: <code>rmdir   /home/larry/papers</code>   удаляет   каталог
<code>/home/larry/papers</code>, если он пустой.</p>
<p></p>
<dt><b>man</b><dd><p>Выдает страницу Руководства по данной команде или ресурсу.
(здесь  "ресурс"  -  это любая системная утилита, которая не
является командой, например библиотечная функция).<br>
Синтаксис: <code>man &lt;command&gt;</code><br>
Где   <code>&lt;command&gt;</code>   имя   команды  или  ресурса,  о котором
запрашивается информация.<br>
Пример: <code>man ls</code> - дает помощь по команде <code>ls</code>.</p>
<p></p>
<dt><b>more</b><dd><p>Выдает содержимое названных файлов поэкранно.<br>
Синтаксис: <code>more &lt;file1&gt; ... &lt;fileN&gt;</code><br>
Где <code>&lt;file1&gt; ... &lt;fileN&gt;</code> отображаемые файлы.<br>
Пример:    <code>more   papers/history-final</code>   представляет   файл
<code>papers/history-final</code>.</p>
<p></p>
<dt><b>cat</b><dd><p>Используется для конкатенации файлов.
<code>cat</code>  используется  также для выдачи полного содержания файла
разом<br>
Синтаксис: <code>cat &lt;file1&gt; ... &lt;fileN&gt;</code><br>
Где <code>&lt;file1&gt; ... &lt;fileN&gt;</code> выдаваемые файлы.<br>
Пример:   <code>cat   letters/from-mdw</code>   выдает  на  дисплей  файл
<code>letters/from-mdw</code>.</p>
<p></p>
<dt><b>echo</b><dd><p>Просто повторяет аргументы.<br>
Синтаксис: <code>echo &lt;arg1&gt; ... &lt;argN&gt;</code><br>
Где <code>&lt;arg1&gt; ... &lt;argN&gt;</code> "повторяемые" аргументы.<br>
Пример: <code>echo "Hello world"</code> выдает на экран ``<code>Hello world</code>''.</p>
<p></p>
<dt><b>grep</b><dd><p>выдает все строки в названном файле(лах),
которые содержат заданный образец.<br>
Синтаксис: <code>grep &lt;pattern&gt; &lt;file1&gt; ... &lt;fileN&gt;</code><br>
Где   <code>&lt;pattern&gt;</code> - образец   (представленный   регулярным
выражением)  и  <code>&lt;file1&gt;  ...  &lt;fileN&gt;</code> - файлы,
в  которых  производится поиск.<br>
Пример:  <code>grep loomer /etc/hosts</code> выдаст все строки, в которых
файл <code>/etc/hosts</code>, содержит образец ``<code>loomer</code>''.</p>
</dl>
</p>
<p></p>
<p></p>

<h2>3.5 <A Name="ss3.5"> Исследование файловой системы </h2>

<p>Файловая   система   есть   собрание   файлов   и   иерархия
каталогов.  Я обещал поводить вас по файловой системе - и время
настало.  У  вас достаточно интеллекта и знаний извлечь пользу из
того,  что  я  говорю  и  у  вас есть карта дорог. (Смотрите Рис.
3.2.8).</p>
<p></p>
<p>Перво-наперво  вернемся  в  корневой  каталог  (<code>cd  /</code>)  и
сделаем  <code>ls  -F</code>. Вы, очевидно, увидите каталоги:
<code>bin</code>, <code>dev</code>, <code>etc</code>,
<code>home</code>,  <code>install</code>,  <code>lib</code>,  <code>mnt</code>,  <code>proc</code>,  <code>root</code>,
<code>tmp</code>,  <code>user</code>, <code>usr</code> и <code>var</code>.
(Можете  увидеть  и  несколько  отличный вариант - не волнуйтесь,
различные версии Linux могут иметь отличия).</p>
<p></p>
<p></p>
<p>Присмотримся к каждому каталогу.</p>
<p>
<dl>
<dt><b>/bin</b><dd><p><code>bin</code> - это сокращенно от ``binaries'' (т.е. двоичные или
выполняемые  файлы).  Здесь находится много важных системных
программ. Используйте команду ``<code>ls -F/bin</code>''  чтобы
посмотреть   имеющийся   здесь   список  файлов.  Вы  можете
обнаружить  здесь  уже  знакомые вам команды, вроде <code>cp</code>,
<code>ls</code> и <code>mv</code>.  Это  и  есть  программы  соответствующих  команд. Когда,
например, вы используете команду <code>cp</code>, вы выполняете программу
<code>/bin/cp</code>.</p>
<p>Используя  <code>ls  -F</code>, вы увидите, что большинство (если не все)
файлов  в  <code>/bin</code> имеют справа от имени звездочку (``<code>*</code>''). Это
говорит  о том, что файлы выполняемые, как описано в Разделе
3.3.2.</p>
<p></p>
<dt><b>/dev</b><dd><p>Следующая  остановка  на  нашем  пути  -  <code>dev</code>.  Вновь
посмотрите на содержимое с помощью <code>ls -F</code>.</p>
<p></p>
<p>"Файлы"  в  <code>/dev</code> известны как <b>драйверы устройств</b> - они
используются  для  доступа к устройствам и ресурсам системы,
таким  как  диски,  модемы,  память  и т.д. Например, как вы
можете  читать данные из файла, точно также вы можете читать
входные  сигналы  от  мыши,  имея доступ к <code>/dev/mouse</code>. Имена
файлов,  начинающиеся  на  <code>fd</code> - это дисководы гибких дисков.
<code>fd0</code> - первый дисковод, <code>fd1</code> - второй. Теперь самые шустрые из
вас  заметят,  что  здесь  имеется больше дисководов, чем те
два,    которые    мною    упоминались:   они   представляют
специфические    типы    дисководов.    Например, <code>fd1H1440</code>
представляет   доступ   к  high-density,  3.5"  дискетам  на
дисководе 1.</p>
<p></p>
<p>Вот  перечень  некоторых  из  наиболее  используемых  файлов
устройств.</p>
<p>
<ul>
<li><code>/dev/console/</code>  относится  к  системной  консоли,  т.е.  к
монитору, напрямую связанному с системой.
</li>
<li>Различные <code>/dev/ttyS</code> и <code>/dev/cua</code>
устройства используются для
доступа к  последовательным   портам.   Например,  <code>/dev/ttyS0</code>
относится   к   ``COM1''  под  MS-DOS.  Устройства <code>/dev/cua</code>
относятся  к  "звонящим"  (``callout'') устройствам, которые
используются совместно с модемами.
</li>
<li>Устройства, имена которых начинаются с <code>hd</code>, имеют доступ к жестким
дискам.  <code>/dev/hda</code> относится ко <em>всему</em> первому жесткому диску,
а <code>hda1</code> только к <em>первому разделу</em> <code>/dev/hda</code>.
</li>
<li>Устройства с именами, начинающимися на <code>sd</code> - SCSI-драйверы. Если
у  вас  SCSI  жесткий  диск,  вместо  доступа  к  нему через
<code>/dev/hda</code>,  вы  будете  обращаться  к  <code>/dev/sda</code>.
SCSI  ленты
доступны через устройства <code>st</code>, а SCSI CD-ROM через <code>sr</code>.
</li>
<li>Устройства <code>lp</code> обеспечивают доступ к
параллельным портам. <code>/dev/lp0</code> относится к ``LPT1'' в MS-DOS.
</li>
<li><code>/dev/null</code>  используется как "черная дыра" - любые данные,
посланные  сюда, канут в Лету. Если вы хотите подавить вывод
команды  на  экран,  вы  можете  перенаправить  этот вывод в
<code>/dev/null</code>. Мы об этом позже еще поговорим.
</li>
<li>Устройства с именами  <code>/dev/tty</code> относятся к
"виртуальным  консолям"  вашей системы (доступ путем нажатия
<F>alt-F1</F>,  <F>alt-F2</F>  и  т.д.). <code>/dev/tty1</code> соответствует первой
VC, <code>/dev/tty2</code> соответствует второй и т.д.
</li>
<li>Устройства,   чьи   имена  начинаются на <code>/dev/pty</code>,  это
"псевдотерминалы".  Они  используются  для входа с удаленных
"терминалов".  Например, если ваша машина в сети, вход к вам
по telnet будет использовать одно из устройств <code>/dev/pty</code>.</li>
</ul>
</p>
<p></p>
<dt><b>/etc</b><dd><p><code>/etc</code>  содержит  множество всевозможных системных файлов
конфигурации.   Они  включают <code>/etc/passwd</code>  (файл  паролей),
<code>/etc/rc</code> (командный файл инициализации) и т.д.</p>
<p></p>
<dt><b>/sbin</b><dd><p><code>/sbin</code>
используется  для  хранения  важных  системных
двоичных файлов, используемых системным администратором.</p>
<p></p>
<dt><b>/home</b><dd><p><code>home</code>  содержит  домашние  каталоги  пользователей.
Например,  <code>/home/larry</code>  -  домашний  каталог пользователя
``<code>larry</code>''.  На  вновь инсталлированной системе этот каталог
может   быть   пуст   в   связи   с   временным  отсутствием
зарегистрированных пользователей.</p>
<p></p>
<dt><b>/lib</b><dd><p><code>/lib</code>  содержит образы <b>разделяемых библиотек</b>
(<b>shared library images</b>). Эти файлы
содержат  код,  который могут использовать многие программы.
Вместо  того,  чтобы каждая программа имела свою собственную
копию   этих   выполняемых  файлов,  они  хранятся  в  одном
общедоступном   месте   -  в  <code>/lib</code>.  Это  позволяет  сделать
выполняемые файлы меньше и сэкономит место в системе.</p>
<p></p>
<dt><b>/proc</b><dd><p><code>/proc</code>  -
это "виртуальная файловая система", в которой
файлы хранятся в памяти, а не на диске. Они связаны с различными
<b>процессами</b>,   происходящими   в  системе,  и  позволяют  получить
информацию  о  том,  что  делают программы и процессы в указанное
время. Более детально мы рассмотрим это в Разделе 3.11.1.</p>
<p></p>
<dt><b>/tmp</b><dd><p>Многие  программы нуждаются в создании рабочих файлов,
которые  нужны  короткое  время. Каноническое место для этих
файлов в <code>/tmp</code> (там обычно чаще проводится уборка мусора).</p>
<p></p>
<dt><b>/usr</b><dd><p><code>/usr</code>  - это очень важный каталог.
Он состоит из ряда
подкаталогов,  которые  в  свою  очередь содержат наиболее
важные   и   полезные   программы   и   файлы  конфигурации,
используемые системой.</p>
<p></p>
<p>Различные   каталоги,   описанные   выше,  необходимы  для
нормального  функционирования системы, но большинство вещей,
содержащихся  в <code>/usr</code> необязательны для системы. Но это такие
необязательные  вещи,  которые  делают  систему  полезной  и
интересной.   Без  <code>/usr</code>  вы  бы  имели  достаточно  занудную
систему,  содержащую  только  программы, вроде <code>cp</code> и <code>ls</code>.
<code>/usr</code>
содержит   много   больших   программных   пакетов   и
конфигурационных файлов, которые их сопровождают.</p>
<p></p>
<dt><b>/usr/X386</b><dd><p><code>/usr/X386</code> содержит The X Window System,
если вы ее
инсталлировали.  The  X  Window  System - это  мощная
графическая   среда,  которая  содержит  большое  количество
графических  утилит и программ, отображающих "окна" на вашем
экране.  Если  вы  знакомы с Microsoft Windows или Macintosh
environments,  то  X  Windows будет выглядеть весьма похоже.
Каталог  <code>/usr/X386</code>  содержит все выполняемые и
конфигурационные  файлы  X  Window, а также файлы поддержки.
Более детально это будет обсуждаться в Разделе 5.1.</p>
<p></p>
<dt><b>/usr/bin</b><dd><p><code>/usr/bin</code> настоящее хранилище для различных программ
UNIX.  Он содержит большинство выполняемых программ, которых
нет ни в каких других местах, например, в том же <code>/bin</code> их нет.</p>
<p></p>
<p></p>
<dt><b>/usr/etc</b><dd><p>Точно  также,  как  и  <code>/etc</code>, содержит всевозможные
системные   программы  и  конфигурационные  файлы. <code>/usr/etc</code>
содержит  даже  больше  утилит  и  файлов.  В  общем, файлы,
находящиеся  в <code>/usr/etc</code> несущественны для системы, в отличие
от тех, которые находятся в <code>/etc</code>, и очень существенны.</p>
<p></p>
<dt><b>/usr/include</b><dd><p>/usr/include   содержит <b>include-файлы</b> для
компилятора   Си.   Эти   файлы  (большинство  имен  которых
заканчивается  на  .h  (от слова ``header'') об'являют имена
структур  данных,  подпрограмм  и констант, используемых при
написании  программ  на  Си.  Те  файлы, которые находятся в
<code>/usr/include/sys</code>    в    общем   случае   используются   при
программировании на системном уровне UNIX. Если вы знакомы с
языком  программирования  Си,  здесь вы найдете такие хэдеры
(фрагменты программ, вставляемые обычно в начало программы),
<code>stdio.h</code>, которые описывают такие функции, как <code>printf()</code>.</p>
<p></p>
<dt><b>/usr/g++-include</b><dd><p><code>/usr/g++-include</code> содержит include-файлы для
компилятора Cи++ (очень похожие на <code>/usr/include</code>).</p>
<p></p>
<dt><b>/usr/lib</b><dd><p><code>/usr/lib</code> содержит   библиотеки-"заглушки"   и
"статические"  библиотеки, эквивалентные файлам из <code>/lib</code>. При
компиляции  программа  "связывается" с библиотеками, находящимися
в  <code>/usr/lib</code>,  которые  в  свою очередь направляют
программы  обращаться  в <code>/lib</code>, если им нужет актуальный код.
Кроме  того,  многие другие программы хранят в <code>/usr/lib</code> свои
конфигурационные файлы.</p>
<p></p>
<dt><b>/usr/local</b><dd><p><code>/usr/local</code>  в большой степени
похож на <code>/usr</code> - он
содержит  различные  программы  и  файлы, несущественные для
системы,  но превращающие ее в удовольствие и восторг. В общем,
эти программы, находящиеся в <code>/usr/local</code> специализируются на
специфике вашей системы, т.е. <code>/usr/local</code> сильно отличается в
различных  UNIX.  Здесь вы найдете такие большие программные
пакеты,  как TeX (система форматирования документов) и Emacs
(большой и мощный редактор), если вы их установите.</p>
<p></p>
<dt><b>/usr/man</b><dd><p>Этот  каталог  содержит  страницы  Руководства.
Здесь  два  подкаталога для каждого "раздела" Руководства.
(С  помощью  команды  "man  man"  вы  можете  получить более
подробную   информацию).  Например,  <code>/usr/man/man1</code>  содержит
исходные   тексты   (неотформатированный  оригинал)  страниц
Руководства   в   разделе   1   и   <code>/usr/man/cat1</code>   содержит
отформатированные страницы для раздела 1.</p>
<p></p>
<dt><b>/usr/src</b><dd><p><code>/usr/src</code> содержит  исходные коды
(неоткомпилированные программы) для различных программ вашей
системы.  Наиболее  важная  вещь  здесь, это <code>/usr/src/linux</code>,
содержащий исходные коды ядра Linux.</p>
<p></p>
<dt><b>/var</b><dd><p><code>/var</code>  содержит  каталоги,  которые  часто меняются в
размере  или  имеют  тенденцию  быстро расти. Многие из этих
каталогов   "квартировались"   в  <code>/usr</code>,  но  поскольку  мы
стремимся  сделать его  достаточно  стабильным,  каталоги, которые
часто  меняются  были  перенесены  в <code>/var</code>.  К  числу  таких
каталогов относятся:</p>
<p></p>
<dt><b>/var/adm</b><dd><p><code>/var/adm</code> содержит   различные   файлы,  интересные
системному  администратору,  специфические  системные файлы,
фиксирующие ошибки и проблемы, возникающие в системе. Другие
файлы  фиксируют  входы  в  систему, как и неудачные попытки
войти. Это будет обсуждаться в Главе 4.</p>
<p></p>
<dt><b>/var/spool</b><dd><p><code>/var/spool</code> содержит файлы, которые предварительно
формируются  для других программ. Например, если ваша машина
подключена   к   сети,  входная  почта  будет  помещаться  в
<code>/var/spool/mail</code>  до тех пор, пока вы не прочитаете ее или не
удалите.   Входящие   и   исходящие   новости  помещаются  в
<code>/var/spool/news</code> и т.д.</p>
</dl>
</p>
<p></p>

<h2>3.6 <A Name="ss3.6"> Типы оболочек </h2>

<p>Как  я  уже  много  раз  говорил,  UNIX - это многозадачная,
многопользовательская операционная система. Многозадачность <em>очень</em>
полезна   -   однажды  привыкнув  к  ней,  вы  будете  всегда  ее
использовать. Прежде всего, вы сможете выполнять задачи в фоновом
режиме,  переключать  задачи и об'единять их в конвейер, достигая
сложных результатов простыми средствами.</p>
<p></p>
<p>Многие  из  возможностей,  которые мы будем обсуждать в этом
разделе,   обеспечиваются   самой   оболочкой   (shell).   Будьте
внимательны, не путайте UNIX (фактическую операционную систему) с
оболочкой  -  оболочка,  это  лишь интерфейс с находящейся за ней
системой.   Оболочка  обеспечивает  выполнение  громадного  числа
функций помимо собственно UNIX.</p>
<p></p>
<p>Оболочка - это не только интерпретатор интерактивных команд,
которые вы можете ввести, получив от оболочки подсказку (готовности
принимать  команды).  Это  также  мощный  командный язык, который
позволяет писать программы (<b>shell-scripts</b>), об'единяющие несколько
команд  в  <b>командный  файл</b>. Пользователи MS-DOS почувствуют здесь
нечто  схожее  с  ``batch-файлами''.  Использование  программ на
языке  оболочки  (shell)  -  это  очень  мощное средство, которое
позволяет автоматизировать и и существенно повысить эффективность
использования UNIX. Смотрите дополнительно в Разделе 3.13.1.</p>
<p></p>
<p>Существует несколько типов оболочек в мире UNIX. Две главные
-  это  ``Bourne shell''(shell Баурна) и ``C shell'. Shell Баурна
(или  просто  shell)  использует  командный синтаксис, похожий на
первоначально  для  UNIX  придуманный  (вроде UNIX System III). В
большинстве  UNIX-систем  shell  Баурна имеет имя <code>/bin/sh</code>
(где <code>sh</code>
сокращение  от  ``shell'').  C  shell  использует иной синтаксис,
чем-то   напоминающий  синтаксис  языка  программирования  Си.  В
большинстве UNIX-систем он имеет имя <code>/bin/csh</code>.</p>
<p></p>
<p>В  Linux  есть несколько вариаций этих оболочек. Две наиболее
часто  используемые,  это Новый Shell Баурна (Bourne Again Shell)
или  ``Bash'' (<code>/bin/bash</code>) и Tcsh (<code>/bin/tcsh</code>).
Bash - это развитие
прежнего   shell  с  добавлением  многих  полезных  возможностей,
частично   содержащихся   в   C   shell.   Поскольку  Bash  можно
рассматривать  как  надмножество синтаксиса прежнего shell, любая
программа,  написанная  на  добром  старом  shell  Баурна  должна
работать  и  в  Bash.  Для  тех,  кто  предпочитает  использовать
синтаксис  C  shell,  Linux   поддерживает  Tcsh,  который
является расширенной версией C shell.</p>
<p></p>
<p>Тип оболочки, которую вы решили использовать - это почти как
выбор  религии.  Некоторые предпочитают синтаксис shell Баурна с
дополнительными возможностями, предоставляемыми Bash, а некоторые -
более  структурированный  синтаксис  C  shell.  Для
"нормальных"  команд,  таких  как <code>cp</code> и <code>ls</code>, тип используемого вами
shell  никакой  роли  не  играет.  Только когда вы начнете писать
командные   файлы   или   использовть  некоторые  новые  свойства
оболочек, различия между ними становятся существенными.</p>
<p></p>
<p>При  обсуждении  далее  некоторых свойств оболочек  мы будем
обращать  внимание на различие между Баурновским shell и C shell.
(Если   вам   это   действительно   очень   интересно,  почитайте
Руководство по поводу <code>bash</code> и <code>tcsh</code>).</p>
<p></p>

<h2>3.7 <A Name="ss3.7"> "Уайлдкард" - "дикая карта" </h2>

<p>Ключевое   свойство   большинства   оболочек   Unix   -  это
способность  ссылаться  сразу  более, чем на один файл, используя
для  этого специальные символы. Эти, так называемые "дикие карты"
(<b>wildcards</b>),   позволяют   ссылаться,   скажем,   на  все  файлы,
содержащие символ "<code>n</code>".
<sl>(прим.  переводчика:  Мне  не  известен хороший перевод этой
идиомы (wildcards), наиболее часто у нас встречается "генераторы"
и  "расширители"  символов  -  но  это тяжеловато. Чтобы далее не
испытывать  мучений - буду использовать слово "уайлдкард". Кстати,
и   оболочку   удобнее  далее  именовать  как  shell,  так  легче
воспринимается то, что это язык программирования).</sl>

</p>
<p></p>
<p>Уайлдкард   ``<b>*</b>''  относится  к  любому  символу  или  строке
символов  в  имени  файла.  Например, когда вы используете символ
``<code>*</code>''  в  имени  файла shell заменяет ее всеми возможными именами
файлов  из  каталога, на который вы ссылаетесь. Вот простенький
пример.  Предположим,  что  Larry имеет файлы <code>frog</code>, <code>joe</code> и
<code>stuff</code> в
своем текущем каталоге:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls
    frog     joe     stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Для  обращения  сразу ко всем файлам с буквой ``<code>o</code>'' в имени,
мы можем использовать команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls *o*
    frog     joe
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как  видите,  ``<code>*</code>'' уайлдкард была заменена всеми
возможными именами файлов из имевшихся в текущем каталоге.</p>
<p></p>
<p>Использование просто ``<code>*</code>''даст совпадение со всеми именами,
поскольку все символы совпадают с уайлдкард.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls *
    frog     joe     stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вот еще несколько примеров.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls f*
    frog
    /home/larry# ls *ff
    stuff
    /home/larry# ls *f*
    frog     stuff
    /home/larry# ls s*f
    stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p></p>
<p>Процесс  замены ``<code>*</code>'' на имена файлов называется расширением
уайлдкард  и  выполняется  shell.  Это  важно: конкретные команды,
вроде  <code>ls</code>,  никогда  не  видят  ``<code>*</code>'' в своем списке параметров.
Shell, расширяя уайлдкард, включает в список параметров все имена,
прошедшие сравнение с шаблоном. Так что команда</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls *o*

     расширяется shell до фактической

    /home/larry# ls frog joe
</pre>
</code></blockquote>
</p>
<p></p>
<p>Одно   важное   замечание   относительно   ``<code>*</code>''   уайлдкард.
Использование  этой уайлдкард не даст совпадения с именами файлов,
которые  начинаются с точки (``<code>.</code>''). Эти файлы воспринимаются как
"спрятанные",  хотя  на  самом  деле их никуда не прятали. Они не
показываются  в  списке,  выдаваемом  нормальной командой <code>ls</code> и не
выбираются при использовании ``<code>*</code>'' уайлдкард.</p>
<p></p>
<p>Вот  пример.  Мы  уже упоминали, что каждый каталог имеет
два  специальных  файла: ``<code>.</code>'' - указание на текущий каталог и
``..''  -  указание  на  родительский каталог. Однако, если вы
используете команду <code>ls</code>, эти два файла не будут отображены.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls
    frog     joe     stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Если  вы  используете  опцию  <code>-a</code> в команде <code>ls</code>, то вы сможете
отобразить имена, начинающиеся на ``<code>.</code>'':</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls -a
    .      ..      .bash_profile      .bashrc      frog        joe
    stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как  видим, два специальных файла ``<code>.</code>'' и ``<code>..</code>'', также,
как  два других "спрятанных" файла - <code>.bash_profile</code> и <code>.bashrc</code>. Эти
два  файла используются при входе larry в систему. Более подробно
о них в Разделе 3.13.3.</p>
<p></p>
<p>Обратите  внимание,  что когда мы используем ``<code>*</code>'' уайлдкард,
ни   один  из  файлов,  с  именами,  начинающимися  на  ``<code>.</code>''  не
отображается.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls *
    frog     joe     stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Это  мера  предосторожности: если ``<code>*</code>'' уайлдкард выбирала бы
имена  файлов,  начинающиеся на ``<code>.</code>'', она бы также выбрала имена
``<code>.</code>''  и  ``<code>..</code>''.  Но  это  может быть опасно при выполнении ряда
команд.</p>
<p></p>
<p>Другой  уайлдкард  является  ``<b>?</b>''.  ``<code>?</code>'' уайлдкард позволяет
подставить  строго  один  символ.  Так  ``<code>ls ?</code>'' выдаст на только
имена  файлов,  состоящие  из  одного  символа, а ``<code>ls termca?</code>''
выдаст ``<code>termcap</code>'', но не выдаст на экран ``<code>termcap.backup</code>''. Вот
еще один пример:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ls j?e
    joe
    /home/larry# ls f??g
    frog
    /home/larry# ls ????f
    stuff
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>     Как  видите, уайлдкард позволяет описывать много файлов за
один раз. При обзоре простейших команд в Разделе 3.4 мы говорили,
что  команды <code>cp</code>  и  <code>mv</code> могут копировать или перемещать множества
файлов за один раз. Например,</p>
<p>
<blockquote><code>
<pre>
    /home/larry# cp /etc/s* /home/larry
</pre>
</code></blockquote>
</p>
<p></p>
<p>скопирует  все  файлы  в  <code>/etc</code> , начиная с ``s''в каталог
<code>/home/larry</code>. Формат команды <code>cp</code> на самом деле</p>
<p>
<blockquote><code>
<pre>
    cp &lt;file1&gt; ... &lt;fileN&gt; &lt;destination&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p>где  <code>&lt;file1&gt;  ...  &lt;fileN&gt;</code>  -  список  копируемых  файлов, а
<code>&lt;destination&gt;</code>  это  файл  или  каталог, в который производится
копирование. mv имеет аналогичный синтаксис.</p>
<p></p>
<p>Обратите  внимание,  что  если  производится копирование или
перемещение  более,  чем  одного  файла, <code>&lt;destination&gt;</code> должен быть
каталогом. В файл скопировать или переместить можно только один
файл.</p>
<p></p>

<h2>3.8 <A Name="ss3.8"> Трубопроводы UNIX </h2>

<h2>3.8.1 <A Name="ss3.8.1"> Стандартный вход и стандартный выход </h2>

<p>Многие  команды  UNIX  получают информацию с так называемого
<b>стандартного  входа</b>  и  посылают  информацию  на  (опять  же) так
называемый <b>стандартный выход</b>.  (Для  них  часто  используются
сокращения  ``<b>stdin</b>''  и  ``<b>stdout</b>''  соответственно).  Ваш  shell
организует  дело так, что стандартным входом служит клавиатура, а
стандартным выходом - экран.</p>
<p></p>
<p>Вот  пример  использования команды <code>cat</code>. Нормально cat читает
данные  из  файлов,  чьи имена даны в командной строке и посылает
эти данные прямехонько на stdout. Поэтому при выполнении команды</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# cat history-final masters-thesis
</pre>
</code></blockquote>
</p>
<p></p>
<p>на   экран  пойдет  файл  <code>history-final</code>,  а  за  ним  следом
<code>masters-thesis</code>.</p>
<p></p>
<p>Но  если  команде  cat  не  даны  имена  файлов  в  качестве
параметров,  она  читает  данные  с  stdin и опять же посылает на
stdout. Вот пример.</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# cat
    Hello there.
    Hello there.
    Bye.
    Bye.
    [ctrl-D]
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как  видите,  каждая  строка,  которую напечатал
пользователь,  немедленно  выдается  командой  cat  на экран. При
вводе  со  стандартного  входа  команда  знает, что ввод закончен
тогда,   когда   она   получит   в   каком-то   виде  сигнал  EOT
(End-Of-Text). Обычно он обеспечивается нажатием <F>ctrl-D</F>.</p>
<p></p>
<p>Вот  другой пример. Команда сортировки sort читает построчно
текст  (здесь  опять с stdin, поскольку имена файлов в параметрах
не  указаны,  и  посылает  отсортированный  результат  на stdout.
Попробуйте так.</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# sort
    bananas
    carrots
    apples
    [ctrl-D]
    apples
    bananas
    carrots
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь мы можем упорядочить наш список продуктов, подлежащих
закупке,   в  лексикографическом  порядке...  ну  разве  UNIX  не
полезная вещь?</p>
<p></p>

<h2>3.8.2 <A Name="ss3.8.2"> Перенаправление входа и выхода </h2>

<p>Теперь,   предположим,   что   мы  хотим  послать  результат
сортировки  в  файл,  чтобы  где-то  сохранить список планируемых
покупок.  Shell  дает  нам возможность <b>перенаправлять</b> стандартный
выход в файл, используя символ ``&gt;''. Вот как это работает.</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# sort &gt; shopping-list
    bananas
    carrots
    apples
    [ctrl-D]
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как  вы  можете  видеть,  результат  работы  команды <code>sort</code> не
отображается  на  экране,  вместо  этого  он  сохраняется в файле
<code>shopping-list</code> (список покупок). Давайте посмотрим на этот файл.</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# cat shopping-list
    apples
    bananas
    carrots
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь мы можем не только сортировать (упорядочивать) список
планируемых  покупок, но и сохранять его! Но предположим,
что мы хранили наш неотсортированный исходный закупочный список в
файле  под именем <code>items</code>. Один из способов сортировки и сохранения
его,  это  отсортировать  файл  с данным именем, вместо получения
файла  со стандартного входа, и перенаправить стандартный выход в
файл. Например так</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# sort items &gt; shopping-list
    /home/larry/papers# cat shopping-list
    apples
    bananas
    carrots
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Но  это можно сделать и по-другому. Перенаправлен может быть
не  только  стандартный  выход,  но  также  и  стандартный <em>вход</em>,
используя символ ``&lt;''.</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# sort &lt; items
    apples
    bananas
    carrots
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p></p>
<p>Технически, <code>sort  &lt; items</code>  эквивалентно  <code>sort items</code>,  но
последний  вариант  позволяет  нам  продемонстрировать сказанное:
<code>sort &lt; items</code>  ведет  себя  так,  словно данные файла <code>items</code> были
напечатаны на клавиатуре. shell обслуживает перенаправление. <code>sort</code>
не  было  дано имя файла (<code>items</code>) и команда читала со стандартного
входа, как будто шел ввод с клавиатуры.</p>
<p></p>
<p>Это  иллюстрирует  концепцию <b>фильтра</b>. Фильтр, это программа,
которая  получает  данные  со стандартного входа, обрабатывает их
каким-то  образом  и  посылает результат обработки на стандартный
выход.  С  помощью перенаправления стандартные вход и выход могут
быть переведены на файлы. <code>sort</code> - простейший фильтр: она сортирует
входные  данные  и посылает результат на стандартный выход. <code>cat</code> -
даже  еще  проще:  она  ничего  не  делает со входными данными, а
только выдает все, что не поступит, на выход.</p>
<p></p>

<h2>3.8.3 <A Name="ss3.8.3"> Использование конвейера </h2>

<p>Мы  уже  показали,  как использовать команду sort в качестве
фильтра.  Но  эти примеры предполагали, что вы откуда-то получили
данные  в  файл, или ввели данные с клавиатуры своими собственными
руками.  А  что,  если  данные,  которые вы хотите отсортировать,
являются  выходными данными другой программы, например, такой как
<code>ls</code>?  Если  вы  используете  при сортировке опцию <code>-r</code>, данные будут
расположены  в  порядке,  обратном  лексикографическому.  Если  вы
хотите  получить  перечень  файлов  вашего  каталога в обратном
порядке, один из способов сделать это будет:</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls
    english-list
    history-final
    masters-thesis
    notes
    /home/larry/papers# ls &gt; file-list
    /home/larry/papers# sort -r file-list
    notes
    masters-thesis
    history-final
    english-list
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Здесь  мы  сохранили  результат работы команды <code>ls</code> в файле, а
затем  выполнили  <code>sort -r</code>  над  этим файлом. Но это очень коряво
выглядит   и  требует  создания  временного  файла  для  хранения
результата работы <code>ls</code>.</p>
<p></p>
<p>Выход из положения дает трубопровод (<b>pipeline</b>)
(прим.
переводчика:  в  нашей  литературе  принят термин "<b>конвейер</b>", так
далее  и  будем  переводить  "pipeline").
Конвейер - это еще одно
замечательное   свойство   shell,   которое  позволяет  связывать
последовательность  команд  в конвейер, где stdout первой команды
посылается  прямо  на  stdin второй команды и так далее. Здесь мы
хотим  послать  stdout  команды  <code>ls</code> на stdin команды sort. Символ
``|'' олицетворяет конвейер:</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls | sort -r
    notes
    masters-thesis
    history-final
    english-list
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эта команда намного короче и, очевидно, проще набирается.
Другой полезный пример. Команда</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls /usr/bin
</pre>
</code></blockquote>
</p>
<p></p>
<p>выдает на дисплей длинный список имен файлов, большинство из
которых  слишком  быстро  промелькнет  на экране, чтобы вы успели
прочитать  их.  Давайте подключим к просмотру перечня имен файлов
каталога /usr/bin команду more.</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls /usr/bin | more
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь   вы   можете   постранично   листать   файл  в  свое
удовольствие.</p>
<p></p>
<p>Но  чудеса на этом не кончаются! Мы можем связать в конвейер
более, чем две команды. Команда head представляет из себя фильтр,
который   отображает   первые   строки  входного  потока  (здесь,
пришедшего   по  конвейеру).  Если  мы  хотим  отобразить
последнее имя текущего каталога, упорядоченного по алфавиту, мы
можем написать:</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls | sort -r | head -1
    notes
    /home/larry/papers#
</pre>
</code></blockquote>
</p>
<p></p>
<p>где <code>head -1</code> просто выдает первую строку получаемого входного
потока  (в  данном  случае  это отсортированный в обратном порядке
перечень имен файлов текущего каталога, выданных командой <code>ls</code>).</p>
<p></p>

<h2>3.8.4 <A Name="ss3.8.4"> Перенаправление с добавлением </h2>

<p>Использование  ``&gt;''  для  перенаправления выхода смертельно
для  файла,  в который происходит перенаправление (если было, что
уничтожать), другими словами</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls &gt; file-list
</pre>
</code></blockquote>
</p>
<p></p>
<p>уничтожает  прежнее  содержимое файла <code>file-list</code>. Если вместо
этого  использовать  символ  перенаправления  ``&gt;&gt;'', выход будет
добавлен  к содержимому названного файла (вместо того, чтобы быть
записаным на место старого).</p>
<p>
<blockquote><code>
<pre>
    /home/larry/papers# ls &gt;&gt; file-list
</pre>
</code></blockquote>
</p>
<p></p>
<p>добавит выходную информацию команды ls в файл <code>file-list</code>.</p>
<p></p>
<p>Имейте в виду, что перенаправления и конвейер, это средства,
предоставляемые  оболочкой  shell,  это синтаксис shell и символы
``&gt;'',  ``&gt;&gt;''  и  ``|'' не имеют никакого отношения к командам,
как таковым.</p>
<p></p>


<h2>3.9 <A Name="ss3.9"> Права доступа к файлам </h2>

<h2>3.9.1 <A Name="ss3.9.1"> Концепция прав доступа </h2>

<p>Поскольку   UNIX   -  многопользовательская  система,  чтобы
защитить  файлы  каждого  пользователя  от дурного влияния других
пользователей,   UNIX   поддерживает  механизм,  известный,  как
<b>система прав доступа к файлам</b>. Этот механизм позволяет каждому
файлу  приписать  конкретного  владельца.  Как  пример, поскольку
Larry  создал  файлы  в  своем  домашнем каталоге, именно Larry
владелец этих файлов и имеет к ним доступ.</p>
<p></p>
<p>UNIX    позволяет   также   совместно   использовать   файлы
нескольким  пользователям  и  группам пользователей. Если Larry
так  пожелает,  он  может  закрыть доступ к своим файлам так, что
никто  другой  не сможет к ним подступиться. Однако в большинстве
систем  по умолчанию другим пользователям разрешается читать ваши
файлы, но запрещается изменять или удалять.</p>
<p></p>
<p>Как   об'яснялось   выше,   каждый  файл  имеет  конкретного
владельца.  Но, кроме того файлами, также владеют конкретные <b>группы</b>
пользователей, которые определяются при регистрации пользователей
в  системе.  Каждый  пользователь  становится  членом как минимум
одной   группы   пользователей.   Системный  администратор  может
даровать пользователю доступ более, чем к одной группе.</p>
<p></p>
<p>Группы   обычно  определяются  типами  пользователей  данной
машины.  Например, в университетском UNIX пользователи могут быть
разбиты  на  группы  <code>студент</code>,  <code>преподаватель</code>,  <code>руководство</code>,
<code>гость</code>.
<sl>(прим.   переводчика:  осмелюсь  предположить,  что  в
отечественной  книге перечисление примеров групп было бы начато с
группы "руководство"...).</sl>

</p>
<p></p>
<p>Есть  также  несколько системно-зависимых групп (вроде <code>bin</code> и
<code>admin</code>),   которые  используются  самой  системой  для  управления
доступом к ресурсам. Очень редко обычный пользователь принадлежит
к этим группам.</p>
<p></p>
<p>Права  доступа  подразделяются  на  три типа: <em>чтение</em> (<em>read</em>),
<em>запись</em> (<em>write</em>) и <em> выполнение</em> (<em>execute</em>).
Эти типы прав доступа
могут  быть  предоставлены  трем классам пользователей: владельцу
файла,  группе,  в  которую  входит  владелец,  и  всем  (прочим)
пользователям.</p>
<p></p>
<p>Разрешение   на   чтение   позволяет   пользователю   читать
содержимое   файлов,  а  в  случае  каталогов  -  просматривать
перечень  имен  файлов  в  каталоге  (используя, например, <code>ls</code>).
Разрешение  на  запись  позволяет  пользователю  писать  в файл и
изменять   его.  Для  каталогов  это  дает  право  создавать  в
каталоге  новые  файлы  и  каталоги, или удалять файлы в этом
каталоге.    Наконец,    разрешение    на   выполнение позволяет
пользователю  выполнять  файлы  (как  бинарные  программы,  так и
командные   файлы).  Разрешение  на  выполнение  применительно  к
каталогам означает возможность выполнять команды вроде cd.</p>
<p></p>

<h2>3.9.2 <A Name="ss3.9.2"> Интерпретация прав доступа </h2>

<p>Давайте  рассмотрим пример, демонстрирующий работу с правами
доступа.  Используя  команду  <code>ls</code>  с  опцией  <code>-l</code> можно получить на
экране перечень файлов данного каталога в "длинном" формате,
включающем информацию о правах доступа.</p>
<p>
<blockquote><code>
<pre>

    /home/larry/foo# ls -l stuff

    -rw-r--r--   1 larry    users         505 Mar 13 19:05 stuff

    /home/larry/foo#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Первое  поле в выведенной строке представляет права доступа.
Третье  поле  -  владельца  файла  (<code>larry</code>)  и  четвертое - группу
(<code>users</code>).
Очевидно,  что  последнее  поле  есть  имя  файла (<code>stuff</code>), а
остальные поля мы обсудим позже.</p>
<p></p>
<p>Этим  файлом  владеет  <code>larry</code>, и он принадлежит группе <code>users</code>.
Давайте  посмотрим  на  права  доступа.  В  строке  <code>-rw-r--r--</code> по
порядку указаны права владельца, группы и всех прочих.</p>
<p></p>
<p>Первыый символ этой строки прав доступа (``<code>-</code>'') представляет
тип  файла.  Символ  ``<code>-</code>''  означает,  что  это  обычный  файл (в
противоположность  каталогу  или  специальному  файлу какого-то
устройства).  Следующие  три позиции (``<code>rw-</code>'') представляют права
доступа, которые имеет владелец файла <code>larry</code>. Символ ``<code>r</code>''означает
``read''(читать),  ``<code>w</code>'' - ``write''(писать). Таким образом <code>larry</code>
может читать файл <code>stuff</code> и писать в него.</p>
<p></p>
<p>Как  мы  уже  упоминали, кроме разрешений на чтение и запись
существует  разрешение  на выполнение ``execute'' - представляемое
символом ``<code>x</code>''. Но в данном случае на этой позиции ``<code>-</code>'', так что
у  Larry  нет прав на выполнение этого файла. И это чудесно, файл
<code>stuff</code>  совсем  даже не является программой. Разумеется, поскольку
Larry  владеет  файлом,  он  может  дать  сам  себе разрешение на
выполнение  этого  файла,  если  захочет.  Мы эту процедуру скоро
обсудим.</p>
<p></p>
<p>Следующие  три символа <code>r--</code> представляют права доступа группы
для  этого  файла. Эта группа имеет имя <code>users</code>. Поскольку тут есть
только  ``<code>r</code>'', любой пользователь этой группы может только читать
файл.</p>
<p></p>
<p>Последние  три символа представляют ту же комбинацию <code>r--</code>, то
есть  для  всех  прочих  доступно  чтение этого файла и запрещены
запись и выполнение.</p>
<p></p>
<p>Вот еще несколько примеров на права доступа.</p>
<p>
<dl>
<dt><b>-rwxr-xr-x</b><dd><p>Владелец файла может читать, писать и выполнять файл.
Члены группы и все прочие пользователи могут читать и
выполнять файл.</p>
<dt><b>-rw-------</b><dd><p>Владелец файла может читать и писать в файл. Всем
остальным доступ к файлу закрыт.</p>
<dt><b>-rwxrwxrwx</b><dd><p>Все могут читать писать и выполнять файл.</p>
</dl>
</p>
<p></p>
<p></p>

<h2>3.9.3 <A Name="ss3.9.3"> Зависимости </h2>

<p>Важно  заметить,  что  права  доступа,  которые  имеет  файл
зависят  также  от прав доступа к каталогу, в котором этот файл
находится.  Например,  даже  если  файл  имеет <code>-rwxrwxrwx</code>, другие
пользователи  не  смогут  до  него добраться, если у них не будет
прав на чтение и выполнение каталога, в котором находится файл.
Например,  если  Larry  захочет  ограничить  доступ ко всем своим
файлам,  он  может   может  просто  изменить права доступа
своего  домашнего  каталога  <code>/home/larry</code>  на
<code>drwx------</code>. Таким
образом,  никто  другой  не будет иметь доступ в его каталог, а
следовательно  посторонним  будут  недоступны и все файлы. Так что
Larry может не заботиться об индивидуальной защите своих файлов.</p>
<p></p>
<p>Другими словами, чтобы иметь доступ к файлу, вы должны иметь
доступ  ко  всем  каталогам,  лежащим на пути от корня к этому
файлу, а также разрешение на доступ собственно к этому файлу.</p>
<p></p>
<p>Обычно   пользователи   UNIX  весьма  открыты  всеми  своими
файлами. Обычно файлам устанавливается защита <code>-rw-r--r--</code>, которая
позволяет  другим  пользователям читать файлы, но ни коим образом
их  не  менять.  Каталогамм обычно устанавливаются права доступа
<code>drwxr-xr-x</code>,  что  позволяет другим пользователям ходить с правами
экскурсантов  по  вашим каталогам. Но ничего в них не трогать и
не записывать.</p>
<p></p>
<p>Но  многие  пользователи  хотят держать других пользователей
подальше   от   своих   файлов.  Установив  права  доступа  файла,
<code>-rw-------</code> вы никому не покажете этот файл и не дадите записать в
него. Также хорошо закрывает от всех файлы защита соответствующего
каталога <code>drwx------</code> .</p>
<p></p>

<h2>3.9.4 <A Name="ss3.9.4"> Изменение прав доступа </h2>

<p>Команда  <code>chmod</code>  используется  для установки (изменения) прав
доступа файла. Только владелец файла может менять права доступа к
нему.</p>
<p>Синтаксис команды имеет вид:</p>
<p>
<blockquote><code>
<pre>
    chmod {a,u,g,o}{+,-}{r,w,x} &lt;filenames&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p>Кратко,   вы   выбираете   из  <b>a</b>ll  (все),  <b>u</b>ser
(пользователь),  <b>g</b>roup (группа) или <b>o</b>ther (другие). Далее
указываете, либо вы добавляете права (<code>+</code>), либо лишаете прав (<code>-</code>). И
наконец,  вы  указываете  один или несколько режимов: <b>r</b>ead, <b>w</b>rite
или <b>e</b>xecute. Несколько примеров допустимых команд:</p>
<p>
<dl>
<dt><b>chmod a+r stuff</b><dd><p>Дает всем пользователям право читать файл stuff.</p>
<p></p>
<dt><b>chmod +r stuff</b><dd><p>То же самое, что и ранее (a - по умолчанию).</p>
<p></p>
<dt><b>chmod og-x stuff</b><dd><p>Лишает права на выполнение всех, кроме владельца.</p>
<p></p>
<dt><b>chmod u+rwx stuff</b><dd><p>Разрешает владельцу все (read, write и execute).</p>
<dt><b>chmod o-rwx stuff</b><dd><p>Запрещает все (read,  write и  execute) пользователям
категории другие (other).</p>
</dl>
</p>
<p></p>


<h2>3.10 <A Name="ss3.10"> Управление связями файлов </h2>

<p>Связи  позволяют давать одному физическому файлу много имен.
Системой  файлы  распознаются  по <b>индексам файлов</b>, которые являются
уникальными  идентификаторами  в  рамках  системы.
<sl>Команда <code>ls -i</code>
выдаст  вам  индексы  файлов.</sl>

На  самом  деле  каталог - это
перечень   индексов   файлов   с  соответствующими  этим  индексам
номерами.  Каждое  имя файла в каталоге привязано к конкретному
индексу.</p>
<p></p>
<h2>3.10.1 <A Name="ss3.10.1"> Жесткие связи </h2>

<p>Команда  <code>ln</code>  используется  для создания множества связей для
одного  файла.  Например,  скажем,  что  у  вас  есть  файл  <code>foo</code>.
Используя <code>ls -i</code> можно посмотреть индекс этого файла.</p>
<p>
<blockquote><code>
<pre>
    # ls -i foo
    22192 foo
    #
</pre>
</code></blockquote>
</p>
<p></p>
<p>Здесь  файл  <code>foo</code>  имеет  в файловой системе индекс 22192. Мы
можем создать новую связь для этого файла под именем bar:</p>
<p>
<blockquote><code>
<pre>
    # ln foo bar
</pre>
</code></blockquote>
</p>
<p></p>
<p>С  помощью <code>ls -i</code> можно убедиться, что оба файла имеют один и
тот же индекс.</p>
<p>
<blockquote><code>
<pre>
    # ls -i foo bar
    22192 bar   22192 foo
    #
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь,  обращаясь  к <code>foo</code> или <code>bar</code> мы фактически обратимся к
одном  у  тому  же  файлу. Поэтому, если мы меняем что-то в файле
<code>foo</code>, эти же самые изменения произойдут в файле <code>bar</code>.</p>
<p></p>
<p>Эти   связи  известны,  как <em>жесткие  связи</em> (<em>hard links</em>),
поскольку  они
реализуются  прямой  ссылкой  на индекс файла. Обратите внимание,
что в рамках одной файловой системы вы можете организовать только
жесткие связи; символические связи (смотрите ниже) не имеют этого
ограничения.</p>
<p></p>
<p>Когда  вы  удаляете  файл  командой  <code>rm</code>,  на  самом  деле вы
удаляете только одну ссылку на файл. Если вы введете команду</p>
<p>
<blockquote><code>
<pre>
    # rm foo
</pre>
</code></blockquote>
</p>
<p></p>
<p>Удалаяется  только  связь,  имеющая имя <code>foo</code>; <code>bar</code> будет как и
прежде  существовать.  Файл только тогда действительно удаляется,
когда  на  него больше нет связей. Обычно файлы имеют только одну
связь,  так  что  команда  rm  действительно  приведет к удалению
файла.  Однако,  если  файл  имеет  много  ссылок,  применение rm
приведет  только  к удалению одной связи; для того, чтобы удалить
файл, вы должны удалить все связи на этот файл.</p>
<p></p>
<p>Команда  <code>ls -l</code>  покажет  число ссылок на файл (кроме прочей
информации)</p>
<p>
<blockquote><code>
<pre>
    # ls -l foo bar
    -rw-r--r--   2 root     root          12 Aug  5 16:51 bar
    -rw-r--r--   2 root     root          12 Aug  5 16:50 foo
    #
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вторая колонка с цифрой ``2'' показывает число связей файла.</p>
<p></p>
<p>Самом деле оказывается, что каталоги представляют из
себя   справочник  типа  "имена-индексы".  Кроме  прочего,  каждый
каталог  имеет  минимум  две  жесткие  ссылки: ``<code>.</code>'' (ссылка,
указывающая  на  самого  себя)  и  ``<code>..</code>'' (ссылка, указывающая на
родительский каталог). В корневом каталоге (<code>/</code>) ссылка
``<code>..</code>'' указывает на сам же каталог <code>/</code>.</p>
<p></p>

<h2>3.10.2 <A Name="ss3.10.2"> Символические связи </h2>

<p>Символические  связи, это другой тип связей, отличающийся от
жестких  связей. Символические связи позволяют давать новые имена
файлам, но при этом не ссылаются на индекс файла.</p>
<p></p>
<p>Команда  <code>ln -s</code>  создаст  символическую  ссылку на указанный
файл. Например, если мы воспользуемся командой</p>
<p>
<blockquote><code>
<pre>
    # ln -s foo bar
</pre>
</code></blockquote>
</p>
<p></p>
<p>мы  создадим символьную ссылку <code>bar</code>, указывающую на файл <code>foo</code>.
Если  теперь  используем  команду <code>ls -i</code>, то увидим, что два файла
имеют различные индексы.</p>
<p>
<blockquote><code>
<pre>
    # ls -i foo bar
    22195 bar   22192 foo
    #
</pre>
</code></blockquote>
</p>
<p></p>
<p>Однако,  используя  <code>ls -l</code>,  мы  видим,  что файл <code>bar</code> имеет
символический указатель на <code>foo</code>.</p>
<p>
<blockquote><code>
<pre>
    # ls -l foo bar
    lrwxrwxrwx   1 root     root           3 Aug  5 16:51  bar -&gt; foo
    -rw-r--r--   1 root     root          12 Aug  5 16:50 foo
    #
</pre>
</code></blockquote>
</p>
<p></p>
<p>При  символической  ссылке не используются биты прав доступа
(они  всегда  отображаются,  как  <code>rwxrwxrwx</code>).  Вместо этого, права
доступа  к файлу, полученному символической ссылкой, определяются
правами  доступа  к  файлу,  на  который  он  ссылается (в нашем
примере определяется правами файла <code>foo</code>).</p>
<p></p>
<p>Функционально, жесткие ссылки и символические ссылки похожи,
но   есть   некоторые   различия.  Например,  вы  можете  создать
символическую  ссылку  на  файл,  который  не  существует; так
нельзя  сделать  применительно  к  жесткой  ссылке. Символические
ссылки обрабатываются ядром иным образом, чем жесткие. Это скорее
техническое  отличие,  но  иногда  важное.  Символические  ссылки
полезны,   поскольку  они  позволяют  идентифицировать  файл,  на
который  они  указывают;  для жестких ссылок нет простого способа
определить, какие файлы привязаны к одному и тому же индексу.</p>
<p></p>
<p>Ссылки   используются   во   многих  местах  системы  Linux.
Символические  ссылки  особенно  важны  для  образов  разделяемых
библиотек  в <code>/lib</code>.  Смотри  дополнительную  информацию в Разделе
4.7.2.</p>
<p></p>


<h2>3.11 <A Name="ss3.11"> Управление работами </h2>

<h2>3.11.1 <A Name="ss3.11.1"> Работы и процессы </h2>

<p><b>Управление работами</b> (<b>job control</b>)
это возможность, которую предоставляют
многие  оболочки,  включая  (Bash  и  Tcsh).  Управление работами
<sl>(прим.   переводчика:  job  -  работа  в  добрые  старые  времена
страшноватых  IBM/360 переводилось как "задание", но лучше это не
тащить в сегодня)</sl>

позволяет управлять множеством команд или <b>работ</b>
одновременно.  Прежде,  чем  вы  закопаетесь  значительно глубже,
следует поговорить о <b>процессах</b>.</p>
<p></p>
<p>Каждый  раз, когда вы выполняете программу, вы начинаете то,
что   известно,   как  <em>процесс</em>.  Процесс  -  это  название  для
выполняемой программы. Команда <code>ps</code> выдает перечень имеющих место в
данный момент процессов. Вот пример:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# ps

      PID TT STAT  TIME COMMAND
       24  3 S     0:03 (bash)
      161  3 R     0:00 ps

    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p><b>PID</b> (<b>Process IDentificator</b>), перечисленные в первой колонке,
это неповторяющиеся числа приписанные всем идущим процессам.</p>
<p></p>
<p>Последний  столбец  (COMMAND)  дает имя выполняемой команды.
Здесь  мы  видим  только  процессы, которые инициировал Larry. (В
системе выполняется и много других процессов. Команда ``<code>ps -aux</code>''
может   выдать   перечень   всех  происходящих  в  данный  момент
процессов).</p>
<p></p>
<p>В   выведенном   перечне   указаны   <code>bash</code>   (это   оболочка,
используемая  Larry)  и  сама  команда  <code>ps</code>.  Как  вы видите, bash
выполняется  параллельно  с  командой <code>ps</code>. bash выполнит <code>ps</code>, когда
Larry  введет команду. После окончания <code>ps</code> (после того, как выдана
таблица  процессов),  управление  возвращается  к  процессу  <code>bash</code>,
который выдает на экран подсказк готовности к приему новых команд.</p>
<p></p>
<p>Выполняемый  процесс  известен  shell  как  <em>работа</em>.  Термины
<em>процесс</em> и <em>работа</em> взаимозаменяемы.   Однако  процесс  обычно
воспринимается,  как  "работа",  когда  речь идет об <b>управлении
работами</b> (<b>job control</b>)-
свойстве   shell,   позволяющем   уделять   внимание   нескольким
независимым работам.</p>
<p></p>
<p>В большинстве случаев пользователи выполняют в каждый момент
времени одну работу, ту которая соответствует последней переданной
shell  команде.  Однако, используя управление работами, вы можете
одновременно   выполнять   несколько   работ,   по  необходимости
переключаясь  с  одной  на другую. Какая от этого польза? Давайте
предположим,  что  вы  редактируете  текстовый  файл и неожиданно
хотите  прерваться  и сделать что-то другое. С помощью управления
работами  вы  можете  отложить  редактирование  и,  вернувшись  к
подсказке shell, начать какую-то другую работу. После этого
вы  можете  вернуться  к редактированию, именно к тому
месту,  где  вы  прервали  редактирование. Это всего один пример.
Управление работами очень полезно на практике.</p>
<p></p>

<h2>3.11.2 <A Name="ss3.11.2"> Выполнение работ на переднем плане и в фоне </h2>

<p>Работы  могут  выполняться как на <b>переднем плане</b>, так и в
<b>фоне</b>.  На  переднем  плане в каждый момент может быть только одна
работа.   Работа  переднего  плана,  это  работа,  с  которой  вы
взаимодействуете, она получает информацию с клавиатуры и посылает
результаты  на  ваш  экран. (Кроме, разумеется, случаев, когда вы
сами  перенаправляете  вход  или выход, как описывалось в Разделе
3.8).  С  другой стороны, фоновые работы не получают информации с
терминала, в общем случае они тихо (в смысле - мирно) выполняются,
не испытывая потребности в общении с пользователем.</p>
<p></p>
<p>Некоторые  работы  требуют очень большого времени для своего
завершения  и  не  свершают  ничего внешне интересного в процессе
этой  работы.  Компиляция  программ  - одна из таких работ, как и
компрессия  больших  файлов. Нет вразумительных причин, почему вы
должны при этом сидеть рядом и мучительно ждать, когда эти работы
закончатся.  Вы  можете  просто запустить их в фоне. Пока они там
выполняются, вы можете заняться другими программами.</p>
<p></p>
<p>Работы  могут  быть  также <b>отложены</b>. Отложенная работа - это
работа,  которая  в  данный  момент  не  выполняется и временно
остановлена.  После  того, как вы остановили работу, в дальнейшем
вы  можете ее продолжить как на переднем плане, так и в фоне.
Возобновление  приостановленной  работы не изменит ее состояния -
при  возобновлении  она  начнется  с  того места, на котором была
приостановлена.</p>
<p></p>
<p>Имейте  в  виду,  что приостановка работы, это не <em>прерывание</em>
работы.  Когда  вы  прерываете  идущий  процесс  (нажимая клавиши
прерывания,  обычно  это <F>ctrl-C</F>), то убиваете процесс насовсем.
(Клавиши  прерывания  можно  переустанавливать  командой stty. По
умолчанию  прерывание  находится под <F>ctrl-C</F>, но мы не можем это
гарантировать для всех систем). Если работа убита, то уж убита, и
нет  другого способа возобновить ее, как вновь запустить сначала,
используя прежнюю команду. Заметим также, что некоторые программы
могут   перехватывать   прерывания,  тогда  нажатие  <F>ctrl-C</F>  не
приведет   к   немедленному   прекращению  работы.  Это  позволит
программе  выполнить необходимые операции аккуратного завершения.
Некоторые программы вообще не позволят вам их прервать.</p>
<p></p>
<p></p>
<p></p>

<h2>3.11.3 <A Name="ss3.11.3"> Работа в фоне и ликвидация работ </h2>

<p>Давайте  начнем  с  простого примера. Команда <code>yes</code> - вроде бы
бесполезная  команда,  посылающая  бесконечный  поток  "y" на
стандартный выход. (Но это очень полезно. Если вы направите через
конвейер  эти  "y"  на  вход  другой  команды, которая требует
ответов <code>yes</code> и "no" на вопросы, поток "y" даст подтверждение
на все вопросы). Попробуйте.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# yes
    y
    y
    y
    y
    y
</pre>
</code></blockquote>
</p>
<p></p>
<p>Это  закончится  в  <em>бесконечности</em>.  Вы можете убить процесс,
нажав  клавиши  прерывания; обычно это <F>ctrl-C</F>. Чтобы нас больше
не  раздражал  поток  нескончаемых  "y",  перенаправим  его в
<code>/dev/null</code>. Как вы помните, <code>/dev/null</code>
выступает в качестве "черной
дыры" для данных. В ней исчезают бесследно любые данные.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# yes &gt; /dev/null
</pre>
</code></blockquote>
</p>
<p></p>
<p>Ох, теперь намного лучше. Ничего не печатается, но и подсказка
shell   не  появляется.  Это  потому,  что  программа  продолжает
работать,  посылать  "y"  в  <code>/dev/null</code>.  Снова нажмите клавиши
прерывания, чтобы прекратить это.</p>
<p></p>
<p>Давайте   предположим,  что  мы  хотим,  чтобы  команда <code>yes</code>
продолжала  работать,  но  также  хотим  получить обратно подсказку
shell,  чтобы выполнять другие работы. Мы можем перевести команду
<code>yes</code> в фоновый режим, что позволит ей выполняться, но без выхода на
взаимодействие с пользователем.</p>
<p></p>
<p>Чтобы  переместить процесс в фоновый режим, необходимо после
команды символ ``<code>&amp;</code>''.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# yes &gt; /dev/null &;
    [1] 164
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы   видите,  что мы  вновь получили подсказку. Но что
значит ``<F>1</F> 164''? И выполняется ли команда <code>yes</code> на самом деле?</p>
<p></p>
<p>``<F>1</F>''  представляет <b>номер работы</b> для программы <code>yes</code>. Shell
приписывает  номер  каждой выполняемой работе. Поскольку "yes" - одна
единственная  работа,  которая  в  данный  момент выполняется, ей
присвоен  номер  1.  ``164''  - идентификатор процесса (PID); это
номер, присвоенный системой работе. Любой из этих номеров можно
использовать  при  обращении  к  работе, как это будет показано в
дальнейшем.</p>
<p></p>
<p>Теперь  мы  имеем  выполняемый процесс <code>yes</code> в фоновом режиме,
непрерывно  посылающий поток "y"-ков в <code>/dev/null</code>. Чтобы проверить
состояние  этого процесса, используйте внутреннюю команду shell -
<code>jobs</code>.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# jobs
    [1]+  Running                 yes &gt;/dev/null  &
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Ясно,  что  она  выполняется.  Вы можете также воспользоваться
командой <code>ps</code>, показанной ранее, для проверки статуса работ.</p>
<p></p>
<p>Для  завершения работы используйте команду <code>kill</code>. Эта команда
может  брать  в  качестве  аргумента  как  номер  работы,  так  и
идентификатор процесса. Это была работа номер 1, так что используя
команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry# kill %1
</pre>
</code></blockquote>
</p>
<p></p>
<p>мы  ликвидируем  работу.  При идентификации работы по номеру
необходимо впереди ставить символ процента (``%'').</p>
<p></p>
<p>Теперь,  после  ликвидации, мы можем снова использовать <code>jobs</code>
для проверки:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# jobs

    [1]+  Terminated              yes &gt;/dev/null

    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Работа  действительно  мертва, и если мы снова воспользуемся
командой <code>jobs</code>, ничего не будет выведено на экран.</p>
<p></p>
<p>Вы можете также убить работу, используя номер идентификатора
процесса  (PID),  который  выводится  наряду  с работой, когда вы
начинаете  работу  (в  фоновом  режиме). В нашем пример PID равен
164, так что команда</p>
<p>
<blockquote><code>
<pre>
    /home/larry# kill 164

     эквивалентна

    /home/larry# kill %1
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вам  не  надо  использовать  ``<code>%</code>'',  когда  вы обращаетесь к
работе по номеру идентификатора процесса.</p>
<p></p>
<p></p>
<p></p>

<h2>3.11.4 <A Name="ss3.11.4"> Остановка и возобновление работы </h2>

<p>Есть  другой  способ  перевести  работу  в фоновый режим. Вы
можете  начать  работу  нормально  (в  режиме  переднего  плана),
<b>остановить</b> работу и продолжить в фоновом режиме.</p>
<p></p>
<p>Сначала начнем работу "нормально":</p>
<p>
<blockquote><code>
<pre>
    /home/larry# yes &gt; /dev/null
</pre>
</code></blockquote>
</p>
<p></p>
<p>Поскольку  опять работа выполняется на переднем плане, вы не
получите обратно на экран подсказку shell.</p>
<p></p>
<p>Теперь,  вместо  того,  чтобы  прерывать  работу  с  помощью
<F>ctrl-C</F>, мы остановим работу. <em>Приостановка</em> работы не убивает ее.
Чтобы осуществить приостановку работы, надо нажать соответствующие
клавиши, обычно это <F>ctrl-Z</F>.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# yes &gt; /dev/null
    [ctrl-Z]
    [1]+  Stopped                 yes &gt;/dev/null
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Пока  работа  остановлена, она просто не выполняется. На нее
не  тратится  время  процессора.  Но вы всегда можете возобновить
работу, и она продолжится как ни в чем не бывало.</p>
<p></p>
<p>Для   возобновления   работы   в   режиме   переднего  плана
используйте команду <code>fg</code> (``foreground'' - передний план).</p>
<p>
<blockquote><code>
<pre>
    /home/larry# fg
    yes &gt;/dev/null
</pre>
</code></blockquote>
</p>
<p></p>
<p>Shell  снова  выдаст  на  экран  имя команды, чтобы вы могли
проконтролировать,   какую работу   вы   активизировали  в  режиме
переднего  плана.  Вновь  остановите работу с помощью <F>ctrl-Z</F>. В
этот  раз  используйте  команду <code>bg</code> (``background'' - задний план,
фоновый  режим),  чтобы  перевести работу в фоновый режим. Эффект
будет  аналогичен  тому,  как  если  бы  вы набрали после команды
``<code>&amp;</code>''.</p>
<p>
<blockquote><code>
<pre>
    /home/larry# bg
    [1]+ yes &gt;/dev/null &
    /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>И  мы  получили  назад  подсказку.  Команда  jobs сообщит, что
команда  yes действительно выполняется, и мы можем снова ее убить
с помощью команды <code>kill</code>, как мы это уже делали.</p>
<p></p>
<p>Как  теперь  остановить  работу?  Использование  <F>ctrl-Z</F> не
поможет,  поскольку  работа  находится  в фоновом режиме. Ответ -
переместить  работу  на  передний  план,  а  затем остановить. Вы
можете  использовать  <code>fg</code>  как  для остановленных работ, так и для
работ, находящихся в фоне.</p>
<p></p>
<p>Существует   большая   разница   между   фоновой  работой  и
остановленной.   Остановленная   работа   не   выполняется  и  не
использует  время процессора, да и никакой работы, честно говоря,
в  этот  момент  не  делает  (но  занимает  память,  хотя по воле
своппинга  может  оказаться  на диске). Работа в фоновом режиме и
выполняется,  и  занимает  память. Она может даже выводить
что-то  на  экран,  хотя  это  может  раздражать  вас,  когда  вы
работаете  над  чем-то  другим.  Например,  если  вы использовали
команду:</p>
<p>
<blockquote><code>
<pre>
    /home/larry# yes &
</pre>
</code></blockquote>
</p>
<p></p>
<p>без  перенаправления  stdout в <code>/dev/null</code>, поток "y" будет
выводиться  на  экран без возможности прервать это (вы не сможете
использовать  <F>ctrl-C</F>  для  прерывания  работ  фонового режима).
Чтобы  остановить эту бесконечную выдачу, вам следует использовать
команду  fg  для перевода работы в режим переднего плана, а затем
использовать <F>ctrl-C</F>, чтобы ее убить.</p>
<p></p>
<p>Еще  одно  замечание.  Команды <code>fg</code> и <code>bg</code> обычно переводят на
передний   план   или   в  фоновый  режим  работы,  которые  были
остановлены  последними  (что  определяется  символом ``<code>+</code>'' после
номера  работы,  это  когда вы используете команду jobs). Если вы
выполняете  много  работ  одновременно,  вы  можете  перевести на
передний  план  или,  наоборот,  в фоновый режим конкретную работу
заданием идентификатора работы в качестве аргумента команд fg или
bg, как в</p>
<p>
<blockquote><code>
<pre>
    /home/larry# fg %2
</pre>
</code></blockquote>
</p>
<p>(перевод на передний план работы номер 2) или</p>
<p>
<blockquote><code>
<pre>
    /home/larry# bg %3
</pre>
</code></blockquote>
</p>
<p>(перевод в фон работы номер 3).</p>
<p></p>
<p>Для этих команд нельзя использовать идентификаторы процессов.
Кроме того, использование только номеров работ, как в</p>
<p>
<blockquote><code>
<pre>
    /home/larry# %2

     эквивалентно

    /home/larry# fg %2
</pre>
</code></blockquote>
</p>
<p></p>
<p>Помните,   что  управление  работами,  это  свойство  shell.
Команды  <code>fg</code>,  <code>bg</code>  и  <code>jobs</code>  -  внутренние  команды  shell. Если по
какой-то  причине  вы  используете shell, который не поддерживает
управление работами, там вы не найдете этих команд.</p>
<p></p>
<p>В  дополнение  к  этому,  есть  некоторые аспекты управления
работами, которые различаются в Bash и Tcsh. Некоторые оболочки не
имеют  управления работами, хотя большинство оболочек Linux имеют такую
возможность.</p>
<p></p>
<p></p>


<h2>3.12 <A Name="ss3.12"> Использование редактора vi </h2>

<p>Текстовый   редактор,   это   программа,   используемая  для
редактирования  файлов,  которые содержат текст, например письма,
С-программы  или  системные конфигурационные файлы. Хотя в Linux
много всяких разных редакторов, единственный редактор, который вы
с гарантией найдете в любом UNIX - это <code>vi</code> (``visual editor''). <code>vi</code>
- это  не  самый  простой в использовании редактор. Но поскольку он
так  распространен  в  мире  UNIX  и  в  любой  момент  может вам
потребоваться, он заслуживает хоть какого-то описания здесь.</p>
<p></p>
<p>Выбор  редактора,  это  дело  персонального  вкуса  и стиля.
Многие  пользователи  предпочитают  витиеватый  и  мощный <em>Emacs</em> -
редактор  с  самым  большим набором возможностей, по сравнению со
всеми другими редакторами в мире UNIX. Например, Emacs имеет свой
собственный  встроенный  диалект  языка  программирования  LISP и
множество расширений (одно из которых ``Eliza''- в некотором роде
программа  искусственного интеллекта). Однако, поскольку Emacs со
всеми  поддерживающими его файлами сравнительно велик, его нет на
многих  системах.  <code>vi</code>, наоборот, маленький и удаленький, но, увы,
более  сложный  в  использовании. Но когда вы с ним освоитесь, вы
поймете, что он очень простой. Правда осваивать его сложно.</p>
<p></p>
<p>Этот  раздел  -  вразумительное  введение  в <code>vi</code>. Мы не будем
обсуждать все его свойства, а только те, которые вы должны знать,
чтобы  начать работать. Если вы пожелаете знать больше деталей, обратитесь
к страницам Руководства.</p>
<p></p>
<p></p>
<h2>3.12.1 <A Name="ss3.12.1"> Концепции </h2>

<p>При  использовании  <code>vi</code>  в любое время вы можете находиться в
одном  из  трех режимов работы. Эти режимы известны как командный
режим, режим вставки и режим последней строки.</p>
<p></p>
<p>Когда  вы  начинаете  работать с <code>vi</code> - вы в командном режиме.
Этот   режим  позволяет  использовать  определенные  команды  для
редактирования  файлов  или  перехода  в другие режимы. Например,
напечатав  ``<code>x</code>''  при  нахождении  в  командном  режиме, удаляете
символ, находящийся перед курсором. Стрелки передвигают курсор по
редактируемому   файлу.   Большинство   команд,   используемых  в
командном режиме, состоит из одного или двух символов.</p>
<p></p>
<p>Вставку  или редактирование текста вы осуществляете в режиме
вставки. При использовании <code>vi</code> вы, возможно, большую часть времени
находитесь  именно в этом режиме. Вы переходите в режим вставки с
помощью  команды  ``<code>i</code>''  (``insert''  -  вставка)  из  командного
режима.  В режиме вставки вы вставляете текст в документ на место,
указываемое  курсором. Для завершения режима вставки и возврата в
командный режим следует нажать <F>esc</F>.</p>
<p></p>
<p>Режим последней строки - это специальный режим, используемый
для  расширения  возможностей  командного режима. При вводе таких
команд  они  появляются в последней строке экрана. Например, если
вы  напечатаете  ``:''  в  командном режиме, вы перейдете в режим
последней строки и сможете использовать такие команды, как ``<code>wq</code>''
(записать  (write)  файл и выйти (quit) из vi), или ``<code>q!</code>'' (выйти
из  vi  без сохранения изменений). Режим последней строки в общем
случае   используется  для  команд  <code>vi</code>,  которые  длиннее  одного
символа.  В  режиме  последней  строки  вы  вводите  однострочные
команды и нажимаете <F>enter</F> для их выполнения.</p>
<p></p>
<p></p>

<h2>3.12.2 <A Name="ss3.12.2"> Начала vi </h2>

<p>Лучший способ освоить эту концепцию, это вызвать
<code>vi</code> и отредактировать файл. В примере
``<code>screens</code>'', приводимом ниже, мы собираемся только показать
несколько строк текста, будто бы экран состоит всего из
шести строк (вместо двадцати четырех).</p>
<p>
<blockquote><code>
<pre>
     Вызов vi

     vi &lt;filename&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p>где <code>&lt;filename&gt;</code> - имя редактируемого файла.</p>
<p></p>
<p>Ну так вызовите <code>vi</code>, напечатав</p>
<p>
<blockquote><code>
<pre>
     /home/larry# vi test
</pre>
</code></blockquote>
</p>
<p></p>
<p>для редактирования файла <code>test</code>.  Вы увидите нечто вроде</p>
<p>
<blockquote><code>
<pre>
____________________________________________________________________
|~_                                                                 |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|"test"_[New_file]__________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Столбец символов ``~'' говорит о том, что вы стоите на конце
файла.</p>
<p></p>
<p></p>

<h2>3.12.3 <A Name="ss3.12.3"> Вставка текста </h2>

<p>Вы  находитесь в командном режиме; для того, чтобы вставлять
текст  в  файл, нажмите <F>i</F> (что переведет вас в режим вставки) и
начинайте печатать.</p>
<p>
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all good men to come to the aid of the party._ |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>При  вставке  текста  вы  можете  напечатать  столько строк,
сколько  пожелаете  (нажимая  <F>return</F>  после  каждой  строки), и
можете   корректировать   ошибки   используя   клавишу   возврата
(backspace).</p>
<p></p>
<p>Для  завершения  режима вставки и возврата в командный режим
нажмите <F>esc</F>.</p>
<p></p>
<p>В   командном  режиме  вы  можете  использовать  клавиши  со
стрелками  для  перемещения  по  файлу.  Здесь, поскольку мы имеем
только одну строку текста, попытки использовать стрелки "вверх" и
"вниз" приведут лишь к тому, что vi на вас загудит.</p>
<p></p>
<p>Есть   несколько   способов   вставки  текста,  отличных  от
использования команды <code>i</code>. Например, команда <code>a</code> вставляет в текст,
начиная  <em>после</em> текущего положения курсора, вместо текущей позиции
курсора.  Используйте  левую  стрелку  для перемещения
курсора между словами ``good'' и ``men''.</p>
<p>
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all good_men to come to the aid of the party.  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Нажмите  <F>a</F>, для начала режима вставки, напечатайте ``<code>wo</code>'',
а затем нажмите <F>esc</F> для возврата в командный режим.</p>
<p>
<blockquote><code>
<pre>
____________________________________________________________________
|Now is the time for all good women to come to the aid of the party.|
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Для  того, чтобы начать вставку текста в строку ниже текущей,
используйте  команду  ``<code>о</code>''.  Например,  нажмите  <F>o</F> и напечатайте
строчку или две
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all good women to come to the aid of the party.|
|Afterwards, we'll go out for pizza and beer._                      |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Но помните, что в любое время вы находитесь либо в командном
режиме  (где команды, такие как <code>i</code>, a или o могут применяться) или
в  режиме  вставки  (где  вы  вставляете текст, а затем с помощью
<F>esc</F>  возвращаетесь  в  командный  режим)  или в режим последней
строки  (в  котором  вы  расширяете  расширяемые команды, как это
обсуждается ниже).</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.4 <A Name="ss3.12.4"> Удаление текста </h2>

<p>В   командном   режиме  команда  "<code>x</code>"  удаляет  символ  перед
курсором. Если вы нажмете <F>x</F> пять раз, вы закончите в ситуации:</p>
<p>
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all good women to come to the aid of the party.|
|Afterwards, we'll go out for pizza and _                           |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь  нажмите  <F>a</F>,  вставьте  некоторый  текст,  а  затем
нажмите <F>esc</F>:</p>
<p>
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all good women to come to the aid of the party.|
|Afterwards, we'll go out for pizza and Diet Coke._                 |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы  можете  удалять  целые  строки, набирая команду <code>dd</code> (т.е.
нажимая  <F>d</F>  дважды).  Если  ваш  курсор  на второй строке, и вы
напечатали <code>dd</code>,
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all good women to come to the aid of the party.|
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Чтобы   удалить   слово,   на   котором   находится  курсор,
используйте  команду  <code>dw</code>.  Поместите  курсор  на слово ``good'' и
напечатайте <code>dw</code>.
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all women to come to the aid of the party.     |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.5 <A Name="ss3.12.5"> Изменение текста </h2>

<p>Вы  можете  заменить  фрагменты текста, используя команду <code>R</code>.
Поместите  курсор  на первую букву слова ``party'', нажмите <F>R</F> и
напечатайте слово ``hungry''.
<blockquote><code>
<pre>
 ____________________________________________________________________
|Now is the time for all women to come to the aid of the hungry._   |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Использование  <code>R</code>  для редактирования текста очень походит на
на  команды  <code>i</code>  и <code>a</code>, но <code>R</code> заменяет прежний текст вместо вставки в
него.
Команда   <code>r</code>   заменяет  один  символ,  отмеченный  курсором.
Например,   переместите   курсор   на   начало  слова  ``Now''  и
напечатайте <code>r</code>, а следом <code>C</code>, то вы получите:
<blockquote><code>
<pre>
 ____________________________________________________________________
|Cow is the time for all women to come to the aid of the hungry._   |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Команда  ``<code>&tilde;</code>''  изменяет  размер буквы, отмеченной курсором:
большую  делает маленькой и наоборот. Например, если вы поместите
курсор на ``o'' в ``Cow'' и затем последовательно будете нажимать
<F>~</F>, вы в конечном итоге получите:
<blockquote><code>
<pre>
 ____________________________________________________________________
|COW IS THE TIME FOR ALL WOMEN TO COME TO THE AID OF THE HUNGRY.    |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.6 <A Name="ss3.12.6"> Команды перемещения </h2>

<p>Вы  уже  знаете,  как использовать стрелки для перемещений по
документу.  Вы также можете использовать команды <code>h</code>, <code>j</code>,
<code>k</code>, и <code>l</code> для
перемещения  курсора  влево, вниз, вверх и вправо соответственно.
Это удобно, если (по каким-то причинам) ваши клавиши
со стрелками не работают как надо.</p>
<p></p>
<p>Команда <code>w</code> перемещает курсор на начало следующего слова; <code>b</code> -
перемещает на начало предыдущего слова.</p>
<p></p>
<p>Команда  <code>0</code>  (это  ноль) передвигает курсор на начало текущей
строки, а команда <code>$</code> перемещает на конец строки.</p>
<p></p>
<p>При  редактировании  больших  файлов  вы хотите перемещаться
вперед  и  назад сразу на размер экрана. Нажатием <F>ctrl-F</F> курсор
перемещается на экран вперед, с помощью <F>ctrl-B</F> - на
экран назад.</p>
<p></p>
<p>Для   того,   чтобы   переместить   курсор  в  конец  файла,
напечатайте   <code>G</code>.  Можно  переместиться  также  на  любую  строку,
напечатав  команду  <code>10G</code>  вы  переместите курсор на десятую строку
файла.  Для  того,  чтобы  встать  на  начало (на первую строку),
используйте <code>1G</code>.</p>
<p></p>
<p>Вы  можете сочетать команды перемещения с другими командами,
такими   как   удаление.   Например,   команда   <code>d$</code>   удалить  от
местоположения  курсора до конца строки; <code>dG</code> удалит все от курсора
до конца файла и т.д.</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.7 <A Name="ss3.12.7"> Сохранение файлов и выход из vi </h2>

<p>Для выхода из
<code>vi</code> без внесения изменений в ранее существовавший файл используйте команду
<code>:q!</code>.</p>
<p>Когда вы напечатаете ``<code>:</code>'', курсор переместится на последнюю строку экрана,
поскольку вы перейдете в режим последней строки.
<blockquote><code>
<pre>
 ____________________________________________________________________
|COW IS THE TIME FOR ALL WOMEN TO COME TO THE AID OF THE HUNGRY.    |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|:__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>В   режиме  последней  строки  могут  выполняться  некоторые
расширенные команды. Одна из них - <code>q!</code>, которая позволяет выйти из
<code>vi</code>  без  записи. Команда <code>:wq</code> сохраняет (записывает) файл, а затем
выходит   из   <code>vi</code>.   Команда  <code>ZZ</code>  (в  режиме  команд,
без  `<code>:</code>'')
эквивалентна  <code>:wq</code>.  Помните,  что  вы должны нажать <F>enter</F> после
набора  команды  в  режиме последней строки. Если хотите записать
файл без выхода из /<code>vi</code>, используйте просто <code>:w</code>.</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.8 <A Name="ss3.12.8"> Редактирование еще одного файла </h2>

<p>Для  того,  чтобы  отредактировать  другой файл, используйте
команду  <code>:e</code>. Например, чтобы прекратить редактирование файла <code>test</code>
и перейти к редактированию файла <code>foo</code>, используйте команду
<blockquote><code>
<pre>
 ____________________________________________________________________
|COW IS THE TIME FOR ALL WOMEN TO COME TO THE AID OF THE HUNGRY.    |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|:e foo_____________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Если  вы  используете  :e  без  предварительного  сохранения
файла, то сначала вы получите сообщение об ошибке.</p>
<p>
<blockquote><code>
<pre>
 ____________________________________________________________________
 |No_write_since_last_change_(":edit!"_overrides)____________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>которое  просто  означает,  что <code>vi</code> не желает редактировать
другой  файл,  пока  не  будет  сохранен первый. В этот момент вы
можете  использовать  <code>:w</code>,  чтобы сохранить исходный файл, а затем
использовать <code>:e</code> или использовать команду
<blockquote><code>
<pre>
 ____________________________________________________________________
|COW IS THE TIME FOR ALL WOMEN TO COME TO THE AID OF THE HUNGRY.    |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|~                                                                  |
|:e! foo_____________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>``<code>!</code>''  говорит <code> vi</code>,  что  вы  на  самом деле имеете в виду -
редактировать   новый  файл  без  сохранения  изменений,  которые
делались в первом.</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.9 <A Name="ss3.12.9"> Включение других файлов </h2>

<p>Если   вы   используете   команду  <code>:r</code>,  вы  можете  включить
содержимое другого файла в текущий файл. Например, команда</p>
<p>
<blockquote><code>
<pre>
    :r foo.txt
</pre>
</code></blockquote>
</p>
<p></p>
<p>вставит содержимое файла <code>foo.txt</code> в данное место текста.</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.10 <A Name="ss3.12.10"> Выполнение команд Shell </h2>

<p>Вы  можете  также выполнять команды прямо из <code>vi</code>. Команда <code>:r!</code>
работает  как  <code>:r</code>,  но  вместо  чтения  файла она вставляет выход
данной  команды в буфер, в место, где находится курсор. Например,
если вы используете команду</p>
<p>
<blockquote><code>
<pre>
    :r!  ls -F
</pre>
</code></blockquote>
</p>
<p></p>
<p>вы получите в результате
<blockquote><code>
<pre>
 ____________________________________________________________________
|COW IS THE TIME FOR ALL WOMEN TO COME TO THE AID OF THE HUNGRY.    |
|letters/                                                           |
|misc/                                                              |
|papers/_                                                           |
|~                                                                  |
|~__________________________________________________________________|
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы  можете  выполнить  команду  <code>a</code>, находясь в редакторе <code>vi</code> и
вернуться  в  редактор  после  ее  завершения  Напрмиер,  если вы
используете команду</p>
<p>
<blockquote><code>
<pre>
    :!  ls -F
</pre>
</code></blockquote>
</p>
<p></p>
<p>будет  выполнена  команда  <code>ls  -F</code>,  а результат выдан на
экран,  а  не  вставлен в редактируемый файл. Если вы используете
команду</p>
<p>
<blockquote><code>
<pre>
    :shell
</pre>
</code></blockquote>
</p>
<p></p>
<p><code>vi</code> запустит shell, который позволит временно "отложить" vi и
выполнить команды. После выхода из shell (используя команду <code>exit</code>)
вы вернетесь в <code>vi</code>.</p>
<p></p>
<p></p>
<p></p>

<h2>3.12.11 <A Name="ss3.12.11"> Получение помощи </h2>

<p><code>vi</code> не слишком силен в интерактивной помощи (да и большинство
UNIX-ов   также),   но   вы  всегда  можете  посмотреть  страницы
Руководства  для <code>vi</code>. <code>vi</code> - это "визуальная составляющая" редактора
<code>ex</code>;  это <code>ex</code> делает многое для поддержания режима последней строки
и  командного  режима  в  <code>vi</code>.  Так  что  в  дополнение  к  чтению
Руководства по <code>vi</code> посмотрите также Руководство по <code>ex</code>.</p>
<p></p>
<p></p>
<p></p>


<h2>3.13 <A Name="ss3.13"> Установка среды </h2>

<p>Shell    обеспечивает   различные   механизмы   настройки
вашей  рабочей  среды.  Мы  уже упоминали ранее, что
shell  больше,  чем команда интерпретации - это также мощный язык
программирования.  Но  обсуждение программирования на shell увело
бы  нас  далеко  в  сторону,  а  мы  бы  хотели познакомить вас с
некоторыми  способами  упрощения  вашей  работы  в  UNIX  за счет
использования некоторых дополнительных полезных свойств shell.</p>
<p></p>
<p>Как   мы  упоминали  ранее,  различные  оболочки  используют
различный  синтаксис для написания своих программ. Например, Tcsh
использует  синтаксис,  похожий на язык Си, в то время как shell
Баурна  имеет  другой  синтаксис.  В  этом  разделе  мы  не будем
заниматься   их   различиями,  а  рассмотрим  примеры,  используя
синтаксис  shell  Баурна
<sl>(прим.  переводчикf:  как  все  обычно и
делают).</sl>

</p>
<p></p>
<p></p>
<h2>3.13.1 <A Name="ss3.13.1"> Сценарии shell </h2>

<p><F>прим.  переводчика: применительно к программам этого типа в
англоязычной    литературе    последнее   время   преимущественно
используют  слово  script  -  "сценарий",  хотя  то, что под этим
имеется   в   виду   во   многих  книгах  на  русском  называется
"традиционно" как "программа на shell" или "командный файл"</F></p>
<p></p>
<p>Предположим,  что вы часто используете серию команд и хотели
бы  сократить  об'ем  постоянной  печати за счет группировки их в
одну команду. Например, команды</p>
<p>
<blockquote><code>
<pre>
    /home/larry# cat chapter1 chapter2 chapter3 &gt; book
    /home/larry# wc -l book
    /home/larry# lp book
</pre>
</code></blockquote>
</p>
<p></p>
<p>об'единяют   файлы,   содержащие   главы   книги:  <code>chapter1</code>,
<code>chapter2</code>,  <code>chapter3</code>  и  помещают  результат  в  файл  <code>book</code>.
Затем
подсчитывается  число строк в книге (в файле <code>book</code>) и отображается
на дисплее и, наконец, печатается командой <code>lp</code>.</p>
<p></p>
<p>Вместо введения каждый раз этих команд, вы можете собрать их
в один сценарий (командный файл). Сценарии shell мы кратко опишем в
Разделе  3.13.1.  А  сценарий,  который  выполнит вышеприведенные
команды, будет выглядеть следующим образом</p>
<p>
<blockquote><code>
<pre>
    #!/bin/sh
    # A shell script to create and print the book

    cat chapter1 chapter2 chapter3 &gt; book
    wc -l book
    lp book
</pre>
</code></blockquote>
</p>
<p></p>
<p>Если  этот  сценарий  будет  помещен  в файл <code>makebook</code>, то вы
можете просто использовать далее команду</p>
<p>
<blockquote><code>
<pre>
    /home/larry# makebook
</pre>
</code></blockquote>
</p>
<p></p>
<p>которая  выполнит все команды сценария. Сценарии shell - это
обычные  текстовые  файлы,  которые вы можете создавать с помощью
редактора вроде <code>emacs</code> или <code>vi</code>. (<code>vi</code> обсуждался в Разделе 3.12)</p>
<p></p>
<p>Давайте   посмотрим   на   этот   сценарий.   Первая  строка
``<code>#!</code>bin/sh/''  говорит  о  том,  что  этот  файл  есть сценарий и
сообщает   shell,   как   выполнить  сценарий.  В  данном  случае
необходимо  передать сценарий для выполнения команде <code></code>bin/sh/, где
<code></code>bin/sh/  -  сама программа shell. Почему это важно? В большинстве
систем UNIX <code></code>bin/sh/ - это shell Баурновского типа, например <code>bash</code>.
Инициируя  работу  сценария shell выполняется, используя <code></code>bin/sh/,
при  этом  мы  гарантируем, что сценарий будет выполняться именно
под  shell  Баурновского  типа  (а не, скажем, под C shell). Этот
сценарий  будет  выполняться  под  shell  Баурна,  даже  если  вы
используете  Tcsh  (или какой-то другой C shell) как свою рабочую
оболочку.</p>
<p></p>
<p>Вторая  строка представляет из себя комментарий. Комментарии
начинаются  символом ``<code>#</code>'' и могут продолжаться до конца строки -
они  игнорируются  shell и могут использоваться программистом для
пояснений.</p>
<p></p>
<p>Остальные  строки  сценария  - обычные команды в том виде, в
каком  бы  вы их вводили прямо на выполнение. Shell читает каждую
строку  сценария и выполняет эту строку, как будто вы ввели эту
строку в ответ на подсказку shell.</p>
<p></p>
<p>Права  доступа важны для сценариев. Если вы создали сценарий,
вы должны убедиться, что вы имеете права на его выполнение.
<sl>Если
вы  создавали  сценарий  в  редакторе, то он (обычно) не получает
автоматически прав на выполнение.</sl>

Можно использовать команду</p>
<p>
<blockquote><code>
<pre>
       /home/larry# chmod u+x makebook
</pre>
</code></blockquote>
</p>
<p></p>
<p>чтобы    дать   самому   себе   разрешение   на   выполнение
shell-сценария <code>makebook</code>.</p>
<p></p>
<p></p>
<p></p>

<h2>3.13.2 <A Name="ss3.13.2"> Перемещение shell  и среда </h2>

<p>Shell  позволяет  определять <b>переменные</b>,  как и большинство
языков  программирования. Переменная - это порция данных, которой
дано имя.
<sl>(прим. переводчика: В языке shell переменные не определяются
(в   традиционном   смысле),  так  как  все  они  одного  типа  -
"строкового",   речь  может  идти  только  об  их  инициировании:
присваивании начальных значений).</sl>

</p>
<p></p>
<p><b>ВНИМАНИЕ!</b>  Имейте  в  виду,  что Tcsh, также, как и C shell,
используют    различные    механизмы    определения   переменных,
отличающиеся  от  используемых  здесь.  Здесь  обсуждается  shell
Баурна.   Когда   вы  присвоите  значение  переменной  (используя
оператор ``<code>=</code>'' ), вы сможете получить это значение, добавив перед
именем переменной символ ``<code>$</code>'', как это показано ниже</p>
<p>
<blockquote><code>
<pre>
       /home/larry# foo=``hello there''
</pre>
</code></blockquote>
</p>
<p></p>
<p>Переменной  foo присвоено значение ``<code>hello there</code>''. Теперь вы
можете  обратиться к этой переменной, добавив перед именем
символ ``<code>$</code>''. Команда</p>
<p>
<blockquote><code>
<pre>
       /home/larry# echo $foo
       hello there
       /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>дает тот же самый результат, что и</p>
<p>
<blockquote><code>
<pre>
       /home/larry# echo ``hello there''
       hello there
       /home/larry#
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эти переменные являются внутренними для shell. Это означает,
что  только  shell имеет доступ к этим переменным. Это может быть
полезно для сценариев; если вам надо сохранить информацию о имени
файла,  вы,  например, можете поместить его в переменную. Команда
set  может  показать  вам  перечень  всех определенных переменных
shell.</p>
<p></p>
<p>Shell  позволяет  <b>экспортировать</b> переменные в среду. <b>Среда</b> -
это   множество   переменных,   к   которым  могут  иметь  доступ
все выполняемые команды. Определив однажды переменную внутри shell
<sl>(прим.   переводчика:  определить  -  здесь  означает  "присвоить
значение"),</sl>

командой <code>export</code> вы можете передать ее среде.</p>
<p></p>
<p><b>ВНИМАНИЕ!</b>  Здесь  вновь  есть отличие между Bash и Tcsh. При
использовании  Tcsh  используется другой сиснтаксис для помещения
переменных  в среду (используется команда <code>setenv</code>). Дополнительную
информацию можно найти в Руководстве по Tcsh.</p>
<p></p>
<p>Среда   очень   важна   в   системах   UNIX.  Она  позволяет
конфигурировать некоторые команды за счет установки переменных, о
которых знают команды.</p>
<p></p>
<p>Вот  небольшой  пример.  Переменная среды <code>PAGER</code> используется
командой  man. Она указывает команду, которая используется в свою
очередь командой man для просмотра Руководства на экране. Если вы
установите  в  качестве значения <code>PAGER</code> имя другой команды, то эта
команда  вместо  будет обеспечивать просмотр вместо more (которая
применялась по умолчанию).</p>
<p></p>
<p>Присвойте <code>PAGER</code> значение ``<code>cat</code>''. Выдача на экран руководства
будет вся разом, а не поэкранно, как это делала команда more.</p>
<p>
<pre>
       /home/larry# PAGER=cat
</pre>
</p>
<p></p>
<p>Теперь экспортируйте <code>PAGER</code> в среду.</p>
<p>
<pre>
       /home/larry# export PAGER
</pre>
</p>
<p></p>
<p>Попробуйте команду <code>man ls</code>. Руководство промелькнет по вашему
экрану без (желательных) задержек.</p>
<p></p>
<p>Теперь,  если  присвоить  <code>PAGER</code>  значение  ``<code>more</code>'',  то для
выдачи на экран будет использоваться команда more.</p>
<p>
<pre>
       /home/larry# PAGER=more
</pre>
</p>
<p></p>
<p>Обратим  внимание  на то, что нам не надо заново использовать
команду <code>export</code> после изменения значения <code>PAGER</code>. Необходимо только
раз  экспортировать  переменную;  любые  изменения, которые будут
происходить после этого, будут отражаться в среде.</p>
<p></p>
<p>Страницы   Руководства   для   конкретных   команд  содержат
информацию  о  том,  использует  ли  команда  какие-то переменные
среды.  Например,  Руководство  по команде man говорит о том, что
для  определения  режима  выдачи  страницы  руководства  на экран
используется   переменная  <code>PAGER</code>.  Некоторые  команды  совместно
используют  переменные среды, например, многие команды используют
переменную среды <code>EDITOR</code> для указания используемого редактора.</p>
<p>Переменные среды используются также для сохранения важной информации
о процедуре входа. Например переменная <code>HOME</code> содержит имя
вашего домашнего каталога.</p>
<p>
<pre>
    /home/larry/papers# echo $HOME
    /home/larry
</pre>
</p>
<p></p>
<p>Другая интересная переменная среды - <code>PS1</code>, которая определяет
главную подсказкн shell. Например,</p>
<p>
<pre>
    /home/larry# PS1=``Your command, please:  ''
    Your command, please:
</pre>
</p>
<p></p>
<p>Для  переустановки  подсказки обратно в нормальное состояние
(когда  она  показывает  текущий  рабочий  каталог,  после
которого следует значек ``<code>#</code>''), выполните следующее:</p>
<p>
<pre>
    Your command, please:  PS1=``\w# ''
    /home/larry#
</pre>
</p>
<p></p>
<p>В  Руководстве  <code>bash</code>  есть  подробное  описание  синтаксиса,
используемого при установке подсказки.</p>
<p></p>
<p></p>
<p></p>
<h2>3.13.2.1 <A Name="ss3.13.2.1"> Переменная среды  PATH </h2>

<p>Когда   вы   используете   команду  <code>ls</code>,  как  shell  находит
соответствующий выполняемый файл (программу) для <code>ls</code>? На самом деле
в  большинстве  систем  <code>ls</code>  находится в <code>/bin/ls</code>. shell использует
переменную   среды   <code>PATH</code>   ("ТРОПА")   для  указания  возможного
местоположения выполняемых файлов соответствующих команд.</p>
<p></p>
<p>Например, ваша переменная<code>PATH</code> может иметь значение</p>
<p>
<pre>
    /bin:/usr/bin:/usr/local/bin:.
</pre>
</p>
<p></p>
<p>Это   список  каталогов  (в  которых  shell  будет  искать
команду),  отделяемых  друг  от  друга  двоеточием ``<code>:</code>''. Когда вы
используете  команду  <code>ls</code>,  <code>shell</code>  прежде  всего проверяет наличие
<code>/bin/ls</code>, затем <code>/usr/bin/ls</code> и т.д.</p>
<p></p>
<p>Обратите  внимание  на  то,  что переменная <code>PATH</code> не помогает
находить обычные файлы. Например, если вы используете команду</p>
<p>
<pre>
    /home/larry# cp foo bar
</pre>
</p>
<p></p>
<p>shell  не  использует  <code>PATH</code>  для  нахождения местопребывания
файлов  <code>foo</code>  и  <code>bar</code>  -  предполагается,  что эти имена однозначно
определяют  место.  shell  использует  <code>PATH</code> только для нахождения
команды cp.</p>
<p></p>
<p>Это  экономит  вам  массу  времени;  это означает, что вы не
обязаны  помнить,  где  находятся  выполняемые  файлы  команд. Во
многих  системах  выполняемые  файлы разбросаны во многих местах,
таких  как  <code>/usr/bin</code>, <code>/bin</code> или <code>/usr/local/bin</code>.
Вместо того, чтобы
писать   полное   имя  команды  (вроде  <code>/usr/bin/cp</code>),  вы  просто
указываете  в  <code>PATH</code>  перечень  каталогов, которые бы вы хотели,
чтобы shell автоматически просматривал.</p>
<p></p>
<p>Обратите  внимание,  что  <code>PATH</code>  содержит ``<code>.</code>'', что означает
"текущий   рабочий   каталог".  Это  позволяет  вам  создавать
shell-сценарии  или  программы  и  выполнять  их  как команды из
текущего каталога, без необходимости указывать это прямо (как в
случае <code>./makebook</code>). Если каталог не указан в <code>PATH</code>, то shell не
будет  его просматривать в поиске команд, это касается и текущего
каталога.</p>
<p></p>
<p></p>
<p></p>


<h2>3.13.3 <A Name="ss3.13.3"> Shell-Сценарии инициализации </h2>

<p>В   дополнение   к  shell-сценариям,  которые  создаете  вы,
существует  множество сценариев, которые использует сам shell для
своих   целей.  Наиболее  важными  среди  них  являются  <b>сценарии
инициализации</b>,  которые автоматически выполняются shell при вашем
входе в систему.</p>
<p></p>
<p>Сценарии  инициализации сами по себе - это обычные сценарии,
как  это  описывалось  выше.  Но  они очень полезны при установке
вышей  среды  путем  автоматического выполнения набора команд при
вашем  входе  в  систему.  Например,  если  вы всегда используете
команду  <code>mail</code>  для проверки своей почты в момент входа в систему,
вы  можете  поместить эту команду в свой сценарий инициализации и
она будет выполнена автоматически.</p>
<p></p>
<p>Как  Bash,  так и Tcsh делают различие между начальным shell
(вызываемым  при  входе  в  систему)  и  прочими  вызовами shell.
Начальный shell вызывается в момент входа пользователя в систему;
часто  это  единственный экземпляр shell, который вы используете.
Но  если вы вызываете shell из другой программы, такой как<code>vi</code>, вы
тем  самым  запускаете новый (экземпляр) shell. Кроме того, когда
вы  запускаете  на  выполнение  shell-сценарии,  вы автоматически
инициируете новый экземпляр shell.</p>
<p></p>
<p>Файлы   инициализации,  используемые  в  Bash:  <code>/etc/profile</code>
(устанавливается  системным  администратором,  выполняется  всеми
экземплярами  начальных  пользовательских  <code>bash</code>,  вызванными  при
входе  пользователей в систему), <code>$HOME/.bash_profile</code> (выполняется
при   входе  пользователя)  и  <code>$HOME/.bashrc</code>  (выполняемый  всеми
прочими  <F>не  начальными</F>  экземплярами <code>bash</code>). Если <code>.bash_profile</code>
отсутствует, вместо него используется <code>.profile</code>.</p>
<p></p>
<p>Tcsh    использует    следующие    сценарии    инициализции:
<code>/etc/csh.login</code> (выполняется всеми пользовательскими <code>tcsh</code> в момент
входа  в  систему),  <code>$HOME/.tcshrc</code>  (выполняется во время входа в
систему   и   всеми  новыми  экземплярами  <code>tcsh</code>)
и  <code>$HOME/.login</code>
(выполняется   во   время  входа  после  <code>.tcshrc</code>).  Если  <code>.tcshrc</code>
отсутствует, вместо него используется <code>.cshrc</code>.</p>
<p></p>
<p>Для  того,  чтобы  лучше  понять  функции  этих  файлов, вам
следует  больше узнать о shell. Программирование на shell сложный
вопрос,  далеко  выходящий  за  рамки  этой  книги. Дополнительную
информацию можно получить из Руководства на <code>bash</code> и <code>tcsh</code>.</p>
<p></p>
<p></p>
<p></p>
<p></p>


<h2>3.14 <A Name="ss3.14"> Не хотите ли отправиться в самостоятельное плавание </h2>

<p>Надеемся,  что  мы  дали  достаточно информации относительно
того,  как использовать систему. Имейте в виду, что большая часть
интересных  и  важных аспектов Linux здесь не обсуждалась - здесь
рассматривались  только  самые базовые. Но этот фундамент поможет
вам  быстро освоить и использовать более сложные приложения. Если
все рассмотренное здесь вам не показалось волнующе интересным, не
унывайте  -  в  Linux есть еще много того, с чем следовало бы
познакомиться.  Один  из  незаменимых способов изучения системы -
это  чтение  Руководства.  Хотя многие страницы Руководства могут
выглядеть  и  достаточно  сложными,  если  вы  будете  достаточно
глубоко   копать,   вы   откопаете   несметные  россыпи  полезной
информации.</p>
<p></p>
<p>Мы также советуем прочитать какую-то полную книгу по системе
UNIX.  В  UNIX значительно больше разнообразных возможностей, чем
можно  увидеть  с  певого  взгляда  - к сожалению, они выходят за
рамки  этой  книги.  Некоторые  хорошие  книги  по UNIX указаны в
Приложении A.</p>
<p></p>

<p><a href="lig-4.html"> След. </a> Глава, <a href="lig-2.html"> Пред. </a> Глава</p><p>Содержимое <a href="lig.html#toc3">этой главы</a>,
 Главное <a href="lig.html#toc">оглавление</a></p>
<p><a href="lig.html"> Начало </a> документа,
 <a href="lig-3.html#0"> Начало этой главы</a></p>