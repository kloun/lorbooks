<title>Администрирование</title>
<?php include("/home/maxcom/linux_html/books/head.php3") ?>
<h1>4 <a name="s4"> Администрирование </h1>
<p> <a href="lig.html#toc4"> Содержимое этого раздела</a></p>

<p>Эта   глава  представляет  обзор  функций  администрирования
системы   Linux,   включая  ряд  особых  функций,  предназначенных
исключительно для администратора системы.</p>
<p></p>
<p>Как  в  каждой  бочке  меда  присутствует ложка дегтя, так и
каждая  система  имеет своего администратора. А администрирование
системы  -  это  очень  важная  и  иногда пожирающая уйму времени
работа, даже если вы единственный пользователь системы.</p>
<p></p>
<p>Мы   постараемся   обсудить   здесь  наиболее  важные  вещи,
связанные  с  администрированием,  о  котором вы должны знать при
использовании  Linux,  чтобы не испытывали неудобств при работе с
ОС.  Чтобы  быть не слишком болтливыми и приятными собеседниками,
мы и раньше рассматривали только основные черты, пропуская многие
важные  детали.  Вам  следует  прочитать  книгу  "  Linux  System
Administrator's   Guide",   если   у  вас  относительно  Linux
серьезные  намерения.  Это  поможет  вам лучше понять как там все
происходит, и как там все взаимодействует. В крайнем случае, стоит
все  это  просмотреть, чтобы знать что в книге содержится и какой
помощи вам следует от нее ожидать.</p>
<p></p>
<h2>4.1 <A Name="ss4.1"> О корнях власти, волшебной шапке и приятных ощущениях. </h2>

<p>Как  вы  знаете, UNIX различает различных пользователей, так
что  то, что они могут сделать друг другу и системе, регулируется
(например, не хочется, чтобы кто-то читал чужие любовные письма).
Каждый  пользователь получает <b>account</b> (регистрируется в системе),
что  включает  имя  пользователя,  домашний  каталог  и т.д. В
дополнение  к регистрации реальных людей, регистрируются (для них
также  открывается  счет  :-)  несколько специальных пользователей,
имеющих привилегии. Наиболее "важный" даже среди них пользователь
- <code>root</code> (корень).</p>
<p></p>
<h2>4.1.1 <A Name="ss4.1.1"> Регистрация  root </h2>

<p>Обычные  пользователи в общем случае ограничены так, что они
не могут причинить вред кому-либо другому в системе (включая саму
систему),  кроме  самих  себя.  Права  доступа к файлам в системе
организованы  таким  образом,  что  простой пользователь не может
удалить   или   изменить   файл,   файл  в  каталогах,  которые
пользователи  используют  совместно  (такие как <code>/bin</code> и
<code>/usr/bin</code>).
Большинство  пользователей  также защищают свои собственные файлы
так,  что  не  могут  их изменить, а иногда и вообще добраться до
них.</p>
<p></p>
<p>Но  все  эти ограничения не распространяются на пользователя root. 
Пользователь root может читать, модифицировать или удалять любой файл
системы, изменять его права доступа или менять его владельца.  Он
(<code>root</code>) может также выполнять специальные (привилегированные) программы,
такие как разбитие диска на разделы или создание файловой системы. Основная
идея состоит в том, что некто (их может быть несколько), кто выполняет
регистрацию пользователей (и носит имя <code>root</code>), должен, когда это
необходимо, иметь возможность выполнять работы, которые не могут быть
выполнены обычным рядовым пользователем.  Поскольку root может делать все,
что угодно, ему легко совершить какую-то ошибку, приводящую к
катастрофическим последствиям.</p>
<p></p>
<p>Например,   если вы как   обычный  пользователь  случайно
попытаетесь  удалить  файл  в  <code>/etc</code>,  система не разрешит вам это
сделать.  Но,  если  вы  вошли  как <code>root</code>, система даже не пикнет,
выполняя  все, что прикажете. Легко уничтожить систему, пребывая в
системе  в  качестве  root. Лучший способ избежать неприятностей,
это:</p>
<p>
<ul>
<li>Посидеть  на  собственных  ладошках,  прежде  чем  нажать
<F>return</F> для выполнения команды, которая может быть причиной
катастрофы.   Например,   если   вы   собираетесь   очистить
каталог,  перед нажатием <F>return</F> перечитайте всю команду
и убедитесь, что она написана правильно.
</li>
<li>Не  привыкайте использовать <code>root</code>. Чем более комфортно вам
будет  в  роли  root,  тем  больше  вы  будете  путать  ваши
привилегии    с   привилегиями   нормального   пользователя.
Например,  вы  можете  подумать,  что вы сейчас находитесь в
системе  как  <code>larry</code>,  хотя  на самом деле будете неудержимым
root.
</li>
<li>Используйте  отличающуюся  подсказку  для  <code>root</code>.  Для этого
следует  внести  изменения  в root-овский <code>.bashrc</code> или <code>.login</code>
файл  для  того,  чтобы сделать подсказку для root отличной от
других. Например, многие используют символ ``<code>$</code>'' в подсказках
обычных  пользователей и оставляют символ ``<code>#</code>'' для подсказки
root.
</li>
<li>Входите под именем <code>root</code> только тогда, когда это абсолютно
необходимо.  И,  как  только  вы  закончите  работу  root-а,
выйдите (выведите root-а из системы). Чем меньше используете
root, тем меньше навредите системе.</li>
</ul>
</p>
<p></p>
<p>Разумеется,  есть  племя  хакеров,  которые  используют  <code>root</code>
практически всегда и везде. Но каждый из них когда-то по глупости
уничтожил  хотя  бы  (в  лучшем  случае) одну систему. Есть общее
правило: пока вы не познакомились с неограниченными возможностями
<code>root</code>,  и не привыкли к отсутствию ограничений, входите под root в
крайнем случае.</p>
<p></p>
<p>Разумеется, все совершают ошибки. Однажды сам Linus Torvalds
(создатель linux)  случайно  удалил  все поддерево каталогов,
содержавшее  программы  ядра.  Многие  часы работы пропали (бы) в
один  миг  навсегда.  К  счастью, однако, благодаря своему знанию
кодов   файловой   системы,   он  смог  перезагрузить  систему  и
реконструировать дерево каталогов вручную.</p>
<p></p>
<p>Давайте  по-другому,  если вы представите использование <code>root</code>
как   ношение  специальной  волшебной  шапки,  которая  дает  вам
могущество,  так  что  вы  можете мановением руки разрушить целые
города,  то  уместная  мысль,  что  надо  очень следить за своими
руками.  А  поскольку  такая  мощь  опасна (да и рукам неудобно),
лучше  без большой нужды не надевать волшебную шапку, даже если в
шапке у вас повышается самоуважение.</p>
<p></p>

<h2>4.1.2 <A Name="ss4.1.2"> Злоупотребление системой </h2>

<p>С  приходом  ощущения  власти  приходит желание вредить. Это
темная  сторона  администрирования  в  UNIX,  но всякий через это
когда-то должен пройти. Большинство пользователей UNIX никогда не
получат   возможность   испытать   это   на   университетских   и
производственных   системах  UNIX.  Только  высокооплачиваемые  и
высокообразованные   системные   администраторы  могут  входит  в
систему   под   именем   <code>root</code>.  Действительно,  во  многих  таких
заведениях  пароль  root  -  это  строго  охраняемый  секрет. Это
священная  корова  фирмы.  Много  делается  попыток  пролезть под
именем   root   в   систему;   она  представляется  мудрой  и
устрашающей силой, покоряющейся только тем, кто знает заклинания.</p>
<p></p>
<p>Такая  позиция  по  отношению  к <code>root</code> очень легко приводит к
опасностям  и  соблазнам.  Поскольку  <code>root</code>  столь одурманивающая
штука,  то когда  пользователь  дорывается  до возможности войти под
root,  прослеживается  начало использования свалившихся
привилегий  в  плане  вредительства.  Я  знавал  таких "системных
администраторов",  которые  читали  без  разрешения  почту других
пользователей  и  вообще  вели  себя как дети, которым дали столь
мощную клевую "игрушку".</p>
<p></p>
<p>Поскольку  <code>root</code>  имеет в системе такие привилегии, требуется
определенный  уровень зрелости и самоконтроля, чтобы использовать
этот  account  (этот  привилегированный  "счет"),  как  это  было
задумано  -  для  эксплуатации системы. Существует негласный закон
чести в отношениях администратора с пользователями. Как вы будете
себя чувствовать, если системный администратор читает ваши письма
и  просматривает  ваши файлы? До сих пор нет достаточно серьезной
юридической  основы  для  неприкосновенности  личной информации в
многопользовательских компьютерных системах. В системах семейства
UNIX пользователь root имеет возможность преодолевать все штатные
механизмы  защиты  системы.  Важно,  чтобы  у администратора были
доверительные  отношения  с  пользователями  системы. Невозможно
переоценить важность этого.</p>
<p></p>

<h2>4.1.3 <A Name="ss4.1.3"> Взаимодействие с пользователями </h2>

<p>Безопасность  UNIX  довольно  рыхлая  от  рождения.  Вопросы
безопасности   были   додуманы  "в  догонку"  -  исходно  система
создавалась  в  неформальной  атмосфере,  когда все вмешивались в
работу  друг  друга.  Благодаря  этому,  даже  несмотря  на  меры
безопасности,  у  нормального пользователя существуют возможности
причинить системе вред.</p>
<p></p>
<p>Системный    администратор   может   выбрать   две   тактики
взаимодействия   с   злоупотребляющими
<sl>(прим.   переводчика:  в
исходном, а не в узко русском смысле этого слова)</sl>

пользователями.
Это  может  быть параноидная тактика и тактика доверия. Системный
администратор с паранойей обычно своими действиями наносит больше
вреда,   чем  предотвращает.  Одна  из  моих  любимых  присказок:
"Никогда  не  списывай  на  зловредность то, что можно списать на
тупость".  Взгляните  с другой стороны, большинство пользователей
не  имеют  возможностей  и  знаний, чтобы причинить реальный вред
системе.  90%  процентов  того, что делает пользователь, причиняя
вред   системе   (например,   забивая  пользовательский раздел
огромными   файлами  или  выполняя  сразу  несколько  экземпляров
громадной  программы),  он  делает  просто  не подозревая, что он
кому-то   создает   проблемы.   Мне  приходилось  сталкиваться  с
пользователями,  которые были источниками огромных неприятностей,
но они они действовали по простоте душевной, а не со зла.</p>
<p></p>
<p>Когда  вы  имеете  дело  с  пользователями,  которые  опасны
потенциально,  не  накидывайтесь  на  них  с  обвинениями. Старое
правило  "презумпции  невиновности"  все  еще  не отменили. Лучше
всего  поговорить  с пользователем, поспрашивать о его проблемах,
вместо  того,  чтобы  идти  на  конфронтацию.  Самое  плохое, это
пытаться  отвечать  ему  "встречными" неприятностями. Это создаст
вокруг  вас  -  системного  администратора  -  много  подозрений,
поставит  под  сомнение  вашу  способность корректно сопровождать
систему.  Если  пользователь решит, что вы не верите ему или даже
не любите, он может обвинить вас в том, что вы удаляете его файлы
и  вообще  подсматриваете.  Вряд  ли  вы хотите оказаться в такой
ситуации.</p>
<p></p>
<p>Если  вы  убедились, что пользователь действительно пытается
``взломать''  систему  или  умышленно  ей  вредит,  старайтесь не
отвечать  угрозами  на  угрозы.  Вместо этого просто предупредите
его, но сохраняйте гибкость. Во многих случаях вы можете"схватить
его  за  руку"  в  процессе  свершения  вредительства - вот тут и
предупредите.  Скажите,  чтобы он так больше не делал. Но если вы
снова  его  поймаете  на  вредительстве,  то  убедитесь,  что это
действительно  намеренно.  Я  просто  не  смогу  перечислить  все
случаи,  когда оказывалось, что неприятность была либо случайной,
либо я сам был виноват.</p>
<p></p>

<h2>4.1.4 <A Name="ss4.1.4"> Установление правил </h2>

<p>Лучший  способ  управления  системой  -  это  управление без
применения  железного  кулака.  Может  так  вы хорошо управляли в
армии,  но это не для UNIX. Имеет смысл сделать
простой и гибкий свод руководств для пользователей, но чем меньше
у  вас  будет  правил,  тем меньше шансов их нарушить. Даже если
ваши   правила   использования  системы  очень  ясны  и  разумны,
пользователи все равно время от времени будут их без злого умысла
нарушать.  Это, в особенности, относится к новичкам в UNIX, которые
еще  только  изучают основы системы. Да и вы сами можете время от
времени рассылать гигабайтные файлы всем пользователям системы...
Пользователям  надо  помочь понять правила и об'яснить, зачем они
нужны.</p>
<p></p>
<p>Если  вы  создали  руководство  для  пользователей  системы,
убедитесь,  что  причины введения тех или иных правил им понятны.
Если  вы  этого  не  сделаете,  пользователи творчески подойдут к
тому, как обходить эти правила. может быть и не сознавая, что они
их действительно обходят.</p>
<p></p>

<h2>4.1.5 <A Name="ss4.1.5"> Что все это значит </h2>

<p>Мы   не   можем  до  последней  детали  расписать  вам,  как
эксплуатировать систему. Большая часть философии зависит от того,
как  вы  используете  систему. Если у вас много пользователей, то
это сильно отличается от того, когда их  мало, или вообще вы
один.  Но  при  любом  раскладе  очень  полезно задуматься, что в
данной  конкретной системе дествительно означают слова "системный
администратор" (или "администратор системы").</p>
<p></p>
<p>Должность   администратора  системы  не  делает  вас  крутым
юниксистом.  На  свете  много  системных администраторов, которые
мало  что знают о UNIX. Похоже, что существует много "нормальных"
пользователей,  которые,    знают  о  UNIX  больше  любого
системного  администратора. Пребывание в должности администратора
не  дает  вам  права  использовать  угрозы в адрес пользователей.
Именно потому, что система дает вам привилегию устроить из файлов
пользователя  все,  что  угодно,  вы не имеете никакого права это
делать.</p>
<p></p>
<p>Наконец,  быть  системным  администратором, это невесть что.
При  этом  не  имеет  значения,  опекаете  вы маленький 386-ой или
суперкомпьютер Cray. Знание заветного пароля root не принесет вам
денег и славы; оно поможет сопровождать систему и поддерживать ее
работоспособность. Вот так.</p>
<p></p>
<p></p>


<h2>4.2 <A Name="ss4.2"> Загрузка системы </h2>

<p>Существует  несколько  способов  загрузки  системы:  либо  с
дискеты, либо с жесткого диска.</p>
<p></p>
<h2>4.2.1 <A Name="ss4.2.1"> Использование загрузочной дискеты </h2>

<p>Многие   загружают   Linux   используя  ``загрузочную
дискету'',  которая  содержит  копию  ядра  Linux.  В  ядре  есть
информация  о  корневом  разделе  Linux, так что ядро знает, где
искать  на жестком диске корневую файловую систему. (Команда rdev
может  использоваться  для  установки  корневого раздела в образе
ядра;  см. ниже). Это тип дискеты, созданной, например, Slackware
в процессе инсталляции.</p>
<p></p>
<p>Для  создания своей собственной загрузочной дискеты, сначала
разместите  образ  ядра на своем жестком диске. Оно должно быть в
файле <code>/Image</code> или <code>/etc/Image</code>. Некоторые инсталляции используют для
формирования ядра файл <code>/vmlinux</code>.</p>
<p></p>
<p>Вместо  этого  у  вас  может  быть  скомпрессированное ядро.
Скомпрессированное  ядро  само  раскомпрессируется при загрузке в
память  и  занимает значительно меньше места на диске. Если у вас
есть  скомпрессированное  ядро, оно находится в файле <code>/zImage</code> или
<code>/etc/zImage</code>.</p>
<p></p>
<p>Зная,   где   у  вас  находится  ядро,  установите  корневое
устройство  в образе ядра на имя вашего корневого раздела командой
<code>rdev</code>. Формат команды:</p>
<p>
<blockquote><code>
<pre>
    rdev &lt;kernel-name&gt; &lt;root-device&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p>где <code>&lt;kernel-name&gt;</code>; это имя образа ядра, a
<code>&lt;root-device&gt;</code> - имя
корневого   раздела  Linux.  Например,  для  установки  корневого
устройства в ядре <code>/etc/Image</code> на <code>/dev/hda2</code> используется команда</p>
<p>
<blockquote><code>
<pre>
    # rdev /etc/Image /dev/hda2
</pre>
</code></blockquote>
</p>
<p></p>
<p>rdev  может  устанавливать  другие  опции  в ядре, такие как
взятый  по  умолчанию  режим  SVGA,  для  использования  во время
загрузки. Используйте ``<code>rdev -h</code>'' для получения помощи.</p>
<p></p>
<p>После   установки  корневого  устройства  вы  можете  просто
скопировать  образ  ядра  на  дискету.  При копировании данных на
дискету,  хорошо бы сначала отформатировать  дискету в MS-DOS.
При  форматировании  выдается  информация  о  секторах  и  треках
дискеты,  так  что  можно определить какую плотность записи имеет
эта дискета.</p>
<p></p>
<p>Например, для копирование файла ядра <code>/etc/Image</code> на дискету в
<code>/etc/fd0</code> используйте команду</p>
<p>
<blockquote><code>
<pre>
    # cp /etc/Image /dev/fd0
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь эта дискета должна загружать Linux.</p>
<p></p>

<h2>4.2.2 <A Name="ss4.2.2"> Использование LILO </h2>

<p>Другой  метод  загрузки -  это использование LILO, программы,
которая  располагается  в  загрузочном  секторе  вашего  жесткого
диска.  Эта  программа  выполняется,  когда система загружается с
жесткого  диска  и  может автоматически загрузить Linux из образа
ядра, хранящегося на жестком диске.</p>
<p></p>
<p>LILO  может быть также использована, как начальный загрузчик
для  нескольких  операционных  систем,  позволяя  вам выбирать во
время  загрузки,  какую операционную систему (например, Linux или
MS-DOS)  загружать.  Когда вы загружаетесь с использованием LILO,
то загружается операционная система, установленная по умолчанию,
если  вы не нажмете <F>ctrl</F>, <F>alt</F> или <F>shift</F> во время выполнения
загрузочной  последовательности.  Если  вы  нажмете любой из этих
ключей, то вам будет выдана подсказка загрузчика, в ответ на которую
вы  напечатаете  имя операционной системы, которую надо загрузить
(например,  ``<code>linux</code>''  или  ``<code>msdos</code>'').  Если  вы нажмете <F>tab</F> в
ответ  на  подсказку загрузчика, вам будет выдан перечень доступных
операционных систем.</p>
<p></p>
<p>Простой  способ  инсталлировать  LILO - отредактировать файл
конфигурации <code>/etc/lilo.conf</code> и выполнить команду</p>
<p>
<blockquote><code>
<pre>
    # /sbin/lilo
</pre>
</code></blockquote>
</p>
<p></p>
<p>Файл  конфигурации  LILO  содержит  ``stanza''("стансы" - не
пугайтесь, это действительно про поэзию). для каждой операционной
системы,    которую   вы   желаете   загрузить.   Лучший   способ
продемонстрировать  это  на  примере конфигурационного файла LILO
config.  Нижеприведенные  установки  для  системы,  которая имеет
корневой  раздел  Linux  на  <code>/dev/hda1</code>  и  раздел  MS-DOS  на
<code>/dev/hda2</code>.</p>
<p>
<blockquote><code>
<pre>
    # Tell LILO to modify the boot record on /dev/hda (the first
    # non-SCSI hard drive). If you boot from a drive other than /dev/hda,
    # change the following line.
    boot = /dev/hda

    #  Name  of  the  boot  loader.  No  reason  to  modify  this
    #  un less you're doing some serious hacking on LILO.
    install = /boot/boot.b

    # Have LILO perform some optimization.
    compact

    # Stanza for Linux root partition on /dev/hda1.
    image = /etc/Image   # Location of kernel
       label = linux     # Name of OS (for the LILO boot menu)
       root = /dev/hda1  # Location of root partition
       vga   =   ask     # Tell kernel to ask for SVGA modes at boot time

    # Stanza for MSDOS partition on /dev/hda2.
    other = /dev/hda2    # Location of partition
       table = /dev/hda  # Location of partition table for /dev/hda2
       label = msdos     # Name of OS (for boot menu)
</pre>
</code></blockquote>
</p>
<p></p>
<p>Стансы  первой  операционной системы в файле <code>config</code> - это та
ОС, которую LILO загружает по умолчанию. Вы можете выбрать другую
ОС  во  время  загрузки  в  ответ  на  подсказку  LILO, как это уже
обсуждалось ранее.</p>
<p></p>
<p>Помните,  что  каждый  раз, когда вы изменяете образ ядра на
диске,  вы  должны  заново  выполнить <code>/sbin/lilo</code>, чтобы изменения
отразились в загрузочном секторе вашего диска.</p>
<p></p>
<p>Имейте  также  в  виду, что если вы используете здесь строку
``<code>root  =</code>'',  нет смысла использовать rdev для установки корневого
раздела в образе ядра. LILO установит ее во время загрузки.</p>
<p></p>
<p><em>Linux   FAQ</em>   (смотри   Приложение  A)  дает  дополнительную
информацию  по  тому,  как  использовать  LILO  при загрузке Boot
Manager   OS/2.
<sl>(прим.  переводчика:  <em>The  Linux  FAQ</em>  -  Часто
Задаваемые Вопросы по Linux.</sl>

</p>


<h2>4.3 <A Name="ss4.3"> Выключение системы </h2>

<p>Выключение  Linux  -  это немножко акробатика. Не забывайте,
что  никогда  нельзя  просто  выключить питание или нажать кнопку
"reset"  во время работы системы. Ядро отслеживает диск при вводе-
выводе  с  помощью буферов. Если вы перезагружаете систему, не дав
шанса  ядру  переписать  буфера  на  диск,  вы  можете  попортить
файловые системы.</p>
<p></p>
<p>Необходимы  и  другие  меры предосторожности при выключении.
Всем  процессам  посылается  сигнал, который позволяет им красиво
умереть  (записав,  что надо и закрыв все файлы и т.д.). Файловые
системы для безопасности размонтируются. Если вы желаете, система
может также предупредить пользователей, что предстоит выключение,
чтобы дать им шанс тоже (красиво) выйти из системы.</p>
<p></p>
<p>Простейший  способ  выключения,  это  использование  команды
<code>shutdown</code>. Формат команды</p>
<p>
<blockquote><code>
<pre>
    shutdown &lt;time&gt; &lt;warning-message&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p><code>&lt;time&gt;</code> -  время  выключения  системы  (в формате hh:mm:ss -
чч:мм:сс)   и  <code>&lt;warning-message&gt;</code> -  сообщение,  выдаваемое  на
терминалы  всех пользователей перед выключением. Вы можете просто
указать    время   (<code>&lt;time&gt;</code>)   как   ``<code>now</code>'',   что   приведет   к
безотлагательному  выключению.  Опция <code>-r</code> приведет к перезагрузке
после выключения.</p>
<p></p>
<p>Например, выключить систему в 8:00 вечера можно командой</p>
<p>
<blockquote><code>
<pre>
       # shutdown -r 20:00
</pre>
</code></blockquote>
</p>
<p></p>
<p>Команда  <code>halt</code> может инициировать немедленное выключение без
посылки  предупреждающих сообщений или предоставления паузы перед
выключением.  <code>halt</code> полезна,  если  вы  единственный пользователь
системы и хотите выключить систему и вырубить питание.</p>
<p></p>
<p><b>ВНИМАНИЕ!</b> На  выключайте электропитание и не перезагружайте
ее, пока не увидите на консоли сообщение:</p>
<p>
<blockquote><code>
<pre>
       The system is halted
</pre>
</code></blockquote>
</p>
<p></p>
<p>Важно cделать выключение "чисто", используя команды <code>shutdown</code>
или  <code>halt</code>.  В  некоторых  системах  нажатие  <F>ctrl-alt-del</F> будет
перехвачено  системой  и  приведет  к  ее выключению, но в других
системах   использование   "затычки   для   вулкана"  приведет  к
немедленной   перезагрузке   системы   и   может   быть  причиной
неприятностей.</p>
<p></p>

<h2>4.4 <A Name="ss4.4"> Работа с пользователями </h2>

<p>Вне  зависимости от того, много у вас пользователей или нет,
важно  понять проблему работы с пользователем Linux. Даже если вы
единственный  пользователь  вы должны иметь различные account для
<code>root</code>  и для себя. Каждый человек, использующий систему, должен иметь свой
собственный  account  (быть  индивидуально  зарегистрированным  в
системе). Редко может быть целесообразно, чтобы несколько человек
входили  в  систему  под  одним  именем.  Здесь  дело не только в
безопасности,   но   account   используется   для   идентификации
пользователя  в системе. Необходимо иметь возможность проследить,
кто что делает.</p>
<p></p>
<h2>4.4.1 <A Name="ss4.4.1"> Концепция работы с пользователями </h2>

<p>Система сохраняет различную информацию о каждом пользователе
К такого рода информации относится перечисленная ниже.</p>
<p>
<dl>
<dt><b>username</b><dd><p>уникальный  идентификатор,  присваиваемый  каждому
пользователю  в  системе.  Примеры имен пользователей <code>larry</code>,
<code>karl</code>  и  <code>mdw</code>.  Могут  использоваться  буквы и цифры, а также
нижнее  подчеркивание  и  точка.  Обычно имена пользователей
ограничиваются восемью символами.</p>
<p></p>
<dt><b>user</b><dd><p>ID (или UID) - идентификатор пользователя - уникальный
номер,  присваиваемый  каждому пользователю системы. Система
обычно отслеживает инентификаторы пользователей, а не имена.</p>
<p></p>
<p></p>
<dt><b>group</b><dd><p>ID (или GID) - идентификатор группы это идентификатор
группы  пользователя.  В  Разделе  3.9  мы  обсуждали  права
группы;  каждый  пользователь  принадлежит к одной или более
группам,  определенных  системным администратором. Подробнее
об этом ниже.</p>
<p></p>
<dt><b>password</b><dd><p>Система  также  хранит в зашифрованном виде пароль
пользователя.  Команда  passwd  используется для установки и
изменения пароля.</p>
<p></p>
<dt><b>full name</b><dd><p>"<b>Полное  имя</b>"  или "<b>действительное имя</b>" хранится
вместе  с именем пользователя. Например, пользователь schmoj
может   иметь   действительное   имя  ``Joe  Schmo''
<sl>(прим.
переводчика:  неужели  для  английского уха оно звучит также
красиво, как для русского).</sl>

</p>
<p></p>
<dt><b>home directory</b><dd><p>Домашний  каталог  -  это  каталог, в
который  пользователь начально попадает при входе в систему.
Каждый  пользователь  должен иметь свой собственный домашний
каталог, обычно ниже <code>/home</code>.</p>
<p></p>
<dt><b>login shell</b><dd><p>Исходный shell - это shell, который запускается
для  пользователя  при  его  входе в систему. Это, например,
может быть <code>/bin/bash</code> и <code>/bin/tcsh</code>.</p>
</dl>
</p>
<p></p>
<p>Файл  <code>/etc/passwd</code> содержит эту информацию про пользователей.
Каждая   строка   этого   файла   содержит  информацию  об  одном
пользователе; формат строки имеет вид:</p>
<p>
<blockquote><code>
<pre>
username:encrypted_password:UID:GID:full_name:home_directory:login_shell
</pre>
</code></blockquote>
</p>
<p></p>
<p>Например, это может выглядеть так:</p>
<p>
<blockquote><code>
<pre>
    kiwi:Xv8Q981g71oKK:102:100:Laura Poole:/home/kiwi:/bin/bash
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как   видно,   первое  поле  ``<code>kiwi</code>''  -  имя  пользователя.
Следующее поле ``<code>Xv8Q981g71oKK</code>'' - зашифрованный пароль. Пароли в
читаемом  виде  в системе не хранятся. Сами пароли шифруются как
секретные  ключи.  Другими словами, вы должны знать пароль, чтобы
его расшифровать. Эта форма шифрации достаточно надежна.</p>
<p></p>
<p></p>
<p>Некоторые системы Linux
используют "теневой пароль", в котором информация о
паролях хранится в файле <code>/etc/shadow</code>. Поскольку <code>/etc/passwd</code>
всем доступен, <code>/etc/shadow</code> обеспечивает дополнительный  уровень
секретности  своей  недоступностью. Теневой пароль обеспечивает и
некоторые  другие  свойства,  вроде прекращения действия пароля и
т.д.; мы здесь не будем вдаваться в эти тонкости.</p>
<p></p>
<p>Третье  поле,  ``<code>102</code>'',  - идентификатор пользователя (UID).
Оно  должно  быть  уникальным для каждого пользователя. Четвертое
поле,  ``<code>100</code>'',  идентификатор  группы  (GID).  Этот пользователь
принадлежит  к  группе номер 100. Информация по группе хранится в
файле  <code>/etc/group</code>.  Смотрите  дополнительную информацию в Разделе
4.4.5.</p>
<p></p>
<p>Пятое  поле  -  полное  имя  пользователя , ``Laura Poole''.
Последние   два   поля   -   домашний   каталог   пользователя
(<code>/home/kiwi</code>) и исходный shell (<code>/bin/bash</code>) соответственно.
Домашний
каталог   пользователя   не   обязательно  должен  иметь  имя,
совпадающее с именем пользователя (username). Однако это помогает
в идентификации.</p>
<p></p>

<h2>4.4.2 <A Name="ss4.4.2"> Добавление пользователей </h2>

<p>При  добавлении  пользователя  следует  совершить  несколько
шагов.  Первое,  пользователь  должен быть занесен в файл паролей
<code>/etc/passwd</code>  под уникальным именем и идентификатором. Должны быть
описаны   идентификатор   группы   (GID),  полное  имя  и  другая
информация.</p>
<p></p>
<p>Должен   быть  создан  домашний  каталог  пользователя  и
установлены необходимые права доступа. Домашний каталог должен
быть  снабжен  необходимыми  файлами  инициализации shell. Должны
быть выполнены и другие работы по конфигурации ( например, создан
spool для входной почты).</p>
<p></p>
<p>Хотя  очень  несложно добавлять пользователей вручную (я так
делаю), когда вы сопровождаете систему со многими пользователями,
легко   что-то   упустить.   Самый   простой  способ  регистрации
пользователей - это  использование диалоговой программы, которая
задаст  вам  все необходимые вопросы и автоматически скорректирует
все необходимые системные файлы. Эта программа называется <code>useradd</code>
или  <code>adduser</code>,  в  зависимости  от  вашего  дистрибутива. Страницы
руководства для этих программ должны быть достаточно понятными.</p>
<p></p>

<h2>4.4.3 <A Name="ss4.4.3"> Удаление пользователей </h2>

<p>Аналогично,  удаление  пользователей  может быть выполнено с
помощью  команд <code>userdel</code> или <code>deluser</code> в зависимости от конкретного
дистрибутива.</p>
<p></p>
<p>Если   вы  пожелаете  временно  "отключть"  пользователя  от
системы,  (без удаления его account ), вы можете просто приписать
звездочку  (``<code>*</code>'')  в  поле пароля в файле пароля
<code>/etc/passwd</code>.
Например, изменить у <code>kiwi</code> в файле <code>/etc/passwd</code></p>
<p>
<blockquote><code>
<pre>
    kiwi:*Xv8Q981g71oKK:102:100:Laura Poole:/home/kiwi:/bin/bash
</pre>
</code></blockquote>
</p>
<p></p>
<p>это закроет для  <code>kiwi</code> вход в систему.</p>
<p></p>

<h2>4.4.4 <A Name="ss4.4.4"> Занесение атрибутов пользователя </h2>

<p>После создания пользователя вам может потребоваться изменить
его  атрибуты, такие как домашний каталог и пароль. Простейший
способ  -  это  прямо  изменить  значения  в  <code>/etc/passwd</code>.  Чтобы
установить   пароль   пользователя  используйте  команду  passwd.</p>
<p></p>
<p>Например,</p>
<p>
<blockquote><code>
<pre>
    # passwd larry
</pre>
</code></blockquote>
</p>
<p></p>
<p>     изменить пароль larry.</p>
<p></p>
<p>Только  <code>root</code>  может  изменять  пароли  других пользователей.
Пользователи  также  могут  изменять  пароли  с  помощью  команды
passwd, но только свои собственные.</p>
<p></p>
<p>В   некоторых   системах   имеются   команды  <code>chfn</code>  и  <code>chsh</code>,
позволяющие  пользователю  самому устанавливать свое полное имя и
исходные  атрибуты shell. Если нет, то пользователи должны просить
системного администратора изменить эти атрибуты для них.</p>
<p></p>

<h2>4.4.5 <A Name="ss4.4.5"> Группы </h2>

<p>Как мы говорили, каждый пользователь принадлежит к одной или
более  группам.  Единственное значение группы замыкается на права
доступа к файлу, как вы помните из Раздела 3.9. Каждый файл имеет
"групповое владение" (``group ownership''), то есть хранит права
доступа,  которые определяют, как члены группы могут обращаться с
файлом.</p>
<p></p>
<p>Существует  несколько  групп,  определяемых  системой, вроде
<code>bin</code>,  <code>mail</code> и <code>sys</code>.
Пользователи не могут принадлежать к какой-либо
из  этих  групп.  Эти группы используются для системных файлов. А
пользователи, наоборот, принадлежат к специальной группе, например
users.  Если  вам  хочется больше проблем, вы можете поддерживать
несколько групп пользователей, например
<code>student</code>, <code>staff</code> и <code>faculty</code>.</p>
<p></p>
<p>Файл <code>/etc/group</code> содержит информацию о группах. Формат каждой
строки следующий</p>
<p>
<blockquote><code>
<pre>
    group name:password:GID:other members
</pre>
</code></blockquote>
</p>
<p></p>
<p>Примерами групп могут быть:</p>
<p>
<blockquote><code>
<pre>
    root:*:0:
    users:*:100:mdw,larry
    guest:*:200:
    other:*:250:kiwi
</pre>
</code></blockquote>
</p>
<p></p>
<p>Первая    группа,   <code>root</code>,   специальная   системная   группа
зарезервированная  для root. Следующая группа, <code>users</code>, для обычных
пользователей.  Она  имеет идентификатор группы (GID) 100. К этой
группе  имеют  доступ  пользователи  <code>mdw</code>  и <code>larry</code>. Помните, что в
<code>/etc/passwd</code>  каждый пользователь получил (выдаваемый по умолчанию)
GID.  Но  пользователь  может  принадлежать  более,  чем  к одной
группе,  путем  добавления  имен пользователей в другие группы (в
строки  файла  <code>/etc/group</code>).  Команда <code>groups</code>
перечисляет, в какие
группы вы входите.</p>
<p></p>
<p>Третья  группа,  guest,  для  гостей,  а  other для "других"
пользователей. Пользователь <code>kiwi</code> имеет доступ и в эту группу.</p>
<p></p>
<p>Как  вы  можете  видеть,  поле "пароль" в <code>/etc/group</code> редко
используется.  Иногда оно используется для установления пароля на
доступ   к   группе.   Это   редко   бывает   нужно.  Для  защиты
привилегированных  групп  от  обычных  пользователей  (с  помощью
команды <code>newgroup</code>) установите в поле пароля звездочку ("<code>*</code>").</p>
<p></p>
<p>Команды  <code>addgroup</code>  или  <code>groupadd</code> могут быть использованы для
добавления  групп  в  вашу  систему.  Обычно  легче просто самому
добавить  запись  в  <code>/etc/group</code>,  поскольку  не  требуется других
настроек  при  добавлении  группы.  Для  удаления  группы  просто
удалите соответствующую запись в <code>/etc/group</code>.</p>
<p></p>


<h2>4.5 <A Name="ss4.5"> Архивация и компрессирование файлов </h2>

<p>Прежде,  чем  мы сможем говорить о сохранении (резервировании)
программ,  мы  должны  представить  инструменты, используемые для
архивации файлов и программ в системах UNIX.</p>
<p></p>
<h2>4.5.1 <A Name="ss4.5.1"> Использование tar </h2>

<p>Команда   <code>tar</code>  наиболее  часто  используется  для  архивации
файлов. Формат команды <code>tar</code></p>
<p>
<blockquote><code>
<pre>
    tar &lt;options&gt; &lt;file1&gt; ... &lt;fileN&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p>где  <code>&lt;options&gt;</code> есть список команд и опций для <code>tar</code>,
a <code>&lt;file1&gt; ... &lt;fileN&gt;</code> есть список файлов добавляемых
в  архив  или извлекаемых из него.</p>
<p></p>
<p>Например, команда</p>
<p>
<blockquote><code>
<pre>
    # tar cvf backup.tar /etc
</pre>
</code></blockquote>
</p>
<p></p>
<p>упакует  все  файлы,  содержащиеся  в  <code>/etc</code>,
в архив <code>tar</code> под
именем  <code>backup.tar</code>.  Первый  аргумент  команды  <code>tar  -``cvf'</code>, это
(внутренняя)  "команда"  <code>tar</code>. ``<code>c</code>'' указывает <code>tar</code>
создать новый
архивный  файл.  Опция  ``<code>v</code>'' заставляет tar выводить имя каждого
архивируемого  файла. Опция ``<code>f</code>'' говорит, что следующий аргумент
-   <code>backup.tar</code>   -  имя  созданного  архивного  файла.  Остальные
аргументы  команды  <code>tar</code>  -  имя  файла и имя добавляемого в архив
каталога.</p>
<p></p>
<p>Команда</p>
<p>
<blockquote><code>
<pre>
    # tar xvf backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>извлечет  архивный файл в текущий каталог. Это может быть
иногда и небезопасным занятием, когда извлеченные из архива файлы
затирают существовавшие файлы.</p>
<p></p>
<p>Поэтому перед извлечением архивированных файлов важно знать,
где   файлы  следует  распаковать.  Например,  вы  заархивировали
следующие  файлы:  <code>/etc/hosts</code>,  <code>/etc/group</code>
и <code>/etc/passwd</code>. Если вы
используете команду</p>
<p>
<blockquote><code>
<pre>
    # tar cvf backup.tar /etc/hosts /etc/group /etc/passwd
</pre>
</code></blockquote>
</p>
<p>в  начало  имени каждого файла добавится каталог с именем
<code>/etc</code>.  Чтобы  извлечь  файлы  в  нужное  место,  вам  потребуется
использовать следующие команды:</p>
<p>
<blockquote><code>
<pre>
    # cd /
    # tar xvf backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>поскольку файлы извлечены с сохраненной в архиве тропой</p>
<p></p>
<p>Если вы заархивировали файлы командой</p>
<p>
<blockquote><code>
<pre>
    # cd /etc
    # tar cvf hosts group passwd
</pre>
</code></blockquote>

имя  каталога  не сохраняется в архивном файле. Поэтому вы
должны   выполнить  ``<code>cd  /etc</code>''  перед  извлечением  файлов.  Вы
обратили внимание: то, как вы создали архивный файл сильно влияет
на то, в каком месте его следует извлекать. Команда</p>
<p>
<blockquote><code>
<pre>
    # tar tvf backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>может  быть  использована  для просмотра "индекса" архивного
файла  перед его распаковкой. Таким образом вы можете посмотреть,
к  какому  каталогу  относятся  архивированные  файлы и сможете
извлечь файлы из архива в нужном месте.</p>
<p></p>

<h2>4.5.2 <A Name="ss4.5.2"> gzip и compress </h2>

<p>В  отличие  от  архивирующих  программ  для  MS-DOS, <code>tar</code> не
компрессирует   автоматически  файлы  в  процессе  архивирования.
Поэтому,   если   вы   архивируете  два  одно-мегабайтных  файла,
результирующий   архивный  файл  будет  размером  два  мегабайта.
Команда  <code>gzip</code>  может  использоваться  для  компрессирования файла
(компрессируемый файл не обязан быть <code>tar</code>-файлом)</p>
<p>Команда</p>
<p>
<blockquote><code>
<pre>
    # gzip -9 backup.tar
</pre>
</code></blockquote>
</p>
<p>скомпрессирует <code>backup.tar</code> и оставит вас наедине  с
<code>backup.tar.gz</code>, скомпрессированной версией файла. Опция <code>-9</code> говорит
команде  <code>gzip</code>,  что  следует  использовать максимальную возможную
компрессию.</p>
<p></p>
<p>Команда  <code>gunzip</code> может     быть    использована    для
раскомпрессирования "зазипованного" файла. С аналогичным эффектом
вы можете использовать ``<code>gzip -d</code>''.</p>
<p><code>gzip</code> - сравнительно новый инструмент в кругах, приближенных
к  UNIX. Долгие годы вместо этого использовалась команда <code>compress</code>.
Однако,   по   нескольким   причинам   (тут   и  патентные  дрязги
относительно  алгоритма,  и то, что <code>gzip</code> значительно эффективнее)
<code>compress</code> оказался не у дел.</p>
<p></p>
<p>Обработанные    командой  <code>compress</code>   файлы   заканчивались
расширением  <code>.Z</code>.  Например, <code>backup.tar.Z</code> - это компрессированная
версия  файла <code>backup.tar</code>, а <code>backup.tar.gz</code> - зазипованная версия.
<sl>(Чтобы  еще  надежнее запутать дело, для обозначения зазипованных
файлов  некоторое  время  использовалось расширение <code>.z</code> (маленькая
``<code>z</code>'').
В   настоящее   время   (прим.   переводчика:  это  для
современников автора) официальное расширение - .gz.</sl>

</p>
<p></p>
<p>Команда  <code>uncompress</code>  используется  для  развертывания файла,
который  был  обработан командой <code>compress</code>. Но команда <code>gunzip</code> тоже
знает, как обращаться с такими файлами.</p>
<p></p>

<h2>4.5.3 <A Name="ss4.5.3"> Можно вместе </h2>

<p>Чтобы  заархивировать  и  скомпрессировать группу файлов, вы
можете использовать команды:</p>
<p>
<blockquote><code>
<pre>
    # tar cvf backup.tar /etc
    # gzip -9 backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>Результат  будет  <code>backup.tar.gz</code>.  Для распаковки этого файла
используйте обратную последовательность команд:</p>
<p>
<blockquote><code>
<pre>
    # gunzip backup.tar.gz
    # tar xvf backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>Разумеется,  всегда  следует  убедиться  перед  распаковкой
файла, что вы в нужном каталоге.</p>
<p></p>
<p>Вы  можете  опереться  на  некоторую сообразительность UNIX,
позволяющего  сделать  это  одной  командой
<sl>(прим.  переводчика:
Верно,  но сказать - одной "командной строкой" - было бы честнее,
да и проще описывать работу этой конструкции).</sl>

</p>
<p>
<blockquote><code>
<pre>
    # tar cvf - /etc | gzip -9c &gt; backup.tar.gz
</pre>
</code></blockquote>
</p>
<p></p>
<p>Здесь  мы  посылаем <code>tar</code>-файл, сформированный из <code>/etc</code>,
в файл
``<code>-</code>'',  который  представляет  стандартный  выход.  Результат  по
конвейеру  поступает  на вход команды <code>gzip</code>, которая компрессирует
этот файл и результат сохраняет в <code>backup.tar.gz</code>. Опция <code>-c</code> команды
<code>gzip</code>  говорит,  что  выход  команды  <code>gzip</code>  посылает  результат на
стандартный выход, который перенаправляется на <code>backup.tar.gz</code>.</p>
<p></p>
<p>Единственная    <F>составная</F>    команда,   используемая   для
распаковки этого архива, будет:</p>
<p>
<blockquote><code>
<pre>
    # gunzip -c backup.tar.gz | tar xvf -
</pre>
</code></blockquote>
</p>
<p></p>
<p>Опять,  команда  <code>gunzip</code>  раскомпрессирует  содержимое  файла
<code>backup.tar.gz</code>  и  посылает  результирующий  файл  на  стандартный
выход.  Он  по конвейеру передается команде <code>tar</code>, которая
читает  файл  ``<code>-</code>'', что в данном случае олицетворяет стандартный
выход.</p>
<p></p>
<p>К счастью, команда   <code>tar</code>  также содержит опцию
<code>z</code>, автоматически компрессируя-раскомпрессируя файлы, используя
алгоритм компрессии  <code>gzip</code>.</p>
<p></p>
<p>Например, команда (прим. переводчика: одна)</p>
<p>
<blockquote><code>
<pre>
    # tar cvfz backup.tar.gz /etc
</pre>
</code></blockquote>
</p>
<p></p>
<p>эквивалентна</p>
<p>
<blockquote><code>
<pre>
    # tar cvf backup.tar /etc
    # gzip backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>Как и команда</p>
<p>
<blockquote><code>
<pre>
    # tar xvfz backup.tar.Z
</pre>
</code></blockquote>
</p>
<p></p>
<p>может быть использована вместо</p>
<p>
<blockquote><code>
<pre>
    # uncompress backup.tar.Z
    # tar xvf backup.tar
</pre>
</code></blockquote>
</p>
<p></p>
<p>За  дополнительной  информацией  обратитесь к Руководству по
<code>tar</code> и <code>gzip</code>.</p>
<p>4.6 Использование дискет и осуществление резервирования</p>
<p>Дискеты часто используются как средство резервирования. Если
у вас нет ленты (стриммера), можно использовать дискеты (хотя они
медленнее и, в некотором смысле, менее надежны).</p>
<p>Вы   можете   использовать   дискеты  также  для  хранения
отдельных файловых  систем  -
в этом случае вы должны <b>монтировать</b> (<b>mount</b>)
дискету для получеия доступа к ее данным.</p>
<p></p>

<h2>4.5.4 <A Name="ss4.5.4"> Использование дискет для резервирования </h2>

<p>Простейший    способ   резервирования   на   дискетах,   это
использование команды <code>tar</code>.</p>
<p>
<blockquote><code>
<pre>
    # tar cvfzM /dev/fd0 /
</pre>
</code></blockquote>
</p>
<p></p>
<p>сделает   полную   копию   вашей  системы  с  использованием
дисковода <code>/dev/fd0</code>. Опция ``<code>M</code>''
позволяет копировать на несколько
дискет   (multivolume   backup);  то  есть,  когда  одна  дискета
заполнится, tar запросит следующую.
Команда</p>
<p>
<blockquote><code>
<pre>
    # tar xvfzM /dev/fd0
</pre>
</code></blockquote>
</p>
<p></p>
<p>может  быть  использована  для  полного восстановления. Этот
метод может быть также использован для лент (<code>/dev/rmt0</code>).</p>
<p></p>
<p>Существует   несколько  других  программ  для  осуществления
многотомного  резервирования.  Вам  могут  пригодиться  программы
"<code>backflops</code>", которые можно взять на <code>tsx-11.mit.edu</code>.</p>
<p></p>
<p>Создание    полной   копии   системы   может   быть   весьма
время-ресурсо емким.   Большинство   системных  администраторов
использует  "инкрементальную"  стратегию  резервирования.  Каждый
месяц  производится  полное копирование, а каждую неделю - только
тех  файлов,  которые  были  модифицированы  в эту неделю. В этом
случае,  если  вы  грохнете  свою  систему  в середине месяца, вы
можете  просто  восстановить  состояние на начало месяца, а затем
восстановить понедельные изменения.</p>
<p></p>
<p>Команда  <code>find</code>  может  быть  полезна  в  выискивании  файлов,
которые  изменились  после  какой-то  даты.  Несколько  сценариев
(командных  файлов  на shell) для инкрементального резервирования
можно найти на <code>sunsite.unc.edu</code>.</p>
<p></p>

<h2>4.5.5 <A Name="ss4.5.5"> Использование дискет в качестве файловых систем </h2>

<p>Вы  можете  создать файловую систему на дискете точно также,
как в разделе жесткого диска. Например,</p>
<p>
<blockquote><code>
<pre>
    # mke2fs /dev/fd0 1440
</pre>
</code></blockquote>
</p>
<p></p>
<p>создает  файловую  систему  на  дискете  на /dev/fd0. Размер
файловой  системы  должен соответствовать размеру дискеты. Дискеты
high-density  3.5"  -  размером  в  1.44  Mбайт  или 1440 блоков.
Дискеты high-density 5.25" - размером в 1200 блоков.</p>
<p></p>
<p>Для   того,   чтобы   иметь  доступ  к  дискете,  вы  должны
примонтировать содержащуюся на ней файловую систему. Команда</p>
<p>
<blockquote><code>
<pre>
       # mount -t ext2 /dev/fd0 /mnt
</pre>
</code></blockquote>
</p>
<p></p>
<p>примонтирует  дискету,  находящуюся на <code>/dev/fd0</code> к каталогу
<code>/mnt</code>.  Теперь все файлы, находящиеся на дискете, будут находиться
в каталоге <code>/mnt</code> вашего жесткого диска.
<sl>(прим. переводчика: в
/mnt  непосредственно  будет  находиться  вершина дерева файловой
системы  дискеты,  все  остальное опосредовано - ниже по дереву).</sl>

``<code>-t  ext2</code>''указывает  тип  файловой  системы  (ext2fs).  Если вы
создали  другой  тип файловой системы на дискете, вам потребуется
описать его тип команде <code>mount</code>.</p>
<p></p>
<p>"Точка    монтирования"    (каталог,    к   которому   вы
примонтируете  файловую  систему)  должен  существовать, когда вы
применяете  команду  <code>mount</code>. Если он не существует, создайте его с
помощью команды <code>mkdir</code> - и все проблемы.</p>
<p></p>
<p>Дополнительную информацию по файловым системам, монтированию
и точкам монтирования смотрите в Разделе  4.8.</p>
<p></p>
<p><b>Важное замечание!</b> Ввод/вывод на дискету буферизируется точно
также,  как  и  для  жесткого  диска. Когда вы меняете (достаете)
дискету,  вы  не  должны  видеть горящую лампочку дисковода (пока
ядро  работает  с  буферами  ввода/вывода).  Важно,  чтобы  вы не
извлекали  дискету  из  дисковода  до ее размонтирования, которое
можно выполнить командой</p>
<p>
<blockquote><code>
<pre>
       # umount /dev/fd0
</pre>
</code></blockquote>
</p>
<p></p>
<p>Нельзя  просто  взять  и  вытащить  дискету,  как  в
MS-DOS. При замене дискет сначала размонтируйте одну, а
затем примонтируйте вторую.</p>
<p></p>


<h2>4.6 <A Name="ss4.6"> Модернизация и инсталляция программ </h2>

<p>Другая  обязанность системного администратора - модернизация
и инсталляция новых программ.</p>
<p></p>
<p>Сообщество  приверженцев Linux очень динамично. Новые версии
ядра  появляются  каждые  несколько недель, да и другие программы
изменяются не менее часто. Поэтому новые пользователи Linux часто
чувствуют необходимость в постоянной модернизации (upgrade) своей
системы,  чтобы поспевать за изменениями, идущими лихой поступью.
Это  необходимо и это и потеря времени: отслеживать все
изменения  в  мире  Linux. Просто у вас может абсолютно все время
уходить на модернизацию системы и лишь оставшееся - на собственно
использование системы.</p>
<p></p>
<p>Ну,  так когда желаете занятся модернизацией? Некоторые
нутром  чувствуют,  что заниматься  модернизацией  пристало тогда,
когда   появилась  новая  версия  дистрибутива,  например,  когда
появляется  новая  версия  Slackware.  Многие  пользователи Linux
каждый  раз при этом полностью переинсталлируют свою систему. Это
тоже   потеря  времени.  Обычно  изменения  от  версии  к  версии
Slackware    незначительные.    Бессмысленно    переписывать    и
переинсталлировать  30  дисков,  когда  только  10% программ были
действительно модифицированы.</p>
<p></p>
<p>Лучший  вариант  модернизации  системы  - это ручная работа:
модернизируйте только те программные пакеты, про которые вы точно
знаете,  что их стоит менять. Это многих пугает: они хотят знать,
что менять, и как, и что они теряют, если не модернизируют. Залог
успеха  в  Linux  -  это преодолеть боязнь принципа "сделай сам",
одного из фундаментальных принципов Linux.</p>
<p></p>
<p>Действительно,  благостное состояние пользователя работающей
и  хорошо  настроенной системы враз меняется при переинсталляции,
поскольку,  без сомнения, приводит и к перенастройке всего и вся,
к  тому,  что  опять  все  не  работает,  как это было при первой
инсталляции системы. Так что определенные сеансы самопсихотерапии
необходимы,  чтобы иметь деловой настрой. Все, что требуется - это
немножко "ноу-хау" по модернизации системы.</p>
<p></p>
<p>Вы  обнаружите,  что когда вы модернизируете одну компоненту
вашей  системы, другие вещи не должны ломаться. Например, большая
часть  моей  системы оставлена со времен древней 0.96 MCC Interim
installation.  Тем  не  менее, я использую новейшую версию ядра и
библиотек  без  проблем.  Большей  частью бессмысленно заниматься
модернизациями, чтобы "не отстать от моды". Суета все это. Это вам
не  MS-DOS  или  Microsoft  Windows.  У  нас нет серьезных причин
обязательно  работать  на новейшей во все времена версии системы.
Если  вы осознаете, что вам действительно нужны некоторые вещи из
новой  версии  -  тогда модифицируйте на здоровье. А если нет, то
лучше  не  надо.  Другими  словами  модернизируйте только то, что
надо,  и  только  тогда,  когда  надо.  Не  модернизируйте во имя
модернизации.</p>
<p></p>
<p>Наиболее  важная  часть  вашей системы, как возможный об'ект
модернизации,  это  ядро,  библиотеки  и  компилятор gcc. Это три
ключевые  части  вашей системы,  и в некоторых случаях они бывают
взаимозависимыми.   Большая   часть  остального  хозяйства  вашей
системы и без периодических модернизаций сойдет.</p>
<p></p>
<h2>4.6.1 <A Name="ss4.6.1"> Модернизация ядра </h2>

<p>Модернизация  ядра - это просто надо взять исходные тексты и
самому  их  откомпилировать.  Вы  должны компилировать ядро сами,
поскольку  вам решать, какие свойства включать и не включать, как
и  убедиться, что ядро будет оптимизировано применительно к вашей
машине.   Процесс   вполне  безболезненный.
<sl>(прим.  переводчика:
Настоящие парашютисты сами укладывают свой парашют).</sl>

</p>
<p></p>
<p>Исходные  тексты  ядра можно раздобыть на любом Linux-овском
FTP-сервере  (список  смотрите  в Разделе  C). На <code>sunsite.unc.edu</code>,
например,  исходники  ядро  находятся в <code></code>pub/Linux/kernel/. Версии
ядра  нумеруются  с  использованием номера версии ядра (kernel) и
уровня  исправления  (patchlevel).  Например, kernel version 0.99
patchlevel  11  обычно  записывается как <code>0.99.pl11</code>, или еще проще
<code>0.99.11</code>.</p>
<p></p>
<p>Исходники   ядра   распространяются   в   виде  зазипованных
tar-файлов.  (  Часто  patch-файлы  ("заплаты")  выпускаются  для
текущей  версии ядра, которая позволяет модернизировать исходники
вашего    действующего   ядра   на   основе   последнего   уровня
исправлений, используя  программу  patch.  В  большинстве случаев,
между тем, обычно проще инсталлировать целиком новую версию ядра.
Например,   файл,   содержащий   исходники   ядра   0.99.pl11   -
<code>linux-0.99.11.tar.gz</code>.
<sl>(
прим. переводчика: На момент перевода книги
существуют следующие серии ядер:
0.1-0.99,
1.0.1-1.0.9,
1.1.1-1.1.95,
1.2.1-1.2.13,
1.3.1-1.3.83.
Ядра, принадлежащие серии с четной 2-й цифрой (1.0, 1.2),
являются стабильными (то есть не включают никаких экспериментальных кодов).
Ядра серии (1.1, 1.3) включают экспериментальные коды (такие как
Mobile IP, IP-masquarading и т. п. в серии 1.3).
Переводчик, исходя из декларированного автором принципа
"от добра добра не ищут",
работает в версии 1.2.13 и с нетерпением ждет появления версии
1.4.1 или 2.0.)</sl>

</p>
<p></p>
<p>Распакуйте  этот  файл  из  каталога  <code>/usr/src</code>; он создаст
каталог  <code>/usr/src/linux</code>,  который содержит исходники ядра. Вам
следует  удалить  или  переименовать  существующий <code>/usr/src/linux</code>
перед распаковкой новой версии.</p>
<p></p>
<p>Когда  исходники  распакованы, вам необходимо убедиться, что
две  символические  связи  в <code>/usr/include</code> корректны. Для создания
этих связей используйте команды</p>
<p>
<blockquote><code>
<pre>
    # ln -sf /usr/src/linux/include/linux /usr/include/linux
    # ln -sf /usr/src/linux/include/asm /usr/include/asm
</pre>
</code></blockquote>
</p>
<p>Если  вы однажды создали эти связи, нет причины создавать их</p>
<p>снова,  когда  вы  инсталлируете следующую версию ядра. (Смотрите
Раздел  3.10 по поводу символических связей).</p>
<p></p>
<p>Обратите  внимание,  что для компиляции ядра у вас в системе
должны быть инсталлированы компиляторы <code>gcc</code> и <code>g++</code> C и C++. Если вы
нуждаетесь  в  более  свежих  версиях этих компиляторов, смотрите
ниже Раздел  4.7.3.</p>
<p></p>
<p>Для   компиляции   ядра   прежде   всего   выполните <code>cd</code>  в
<code>/usr/src/linux</code>.   Выполните  команду  <code>make  config</code>.
Эта  команда
запросит  у вас несколько настроечных опций, таких как "Какой тип
файловой  системы  вы  желаете  включить  в  новое  ядро".  Затем,
отредактируйте  <code>/usr/src/linux/Makefile</code>. Убедитесь,    что
определение  для  <code>ROOT_DEV</code> корректно - оно определяет устройство,
используемое  в  качестве  корневой  файловой  системы  во  время
загрузки. Обычное определение имеет вид:</p>
<p>
<blockquote><code>
<pre>
    ROOT_DEV = CURRENT
</pre>
</code></blockquote>
</p>
<p></p>
<p>Менять  это  нет  смысла,  кроме  случая,  когда  вы меняете
устройство для вашей корневой файловой системы.</p>
<p></p>
<p>Затем  выполните команду <code>make dep</code> для отслеживания всех
взаимосвязей исходных текстов Это очень выхный этап.</p>
<p></p>
<p>И  наконец, вы готовы компилировать ядро. Команда <code>make Image</code>
скомпилирует   ядро   и   оставит  образ  нового  ядра  в  файле
<code>/usr/src/linux/Image</code>.
<sl>(прим. переводчика:
Начиная с ядер серии 1.2 собранное ядро записывается в каталог
<code>/usr/src/linux/arch/i386/boot/Image</code>
(если конечно вы собирали ядро для процессоров серии
intel, а не alpha, mips или sparc.)</sl>

А   команда  <code>make zImage</code>  скомпилирует
скомпрессировнный  образ  ядра, который раскомпрессирует сам себя
во время загрузки, а так занимает на диске меньше места.</p>
<p></p>
<p>После  компиляции  ядра  вы  должны  либо скопировать его на
загрузочную  дискету (командой вроде ``<code>cp Image /dev/fd0</code>''), либо
инсталлировать его, используя LILO для загрузки с вашего жесткого
диска. Дополнительную информацию можно найти в Разделе  4.2.2 .</p>
<p></p>

<h2>4.6.2 <A Name="ss4.6.2"> Модернизация библиотек </h2>

<p>Как   говорилось   ранее,   большинство   программ   системы
компилировалось  для использования разделяемых библиотек
содержащих   общие   подпрограммы,  которыми  пользуются  различные
прикладные программы.</p>
<p></p>
<p>Если вы увидите сообщение</p>
<p>
<blockquote><code>
<pre>
    Incompatible library version
    (Несовместимая версия библиотеки)
</pre>
</code></blockquote>
</p>
<p></p>
<p>При   попытке  выполнить  программу,   вам  необходимо
модернизировать   версию   ваших  библиотек,  которые  использует
программа.  Библиотеки совместимы в обратном направлении, то есть
программа,  откомпилированная  для  использования  с более ранней
версией  библиотек,  должна работать с новой версией библиотек. А
обратное не справедливо.</p>
<p></p>
<p>Самая   последняя   версия   библиотек  может  быть  найдена
FTP-серверах   Linux.   На <code>sunsite.unc.edu</code>  они  расположены  в
<code>/pub/Linux/GCC</code>.  Файлы  "версии"  (``release'') должны описывать,
какие  файлы  вам  необходимо  скачать,  и как их инсталлировать.
Кратко,    вы   должны   иметь   файлы <code>image-version.tar.gz</code> и
<code>inc-version.tar.gz</code>,  где  версия  указывает версию инсталлируемых
библиотек,  например  4.4.1.
<sl>(прим. переводчика:
На момент перевода книги последняя версия была 5.3.9.)</sl>

Это  зазипованные  tar-файлы. Файлы
образов  содержат  образы  инсталлируемых  библиотек в <code>/lib</code> and
<code>/usr/lib</code>.  Файл  <code>inc</code>  содержит  include-файлы  для  инсталляции в
<code>/usr/include</code>.</p>
<p></p>
<p>Файл <code>release-</code><em>version</em><code>.tar.gz</code> об'ясняет   инсталляционную
процедуру  в  деталях (конкретные инстукции для конкретных версий
отличаются). В общем случае вы должны инсталлировать
библиотечные <code>.a</code>  и  <code>.sa</code> файлы в <code>/usr/lib</code>.
Эти библиотеки используются на этапе
компиляции.</p>
<p></p>
<p>Дополнительно,   разделяемая   библиотека  образов  файлов
<code>libc.so.</code><em>version</em> инсталлируется в <code>/lib</code>.
Это разделяемые библиотеки
образов   загружаются   во   время  выполнения  использующими  их
программами.   Каждая   библиотека   имеет  символическую  связь,
использующую старшее число версии библиотеки в
<code>/lib</code>.</p>
<p></p>
<p>Например,  библиотека  <code>libc</code> версия 4.4.1 имеет старшую цифру
версии   4.   Файл,   содержащий   библиотеку - <code>libc.so.4.4.1</code>.
Символическая  связь с именем <code>libc.so.4</code>, указывающая на этот файл,
также  в  <code>/lib</code>. Вы должны изменить эту символическую связь, когда
модифицируете  библиотеки. Например, когда идет смена версий,
вы должны изменить символическую связь файла <code>libc.so.4</code> на новую
версию.</p>
<p></p>
<p><b>Важное  замечание!</b>  Надо  менять символическую связь за один
шаг,   как  показано  ниже.  Если  вы  каким-то  образом  удалили
символическую  связь  <code>libc.so.4</code> тогда программы, которые зависят
от этой связи (включая базовые утилиты вроде <code>ls</code> и <code>cat</code>) перестанут
работать.    Используйте   следующую   команду   для   обновления
символической  связи  <code>libc.so.4</code>,  чтобы  она  указывала  на  файл
<code>libc.so.4.4.1</code>:</p>
<p>
<blockquote><code>
<pre>
       # ln -sf /lib/libc.so.4.4.1 /lib/libc.so.4
</pre>
</code></blockquote>
</p>
<p></p>
<p>Вы должны также изменить символическую связь
<code>libm.so.</code><em>version</em>
таким  же  манером.  Если  вы переходите на отличную (от прежней)
версию библиотек, замените имена вышеупомянутых файлов. Пояснения
к  версии  библиотеки  должны  прояснить  детали. (Дополнительную
информацию про символические связи смотрите в Разделе  3.10).</p>
<p></p>

<h2>4.6.3 <A Name="ss4.6.3"> Модернизация gcc </h2>

<p>Компиляторы <code>gcc</code> C и C++ используются для компиляции программ
вашей  системы, в первую голову - ядра. Новейшую версию gcc можно
найти на FTP-серверах Linux. На <code>sunsite.unc.edu</code> его можно найти в
каталоге   <code>/pub/Linux/GCC</code>   (вместе   с  библиотеками).  Должен
существовать файл версии для дистрибуции gcc, детализирующий, какие
файлы вы должны переписать и как их инсталлировать.</p>
<p></p>
<p></p>

<h2>4.6.4 <A Name="ss4.6.4"> Модернизация других программ </h2>

<p>Модернизация других программ, это в основном проблема добычи
соответствующих  файлов и их инсталляции. Большинство программ для
Linux  распространяются  как  зазипованные tar-файлы, включая как
исходные,  так  и  выполняемые, или те и другие. Если выполняемые
файлы   не   включены   в   версию,   вам   может   потребоваться
самостоятельно  их  откомпилировать.  Обычно  это означает запуск
make в каталоге, где находятся исходники.</p>
<p></p>
<p>Чтение   группы  новостей  USENET  <code>comp.os.linux.announce</code>  -
простейший  путь,  чтобы  выловить информацию о новых программах.
Так  что  самый  простой  способ отыскать какие-то программы, это
побродить  по  FTP-серверам,  поскачивать  с  серверов  (<code>ls-lR</code>)
индексные файлы и, используя <code>grep</code>, найти желаемые файлы. Если вам
доступен  архив,  это  также  может  помочь.  Детали  смотрите  в
Приложении  А.  (Если у вас нет архива, вы можете по <code>telnet</code> выйти
на архивный сервер вроде <code>archie.rutgers.edu</code>, войти как ``<code>archie</code>''
и   воспользоваться   командой   ``<code>help</code>'').   Детали  смотрите  в
Приложении А.</p>
<p></p>
<p>Один  из  удобных  источников программ Linux - дисковый образ
Slackware.  Каждый  диск содержит ряд файлов <code>.tgz</code>,  просто
зазипованных  <code>tar</code>-файлов.  Вместо  переписывания  диска  вы можете
переписать  желаемые  <code>.tgz</code>  файлы  из  каталогов  Slackware  на
FTP-сервере  и  прямо  их  инсталлировать.  Если  вы  используете
дистрибутив   Slackware,   команда <code>setup</code>   может  автоматически
загрузить и инсталлировать полный набор дисков.</p>
<p></p>
<p>И   еще   раз,   обычно   не  самое  умное  дело  заниматься
модернизацией  путем переинсталляции новейшей версии Slackware или
другого  дистрибутива.  Если вы таким образом реинсталлируете, вы
обязательно   уничтожите   ваш   сегодняшний   вариант,   включая
каталоги  пользователей  и  ваши  стандартные  настройки.  Лучше
заниматься   модернизацией  по  частям,  то  есть,  если  нашлась
программа,  которую  вы  часто  используете и которая имеет новую
версию,  модернизируйте ее. А иначе не волнуйте себя по пустякам.
Правило  усталого  ветерана: "Если само не ломается - не трогай".
Если  ваша  система  работает  -  нет  достаточных  оснований для
модернизации.</p>
<p></p>


<h2>4.7 <A Name="ss4.7"> Управление файловыми системами </h2>

<p>Другая  задача  системного администратора - забота о файловой
системе.  Большая  часть  этой работы состоит в проверке файловой
системы  на  наличие  поврежденных или испорченных файлов; многие
системы делают такие проверки во время загрузки.</p>
<p></p>
<h2>4.7.1 <A Name="ss4.7.1"> Монтирование файловых систем </h2>

<p>Сначала   несколько   концепций,   связанных   с   файловыми
системами.  Прежде,  чем  файловая  система  будет  принята вашей
системой,  она должна быть <b>примонтирована</b> к какому-то каталогу.
Например,  если  у  вас файловая система на дискете, то вы должны
примонтировать  ее  в каталог, скажем <code>/mnt</code>, для того, чтобы
обеспечить  доступ  к  ее  файлам  (смотрите Раздел  4.6.2). После
монтирования файловой системы все файлы этой системы появляются в
этом  каталоге (и ниже). После размонтирования файловой системы
каталог  (в  нашем  случае  <code>/mnt</code>)  будет  пуст,  то  же  самое
справедливо   для  файловой  системы  на  жестком  диске.
<sl>(Прим.
переводчика:  Каталог  <code>/mnt</code>  будет  пуст,  если  он был пуст до
монтирования,  иначе  наоборот,  станут  видными файлы каталога
<code>/mnt</code> (основной системы), которые становятся "невидимыми", когда к
этому   каталогу  монтируется   файловая   система).</sl>

Система
автоматически  монтирует  файловые системы на ваш жесткий диск во
время   загрузки.  Так  называемая  "корневая  файловая  система"
монтируется  к  каталогу  <code>/</code>.  Если  у  вас  отдельные  файловые
системы, например, для <code>/usr</code> - она монтируется на <code>/usr</code>.
Если у вас
только   корневая   файловая   система,  то  все  файлы,  включая
содержимое <code>/usr</code>, существуют в этой файловой системе.</p>
<p></p>
<p>Команда   <code>mount</code>   используется   для  монтирования  файловой
системы.</p>
<p>
<blockquote><code>
<pre>
       mount -av
</pre>
</code></blockquote>
</p>
<p></p>
<p>Выполняется   из   файла  <code>/etc/rc</code>  (файла  системной
инициализации во время загрузки, смотрите Раздел 4.10.1). Команда
<code>ount -av</code>  получает информацию о файловых системах и монтирует в
соответствии  с  файлом  <code>/etc/fstab</code>.  Пример  файла <code>fstab</code>
показан
ниже.</p>
<p>
<blockquote><code>
<pre>
       # device       directory      type     options
       /dev/hda2       /             ext2     defaults
       /dev/hda3       /usr          ext2     defaults
       /dev/hda4       none          swap     sw
       /proc           /proc         proc     none
</pre>
</code></blockquote>
</p>
<p></p>
<p>Первое  поле  -  это  устройство (имя монтируемого раздела).
Второе  поле  -  точка  монтирования.  Третье поле - тип файловой
системы  (например,  <code>ext2</code>  для  системы типа ext2fs или <code>minix</code> для
Minix   filesystems).  Таблица  4.1  перечисляет  различные  типы
файловых систем, доступных в Linux.</p>
<p></p>
<p>Эта таблица для ядра версии 1.1.37.</p>
<p>
<blockquote><code>
<pre>
Файловая система            Имя типа   Комментарий

Second Extended Filesystem  ext2       Наиболее распространенная для Linux
Extended Filesystem         ext        Вытеснена системой ext2
Minix Filesystem            minix      Файловая система Minix; редко
                                               используется
Xia Filesystem              xia        Похожа на ext2; редко используется
UMSDOS Filesystem           umsdos     Для инсталяции Linux на разделы
                                               MS-DOS
MS-DOS Filesystem           msdos      Для доступа к файлам MS-DOS
/proc Filesystem            proc       Дает информацию о процессах для
                                               ps и т.п.
ISO 9660 Filesystem         iso9660    Используется большинством CD-ROM
Xenix Filesystem            xenix      Для доступа к файлам из Xenix.
System V Filesystem         sysv       Для доступа к файлам из System V
                                               вариант для x86.
Coherent Filesystem         coherent   Для доступа из Coherent
HPFS Filesystem             hpfs       Доступ только на чтение
                                               для разделов HPFS (DoubleSpace).

                Таблица 4.1. Типы Файловых систем Linux
</pre>
</code></blockquote>
</p>
<p></p>
<p>Не  все  эти типы могут быть доступны на вашей системе; ваше
ядро  должно  иметь соответствующую откомпилированную поддержку. О
компиляции ядра смотрите в Разделе  4.7.</p>
<p></p>
<p>Последнее   поле  файла  <code>fstab</code>  (options)  <F>это  было  перед
Таблицей   4.1</F>   содержит   опции   монтирования,   обычно   они
устанавливаются в ``<code>defaults</code>''.</p>
<p></p>
<p>Вы  можете  видеть,  что  разделы своппинга также включены в
<code>/etc/fstab</code>.  Они  имеют  каталог  монтирования
"tt/none/",  и  тип
<code>"swap</code>". Команда <code>swapon -a</code> выполняемая из <code>/etc/rc</code>
используется для
обеспечения   своппинга   на   все   устройства,  перечисленные  в
<code>/etc/fstab</code>.</p>
<p></p>
<p>Файл  <code>fstab</code>  содержит  одну  специальную запись для файловой
системы  <code>/proc</code>. Как говорилось в Разделе  3.11.1, файловая система
<code>/proc</code> используется для хранения информации о системных процессах,
доступной  памяти  и  т.п.  Если  <code>/proc</code>  не  примонтирован, такие
команды, как ps не будут работать.</p>
<p></p>
<p><b>Внимание!</b>  Команда  <code>mount</code>  может использоваться только
<code>root</code>.
Это  для обеспечения безопасности системы. Вам не захочется, чтобы
монтирование   и  размонтирование  файловых  систем  зависело  от
прихоти   рядовых   пользователей.   Есть  несколько  программных
пакетов, которые дают возможность тем самым рядовым пользователям
монтировать   и  размонтировать  файловые  системы  (особенно  на
дискетах) не затрагивая безопасности системы.</p>
<p></p>
<p>Команда <code>mount -av</code> фактически монтирует все файловые системы, кроме
корневой  файловой   системы  (в  ранее  приведенной  таблице  -
<code>/dev/hda2</code>).  Корневая  файловая система автоматически монтируется
ядром во время загрузки.</p>
<p></p>
<p>Вместо  использования  <code>mount -av</code>  вы  можете примонтировать
файловую систему вручную. Команда</p>
<p>
<blockquote><code>
<pre>
    # mount -t ext2 /dev/hda3 /usr
</pre>
</code></blockquote>
</p>
<p>эквивалентна  монтированию  файловой  системы на <code>/dev/hda3</code> в
примере <code>fstab</code>, рассмотренном ранее.</p>
<p></p>
<p>Вам  никогда не следует монтировать и размонтировать файловые
системы  вручную.  Команда  <code>mount  -av</code> в <code>/etc/rc</code>
позаботится о
монтировании  файловых систем во время загрузки. Файловые системы
автоматически  размонтируются  командами  <code>shutdown</code> или <code>halt</code> перед
выключением системы.</p>
<p></p>

<h2>4.7.2 <A Name="ss4.7.2"> Проверка файловых систем </h2>

<p>Бывает  полезно  почаще  проверять  вашу файловую систему на
наличие  поврежденных  и  испорченных  файлов.  Некоторые системы
автоматически  проверяют  свои файловые системы во время загрузки
(с помощью соответствующих команд из <code>/etc/rc</code>).</p>
<p></p>
<p>Для проверки файловых систем используются команды, зависящие
от  типа  файловой  системы.  Для  файловой системы <code>ext2fs</code> (самый
широко используемый тип), такой командой служит <code>e2fsck</code>. Например,
команда</p>
<p>
<blockquote><code>
<pre>
    # e2fsck -av /dev/hda2
</pre>
</code></blockquote>
</p>
<p></p>
<p>проверит    файловую   систему <code>ext2fs</code> на <code>/dev/hda2</code> и
автоматически исправит ошибки.</p>
<p>Обычно  бывает  полезно размонтировать файловую систему перед</p>
<p>ее проверкой. Например команда</p>
<p>
<blockquote><code>
<pre>
       # umount /dev/hda2
</pre>
</code></blockquote>
</p>
<p></p>
<p>Размонтирует  файловую  систему  на <code>/dev/hda2</code>, после чего вы
можете   ее   проверить.  Есть  одно  исключение,  вы  не  можете
размонтировать   корневую   файловую   систему.  Для  того,  чтобы
проверить  размонтировнную  корневую  файловую систему вам следует
использовать   специальную  boot/root  дискету  (смотрите  Раздел
4.11.1). Вы также не можете размонтировать файловую систему, если
хотя  бы  один из ее файлов "занят" (``busy''), т.е. используется
действующим  процессом.  Например,  вы  не  можете размонтировать
файловую   систему,   если   хотя  бы  один  из  текущих  рабочих
каталогов  пользователя  находится на этой файловой системе. Вы
получите   сообщение   ``<code>Device   busy</code>'',   если  вы  попытаетесь
размонтировать используемую файловую систему.</p>
<p></p>
<p>Другая  файловая  система использует различные формы команды
<code>e2fsck</code>,  такие как <code>efsck</code> и <code>xfsck</code>.
На некоторых системах вы можете
просто  использовать команду <code>fsck</code>, которая определит тип файловой
системы и выполнит соответствующую команду.</p>
<p></p>
<p><b>Внимание!</b>  Необходимо  немедленно перезагрузить операционную
систему  после проверки монтированной файловой системы, если были
внесены  какие-то  изменения  в  файловую  систему. (Хотя в общем
случае  проверять неразмонтированную файловую систему). Например,
если  <code>e2fsck</code>  сообщает,  что  она исправила хотя бы одну ошибку в
файловой  системе,  вам следует немедленно выполнить <code>shutdown -r</code>,
чтобы    перезагрузить    систему.    Это    позволить    системе
"ресинхронизировать"   информацию   о   файловой  системе,  после
модификации  ее  с  помощью  <code>e2fsck</code>.
<sl>(прим. переводчика: То есть
сново  согласовать  содержимое  буферов  памяти с соответствующими
фрагментами файловой системы на диске).</sl>

</p>
<p></p>
<p>Файловая  система  <code>/proc</code>  никогда  не  нуждается в проверках
такого  рода.  <code>/proc</code> - это файловая система памяти, управляемая
непосредственно ядром.</p>
<p></p>


<h2>4.8 <A Name="ss4.8"> Использование файла своппинга </h2>

<p>Вместо  того,  чтобы  резервировать специальные разделы для
области  своппинга, вы можете использовать файл. Однако, чтобы это
сделать,    вы    должны   инсталлировать   программы   Linux   и
предварительно  сделать  все,  что  необхоимо для создания файлов
своппинга.</p>
<p></p>
<p>Если  у  вас  есть инсталлированная система Linux, вы можете
использовать  следующие команды для создания файла своппинга. Ниже
мы собираемся создать файл своппинга размером в 8208 блоков (около
8 Мбайт).</p>
<p>
<blockquote><code>
<pre>
       # dd if=/dev/zero of=/swap bs=1024 count=8208
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эта  команда  создает  файл  своппинга.  Замените  ``<code>count=</code>''
размером файла своппинга в блоках.</p>
<p>
<blockquote><code>
<pre>
       # mkswap /swap 8208
</pre>
</code></blockquote>
</p>
<p></p>
<p>Эта  команда инициализирует <code>swap</code>-файл; вновь замените имя и
размер своп-файла соответствующими значениями.</p>
<p>
<blockquote><code>
<pre>
       # /etc/sync
       # swapon /swap
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь  в своппинге будет задействован файл <code>/swap</code>, который мы
создали,  после  синхронизации, которая гарантирует, что файл был
записан на диск.</p>
<p></p>
<p>Главная    неприятность,    связанная    с    использованием
<code>swap</code>-файлов,  состоит  в  том,  что доступ к ним происходит
через  файловую  систему.  Это означает, что блоки, составляющие
swap-файл могут быть не смежними на диске.
То есть скорость своппинга при использовании swap-файла ниже, чем
при использовании swap-раздела,
для  которой  блоки  всегда смежны (последовательны) и
запросы на ввод/вывод происходят прямо к устройству.</p>
<p></p>
<p>Другая  проблема, связанная с использованием <code>swap</code>-файла, это
возможность   испортить  информацию  в  файловой  системе  -  при
использовании  больших  файлов  своппинга  существует шанс, что вы
попортите  систему,  если  что-то  происходит  неправильно.  Имея
раздел  своппинга отдельно от файловой системы вы страхуетесь от
таких неприятностей.</p>
<p></p>
<p>Использование  файла  своппинга  может  быть очень полезным,
если   у   вас   есть   временная  потребность  в  дополнительном
пространстве для своппинга. Например, если вы компилируете большую
программу и хотите ускорить дело, вы можете временно создать файл
своппинга  и  использовать  его  в  дополнение к имеющейся области
своппинга.</p>
<p></p>
<p>Для   того,  чтобы  избавиться  от  файла  своппинга,  вначале
используйте <code>swapoff</code></p>
<p>
<blockquote><code>
<pre>
    # swapoff /swap
</pre>
</code></blockquote>
</p>
<p></p>
<p>А теперь вы можете смело удалить файл.</p>
<p>
<blockquote><code>
<pre>
    # rm /swap
</pre>
</code></blockquote>
</p>
<p></p>
<p>Помните,  что каждый файл своппинга (или раздел) может быть
размером  до  16  Мбайт,  но  вы  можете использовать до 8 файлов
своппинга или разделов на своей системе.</p>
<p></p>

<h2>4.9 <A Name="ss4.9"> Разношерстные задачи </h2>

<p>Хотите верьте, хотите - нет, но существует ряд хозяйственных
задач,  входящих  в функции системного администратора, которые не
попадают ни в одну из основных категорий.</p>
<p></p>
<h2>4.9.1 <A Name="ss4.9.1"> Файлы установки системы </h2>

<p>При   загрузке   системы  некоторые  сценарии  автоматически
выполняются  системой до входа в нее пользователей. Далее следует
описание  того,  что  в  это  безвременье  происходит.  Во  время
загрузки  ядро запускает процесс <code>/etc/init</code>. <code>init</code>
- это программа,
которая читает свои настроечные файлы (<code>/etc/inittab</code>)
и запускает
другие  процессы, базирующиеся на содержании этих файлов. Один из
важных  процессов  запускается  из <code>inittab</code> -
это <code>/etc/getty</code> , он
стартует   для   каждой   виртуальной   консоли.   Процесс <code>getty</code>
захватывает  ВК  (Виртуальную Консоль) и запускает на ней процесс
<code>login</code>.  Это позволяет вам входить на каждой ВК. Если
<code>/etc/inittab</code>
не  содержит  процессов <code>getty</code> для конкретной ВК, на эту ВК вы не
войдете.</p>
<p></p>
<p>Другой  процесс,  выполняемый из <code>/etc/inittab</code> -
это <code>/etc/rc</code>,
главный  системный  файл  инициализации
<sl>(прим.  переводчика: или
главный  файл  инициализации системы - что тоже верно).</sl>

Этот файл
представляет  из  себя  shell-сценарий, который выполняет любые необходимые
команды  инициализации  во  время  загрузки, такие например, как
монтирование    файловых   систем   (смотрите   Раздел  4.8)   и
инициализации области своппинга.</p>
<p></p>
<p>Ваша  система  может  также  выполнять  и  другие  сценарии,
например  <code>/etc/rc.local</code>.
<code>/etc/rc.local</code>  обычно  содержит команды
инициализации, специфичные для вашей системы, такие как установка
хост-имени    (смотрите   следующий  раздел ).
<code>rc.local</code>  может
запускаться из <code>/etc/rc</code> или прямо из <code>/etc/inittab</code>.</p>
<p></p>

<h2>4.9.2 <A Name="ss4.9.2"> Установка хост-имени </h2>

<p>В   сетевой  среде  хост-имя  используется  для  однозначной
идентификации  конкретной машины, в то время как отдельно стоящей
машине хост-имя придает чувство собственного достоинства и шарма.
Это, как  дать  имя  вашей  собаке: вы можете обращаться к собаке
просто  ``The  dog''
<sl>(прим.  переводчика:  это просто "собака" (с
определенным  артиклем  -  поскольку конкретная)</sl>

, но значительно
интереснее приписать собаке имя, вроде Spot или Woofie (или Шарик
и Бобик).</p>
<p></p>
<p>Хост-имя элементарно устанавливается командой <code>hostname</code>. Если
вы  в  сети,  ваше  хост-имя должно быть полным хост-именем вашей
машины,  таким  как  <code>goober.norelco.com</code>.  Если  вы  не в сети, вы
можете  выбрать  произвольные  имена для хоста и домена, например
<code>loomer.vpizza.com</code>, <code>shoop.nowhere.edu</code> или <code>floof.org</code>.</p>
<p></p>
<p>При   установке   хост-имени   оно   должно быть  занесено  в  файл
<code>/etc/hosts</code>, который приписывает IP адрес каждому хосту. Даже если
ваша  машина  не  в  сети,  вам  следует включить ваше хост-имя в
<code>/etc/hosts</code>. Например, если вы не имеете выхода в сеть по TCP/IP и
ваше  хост-имя  <code>floof.org</code>,  просто  включите  следующую  запись в
<code>/etc/hosts</code>:</p>
<p>
<blockquote><code>
<pre>
    127.0.0.1       floof.org localhost
</pre>
</code></blockquote>
</p>
<p></p>
<p>Это припишет ваше хост-имя <code>floof.org</code> к
локальному IP-интерфейсу
(loopback  address) 127.0.0.1 (используемому, <F>даже</F> если вы не в
сети).
Синоним  <code>localhost</code> также
приписывается этому адресу.</p>
<p></p>
<p>Если  вы подключены к сети по TCP/IP, ваши действительные IP
адрес  и  хост-имя  должны появиться в <code>/etc/hosts</code>. Например, если
ваше  хост-имя <code>goober.norelco.com</code>, и ваш IP адрес 128.253.154.32,
добавьте следующую строку в <code>/etc/hosts</code>:</p>
<p>
<blockquote><code>
<pre>
    128.253.154.32       goober.norelco.com
</pre>
</code></blockquote>
</p>
<p></p>
<p>Если  вашего хост-имени не будет в <code>/etc/hosts</code>, вы не сможете
его  установить.  Для  установки  хост-имени  просто  используйте
команду <code>hostname</code>. Например, команда</p>
<p>
<blockquote><code>
<pre>
    # hostname -S goober.norelco.com
</pre>
</code></blockquote>
</p>
<p></p>
<p>устанавливает хост-имя <code>goober.norelco.com</code>. Во многих случаях
команда   hostname   выполняется   из   из  одного  из  системных
установочных   файлов,   таких  как  <code>/etc/rc</code>
или  <code>/etc/rc.local</code>.
Отредактируйте  эти  два файла и измените находящуюся там команду
<code>hostname</code>,  установив  хост-имя  своей  машины; после перезагрузки
машины хост-имя будет иметь новое значение.</p>
<p></p>


<h2>4.10 <A Name="ss4.10"> Что делать при ЧП </h2>

<p>В  некоторых случаях администратор системы будет сталкиватся
с   проблемой  выкарабкивания  из  абсолютной  катастрофы,  такой
например,  как  забытие  пароля  <code>root</code>  или крах файловой системы.
Лучший  совет - <em>без паники</em>! Все делают глупые ошибки - это лучший
способ    освоить    системное    администрирование,    хотя    и
патологический.</p>
<p></p>
<p>Linux  не  является нестабильной
<sl>(прим. переводчика: так в оригинале)</sl>

версией UNIX.  Действительно,  у  меня  было  значительно  меньше
проблем  с  зависанием системы, чем с коммерческими версиями UNIX
на   многих   платформах.  Linux  также  выигрывает  от  большого
расположения  к  нему  крутых программистов, которые могут помочь
выпутаться из сложной ситуации.</p>
<p></p>
<p>Первый  шаг  в  исследовании любой проблемы - это попытаться
справиться   с   ней   самостоятельно.   Потыкайтесь   там-сям  и
посмотрите,  что из этого будет получаться. Слишком много времени
системные  администраторы  тратят  на  рассылку  во  все  стороны
отчаянных  воплей  о  помощи,  прежде, чем вникнуть в проблему. В
большем  числе  случаев  вы  обнаружите, что вы сами легко можете
решить проблему. А это уже ваш прямой путь в мэтры.</p>
<p></p>
<p>Очень  редки  случаи,  когда  после краха системы требуется
переинсталляция.  Многие начинающие пользователи случайно удаляют
некоторые   важные   системные   файлы   и  немедленно  бегут  за
инсталляционным  диском. Это не "Боже мой"! Прежде чем применять
такие отвратительные меры, исследуйте проблему и попросите других
помочь  ее  решить.  В большинстве случаев вы можете восстановить
систему с дискеты сопровождения (maintenance diskette).</p>
<p></p>
<h2>4.10.1 <A Name="ss4.10.1"> Восстановление с использованием дискеты сопровождения </h2>

<p>Одно  назаменимое  средство для администратора системы - это
так  называемый  ``boot/root  disk''  -  дискета,  которая  может
загрузить полный Linux, вне зависимости от вашего жесткого диска.
Boot/root  disks  в  действительности  очень  прост - вы создаете
корневую   файловую  систему  на  дискете,  помещая  на  нее  все
необходимые  утилиты,  инсталлируя  на дискете LILO и загружаемое
ядро.  Другой  способ,  это  использовать одну дискету для ядра и
другую  для  корневой  файловой системы. В любом случае результат
одинаков: Вы запускаете Linux полностью с дискет.</p>
<p></p>
<p>Канонический  пример  boot/root  disk - это загрузочный диск
Slackware.
<sl>(Смотрите  Раздел  2.1.1  относительно  информации по
перекачке  его  по  Internet.  Для  этого  вам  не надо скачивать
полностью  -  только  <code>boot</code>  и <code>root</code> дискеты).</sl>

Эти дискеты содержат
загрузочную  таблицу и корневую файловую систему. Предполагается,
что  они используются при инсталляции дистрибутивов Slackware, но
бывают очень полезны для сопровождения системы.</p>
<p></p>
<p>boot/root  disk,  созданный  H.J  Lu,  который можно взять в
<code>/pub/Linux/GCC/rootdisk</code> на <code>sunsite.unc.edu</code> -
другой пример такого
рода диска сопровождения.</p>
<p></p>
<p>Или,  если  вы  достаточно  амбициозны, можете создать свой.
Хотя,  в большинстве случаев, использовать готовый boot/root disk
- значительно легче и надежнее.</p>
<p></p>
<p>Использовать  boot/root  disk  очень легко. Просто загрузите
диск  на  вашей  системе  и войдите под <code>root</code> (обычно без пароля).
Чтобы  получить доступ к файлам вашего жесткого диска, необходимо
примонтировать ваши файловые системы вручную. Например, команда</p>
<p>
<blockquote><code>
<pre>
    # mount -t ext2 /dev/hda2 /mnt
</pre>
</code></blockquote>
</p>
<p>примонтирует  файловую систему ext2fs на <code>/dev/hda2</code>
под <code>/mnt</code>.
Помните, что <code>/</code> теперь находится на boot/root disk; вам необходимо
примонтировать   файловую   систему  вашего  жесткого  диска  под
каким-то  каталогом,  чтобы  получить  доступ к файлам. Так что
<code>/etc/passwd</code>  вашего жесткого диска теперь в
<code>/mnt/etc/passwd</code>, если
вы примонтировали вашу корневую файловую систему на <code>/mnt</code>.</p>
<p></p>

<h2>4.10.2 <A Name="ss4.10.2"> Восстановление пароля для root </h2>

<p>Если  вы  забыли  пароль  вашего  <code>root</code> - нет проблем. Просто
загрузитесь   с   boot/root  disk,  примонтируйте  вашу  корневую
файловую  систему  под  <code>/mnt</code>  и  сотрите  поле  пароля для
<code>root</code> в
<code>/mnt/etc/passwd</code>, как например:</p>
<p>
<blockquote><code>
<pre>
    root::0:0:root:/:/bin/sh
</pre>
</code></blockquote>
</p>
<p></p>
<p>Теперь  <code>root</code> без пароля; когда вы перезагрузитесь с жесткого
диска,  вы  сможете  войти  как <code>root</code>  и снова установить пароль,
используя  команду  <code>passwd</code>.  Не  правда  ли,  вы  счастливы,  что
научились  работать  с  <code>vi</code>?  На вашей boot/root disk, редакторов,
вроде  Emacs  наверняка нет, а <code>vi</code> должен быть.
<sl>(прим.переводчика:
администратор  должен  отдавать  себе отчет, что процедуру снятия
пароля root умеет запросто выполнять не он один).</sl>

</p>
<p></p>
<p></p>
<p></p>

<h2>4.10.3 <A Name="ss4.10.3"> Восстановление файловой системы </h2>

<p>Если  у вас каким-то образом грохнулась файловая система, вы
можете  использовать  <code>e2fsck</code> (это  в случае, если вы используете
файловую  систему типа ext2fs) для исправления попорченых данных
файловой  системы  с  дискет.  Другие файловые системы используют
другие формы команды <code>fsck</code>; детали смотрите в Разделе  4.8.</p>
<p></p>
<p>Когда  вы  проверяете вашу файловую систему с дискеты, лучше
всего, чтобы файловая система не была примонтирована.</p>
<p></p>
<p>Частая   причина  неисправности  файловой  системы  -  порча
суперблока. Суперблок, это "голова" (``header')'файловой системы,
которая  содержит информацию о статусе файловой системы, размере,
свободных   блоках   и  т.д.  Если  вы  попортили  ваш  суперблок
(например,  случайно  прямо  в  него  записали  какие-то  данные)
операционная система может вообще не распознать файловую систему.
Все  попытки примонтировать файловую систему потерпят неудачу, и
<code>e2fsck</code> не поможет решить проблему.</p>
<p></p>
<p>К  счастью,  файловая  система  типа  ext2fs сохраняет копии
суперблока в границах "группы блоков" (``block group'') на диске,
обычно через каждые   8K  блоков.  Для  того, чтобы приказать <code>e2fsck</code>
использовать копию суперблока, вы можете использовать команду</p>
<p>
<blockquote><code>
<pre>
    # e2fsck -b 8193 &lt;partition&gt;
</pre>
</code></blockquote>
</p>
<p></p>
<p>где  <code>&lt;partition&gt;</code>  -  это  раздел, на которой располагается
файловая  система.  Опция <code>-b 8193</code> приказывает <code>e2fsck</code> использовать
копию суперблока, хранящуюся в блоке 8193 файловой системы.</p>
<p></p>

<h2>4.10.4 <A Name="ss4.10.4"> Восстановление потерянных файлов </h2>

<p>Если  вы  случайно  удалили  важные  файлы,  нет  способа их
"разудалить"    обратно.    Однако,    вы    можете   скопировать
соответствующие  файлы  с  дискеты себе на жесткий диск. Например,
если вы удалите <code>/bin/login</code> в своей системе (который обеспечивает
вход   в   систему),   просто   загрузите   boot/root   дискету,
примонтируйте  корневую  файловую  систему  на <code>/mnt</code> и используйте
команду</p>
<p>
<blockquote><code>
<pre>
    # cp -a /bin/login /mnt/bin/login
</pre>
</code></blockquote>
</p>
<p>Опция  <code>-a</code>  приказывает <code>cp</code> сохранить права доступа копируемых
файлов.  Разумеется,  если  удаленные файлы не столь существенны,
что  они  не  были  удостоены  копирования  на  дискету boot/root
floppy, значит вам не повезло. Если вы создавали резервные копии,
вы можете скопировать файлы оттуда.</p>
<p></p>

<h2>4.10.5 <A Name="ss4.10.5"> Восстановление потерянных библиотек </h2>

<p>Если вы случайно потеряли свои библиотеки или символические
связи  в  <code>/lib</code>,  скорее  всего  команды,  которые зависят от этих
библиотек,  больше  не будут выполняться (смотрите Раздел  4.7.2).
Простейшее   решение   -   загрузиться   с   дискеты   boot/root,
примонтировать  вашу  корневую  файловую  систему  и восстановить
библиотеки в <code>/mnt/lib</code>.</p>
<p></p>


<p><a href="lig-5.html"> След. </a> Глава, <a href="lig-3.html"> Пред. </a> Глава</p><p>Содержимое <a href="lig.html#toc4">этой главы</a>,
 Главное <a href="lig.html#toc">оглавление</a></p>
<p><a href="lig.html"> Начало </a> документа,
 <a href="lig-4.html#0"> Начало этой главы</a></p>