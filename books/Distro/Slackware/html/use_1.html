 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html LANG=ru>
<meta name="GENERATOR" content="TtH 2.89">
<table width="100%"  CELLSPACING="1" CELLPADDING="1" >
<tr>
<td align="left"><a href="conf_4.html">Предыдущий</a></td>
<td align="center"><a href="index.html">Содержание</a></td>
<td align="right"><a href="use_2.html">Следующий</a></td>
</table>
<hr />
<p>
 <h1><a name="tth_chAp5">
Chapter 5 </a><br />Использование Slackware Linux</h1>

 <h2><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Оболочка Shell</h2><a name="shell">
</a>

<p>
В графической среде интерфейс представляется программой, которая рисует окна, линии прокрутки, меню, и т.д. В режиме командной строки интерфейс управляется оболочкой (англ. shell), которая интерпретирует команды и вообще делает вещи пригодными к применению. Сразу после входа в систему (который описывается в этом разделе), пользователи попадают в оболочку, и могут делать там то, что они хотят. Этот раздел является введением по оболочке в общем, и так же описывает наиболее распространённую среди пользователей Linux оболочку&nbsp;- Bourne Again Shell,  или просто <b>bash</b>. Для получения дополнительной информации по всем рассмотренным в этом разделе вопросам, обращайтесь к man странице <b>bash</b>(1).

<p>
     <h3><a name="tth_sEc5.1.1">
5.1.1</a>&nbsp;&nbsp;Пользователи</h3><a name="users">
</a>

<p>

<h4>Вход в систему</h4>
Итак, вы загрузились, и перед вами что-то вроде:

<p>

<table>
<tr><td>Welcome to Linux 2.2.14</td></tr>
<tr><td>darkstar login:
</td></tr></table>


<p>
Хм... никто нам ничего не говорил о login. И что такое darkstar? Не волнуйтесь; скорее всего, вы не соединились через гиперпространственную comm-link связь с искусственной луной Империи. (Боюсь, гиперпространственный comm-link ещё не поддерживается Linux ядром :) Нет, drackstar это просто имя одного из наших компьютеров, и его имя устанавливается по умолчанию. Если во время установки вы изменили имя вашего компьютера, то вы увидите его в приглашении входа, вместо drackstar.

<p>
Так что же там про login...  Если это ваш первый вход в систему, вам необходимо войти в систему, как root пользователь. Вас спросят пароль; если вы указали пароль при установке, то введите его. Если нет, просто нажмите ввод. Ну вот, вы вошли в систему!

<p>

<h4>Root: суперпользователь</h4>

<p>
Итак, кто или что такое ''root''? И что он имеет общего с системой?

<p>
Ну, в мире Unix и аналогичных системах (таких, как Linux), есть пользователи и ещё пользователи. Мы вернёмся к более подробному обсуждению позже, но важно знать, что пользователь root, это самый главный пользователь; это всезнающий и все-умеющий пользователь и никто не смеет ослушаться ''root'' пользователя.  Это просто не дозволенно. Root это тот, кого мы называем суперпользователем и имеем на это полное право. И что самое лучшее, так это, что вы и есть root.

<p>
Здорово, не правда ли?

<p>
Если вы не уверенны: да, это очень здорово. Что вы должны усвоить, так это то, что root может поломать всё, что угодно, если пожелает. Возможно, вы захотите заскочить вперёд и заглянуть в раздел&nbsp;<a href="use_5.html#admin">5.5</a> и посмотреть, как добавить пользователя; и войти, как этот пользователь. Мудрость гласит, что лучше всего становится суперпользователем только когда это абсолютно необходимо, чтобы избежать случайных повреждений в системе.

<p>
Кстати, если вы вошли в систему, как обычный пользователь, и вам надо выполнить пару команд, как root, вы можете воспользоваться командой <b>su</b>(1). Вас спросят пароль root-а и затем вы им станете, до тех пор, пока не выйдете. При помощи <b>su</b> вы так же можете стать любым другим пользователем вашей системы, если знаете его пароль. Например, <b>su logan</b> сделает вас мной.

<p>
     <h3><a name="tth_sEc5.1.2">
5.1.2</a>&nbsp;&nbsp;Командная строка</h3>

<h4>Запуск программ</h4>

<p>
Трудно сделать что либо, без выполнения программ; можно использовать ваш компьютер в качестве подпорки для чего-то, например, для открытой двери, и он будет замечательно жужжать, пока включён, но не больше. И наверное, большинство согласиться со мной, что использование компьютеров в качестве жужжащей подпорки для двери не принесло бы им такой популярности, какую они сейчас приобрели.

<p>
Итак, помните, что в Linux почти всё является файлом? Так вот, для программ это тоже справедливо. Каждая команда, которую вы выполняете (если она не встроена в вашу оболочку), соответствует файлу. Вы можете запустить программу, указав полный путь к ней.

<p>
Например, помните команду <b>su</b>? Так вот, на самом деле она является файлом, расположенным в <tt>/bin</tt> каталоге: <b>/bin/su</b> запустит её.

<p>
Почему же тогда простой набор <b>su</b> так же работает? Вы ведь не указывали путь <tt>/bin</tt>. Ведь она могла находится и в <tt>/usr/share</tt>? откуда же компьютер узнал? Ответ в переменной PATH; большинство оболочек имеет PATH или что-то похожее. Она содержит список каталогов, в которых искать программы, которые вы пытаетесь выполнять. Таким образом, когда вы выполнили <b>su</b>, ваша оболочка прошлась по списку каталогов, ища в каждом из них выполняемый файл <b>su</b> и как только она нашла такой файл, она выполняет его.  Это случается каждый раз, когда вы запускаете какую либо программу без указания полного пути к ней; если вы получаете сообщение ''Command not found'', это означает, что программы, которую вы пытаетесь запустить нет в каталогах, перечисленных в PATH переменной. (Это так же будет истиной, если программа вообще не существует...) Мы обсудим переменные окружения более детально в разделеthe Bourne Again Shell (bash).

<p>
Запомните так же, что ''.'' это сокращение для ''каталог, в котором я сейчас нахожусь'', так что если вы в каталоге <tt>/bin</tt>, <b>./su</b> сработает, как полный путь к файлу.

<p>

<h4>Wildcard Matching (шаблоны имён)</h4>

<p>
Практически любая оболочка позволяет использовать некоторые символы, подразумевая, ''здесь может быть всё что угодно''. Такие символы называются ''wildcards''; наиболее распространённые из них это ''*'' и ''?''. По соглашению, ''?'' обычно заменяет любой отдельный символ. Например, допустим у вас в каталоге есть файлы: <tt>example1.txt</tt>, <tt>example2.txt</tt> и <tt>example3.txt</tt>. Вы хотите скопировать все эти файлы (при помощи <b>cp</b> программы, которую мы опишем в разделе&nbsp;<a href="use_3.html#file">5.3</a> в другой каталог, скажем <tt>/tmp</tt>. Набирать <b>cp example1.txt example2.txt example3.txt /tmp</b> потребует слишком много усилий по печатанию всего этого текста. Гораздо проще написать <b>cp example?.txt /tmp</b>; ''?'' будет заменён на все встретившиеся символы ''1'', ''2'' и ''3''.

<p>
Что вы говорите? Всё равно слишком много надо печатать? Вы правы. Это ужасно; ведь у нас есть закон о труде, который защищает нас от таких ситуаций. Но к счастью, у нас в арсенале так же есть ''*''. Как уже упоминалось выше, ''*'' заменяет любое число символов, включая их отсутствие. Так что в случае, если кроме упомянутых выше файлов в каталоге ничего нет, мы можем просто сказать <b>cp * /tmp</b> и убьём их все одним выстрелом.  Предположим теперь, что в том же каталоге есть файлы <tt>example.txt</tt> и <tt>hejaz.txt</tt>. И мы хотим скопировать фалы <tt>example</tt>, но не <tt>hejaz.txt</tt>; <b>cp example*.txt /tmp</b> сделает это для нас.

<p>
<b>cp example?.txt /tmp</b>, конечно, скопирует только наши первые три файла; в файле <tt>example.txt</tt> нет символа, подходящего под ''?'', так что этот файл будет оставлен в покое.

<p>

<h4>Пере-направление ввода/вывода и piping</h4><a name="pipe">
</a>

<p>
(Что-то очень интересное здесь.)

<p>

<table>
<tr><td><tt>$ </tt><b>ps  &gt;  blargh</b>
</td></tr></table>


<p>
Знаете, что это такое? Это я выполняю <b>ps</b>, чтобы посмотреть какие процессы сейчас выполняются; <b>ps</b> описана в разделе&nbsp;<a href="use_4.html#process">5.4</a>. Это не самая интересная часть. Интересная часть вот тут <b> &gt;  blargh</b>, что грубо означает, '' возьми вывод <b>ps</b> и запиши его в файл, называющийся <tt>blargh</tt>''. Но подождите, будет ещё интереснее.

<p>

<table>
<tr><td><tt>$ </tt><b>ps | less</b>
</td></tr></table>


<p>
Эта команда берёт вывод <b>ps</b> и ''pipes'' (прокачивает) его через <b>less</b>, таким образом, я могу пролистывать его как захочу.

<p>

<table>
<tr><td><tt>$ </tt><b>ps  &gt;&gt;  blargh</b>
</td></tr></table>


<p>
Это третий из наиболее используемых redirector-ов (пере-направителей); он делает то же, что и '' &gt; '', только '' &gt;&gt; '' добавит вывод <b>ps</b> к файлу <tt>blargh</tt>, если этот файл существует. А если такого файла нет, то сработает просто как '' &gt; '', и создаст файл. ('' &gt; '' в любом случае полностью перепишет содержимое <tt>blargh</tt>.)  Есть так же и оператор '' &lt; '', который означает ''возьмите ввод из следующего источника'', но он не так часто используется.

<p>

<table>
<tr><td><tt>$ </tt><b>fromdos  &lt;  dosfile.txt  &gt;  unixfile.txt</b>
</td></tr></table>


<p>
Пере-направление становится действительно забавным, когда вы объединяете операторы:

<p>

<table>
<tr><td><tt>$ </tt><b>ps | tac  &gt;&gt;  blargh</b>
</td></tr></table>


<p>
Эта команда запустит <b>ps</b>, инвертирует порядок вывода строк, и присоединит их к фалу <tt>blargh</tt>. Вы можете комбинировать столько операторов, сколько пожелаете; но будьте осторожны и помните, что они интерпретируются с лева направо.

<p>
Загляните в man страницу <b>bash</b>(1) для получения более детальной информации по пере-направлению вывода.

<p>
     <h3><a name="tth_sEc5.1.3">
5.1.3</a>&nbsp;&nbsp;The Bourne Again Shell (bash)</h3>

<p>

<h4>Переменные окружения</h4><a name="variable">
</a>

<p>
Система Linux это сложный зверь. И есть много вещей, за которыми надо следить, много маленьких деталей, которые вступают в игру в вашем обычном взаимодействии с различными программами (о некоторых из которых вам даже не надо знать). Никто не хочет указывать большие наборы опций программе, которую хочет выполнить, указывать ей, какой тип терминала используется, имя хоста компьютера, как должно выглядеть приглашение программ...

<p>
Итак, как объединяющий механизм, пользователи получают то, что называется environment (окружение). Среда окружения определяет условия, в которых выполняется программа; некоторые из этих условий&nbsp;- переменные; пользователь может изменять их и играть с ними. Практически каждая оболочка имеет переменные окружения (если нет, то это наверное не очень удобная оболочка). Здесь мы приведём команды используемые в <b>bash</b> для оперирования с переменными окружения.

<p>

<table>
<tr><td><tt>$ </tt><b>set</b>
</td></tr></table>


<p>
Сама по себе команда <b>set</b> покажет вам все переменные окружения, которые определены в данный момент вместе с их значениями. Как и большинство команд, встроенных в <b>bash</b>, она может быть использована для других целей (при указании параметров); мы оставим изучение подробностей, так как они описаны в man странице <b>bash</b>(1). Отрывок вывода команды <b>set</b> на моём компьютере выглядит следующим образом:

<p>

<table>
<tr><td>PATH=/usr/local/lib/qt/bin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:</td></tr>
<tr><td>/usr/openwin/bin:/usr/games:.:/usr/local/ssh2/bin:</td></tr>
<tr><td>/usr/local/ssh1/bin:</td></tr>
<tr><td>/usr/share/texmf/bin:/usr/local/sbin:/usr/sbin:/home/logan/bin</td></tr>
<tr><td>PIPESTATUS=([0]="0")</td></tr>
<tr><td>PPID=4978</td></tr>
<tr><td>PS1='\h:\w&#126;$ '</td></tr>
<tr><td>PS2='&#62; '</td></tr>
<tr><td>PS4='+ '</td></tr>
<tr><td>PWD=/home/logan</td></tr>
<tr><td>QTDIR=/usr/local/lib/qt</td></tr>
<tr><td>REMOTEHOST=ninja.tdn</td></tr>
<tr><td>SHELL=/bin/bash</td></tr></table>


<p>
Обратите внимание, на PATH переменную, которую мы обсуждали ранее; я могу выполнять любые программы, находящиеся в каталогах, упомянутых в ней, просто набрав их имя, без указания пути.

<p>

<table>
<tr><td><tt>$ </tt><b>unset VARIABLE</b>
</td></tr></table>


<p>
<b>unset</b> удалит как содержание указанной в команде переменной, так и саму переменную; <b>bash</b> забудет, что такая переменная когда либо существовала. (Не волнуйтесь, если это не что-то, что явно было определено в данной сессии оболочки, вероятно оно будет пере-определено при следующей сессии оболочки.)

<p>

<table>
<tr><td><tt>$ </tt><b>export VARIABLE=some_value</b>
</td></tr></table>


<p>
Теперь <b>export</b>, действительно очень полезная команда. С её помощью вы присваиваете переменной VARIABLE значение ''<b>some_value</b>; если VARIABLE не существовала, то она будет создана. Если VARIABLE уже имела какое-то значение, то оно будет потерянно и изменено на новое. Это не есть хорошо, если вы просто пытаетесь добавить имя каталога в PATH. В этом случае вам понадобится команда вроде этой:

<p>

<table>
<tr><td><tt>$ </tt><b>export PATH=$PATH:/some/new/directory</b>
</td></tr></table>


<p>
Обратите внимание на $PATH: когда вы хотите, чтобы <b>bash</b> интерпретировала переменную (заменяла её на её значение), добавьте $ перед именем переменной. Например, <b>echo $PATH</b> высветит значение PATH переменной, в моём случае:

<p>

<table>
<tr><td>$ echo $PATH</td></tr>
<tr><td>/usr/local/lib/qt/bin:/usr/local/bin:/usr/bin:/bin: /usr/X11R6/bin:</td></tr>
<tr><td>/usr/openwin/bin:/usr/games:.:/usr/local/ssh2/bin:/usr/local/ssh1/bin:</td></tr>
<tr><td>/usr/share/texmf/bin:/usr/local/sbin:/usr/sbin:/home/logan/bin</td></tr></table>


<p>

<h4>Завершение по tab</h4>

<p>
(Опять что-то интересное.)

<p>

<ol type="1"><p>
<li> Интерфейс командной строчки требует много печатания.</li>
<p>
<li> Печатание это работа.</li>
<p>
<li> Никто не любит работу.</li>
</ol>

<p>
Из пунктов 3 и 2 мы можем заключить, что 4) никто не любит печатать. К счастью, <b>bash</b> спасает нас от 5 (никто не любит интерфейс командной строки).

<p>
Как же <b>bash</b> справляется с этим, спросите вы? В дополнение к шаблонам имён, обсуждённым выше, <b>bash</b> имеет функцию ''завершение по tab''.

<p>
Завершение по tab работает примерно так: Вы набираете имя файла. Может он есть в PATH, а может быть в текущем каталоге. Всё что вам надо, это напечатать достаточную часть имени файла для его однозначной идентификации. Затем нажмите tab кнопку. <b>bash</b> определит, чего вы хотели и дополнит имя файла за вас!

<p>
Время для примера. Каталог <tt>/usr/src</tt> содержит два под-каталога:<tt>/usr/src/linux</tt> и <tt>/usr/src/sendmail</tt>. Я хочу посмотреть, что находится в <tt>/usr/src/linux</tt>. Я набираю только <b>ls /usr/src/l</b>, нажимаю кнопку <b>TAB</b>, и <b>bash</b> выдаст мне <b>ls /usr/src/linux</b>.

<p>
Теперь, предположим, есть два каталога <tt>/usr/src/linux</tt> и <tt>/usr/src/linux-old</tt>; Если я напечатаю <b>/usr/src/l</b> и нажму <b>TAB</b>, <b>bash</b> дополнит столько, сколько сможет, и я получу /usr/src/linux. Я могу остановиться на этом, или нажать <b>TAB</b> опять и <b>bash</b> покажет мне список каталогов, которые подходят под то, что уже напечатано.

<p>
Итак, меньше печатания (и пользователям может понравиться интерфейс командной строки). Я же говорил, что это здорово.

<p>
     <h3><a name="tth_sEc5.1.4">
5.1.4</a>&nbsp;&nbsp;Виртуальные терминалы</h3>

<p>
Итак, вы делаете что-то и вам надо сделать ещё что-то. По идее вы можете просто бросить то, что вы делали и перейти к выполнению другой задачи. Но ведь это же многопользовательская система вроде? И вы можете войти столько раз, сколько пожелаете? Так зачем же выполнять только одну задачу, если параллельно можно выполнять и другую?

<p>
Проблема в том, что мы не можем подключить несколько  клавиатур, мышек и мониторов к одному и тому же компьютеру; скорее даже большинство из нас просто не захочет этого. Очевидно, что дополнительное оборудование не является решением проблемы. А вот программное обеспечение может помочь, и Linux позволяет это, предлагая ''виртуальные терминалы'', или "VTs".

<p>
Нажав <b>Alt</b> и функциональную кнопку, вы можете переключать виртуальные терминалы; каждая функциональная клавиша соответствует терминалу. Slackware имеет 6 виртуальных терминалов по умолчанию. <b>Alt+F2</b> переключит вас на второй, <b>Alt+F3</b> на третий, и т.д.

<p>
Остальные функциональные клавиши зарезервированы для X сессий. Каждая X сессия использует свой собственный VT, начиная с седьмого (<b>Alt+F7</b>) и выше. Когда вы находитесь в X, <b>Alt+Function</b> комбинация заменяется на <b>Ctrl+Alt+Function</b>; так что если вы в X и хотите переключиться на третий терминал (не завершая X сессию), <b>Ctrl+Alt+F3</b> переключит вас туда. (<b>Alt+F7</b> вернёт вас обратно, если вы используете первую из X сессий.)

<p>
     <h3><a name="tth_sEc5.1.5">
5.1.5</a>&nbsp;&nbsp;Итог</h3>

<p>
В этом разделе были обсуждены пользователи, оболочка, командная строка и виртуальные терминалы. Вы должны уверенно себя чувствовать при работе в режиме командной строки, выполнении программ и использовании pipe-ов и операторов пере-направления вывода. Так же вы должны усвоить, насколько велик и все-могущественен root пользователь, и почему плохо всегда работать, как root.

<hr />
<table width="100%"  CELLSPACING="1" CELLPADDING="1" >
<tr>
<td align="left"><a href="conf_4.html">Предыдущий</a></td>
<td align="center"><a href="index.html">Содержание</a></td>
<td align="right"><a href="use_2.html">Следующий</a></td>
</table>
<hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 2.89.<br />On 24 Apr 2001, 16:43.</small>
</html>