 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html LANG=ru>
<meta name="GENERATOR" content="TtH 2.89">

<table width="100%"  CELLSPACING="1" CELLPADDING="1" >
<tr>
<td align="left"><a href="install.html">Предыдущий</a></td>
<td align="center"><a href="index.html">Содержание</a></td>
<td align="right"><a href="conf_2.html">Следующий</a></td>
</table>
<hr />
<p>
 <h1><a name="tth_chAp4">
Chapter 4 </a><br />Настройка</h1>

 <h2><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Настройка системы</h2>
Перед тем, как приступить к настройке более сложных частей системы, вам следует узнать немного больше о том, как система устроена и как можно найти в ней определённый файл или программу. Вам так же следует разобраться, необходимо ли вам компилировать ядро для вашей системы, и если да, то что для этого надо делать. Этот раздел ознакомит вас с организацией системы и её конфигурационными файлами. А затем мы перейдём к настройке более сложных частей системы.

<p>
     <h3><a name="tth_sEc4.1.1">
4.1.1</a>&nbsp;&nbsp;Обзор системы</h3>
Очень важно понять, как организован Linux перед тем, как погружаться в различные аспекты по его настройке. Система Linux кардинальным образом отличается  от систем DOS или Windows (а так же Macintosh OS). Этот раздел ознакомит вас с расположением основных элементов системы.

<p>

<h4>Организация файловой системы</h4>
Первое принципиальное отличие Slackware Linux от DOS или Windows&nbsp;- это организация файловой системы. Для начинающих пользователей: в Linux различным разделам жёсткого диска не сопоставляются буквы. В этой системе есть только один основной каталог. Вы можете провести аналогию с диском <tt>C:</tt> системы DOS. Каждый раздел жёсткого  диска смонтирован (подключён)<a href="footnotes.html#tthFtNtABC" name="tthFrefABC"><sup>12</sup></a> к одному из каталогов основной директории. Что-то вроде всегда расширяемого диска.

<p>
Мы называем эту основную директорию корневой директорией, или корневым каталогом, а ссылаемся на неё при помощи одинарного слэша (<tt>/</tt>). Эта концепция может показаться вам странной, но на самом деле она значительно упрощает жизнь в том случае, если вам необходимо увеличить размер используемого дискового пространства. Например, у вас закончилось место на том диске, который содержит каталог <tt>/home</tt>. На самом деле, большинство пользователей при установке Slackware создают один большой корневой диск, так что это лишь пример. Так как разделы могут быть подключены к любому каталогу, вы можете просто пойти в магазин, купить ещё один жёсткий диск и подключить его к каталогу <tt>/home</tt><a href="footnotes.html#tthFtNtABD" name="tthFrefABD"><sup>13</sup></a>. И вот вы ''привили''  немного свободного пространства к вашей системе. И всё без особых усилий по пере-настройке и переносу различных программ.

<p>
Ниже вы найдёте описание основных каталогов верхнего уровня в системе Slackware.

<p>

<dl compact="compact">
	<dd><tt>/bin</tt>
Здесь хранятся основные программы пользователей. Имеются в виду самые основные команды, необходимые пользователю для работы в системе. Например, такие как оболочки и команды файловой системы (<b>ls</b>, <b>cp</b> и т.д.). Каталог <tt>/bin</tt> обычно не претерпевает изменений после установки. Если претерпевает, то обычно лишь при обновления пакетов программ предоставленных нами.</dd>

	<dd><tt>/boot</tt> Файлы,
используемые Загрузчиком Linux-a (LILO). Эта директория так же практически не получает изменений после установки.</dd>

	<dd><tt>/cdrom</tt> Помните, что все диски подключаются к определённому каталогу? Так вот, каталог <tt>/cdrom</tt> предоставлен вам для использования в качестве точки монтирования вашего привода компакт дисков.</dd>

	<dd><tt>/dev</tt> В Linux  всё рассматривается, как файл. Даже различные устройства, такие как последовательные порты, жёсткие диски и сканеры. Для получения доступа к определённому устройству, необходимо чтобы существовал специальный файл, называемый device node<a href="footnotes.html#tthFtNtABE" name="tthFrefABE"><sup>14</sup></a> . Все эти ноды находятся в каталоге <tt>/dev</tt>.  Аналогично устроены большинство Unix&nbsp;- подобных операционных систем.</dd>

	<dd><tt>/etc</tt> Этот каталог содержит файлы настроек. Всё, от конфигурационных файлов системы X Window, базы данных пользователей и до стартовых сценариев. Администратор системы детально ознакомится с этим каталогом, со временем, конечно.</dd>

	<dd><tt>/home</tt> Linux является многопользовательской системой. Каждому пользователю присваивается эккаунт и уникальная директория для персональных файлов. Эта директория называется ''home'' (домашним) каталогом пользователя. Каталог <tt>/home</tt> предоставлен для расположения домашних директорий пользователей.</dd>

	<dd><tt>/lib</tt> Системные библиотеки, необходимые для основных программ находятся здесь. Библиотека C, динамический загрузчик, библиотека ncurses и модули ядра&nbsp;- это основные обитатели этого каталога.</dd>

	<dd><tt>/lost+found</tt> При загрузке системы происходит проверка файловых систем на наличие ошибок. Если они обнаружены, то запускается программа <b>fsck</b> и пытается исправить их. Восстановленные части файловой системы сохраняются программой в этом каталоге.</dd>

	<dd><tt>/mnt</tt> Этот каталог предоставляется как временная точка монтирования для жёстких дисков, или отключаемых устройств.</dd>

	<dd><tt>/opt</tt> Дополнительные пакеты программ. Идея в том, что все пакеты программ, устанавливаются в этот каталог, например <tt>/opt/&lt;программный пакет&#62;</tt> и в последствии если этот пакет вам более не нужен, то достаточно всего лишь удалить соответствующий каталог. В Slackware дистрибутиве некоторые программы поставляются в <tt>/opt</tt> каталоге (например KDE в <tt>/opt/kde</tt>), но вы вольны добавить всё, что угодно в <tt>/opt</tt>.</dd>

	<dd><tt>/proc</tt> Это в своём роде уникальная директория. На самом деле, она не является частью файловой системы, это виртуальная файловая система, которая предоставляет доступ к информации ядра. Различная информация, которую ядро хочет сообщить вам, подаётся вам через ''файлы'' в каталоге <tt>/proc</tt>. Вы так же можете сообщить ядру через некоторые из этих ''файлов'' попробуйте выполнить <b>cat /proc/cpuinfo</b>.</dd>

	<dd><tt>/root</tt> Администратор системы известен системе, как ''root''. Его домашний каталог&nbsp;- <tt>/root</tt>, вместо <tt>/home/root</tt>. Причина этого в том, что каталог <tt>/home</tt> может находится в разделе, отличном от <tt>/</tt> и если по какой-то причине <tt>/home</tt> не может быть подключён, то пользователь root вынужден будет войти в систему, чтобы решить проблему. И если его домашний каталог на другом диске, это усложнит вход в систему.</dd>

	<dd><tt>/sbin</tt> Основные программы, выполняемые пользователем root а так же программы, выполняемые процессом загрузки хранятся здесь. Обычные пользователи не будут пользоваться этими программами.</dd>

	<dd><tt>/tmp</tt> Временное хранилище данных. Все пользователи имеют права чтения и записи в этом каталоге.</dd>

	<dd><tt>/usr</tt> Это большой каталог в Linux системе. Практически всё остальное расположено здесь. Программы, документация, исходный код ядра и X Window система. Именно в этот каталог, скорее всего, вы будете устанавливать программы.</dd>

	<dd><tt>/var</tt> Системные лог файлы, кэш файлы и файлы-замки программ хранятся здесь.Это каталог для часто меняющихся данных.</dd>
</dl>

<p>
Теперь у вас должно появится хорошее представление о том, что содержится в каких каталогах. Следующий раздел поможет вам научится легко искать конкретные файлы, чтобы не пришлось это делать вручную.

<p>

<h4>Поиск Файлов</h4>

<p>
Теперь вы знаете, какого рода данные содержит каждый каталог, но это на самом деле не поможет вам при поиске конкретных файлов. Конечно вы можете пролистать все каталоги, в поисках того, что вам надо, но существуют более быстрые способы.  В Slackware есть четыре основных инструмента для поиска файлов.

<p>

<b>which&nbsp;&nbsp;</b>

<p>
Первый из них&nbsp;- это команда <b>which</b>(1). <b>which</b> обычно используется для быстрого поиска программ. Он просто ищет в каталогах, указанных в вашей PATH переменной и выдаёт первое найденное соответствие, а так же путь к этому файлу.  Например:

<p>

<table>
<tr><td><tt>$ </tt><b>which bash</b></td></tr>
<tr><td>/bin/bash</td></tr></table>


<p>
Таким образом, <tt>bash</tt>  находится в <tt>/bin</tt> каталоге. Это очень ограниченная команда для поиска, так как она ищет только в вашем PATH.

<p>

<b>whereis&nbsp;&nbsp;</b>

<p>
Команда <b>whereis</b>(1) работает аналогично программе <b>which</b>, но в дополнение к последней, так же ищет man страницы и исходники программ. Результат выполнения <b>whereis</b> для bash будет следующий:

<p>

<table>
<tr><td><tt>$ </tt><b>whereis bash</b></td></tr>
<tr><td>bash: /bin/bash /usr/bin/bash /usr/man/man1/bash.1.gz
</td></tr></table>


<p>
Эта команда не только говорит, где находится программа, но так же указывает, где находится её онлайн документация. Но она всё ещё весьма ограничена. Что если вам необходимо найти определённый конфигурационный файл? <b>which</b> или <b>whereis</b> тут вам не помогут.

<p>

<b>find&nbsp;&nbsp;</b>

<p>
Команда <b>find</b>(1) может быть использована для поиска всего, чего угодно. Я хочу задать поиск файла <b>xinitrc</b> во всей системе.

<p>

<table>
<tr><td><tt>$ </tt><b>find / -name xinitrc</b></td></tr>
<tr><td>/var/X11R6/lib/xinit/xinitrc
</td></tr></table>


<p>
<b>find</b> потребует много времени для поиска, так как эта команда пролистает всё дерево каталогов для поиска. И если вы выполните команду, как обычный пользователь, то на экран, вероятно, неоднократно будут выведены сообщения об ошибке доступа к некоторым из каталогов (к тем, которые может просматривать только root). Но <b>find</b> нашла наш файл. Уже хорошо. Если бы только она работала чуточку быстрее...

<p>

<b>locate&nbsp;&nbsp;</b>

<p>
Команда <b>locate</b>(1) производит поиск по всей файловой системе, в точности как и <b>find</b>, но она просматривает свою базу данных вместо того, чтобы пролистать все каталоги. База данных настроена так, что она автоматически обновляется в 4:40 утра. Вы так же можете вручную выполнить <b>updatedb</b>(1), для обновления этой базы данных (перед запуском её вручную вам следует выполнить <b>su nobody</b>). Вот пример использования locate:

<p>

<table>
<tr><td><tt>$ </tt><b>locate xinitrc</b>  # нам не надо быть root</td></tr>
<tr><td>/var/X11R6/lib/xinit/xinitrc</td></tr>
<tr><td>/var/X11R6/lib/xinit/xinitrc.fvwm2</td></tr>
<tr><td>/var/X11R6/lib/xinit/xinitrc.openwin</td></tr>
<tr><td>/var/X11R6/lib/xinit/xinitrc.twm</td></tr></table>


<p>
Мы получили больше, чем нам было необходимо и очень быстро в то же время. С этими командами вы можете найти всё, что угодно в Linux системе.

<p>

<h4>Каталог <tt>/etc/rc.d</tt></h4>

<p>
Файлы, выполняемые системой при её инициализации, хранятся в каталоге <tt>/etc/rc.d</tt>. Slackware использует расположение сценариев инициализации в стиле BSD.  Каждое задание или runlevel (уровень загрузки) имеет свой <tt>rc</tt> файл. Таким образом, получается организованная структура, которой легко пользоваться.

<p>
Есть несколько категорий сценариев инициализации. Начальная загрузка системы, уровни загрузки, инициализация сети и System V совместимые. По традиции, мы отнесём всё остальное к категории ''других''.

<p>

<h4>Начальная загрузка системы</h4>

<p>
Первая программа, запускаемая в Slackware после ядра Linux&nbsp;-это <b>init</b>(8).  Эта программа читает <tt>/etc/inittab</tt>(5) файл, чтобы узнать, как загружать систему. Запускает <tt>/etc/rc.d/rc.S</tt> сценарий для подготовки перед переключением на выбранный runlevel. <tt>rc.S</tt> файл активизирует виртуальную память, подключает файловые системы, очищает определённые log каталоги инициализирует Plug and Play устройства, загружает модули ядра, настраивает PCMCIA устройства, активизирует последовательные порты и запускает System V загрузочные сценарии (если таковые присутствуют). <tt>rc.S</tt> выполняет много задач самостоятельно, но так же до завершения своей работы, он вызовет ниже перечисленные сценарии из каталога <tt>/etc/rc.d</tt>:

<p>

<dl compact="compact">
	<dd><tt>rc.S</tt> Это и есть инициализационный сценарий.</dd>

	<dd><tt>rc.modules</tt> Загружает модули ядра. Такие, как поддержка сетевой карты, PPP и другие. Если сценарий находит <tt>rc.netdevice</tt>, то он выполнит и его.</dd>

	<dd><tt>rc.pcmcia</tt> Проверяет наличие и настраивает все PCMCIA устройства, присутствующие в вашей системе. Это наиболее полезно для пользователей laptop компьютеров, у которых, наверняка есть PCMCIA модем или сетевая карта.</dd>

	<dd><tt>rc.serial</tt> Настраивает последовательные порты, запуская соответствующие <b>setserial</b> команды.</dd>

	<dd><tt>rc.sysvinit</tt> Ищет System V инициализационные сценарии, соответствующие выбранному runlevel и выполняет их.  Это более подробно обсуждается ниже.</dd>
</dl>

<p>

<h4>Инициализационные сценарии runlevel</h4>
После того, как инициализация системы завершена, <b>init</b> переходит к инициализации runlevel. Runlevel описывает, в каком режиме ваш компьютер будет работать.  Звучит загадочно? Ну, runlevel сообщает <b>init</b>-у, будете ли вы в многопользовательском (multiuser logins) режиме, или только в одно-пользовательском (single user), хотите ли вы сетевые сервисы и будете ли вы использовать X Window или <b>agetty</b>(8), для управления входом в систему (logins). Файлы, приведённые ниже определяют разные runlevels в Slackware Linux.

<p>

<dl compact="compact">
	<dd><tt>rc.0</tt> Выключает систему (runlevel 0). По умолчанию, это символическая ссылка на rc.6.</dd>

	<dd><tt>rc.4</tt> Многопользовательский запуск (runlevel 4), но в X11 с KDM, GDM или XDM в качестве менеджера входа в систему.</dd>

	<dd><tt>rc.6</tt>
Перезагружает систему (runlevel 6).</dd>

	<dd><tt>rc.K</tt> Запуск в одно-пользовательском режиме (runlevel 1).</dd>

	<dd><tt>rc.M</tt> Многопользовательский режим (runleveld 2 и 3), но со стандартным текстовым входом (login). Это runlevel, используемый в Slackware по умолчанию.</dd>
</dl>

<p>

<h4>Инициализация сети</h4>

<p>
Уровни загрузки 2, 3 и 4 запустят сетевые сервисы. Следующие файлы ответственны за инициализацию сети:

<p>

<dl compact="compact">
	<dd><tt>rc.inet1</tt> Этот файл, созданный программой <b>netconfig</b>, ответственен за настройку сетевого интерфейса.</dd>

	<dd><tt>rc.inet2</tt> Выполняется после <tt>rc.inet1</tt> и запускает основные сетевые сервисы.</dd>

	<dd><tt>rc.atalk</tt> Запускает AppleTalk сервисы.</dd>

	<dd><tt>rc.httpd</tt> Запускает вэб сервер Apache.</dd>

	<dd><tt>rc.samba</tt> Запускает Samba сервис.</dd>

	<dd><tt>rc.news</tt> Запускает сервер новостей.</dd>
</dl>

<p>

<h4>Совместимость с System V</h4>

<p>
Совместимость с System V была предоставлена в Slackware 7.0.  Много других Linux дистрибутивов используют этот форматом вместо BSD формата.  В этом стиле каждому уровню загрузки предоставляется каталог для сценариев, а в BSD-стиле каждому уровню загрузки соответствует только один сценарий.

<p>
<tt>rc.sysinit</tt> сценарий произведёт поиск всех System V init сценариев в <tt>/etc/rc.d</tt> каталоге и выполнит их, если уровень загрузки соответствующий.  Это полезно, если вы пользуетесь коммерческим программным обеспечением, которое устанавливает System V init сценарии, в то же время, вы можете пользоваться и BSD сценариями.

<p>

<h4>Другие файлы</h4>
Сценарии, описанные ниже&nbsp;- это все остальные загрузочные сценарии. Они обычно выполняются одним из вышеперечисленных основных сценариев, таким образом, всё что вам необходимо сделать для изменения настроек, это отредактировать содержание соответствующих файлов.

<p>

<dl compact="compact">
	<dd><tt>rc.cdrom</tt> Если активизирован, то он проверит, есть ли компакт диск в приводе и если есть, то подключит его к <tt>/cdrom</tt>.</dd>

	<dd><tt>rc.gpm</tt> Запускает сервис основной поддержки мыши (general purpose mouse). Это позволит вам копировать и вставлять текст в консоли.</dd>

	<dd><tt>rc.ibcs2</tt> Запускает поддержку Intel Binary Compatibility. Это необходимо только в том случае, если вы планируете выполнять программы, откомпилированные на SCO Unix или на других коммерческих Intel Unix разновидностях. В этом нет необходимости для запуска Linux программ.</dd>

	<dd><tt>rc.font</tt> Загружает пользовательский экранный шрифт для режима командной строки.</dd>

	<dd><tt>rc.local</tt> Содержит всю специфическую загрузочную информацию для вашей конкретной системы. В свеже-установленном дистрибутиве этот файл пуст. Он зарезервирован для использования администратором системы. Этот сценарий выполняется самым последним при загрузке.</dd>
</dl>

<p>
Для активизирования сценария всё, что вам нужно сделать, это добавить ему разрешение на выполнение при помощи <b>chmod</b> программы. Чтобы выключить сценарий, удалите разрешение на выполнение соответствующего файла. Для получения дополнительной справки по <b>chmod</b>, смотрите раздел
<a href="use_2.html#access">5.2.2</a>.

<p>
     <h3><a name="tth_sEc4.1.2">
4.1.2</a>&nbsp;&nbsp;Выбор ядра</h3>
Ядро это та часть операционной системы, которая обеспечивает доступ к аппаратному обеспечению компьютера, управление процессами и контроль за работой всей системы. Ядро содержит поддержку аппаратных устройств, так что выбор ядра для вашей системы&nbsp;- очень важный шаг при установке.

<p>
Slackware предоставляет около 60-ти прекомпилированных ядер. Так что перед вами открывается широкий выбор. Каждое из ядер включает в себя набор стандартных драйверов, плюс дополнительные специфические драйвера. Вы можете использовать одно из прекомпилированных ядер, или вы можете самоcтоятельно откомпилировать ядро для вашей системы. В любом случае, вам следует убедиться в том, что используемое вами ядро содержит поддержку аппаратных устройств, присутствующих в системе.

<p>

<h4>Каталог <tt>/kernels</tt> на Slackware CD-ROM</h4>

<p>
Прекомпилированные Slackware ядра доступны в каталоге <tt>/kernels</tt> на Slackware CD-ROM, а так же на FTP сайте в основном каталоге Slackware. С появлением новых версий дистрибутива, обновляются и ядра, так что документация в каталоге с ядрами&nbsp;- всегда наиболее полный источник информации по ним.  Каталог <tt>/kernels</tt> содержит под-каталог для каждого из ядер. Имена под-каталогов совпадают с именами ядер. В каждом под-каталоге вы найдёте следующие фалы:

<p>

<table>
<tr><td><b>Файл</b> </td><td><b>Назначение</b></td></tr>
<tr><td><tt>System.map</tt> </td><td>Системный map файл для этого ядра</td></tr>
<tr><td><tt>bzImage</tt> (или <tt>zImage</tt>) </td><td>Образ ядра</td></tr>
<tr><td><tt>config</tt> </td><td>Конфигурационный файл исходника</td></tr>
<tr><td></td><td>для этого ядра</td></tr></table>


<p>
Чтобы установить ядро, скопируйте <tt>System.map</tt> и <tt>config</tt> в каталог <tt>/boot</tt> вашей системы, а образ ядра скопируйте в файл <tt>/vmlinuz</tt>. Запустите <b>/sbin/lilo</b>(8), чтобы установить LILO для нового ядра, а затем пере загрузите систему. Это всё что вам необходимо проделать для установки одного из прекомпилированных ядер в вашу систему.

<p>
Ядра, заканчивающиеся на ''.i''&nbsp;- это IDE ядра. Т.е. они не содержат SCSI поддержки в самом ядре. Ядра, заканчивающиеся с ''.s''&nbsp;- это SCSI ядра. Они содержат поддержку IDE устройств точно так же, как и ''.i'' ядра, плюс поддержку SCSI.

<p>

<h4>Компилирование ядра из исходников</h4>

<p>
Новые пользователи часто спрашивают: ''Следует ли мне компилировать ядро для моей системы?''. Ответ, определённо: может быть. Большинству пользователей подойдёт одно из прекомпилированных ядер, с подгружаемыми модулями для устройств, не поддерживаемых самим ядром. Вы захотите откомпилировать ядро в случае, если вы обновляете его версию на более новое, которое мы ещё не предоставили в Slackware, или если вы наложили патч на исходник вашего ядра.

<p>
Сборка своего собственного ядра не такой уж сложный процесс. Первым делом необходимо убедиться, что в вашей системе установлен исходный текст ядра.  Убедитесь, что вы установили пакеты из раздела K во время установки. Вам так же понадобятся пакеты из раздела D, в частности компилятор C, GNU make и GNU binutils. В общем неплохо бы, чтобы весь раздел D был установлен, если вы собираетесь заниматься разработкой чего либо. Теперь мы готовы к сборке ядра:

<p>

<table>
<tr><td><tt>$ </tt><b>su -</b></td></tr>
<tr><td>Password:</td></tr>
<tr><td><tt># </tt><b>cd /usr/src/linux</b>
</td></tr></table>


<p>
Первым делом вернём исходный текст ядра к его первоначальному состоянию. Для этого выполним следующее:

<p>

<table>
<tr><td><tt># </tt><b>make mrproper</b>
</td></tr></table>


<p>
Теперь вы можете настроить ядро под вашу систему. Современное ядро предлагает на ваш выбор три способа выполнения этой задачи. Первый метод&nbsp;- это оригинальная текстовая система вопрос-ответ. Вам будет заданно много вопросов, а после этого будет создан конфигурационный файл. Проблема с этим способом в том, что если вы ошиблись, то вы должны начать всё сначала. Метод, предпочитаемый большинством пользователей&nbsp;- метод, основанный на системе меню. Ну и наконец.  последний&nbsp;- X-ориентированный инструмент настройки ядра. Выберите, какой вам больше нравится, и наберите соответствующую команду:

<p>

<table>
<tr><td><tt># </tt><b>make config</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(текстовая вопрос-ответ версия)</td></tr>
<tr><td><tt>#</tt><b>make menuconfig</b>&nbsp;(menu, текстовая версия)</td></tr>
<tr><td><tt>#</tt><b>make xconfig</b>&nbsp;&nbsp;&nbsp;&nbsp;(X-ориентированная версия, вначале
 убедитесь,</td></tr>
<tr><td>что вы в X)
</td></tr></table>


<p>
<br /><table align="left" border="1"><tr><td width="0" align="center">
<a href="../gifs/make.menuconfig.gif">Figure</a></td></tr></table><!--hbox-->

<p>
Для новых пользователей, вероятно, <b>menuconfig</b> покажется наиболее простой в использовании. Вы можете найти экраны с помощью, которые объяснят предназначение каждой  части ядра. После настройки ядра, выйдите из программы настройки. Она создаст необходимые конфигурационные файлы. Теперь мы можем подготовить дерево исходников ядра к сборке:

<p>

<table>
<tr><td><tt># </tt><b>make dep</b></td></tr>
<tr><td><tt># </tt><b>make clean</b>
</td></tr></table>


<p>
Следующий шаг&nbsp;- компиляция ядра. Вначале попробуйте задать команду <b>zImage</b>. Это не пройдёт, если ваше ядро слишком большое. Не волнуйтесь, вы всё ещё можете попробовать <b>bzImage</b>.

<p>

<table>
<tr><td><tt># </tt><b>make zImage</b>&nbsp;&nbsp; (Вначале попробуйте так)</td></tr>
<tr><td><tt># </tt><b>make bzImage</b>&nbsp;&nbsp; (Если предыдущая команда не</td></tr>
<tr><td>сработала, попробуйте эту)
</td></tr></table>


<p>
В зависимости от скорости процессора, этот процесс может быть достаточно долгим. Во время процесса сборки вы увидите на экране команды компилятора.  После сборки образа ядра вы захотите собрать все те части ядра которые вы указали загружаемыми, как модули.

<p>

<table>
<tr><td><tt># </tt><b>make modules</b>
</td></tr></table>
<a href="footnotes.html#tthFtNtABF" name="tthFrefABF"><sup>15</sup></a>

<p>
Теперь мы можем установить свеже-скомпилированное ядро и модули. Чтобы установить ядро в Slackware системе, необходимо воспользоваться следующими командами:

<p>

<table>
<tr><td><tt># </tt><b>mv /vmlinuz /vmlinuz.old</b></td></tr>
<tr><td><tt># </tt><b>cat arch/i386/boot/zImage &#62; /vmlinuz</b></td></tr>
<tr><td><tt># </tt><b>mv /boot/System.map /boot/System.map.old</b></td></tr>
<tr><td><tt># </tt><b>cp System.map /boot/System.map</b>
</td></tr></table>


<p>
Замените <b>zImage</b> на <b>bzImage</b>, если вам пришлось собрать большее ядро.  Вероятно, вы захотите отредактировать <tt>/etc/lilo.conf</tt> файл и добавить соответствующий раздел для вашего старого ядра, на тот случай, если новое ядро не работает. После этого выполните <b>/sbin/lilo</b>, чтобы установить новый загрузочный блок. Теперь вы можете пере-загрузиться с новым ядром.

<p>

<h4>Использование модулей ядра</h4>

<p>
Модули ядра, это другое название драйверов устройств, которые могут быть вставлены в запущенное ядро. Они позволяют вам расширить список аппаратных устройств, поддерживаемых ядром, без установки другого ядра, или пере-компиляции заново.

<p>
Модули могут быть загружены или выгружены в любое время, даже во время работы системы.  Это позволяет системным администраторам очень легко обновлять драйвера специфических устройств. Новый модуль может быть откомпилирован, старый выгружен, а новый загружен, и всё это без пере-загрузки компьютера.

<p>
Модули хранятся в каталоге <tt>/lib/modules/&lt;kernel version&#62;</tt> вашей системы.  Они могут быть загружены во время загрузки компьютера из <tt>rc.modules</tt> файла. В этом файле есть очень много комментариев и примеров для типичных устройств. Для просмотра загруженных модулей воспользуйтесь командой <b>lsmod</b>(1):

<p>

<table>
<tr><td><tt># </tt><b>lsmod</b> </td><td></td><td></td></tr>
<tr><td>Module       </td><td>Size </td><td>Used by</td></tr>
<tr><td>parport_pc  </td><td>7220 </td><td>0</td></tr>
<tr><td>parport      </td><td>7844 </td><td>0  [parport_pc]</td></tr></table>


<p>
Как видно из примера, у меня загружен только модуль параллельного порта.  Для выгрузки модуля используйте команду <b>rmmod</b>(1). Модули могут быть загружены командами <b>modprobe</b>(1) или <b>insmod</b>(1). <b>modprobe</b> обычно безопаснее, так как автоматически загрузит модули, необходимые для модуля, который вы пытаетесь загрузить.

<p>
Большинство пользователей никогда не загружают или выгружают модули вручную.  Они пользуются загрузчиком ядра для менеджмента модулей. Всё что вам надо сделать, это раз-комментировать строчку <b>/sbin/kerneld</b>(8) в <tt>/etc/rc.d/rc.modules</tt> и автозагрузчик запустится. Он позаботится о загрузке и выгрузке модулей по мере надобности. Автозагрузчик определяет, что нужно загрузить модуль по обращению к устройству, для которого в данный момент модуль не загружен.

<p>
Вы можете найти больше информации в man страницах для каждой из команд, а так же в <tt>rc.modules</tt> файле.

<p>
     <h3><a name="tth_sEc4.1.3">
4.1.3</a>&nbsp;&nbsp;Итог</h3>

<p>
Должно быть, вы теперь знакомы с командами для поиска в файловой системе, с устройством файловой системы, а так же с файлами настроек в каталоге <tt>/etc</tt>. Эти знания будут вам крайне полезны при более подробном изучении системы. В добавок к этому, вы должны были узнать, как настроить и компилировать ядро из исходников.

<hr />
<table width="100%"  CELLSPACING="1" CELLPADDING="1" >
<tr>
<td align="left"><a href="install.html">Предыдущий</a></td>
<td align="center"><a href="index.html">Содержание</a></td>
<td align="right"><a href="conf_2.html">Следующий</a></td>
</table>
<hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 2.89.<br />On 24 Apr 2001, 16:43.</small>
</html>