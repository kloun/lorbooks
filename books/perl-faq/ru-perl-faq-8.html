<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>FAQ по perl и программированию для web: БД на плоских файлах</TITLE>
 <LINK HREF="ru-perl-faq-9.html" REL=next>
 <LINK HREF="ru-perl-faq-7.html" REL=previous>
 <LINK HREF="http://books.gnu.technology/books/perl-faq/ru-perl-faq.html#toc8" REL=contents>
</HEAD>
<BODY>
<A HREF="ru-perl-faq-9.html">Next</A>
<A HREF="ru-perl-faq-7.html">Previous</A>
<A HREF="http://books.gnu.technology/books/perl-faq/ru-perl-faq.html#toc8">Contents</A>
<HR>
<H2><A NAME="БД на плоских файлах"></A> <A NAME="s8">8. БД на плоских файлах</A></H2>

<P>
<H2><A NAME="ss8.1">8.1 Я хочу какую-нибудь простейшую БД и прямо сейчас!</A>
</H2>

<P>
<P>Вы можете использовать простой текстовый файл с разделителями. Например, если
мы пишем нечто типа телефонной книги, то вполне вероятно предположить, что ни
в чьем  имени, ни в номере телефона не встретится последовательность ::, так
что именно ее и можно использовать в качестве разделителей.
<P>Файл с данными может выглядеть так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
phones.data
Иванов И.И.::888-0000::Какая-то улица, 17, кв 40
Сидоров П.И.::888-8429::Другая улица, 5, кв 21
...... и тд.
</PRE>
</CODE></BLOCKQUOTE>
<P>тогда программа, которая читает данные, может быть примерно такого вида:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dump_phones.pl
#!/usr/bin/perl
$filename = 'phones.data';
# открываем файл
open DATA, $filename or die "Невозможно открыть $filename: $!";

# читаем построчно из файла
while (&lt;DATA&gt;) {
        chomp; # удаление символа конца строки
        # теперь в $_ есть строка и мы ее разделяем на переменные
        ($name, $phone, $address) = split(/::/);
        # и выведем на печать
        print "Имя: $name, телефон: $phone, адрес: $address\n";
}
close DATA;
</PRE>
</CODE></BLOCKQUOTE>
<P>Больше проблем возникает в случае, если надо удалить или отредактировать
запись, но и их можно довольно просто и элегантно решить, если использовать
механизм редактирования на месте (inplace edit) -- при использовании операции
"ромб"(&lt;&gt;), можно читать из одного файла, а писать в другой:
<P>
<BLOCKQUOTE><CODE>
<PRE>
change_phones.pl
#!/usr/bin/perl 
$^I = '~'; # запускаем inplace edit
while (&lt;>) { # Обратите внимание, что мы не открывали файл: при такой
        #конструкции имя файла берется из командной строки
        chomp;
        ($name, $phone, $address) = split(/::/);
        if (.... некоторое условие, при котором мы оставляем наши данные ... )
        {
                print "$name::$phone::$address\n"; # теперь данные есть в новом файле
        }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>если запустить это программу как
<PRE>
change_phones.pl phones.data,
</PRE>

то в текущем каталоге будут два файла: phones.data, с записями, которые
удовлетворили нашим условиям и phones.data&nbsp; -- предыдущая копия.
<P>Также, во многих случаях, всю программу такого типа можно записать как
one-liner: 
<PRE>
perl -i~ -n -e 'print if(... условие)'
</PRE>
<P>
<H3>Двоичные файлы</H3>

<P>
<P>Для чтения двоичных файлов в Perl можно использовать функции read и unpack.
К примеру, если использовать двоичный файл для хранения телефонной книги такого
формата:
<P>
<P>40 символов -- фамилия, И.О. 
<P>10 символов -- номер телефона, 
<P>60 символов -- адрес,
<P>
<P>то строка описания формата для unpack будет выглядеть так:
<PRE>
$format_str = 'A40 A10 A60'
</PRE>
, а сама программа, аналогичная 
первому примеру:
<BLOCKQUOTE><CODE>
<PRE>
binary_phones.pl
#!/usr/bin/perl
$format_str = 'A40 A10 A60';
open DATA, 'binary.dat' or die "$!";
while (read(DATA, $buf, 40+10+60)) { # &lt;DATA> не покатит: такая
# конструкция будет читать до символа перевода строки, а это не то, что нужно
        ($name, $phone, $address) = unpack($format_str, $buf);
        # Теперь в $name, $phone, $address есть данные и с ними можно делать
        # все, что захочется
}
close DATA;
</PRE>
</CODE></BLOCKQUOTE>
<P>Чтобы вывести в файл такую запись можно использовать конструкцию типа 
<P><CODE>print FILE pack($format_str, $name, $phone, $address);</CODE>
<P>
<H2><A NAME="ss8.2">8.2 Можно ли как-нибудь из Perl получить доступ к dbf файлам?</A>
</H2>

<P>
<P>Да, можно. На 
<A HREF="http://www.fi.muni.cz/~adelton/">http://www.fi.muni.cz/~adelton/</A> есть модуль XBase, который
позволяет читать/писать dbf. При чтении он даже поддерживает индексы.
Кроме того, в комплект поставки также входит модуль DBD::XBase, при помощи
которого можно оперировать dbf на SQL (более подробно про DBI -- далее).
<P>
<H2><A NAME="ss8.3">8.3 А к MS access .mdb?</A>
</H2>

<P>
<P>К файлам MS Access нельзя обращаться из perl напрямую, по крайней мере, в
настоящее время.
<P>К MS Access можно обращаться по ODBC, при помощи DBD::ODBC.
<P>
<H2><A NAME="ss8.4">8.4 Зачем и как нужно запирать (lock) файлы?</A>
</H2>

<P> 
<P>Представьте себе ситуацию когда одновременно работают несколько копий одной и
той же программы (к примеру, cgi-скрипты, обслуживающие запросы),
читающие/пишущие в один файл, тогда рано или поздно возникнет ситуация при
которой один скрипт прочитал данные, произвел над ними некоторые действия и
собрался записать их назад в файл, но в это же время другой скрипт тоже
прочитал данные, тоже произвел над ними действия, но (!) он прочитал старые
данные, которые он и запишет поверх данных, выданных другим скриптом. Таким
образом, в файле останутся данные записанные одним из скриптов -- в лучшем
случае, в худшем -- структура файла будет испорчена.  Чтобы этого избежать в
Unix и большинстве других ОС есть системный вызов flock(2) или
аналогичный.
<P>
<H3>Как использовать flock</H3>

<P>К примеру, скрипт который записывает имена вызывающих хостов в файл. (На деле
такой список, конечно, можно получить из журнала регистрации web-сервера).
<BLOCKQUOTE><CODE>
<PRE>
lock_exm.pl
#!/usr/bin/perl
use Fcntl; # Импорт констант
open (HOSTS, '>>hosts.log'); # Файл открыт для добавления записи
flock(HOSTS, LOCK_EX); 
# Теперь файл заблокирован: Если любой другой скрипт тоже вызовет flock на
# этом файле, его flock не вернет управление в программу, пока мы не
# разблокируем файл. Обратите внимание: flock -- декларативная функция, если
# один из скриптов ее не использует при записи, то вся ваша блокировка не
# работает.
print HOSTS $ENV{REMOTE_HOST}, "\n"; # записали строку
close HOSTS; # Файл при закрытии разблокируется автоматически

# Вывести сообщение для пользователей
print "Content-Type: text/plain\n\n";
print "Название вашего хоста записано\n";
</PRE>
</CODE></BLOCKQUOTE>
<P>Более подробный рассказ о flock и пример доступны на
<A HREF="http://w3.stonehenge.com/merlyn/WebTechniques/col04.html">http://w3.stonehenge.com/merlyn/WebTechniques/col04.html</A><P>
<H2><A NAME="ss8.5">8.5 Чего делать на системах</A>
</H2>

<P>
<P>Судя по perlfaq5(1), можно использовать модуль File::Lock с CPAN.
<P>
<HR>
<A HREF="ru-perl-faq-9.html">Next</A>
<A HREF="ru-perl-faq-7.html">Previous</A>
<A HREF="http://books.gnu.technology/books/perl-faq/ru-perl-faq.html#toc8">Contents</A>
</BODY>
</HTML>
