<HTML>
<HEAD>
 <TITLE>Еще несколько "переключателей".</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">
   <H2>Еще несколько "переключателей".</H2>

<P>
   Предположим, что у вас раскладка с четырьмя группами (больше вам не
позволит XKB).

<P>
  Причем, опять же, первая группа - "латиница". А остальные три -
варианты "русской" раскладки (например - <B>koi8, alt, cp1251</B>).

<P>
  И опять же, нам хочется, чтобы основной переключтель имел только два
состояниия - <B>"лат"/"какой-нибудь рус"</B>.

<P>
  Попробуем придумать какой-нибудь переключатель для выбора одной из
трех "альтернативных" раскладок. Понятно, что одним переключателем
с двумя состояниями мы тут не обойдемся (хотя можно сделать один с тремя
состояниями, но я его рассматривать не буду).

<P>
  Давайте поступим радикально - выберем три кнопки, и пусть каждая включает
свою группу.

  <H4>Как это можно сделать?</H4>

<UL>
	<LI><A HREF="example4.html#1">Вариант первый - "выделенные скан-коды".</A>
	<LI><A HREF="example4.html#2">Вариант второй - "перекрытия".</A>
</UL>
<P>
  Прежде всего, хочу заметить, что я не могу предложить вам раскладку
с четырьмя группами (откуда я знаю - что вы в них хотите "вложить").

<P>
  Но если вам надо только поэкспериментировать, можно взять одну из
кнопок (не обязательно "буквенную") и "навесить" на нее четыре группы.

<P>
  Я сделал такую кнопку из клавиши "1".

<PRE>
key &lt;AE01&gt; {	[   1, exclam ],
		[   2, exclam ],
		[   3, exclam ],
		[   4, exclam ]  };
</PRE>
 (значение клавиши отражает текущий номер группы :-). 

<P>
  Итак.

  <H3><A NAME="1">Вариант первый - "выделенные скан-коды".</A></H3>

<P>
  Возьмем за основу метод, рассмотренный в предыдущих примерах - две
переменные для номера группы.

<P>
 Пусть у нас дополнительная переменная (например - <B>base group</B>) хранит
номер альтернативной группы. Забудем пока про "гнусное поведение" base group
(что она хранит значение только пока нажата соответствующая клавиша).

<P>
  Тогда пусть основной переключатель манипулирует значением в <B>locked group</B>.
<BR>Он должен
<UL>
<LI> для выбора <B>"одной из рус"</B> просто "обнулить" <B>locked group</B>
<LI> для "возвращения" в <B>"лат"</B> записать в <B>locked group</B> подходящую "добавку".
</UL>

<P>
  Для вычисления "добавки" на время перейдем к "внутренним представлениям
номера группы" - 0,1,2...
<BR>  Тогда
<UL>
	<LI> группа "лат" - 0
	<LI> первая "рус" - 1
	<LI> вторая "рус" - 2
	<LI> третья "рус" - 3
	<LI> максимальное значение номера группы - 3
</UL>

  "Добавки"
<UL>
	<LI> если текущая группа - 0, "добавка" - 0
	<LI> если текущая группа - 1, "добавка" - 3
	<LI> если текущая группа - 2, "добавка" - 2
	<LI> если текущая группа - 3, "добавка" - 1
</UL>

<P>
  Возвращаясь к обозначениям групп из "конфигов", описание клавиши - основного
переключателя получится

<PRE>
key &lt;CAPS&gt; {	[NoSymbol], [NoSymbol], [NoSymbol], [NoSymbol],
		actions[Group1]=[ LockGroup(group=1) ],
		actions[Group2]=[ LockGroup(group=4) ],
		actions[Group3]=[ LockGroup(group=3) ],
		actions[Group4]=[ LockGroup(group=2) ] };
</PRE>

  Все хорошо. Но что нам делать с дополнительным переключателем
(переключателями)?

<P>
  Давайте сформулируем - как должны работать наши переключатели.
<BR>Итак, у нас три кнопки, каждая включает свою <B>"рус"</B>. Поскольку они должны
сохранять соответствующие значения в <B>base group</B>, мы должны повесить
на них "действия" <B>SetGroup</B> (с подходящим аргументом). Естественно, поскольку
<B>base group</B> "держит" значение только пока нажата соответствующая клавиша,
наши кнопки должны быть "залипающими". Но при этом...

<P>
  Если мы нажали кнопку, ответственную за первую "рус", она должна записать
свое значение в <B>base group</B> и "залипнуть". Если мы после этого нажмем кнопку,
отвечающую за вторую "рус", она должна
<UL>
<LI> "отлепить" "залипшую" кнопку
<LI> выполнить свое "действие"
<LI> и, в свою очередь, "залипнуть".
</UL>
  Аналогично должна работать и третья кнопка (из дополнительных переключателей).

<P>
  Но то, что я только что описал, точь в точь описывает поведение кнопок,
принадлежащих одной <A HREF="internals.html#radio">"радио-группе"</A>.

<P>
  Ну и отлично! Объединим наши три дополнительных переключателя в радио-группу,
подвесим на них <B>SetGroup</B> с соответствующими аргументами, и... все.

<P>
  Однако, "засада" в этом решении (как же без "засады"?) в том, что "залипает"
именно клавиша (скан-код), а не отдельное ее "действие" (или символ). То есть,
нам понадобятся три кнопки, которые будут использоваться только для этих
целей и ни для чего больше, поскольку, даже если мы и "подвесим" на них еще
какие-нибудь символы (ну, например, на другой <B>shift level</B>), то воспользоваться
ими все равно не сможем. Так как -
<UL>
 <LI> кнопка будет "залипать" в любом случае, независимо от того - какая группа
и уровень выбраны;
 <LI> если уж она "залипла", то использовать ее, пока не "отлипнет", невозможно.
</UL>

<P>
  Итак. Нам придется выделить на клавиатуре три кнопки, которые будут только
переключателями "альтернативных" "русских" групп и ничем больше.
<BR>(Не огорчайтесь, потом мы это ограничение снимем :-)

<P>
  Я предлагаю взять кнопки <B>F10, F11, F12</B>. Они стоят рядом и используются
сравнительно редко.

<P>
  Можно составлять их описание (это скан-коды <B>&lt;FK10&gt;,&lt;FK11&gt;,&lt;FK12&gt;</B>)

<PRE>
key &lt;FK10&gt; { 	radiogroup=2, [NoSymbol],
		actions[Group1]=[ SetGroup(group=2) ] };
key &lt;FK11&gt; { 	radiogroup=2, [NoSymbol],
		actions[Group1]=[ SetGroup(group=3) ] };
key &lt;FK12&gt; { 	radiogroup=2, [NoSymbol],
		actions[Group1]=[ SetGroup(group=4) ] };
</PRE>

<P>
  Обратите внимание, что номер радио-группы должен быть больше единицы.
Вообще-то, это "баг" XKB, тем более неприятный, что <B>xkbcomp</B> не будет
"возражать" если вы объявите радио-группу номер 1, а вот X-сервер потом
"сдуреет".

<P>
  Теперь можно пробовать.
<BR>  Надо заметить, что есть еще одно маленькое неудобство. В самом начале,
пока еще не нажата ни одна из кнопок радио-группы, получается, что ни одна
из альтернативных "рус" раскладок не выбрана и основной переключатель не будет
ничего переключать.

<P>
 Но после первого же нажатия одного из "дополнительных переключателей"
все будет работать как задумано. (Если не считать того, что опять же - менять
номер альтернативной группы надо только тогда, когда основной переключатель
находится в положении "рус". Иначе результаты получаются не очень приятные).

   <H3><A NAME="2">Вариант второй - "перекрытия".</A></H3>

<P>
  Конечно, предыдущий вариант имеет очень серьезный недостаток - три клавиши
"изымаются из общего пользования".
<BR>  Давайте, все-таки попытаемся вернуть их обратно.

<P>
  Эта проблема легко решилась бы, если бы могли свободно добавлять на свою
клавиатуру новые кнопки (не символы, а именно - физические кнопки).

<P>
  Хотя это и звучит как пустые фантазии, но не лишено смысла. Конечно, новую
физическую кнопку мы на клавиатуре не сделаем, но вот скан-кодов к
существующим кнопкам добавить можем.

<P>
  Напомню, что если кнопка принадлежит к <A HREF="internals.html#overlay">"группе перекрытия"</A> (<B>overlay</B>),
она может эмулировать нажатие другой кнопки (с другим скан-кодом),
естественно, эта другая кнопка не обязана физически присутствовать на
клавиатуре и може быть вполне "виртуальной". К тому же, та кнопка,
которая будет эмулировать "виртуальную" не обязана заниматься этим все
время. Для того, чтобы он перешла в такой режим, нужно "поднять" <A HREF="internals.html#controls">"управляющий
флаг"</A> <B>Overlay1</B> ( или <B>Overlay2</B>), а все остальное время она может ваполнять
свои "основные обязанности".

<P>
  В свою очередь, "управляющий флаг" можно "выставить" с помощью специального
"действия" (такого же как <B>SetGroup</B> или <B>SetMods</B>), причем можно сделать так,
чтобы этот флаг "держался" только пока нажата соответствующая кнопка.

<P>
  Итак. Давайте сначала объявим скан-коды "виртуальных" кнопок.
Заглянем в файл типа <B>xkb_keycodes</B> (скорее всего у вас это <B>keycodes/xfree86</B>).

<P>
  Можно заметить, что под реальные кнопки задействованы скан-коды от 9 до 120
(ну, на самом деле - даже меньше, в зависимости от типа клавиатуры).
<BR>  То есть, мы для своих нужд можем спокойно взять скан-коды, например - 121,
122, 123.

<P>
  Сочиним файл-"добавку" к описанию <B>keycodes</B> (не забудьте его "приплюсовать"
к полной конфигурации в строчку, описывающую <B>xkb_keycodes</B>).

<PRE>
xkb_keycodes {
   &lt;RUS1&gt; = 121;
   &lt;RUS2&gt; = 122;
   &lt;RUS3&gt; = 123;
};
</PRE>
(напомню, что "название скан-кода" может быть произвольное, но не длинее 4
символов).

<P>
  Теперь мы можем наши "действия" убрать с реальных кнопок <B>&lt;FK10&gt; - &lt;FK12&gt;</B>
и "повесить" на наши виртуальные (просто поменяем названия скан-кодов) -

<PRE>
key &lt;RUS1&gt; { 	radiogroup=2, [NoSymbol],
		actions[Group1]=[ SetGroup(group=2) ] };
key &lt;RUS2&gt; { 	radiogroup=2, [NoSymbol],
		actions[Group1]=[ SetGroup(group=3) ] };
key &lt;RUS3&gt; { 	radiogroup=2, [NoSymbol],
		actions[Group1]=[ SetGroup(group=4) ] };
</PRE>

<P>
  Дальше нам надо решить - на какие реальные кнопки мы возложим задачу
эмулировать наши виртуальные клавиши.

<P>
  Поскольку это никак не "ущемляет" реальную кнопку (ее основные обязанности),
выбирать мы можем так - как нам будет удобнее. Можно для этого выбрать
"цифровые" кнопки - 1,2,3. А можно - какие-нибудь "буквенные", например -
<B>K (koi8), A (alt), W (Windows)</B>.
<BR>  Я остановлюсь на первом варианте.

<P>
  Итак. Описание реальных кнопок (можно не писать их заново, а просто добавить
нужную строчку в те описания, которые уже должны быть в нашей раскладке) -

<PRE>
key &lt;AE01&gt; {	overlay1 = &lt;RUS1&gt;,
		[	1,  exclam ],
		[  exclam,       1 ] };

key &lt;AE02&gt; {	overlay1 = &lt;RUS2&gt;,
		[	2,	at ],
		[ quotedbl,	 2 ] };

key &lt;AE03&gt; {	overlay1 = &lt;RUS3&gt;,
		[   3,  numbersign ],
		[ apostrophe,	 3 ] };
</PRE>

<P>
  Осталось только выбрать кнопку, которая будет "махать флагом" и превращать
наши реальные кнопки в виртуальные. В общем-то, это может быть не одиночная
кнопка, а комбинация кнопок, но не забудьте, что вместе с этой "комбинацией"
нам надо будет нажимать и одну из "виртуальных" кнопок (пальцев хватит?).

<P>
  Я остановлюсь на той же <B>&lt;MENU&gt;</B>.
<BR>  Нам нужно "подвесить" на нее "действие" <B>SetControls(controls=overlay1)</B>.
Напомню, что это "действие" "держит" флаг только пока кнопка нажата.
То есть, кнопки 1-2-3 нажатые вместе с <B>Menu </B>(<B>Menu+1, Menu+2, Menu+3</B>) будут
действовать как дополнительные переключатели. А если кнопку Menu не трогать,
то эти клавиши работают как обычно.

<PRE>
key &lt;MENU&gt; {	[NoSymbol],
		actions[Group1]=[ SetControls(controls=overlay1) ]};
</PRE>

<P>
  Все. Можно попробовать.
<BR>(Если это не будет работать, попробуйте заменить <B>SetControls</B> на <B>LockControls</B>.
Естественно, в этом случае клавишу <B>&lt;MENU&gt;</B> не надо удерживать в нажатом
состоянии. По первому нажатию она будет "включать" управляющий флаг <B>overlay1</B>
и кнопки 1-2-3 превратятся в переключатели групп, а по повторному нажатию
флаг <B>overlay1</B> будет "сбрасываться" и кнопки 1-2-3 вернутся к своей "основной
работе").

<P>
  На этом я заканчиваю свои примеры, хотя можно было бы выдумать еще
пару-тройку переключателей.

<P>
  Но, основные механизмы (и "подводные камни") я описал. Все остальное
зависит от вашей фантазии.

<hr>
<p>Иван Паскаль <a href=mailto:pascal@tsu.ru> pascal@tsu.ru </a>
</BODY>
</HTML>
