<HTML>
<HEAD>
 <TITLE>Почему руссификация через XKB не работает?</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

   <H2>Почему руссификация через XKB не работает?</H2>

<UL>
	<LI><A HREF="problems.html#who">Кто виноват?</A>
	<UL>
		<LI><A HREF="problems.html#codes">Что такое "русские буквы"?</A>
		<LI><A HREF="problems.html#LookupString">Процедуры Xlib для преобразования кодов.</A>
		<LI><A HREF="problems.html#locale">Что значит - "установить locale"?</A>
		<LI><A HREF="problems.html#Xsetlocale">"Иксовая" setlocale().</A>
		<LI><A HREF="problems.html#programms">Программы "правильные" и "неправильные".</A>
		<LI><A HREF="problems.html#other">Почему работают другие способы руссификации?</A>
		<LI><A HREF="problems.html#wrong">Почему иногда вводятся "не те буквы"?</A>
	</UL>
	<LI><A HREF="problems.html#What">Что делать?</A>
	<UL>
		<LI><A HREF="problems.html#What-system">Настройка системы.</A>
		<LI><A HREF="problems1.html#What-programs">Что делать с "неправильными" программами?</A>
		<LI><A HREF="problems1.html#hack">Методы "грубого хака".</A>
	</UL>
</UL>
<P>
  К сожалению, настроить XKB с "русской" раскладкой клавиатуры - это еще
"полдела".
<BR>  Очень часто при этом русские буквы вообще "не вводятся" или вводятся,
но "не те", или вводятся, но "не везде" (не во всех программах).

    <H2><A NAME="who">Кто виноват?</A></H2>

    <H3><A NAME="codes">Что такое "русские буквы"?</A></H3>

<P>
  Давайте не поленимся и рассмотрим проблему с самого начала.
<BR>Под русским алфавитом в Юниксах обычно понимают кодировку <B>KOI8-R</B> (хотя иногда
используется <B>iso-8859-5</B> или "вариации на тему" <B>KOI8-R - KOI8-U</B>).
<BR>  В этой кодировке русские буквы занимают коды 0xc0-0xff (в кодах 0x40-0x7f
расположены латинские буквы).

<P>
  Но в этом же диапазоне могут размещаться
<UL>
	<LI> буквы национальных алфавитов стран Западной Европы (буквы с "шляпкой",
	"тильдой", "умлаутом" и т.п.)
	<LI> греческий алфавит
	<LI> арабский алфавит
	<LI> и т.п.
</UL>
  То есть, на одно и то же место в "кодовой таблице" претендуют куча разных
алфавитов.

<P>
  Попытки совместить весь этот "зоопарк" в X-Window, привели к тому, что
под код символа в раскладке клавиатуры были выделены два байта. В старшем
байте хранится некий номер определяющий charset (набор символов), а в
младшем - собственно код символа. (В общем, идея та же что и у UNICODE,
хотя это и не "уникод").

<P>
  Кстати, "кириллическому" алфавиту (не обязательно "русскому") достались
коды, у которых в старшем байте число 6 (признак "кириллицы"), а младший байт
содержит код, который совпадает, как правило, с кодом буквы в koi8-r
(хотя это и не так уж важно, как мы увидим в дальнейшем).

<P>
  Называются эти символы - Cyrillic_a, Cyrillic_be, Cyrillic_tse и т.д.
Обычно про них говорят - Cyrillic коды.

<P>
  Итак. При нажатии клавиши, когда активна "русская" раскладка, в программу
должны попадать двубайтные Cyrillic коды.

<P>
  Но проблема в том, что большинство программ внутри хранит строки
(и выдает их на экран) как цепочку байтов. То есть, двубайтные коды на входе
в программу должны быть преобразованы в однобайтные. При этом, естественно,
часть информации (принадлежность символа к конкретному национальному алфавиту)
теряется.

  <H3><A NAME="LookupString">Процедуры Xlib для преобразования кодов.</A></H3>

<P>
  Для такого преобразования в <B>Xlib</B> существует две процедуры - <B>XLookupString</B>
и <B>XmbLookupString</B> (<B>mb</B> означает - <B>"multi byte"</B>). В качестве аргумента
этим подпрограммам передается "сообщение о нажатии" (или отпускании) клавиши
(Key Press Event), а "на выходе" должен получаться однобайтный код символа.
<br>(Строго говоря, есть еще одна аналогичная процедура - <B>XwcLookupString</B>
(<B>wc</B> означает - <B>"wide char"</B>). Но она используется крайне редко.)

<P>
  Надо отметить, что в большинстве современных программ выбор конкретной
процедуры происходит следующим образом.

<P>
  Процедура <B>XLookupString</B> более "древняя" и более "глупая". Процедура
<B>XmbLookupString</B> более сложная и более гибкая, но в своей работе пользуется
"input context'ом" текущего "окна". Не вдаваясь в подробности, можно сказать,
что "input context" - это некий объект, описывающий особенности ввода (input)
в "свое окно", и содержащий список "методов" для различных преобразований
входных цепочек символов.

<P>
  Поэтому, большинство "иксовых" программ пытаются создать для своих "окон"
input context. И, если им это удается, используют <B>XmbLookupString</B>,
а если по каким-то причинам input context не может быть создан, то
используют <B>XLookupString</B>.


<P>
  Так вот. Для того, чтобы избежать путаницы в алфавитах, обе эти процедуры
ориентируются на "текущую locale" (которая, в частности, определяет
"национальный" алфавит с которым в данный момент работает система).


<P>
  Если вы не знаете - что такое locale, могу порекомендовать сайт -
<A HREF="http://www.sensi.org/~alec/locale/">"Locale AS IS"</A>,
 где это об этом рассказано достаточно подробно (и по русски!).


<P>
  Здесь замечу только, что ...
<UL>
<LI> программы обычно узнают о текущей locale из
"переменных окружения" (environment) <B>LANG</B>, или <B>LC_ALL, LC_CTYPE</B> и т.п.;
<LI> для каждой locale в системе существует набор файлов, в которых содержится
вся информация "зависящая от языка" (и, соответствено - алфавита);
<LI> в системе X-Window (а ее можно рассматривать как отдельную ОС), основными
файлами, описывающим "категории locale" является файлы <B>XLC_LOCALE</B>, разложенные
по отдельным поддиректориям в директории <B>X11R6/lib/X11/locale</B>. Каждая
поддиректория соответствует одной конкретной locale.
<LI> процедуры <B>Xlib</B> в своей работе используют некоторые значения (какие именно -
рассмотрим чуть позже), описанные в файле <B>XLC_LOCALE</B>.
</UL>


<P>
  Кроме того надо заметить, что не бывает "никакой locale". Если locale не
задана "переменными окружения" или задана, но такая, что система затрудняется
найти нужные файлы, то будет использоваться locale - "<B>C</B>".

 
<P>
 Так вот. При старте программа должна установить нужную locale (ниже мы
поговорим об этом немного подробнее).
Библиотека <B>Xlib</B> найдет соответствующий файл, описывающий эту locale.
Процедуры <B>*LookupString</B> по этому описанию будут принимать решение - как
преобразовать двубайтные коды (в нашем случае - Cyrillic коды) в однобайтные
символы.


<P>
  Если заглянуть немного глубже в работу этих процедур, то можно заметить, что
<UL>
 <LI> обе процедуры ориентируются на параметр locale (точнее, он назывется -
класс) - <B>encoding_name</B>;
 <LI> значение этого класса (для работы с Cyrillic) должно быть <B>KOI8-R</B> или
<B>ISO8859-5</B>;
 <LI> в зависимости от значения этого класса...
<UL>
   <LI> если он <B>KOI8-R</B> - Cyrillic превращаются в однобайтные коды <B>koi8-r</B>
   <LI> если <B>ISO8859-5</B> - Cyrillic превращаются в коды <B>iso8859-</B>5
   <LI> если ни то ни другое - Cyrillic вообще ни во что не преобразуется.
То есть "на выход" выдается строчка нулевой длины. Это и выглядит как
"русские буквы не вводятся".
</UL>
</UL>
(Надо отметить, что эти названия "зашиты" в библиотке <B>Xlib</B> вместе с таблицами
перекодировки. Поэтому никакими внешними файлами изменить их, или добавить
новые, нельзя.)


<P>
  Кстати, если locale "никакая" (то есть - <B>C</B>), или <B>encoding_name</B> не определен,
то нормально вводятся коды "национальных алфавитов Западной Европы", которые
занимают то же место в кодовой таблице, что и <B>koi8-r</B>. А если нормально
преобразуются коды Cyrillic, то наоборот - "подавляется" ввод
"западноевропейских" символов.


<P>
  Кроме того, есть отличия в работе двух <B>*LookupString</B>.
<UL>
   <LI> <B>XLookupString</B> прежде всего пытается взять <B>encoding_name</B> из "переменной
окружения" <B>_XKB_CHARSET</B>. Если такая переменная есть, то используется ее
значение и locale устанавливать не нужно.
   <LI> <B>XmbLookupString</B>, напротив, не только обязательно требует правильной
locale, но и еще использует в своей работе значение двух классов -
<B>encoding_name</B> и <B>ct_encoding</B> (<B>ct - "compaund text"</B>). Поэтому, для ее
нормальной работы, значения этих двух классов должно совпадать (по крайней
мере - для "кириллицы").
</UL>

  <H3><A NAME="locale">Что значит - "установить locale"?</A></H3>



<P>
  Конечно, об этом лучше прочитать в man'ах или уже упомянутой 
  <A HREF="http://www.sensi.org/~alec/locale/">"Locale AS IS"</A>.
<BR>Но я постараюсь вкратце описать основные моменты этого действа.


<P>
  Во-первых, надо заметить, что существует "системная" locale (или
"libc'ишная"), которая влияет на работу процедур <B>libc</B>, а не "иксов".

<P>
  В X-Window существует как бы "продолжение" этой locale - дополнительные
файлы, в которых описываются параметры влияющие на работу процедур из
<B>Xlib</B>.


<P>
  Для того, чтобы программа "настроила" <B>libc</B> под нужную locale, она вызывает
в начале процедуру <B>libc</B> - <B>setlocale()</B>.

<P>
  Вызов это процедуры имеет три формы (возможно, так о них не говорят, но
мне легче будет ссылаться)
<OL>
  <LI> <B>setlocale(..., "ru_RU.KOI8-R")</B> - в вызове явно указывается - какую locale
требуется установить;
  <LI> <B>setlocale(..., "")</B> - в этом случае процедура пытается взять название
соответствующей "категории locale" (вот что это такое, я объяснять не буду),
заданной первым аргументом, из "одноименной" переменной окружения; если
такой пременной нет, то из переменной окружения <B>LANG</B>, если и такой нет,
то locale будет "никакая", то есть - <B>"C"</B>.
  <LI> <B>setlocale(..., NULL)</B> - а вот это, скорее, не "<B>set</B>",
а "<B>get</B>", поскольку
она ничего не устанавливает, а наоборот - возвращает название locale,
которое было установленно с помощью одной из первых двух форм вызова
<B>setlocale()</B>. 
</OL>


<P>
  Итак. Для того, чтобы "установить locale" ("libc'ишную"), программа
вызывает <B>setlocale()</B> в первой или второй форме. Обычно используется вторая
форма, поскольку это позволяет пользователю гибко менять текущую locale
с помощью переменных окружения.


<P>
  Если программа "иксовая", то есть использует <B>Xlib</B>, то при первых же вызовах
процедур <B>Xlib</B>, зависящих от locale, происходит настройка "иксовой" locale.

<P>
  Надо заметить, что это делается автоматически. То есть никаких дополнительных
вызовов не требуется.
 
<P>
 Соответствующие процедуры <B>Xlib</B> узнают название текущей "libc'ишной" locale
с помощью "третей формы вызова" <B>setlocale()</B> (это важно!) и по этому названию
пытаются найти соответствующий файл (<B>XLC_LOCALE</B>), содержащий "иксовые"
компоненты locale.

<P>
  Для этого они ищут подходящую поддиректорию в файле
<B>X11R6/lib/X11/locale/locale.dir</B>. Если там название не находится, то сначала
пытаются "подменить" его с помощью файла <B>X11R6/lib/X11/locale/locale.alias</B>,
а потом, опять же, найти с помощью <B>locale.dir</B>. (Содержимое этих файлов
достаточно понятно без дополнительных пояснений.)
<BR>  Если и после этого "ничего подходящего" не находится, то используется
"иксовая" locale <B>"C"</B> (хотя "libc'ишная" может быть другая).


<P>
  Таким образом, для "настройки locale", как "системной", так и "иксовой",
необходимо в начале программы вызвать "libc'ишную" процедуру <B>setlocale()</B>.


<P>
  И вот здесь есть одна тонкость...

  <H3><A NAME="Xsetlocale">"Иксовая" setlocale().</A></H3>



<P>
  Дело в том, что процедуры <B>Xlib</B> для того, чтобы узнать название "текущей
locale" используют "третью форму" вызова "libc'ишной" <B>setlocale()</B>.

<P>
  Но, на тот случай, если в "системной" <B>libc</B> нет такой процедуры, в <B>Xlib</B>
существует "заглушка" - (вообще-то, она называется<B>_Xsetlocale()</B>), которая может
вызываться вместо системной <B>setlocale()</B>.

<P>
  Для того, чтобы работала "заглушка", библиотека <B>Xlib</B> должна быть собрана
с "опцией"
<PRE>
#define	X_LOCALE
</PRE>
(при этом вызовы <B>setlocale()</B> автоматически заменяются на вызовы <B>_Xsetlocale()</B>)

<P>
  Надо заметить, что "иксовая" <B>setlocale()</B>, хотя и вызывается точно так же,
как и "системная" (те же три формы вызова), имеет некоторые отличия во
"второй форме" (наиболее популярном способе установки "текущей locale").
<UL>
  <LI> Категории (первый аргумент) могут быть только <B>LC_ALL</B> или <B>LC_CTYPE</B>.
  <LI> При этом название locale она пытается взять из переменных окружения
<B>LC_CTYPE</B> и, если не получилось - <B>LANG</B>.
  <LI> На переменную окружения <B>LC_ALL</B> она внимания не обращает (даже если
первый аргумент - "категория" <B>LC_ALL</B>).
</UL>
  Ну и, естественно, эта "заглушка" устанавливает только "иксовые" параметры
locale, а не "libc'ишные".


<P>
  Так вот. Проблемы могут возникнуть, если у вас в системе <B>Xlib</B> почему-то
собрана с "опцией" <B>X_LOCALE</B>, хотя в <B>libc</B> соответствующая процедура имеется.

<P>
  Тогда вызов <B>setlocale()</B> из <B>libc</B> запомнит название locale в своих внутренних
переменных, а процедуры <B>Xlib</B> будут спрашивать "текущую locale" у своей
"заглушки", которая, естественно, ее не знает.


<P>
  Если уж у вас <B>Xlib</B> собрана с <B>X_LOCALE</B>, то и программы должны вызывать
не "системную" <B>setlocale()</B>, а "иксовую".

<P>
  Для этого перед вызовом <B>setlocale()</B> должно стоять
<PRE>
#define	X_LOCALE
#include &lt;X11/Xlocale.h&gt;
</PRE>


<P>
  Если <B>Xlib</B> "нормальная" (то есть ориентруется на "системную" <B>setlocale</B>),
то этих строчек не нужно. (Хотя, конечно, понадобится <B>#include &lt;locale.h&gt;</B>)

  <H3><A NAME="programms">Программы "правильные" и "неправильные".</A></H3>



<P>
  Итак. Можно сказать, что программы могут быть "правильными" и "неправильными"
в смысле "установки locale".

<P>
  "Правильные" программы вызывают в начале <B>setlocale()</B> и в них "русские буквы
вводятся" (если, конечно, у вас переменные окружения указывают на существующий
файл <B>XLC_LOCALE</B>).

<P>
  "Неправильные" программы "забывают" установить текущую locale (соответствено,
в них используется locale <B>"C"</B>) и в них "русские буквы НЕ вводятся"
(хотя замечательно вводяться "западноеворопейские" буквы).

  <H3><A NAME="other">Почему работают другие способы руссификации?</A></H3>



<P>
  Кроме "руссификации через XKB" часто используются "старые" методы -
"загрузка <B>xmodmap</B>" и "программы - переключатели клавиатуры" (<B>xruskb, xes</B> и
т.п.).

<P>
  В общем-то, принципиальная разница между ними в том, что ...
<UL>
 <LI> <B>Xmodmap</B> "честно" размещает русские буквы во второй группе таблицы символов
(при этом используются функции core protocol'а, а не XKB) и определяет клавишу -
переключатель между группами.
 <LI> А программы-переключатели "сидят резидентом" в памяти и на каждое переключение
раскладки, просто "нагло" переписывают первую группу таблицы символов.
</UL>


<P>
  А общее у них то, что они в качестве русских букв используют не коды Cyrillic,
а их однобайтные аналоги. Которые, вообще-то, в X-Window отведены под символы
национальных алфавитов Западной Европы ("умлауты", "тильды" и т.п.)


<P>
  То есть, "неправильные" программы (работающие с locale <B>"C"</B>) воспринимают
их как "родные".


<P>
  Проблемы как раз возникают с "правильными" программами, которые выставляют
"кириллическую" locale. Но с ними, обычно борятся "шаманскими" методами -
либо устанавливают "переменные окружения" так, чтобы они НЕ указывали на
"кириллическую" locale, либо убирают из <B>XLC_LOCALE</B> строчку, описывающую
<B>encoding_name</B> (именно по ней <B>*LookupString</B> "догадываются", что допустимыми
являются только коды Cyrillic).

  <H3><A NAME="wrong">Почему иногда вводятся "не те буквы"?</A></H3>



<P>
  Надеюсь, вы поняли - почему бывает, что "русские буквы не вводятся" или
"вводятся, но не везде" (не вводятся, если программа - "неправильная").


<P>
  Почему же бывает, что "вводятся, но не те"?


<P>
  Ну, во-первых, возможно у вас программа использует "не те шрифты" (<B>fonts</B>).
<BR>В обычных "фонтах" на месте "русских" букв расположены "западноевропейские"
(которые имеют те же коды, то и русские в <B>koi8-r</B>).
 
<P>
 Во-вторых, может быть, что у вас неправильно настроена locale (переменными
окружения). То есть, она указывает на "русский" <B>XLC_LOCALE</B>, но не для
кодировки <B>KOI8-R</B>, а для <B>ISO8859-5</B>. Такая ситуация может быть, если вы
используете "сокращенное" название locale (<B>ru, ru_RU, ru_SU, russian</B>),
которое в файле <B>locale.alias</B> указывает на locale <B>"ru_RU.ISO8859-5"</B>.

<P>
  И, наконец, как это ни странно звучит, возможно, что ошибка в <B>Xlib</B>.
Дело в том, что в <B>XFree86 3.3.3</B> как-раз в <B>Xlib</B> содержится ошибка. Из-за
которой Cyrillic коды перекодируются в <B>iso8859-5</B>, если <B>encoding_name - KOI8-R</B>
(если <B>encoding_name ISO8859-5</B>, то вообще ничего не получится, поскольку
они, в свою очередь, перепутаны там с Arabic).

   <H2><A NAME="What">Что делать?</A></H2>



<P>
   Так что же делать?
<BR>Давайте сначала найдем хотя бы одну программу, которая работает с
"XKB руссификацией" правильно. Что делать с "неправильными" программами
решим потом.

<P>
  Лучше всего взять программу <B>xterm</B>, если, конечно, она у вас из того же
"комплекта", что и X-сервер. То есть собрана с "текущей <B>Xlib</B>" и с теми же
"опциями", что и <B>Xlib</B>.

   <H3><A NAME="What-system">Настройка системы.</A></H3>

<P> Если у вас клавиатура уже руссифицирована каким-нибудь "старым" способом
(с помощью <B>xmodmap</B> или программ-руссификаторов <b>xruskb, xes</b> и т.п.),
то уберите их. Они будут только мешать. Во всяком случае, если будет
"очень надо", вернете их потом.

<P> Короче, позаботьтесь о том, чтобы у вас не было русского <b>.Xmodmap</b>
в домашней директории (и/или в <b>{XROOT}/lib/X11/xinit/</b>) и никакие
<b>xruskb</b> не стартовали бы автоматически при запуске "иксов".

<P>
  Итак. Прежде всего убедитесь, что у вас правильно установлены "русские фонты".
Для этого нужно взять текст, "набитый" в <B>koi8</B> (например, в какой-нибудь
"консольной" программе). Если он нормально читается в <B>xterm</B>, то шрифты
установлены "правильные". (Как установить "кириллические" шрифты я здесь
описывать не буду. В Интернете достаточно инструкций на эту тему.)

<P>
  Дальше. Проверьте, что у вас правильно установлена locale.
Обычно она устанавливается переменной окружения <B>LANG</B>. Убедитесь, что
значение этой переменной указывает на существующие файлы для "libc'ишной"
locale (в <B>/usr/share/locale</B>) и "иксовой" locale (через <B>locale.dir</B> и,
если нужно, <B>locale.alias</B>).

<P>
  Не полагайтесть на результаты выдачи команды <b>locale</b>. В некоторых
случаях она может показывать не совсем то, что и процедура <b>setlocale()</b>
вызываемая внутри прикладных программ.

<P>  Если будут проблемы, можете воспользоваться моей тестовой программкой
<A HREF="testXlc.tgz">testXlc.</A>
<BR>Она определяет
<UL>
	<LI> "системную" locale,
	<LI> locale для <B>Xlib</B>,
	<LI> полный путь до файла <B>XLC_LOCALE</B>,
	<LI> значения некоторых классов "иксовой" locale,
	<LI> в том числе - <B>"encodingName"</B> (которое влияет на работу <B>*LookupString</B>).
</UL>

<P>
  Для "сборки" этой программы надо последовательно набрать команды
<PRE>
xmkmf
make
</PRE>
  Надо также заметить, что  эта программа использует внутренние процедуры
<B>Xlib</B> (не предназначенные для вызова в прикладных программах). Поэтому,
нет гарантии, что она будет "собираться" и правильно работать во всех
версиях XFree. Во всяком случае, она должна давать требуемый результат
в версиях 3.3.2, 3.3.3, 3.3.3.1.

<P>
  Далее. Можно проверить, что XKB действительно переключается на "русскую"
раскладку и выдает коды Cyrillic.

<P>
  Для этого можно воспользоваться программой <B>xev</B> (если ее нет в вашей системе,
то можно найти ее в <B>XFree86-contrib</B>).

<P>
  Вообще-то, это "универсальный тестер" "событий" (X events).
Ее надо запустить из под <B>xterm</B>. При нажатии кнопок она должна писать что-то
вроде этого

<PRE>
KeyPress event, serial 21, synthetic NO, window 0x5800001,
    root 0x25, subw 0x0, time 3744190622, (533,270), root:(610,437),
    state 0x2000, keycode 38 (keysym 0x6c6, <B>Cyrillic_ef</B>), same_screen YES,
    XLookupString gives 0 characters:  ""

KeyRelease event, serial 21, synthetic NO, window 0x5800001,
    root 0x25, subw 0x0, time 3744190755, (533,270), root:(610,437),
    state 0x2000, keycode 38 (keysym 0x6c6, <B>Cyrillic_ef</B>), same_screen YES,
    XLookupString gives 0 characters:  ""
</PRE>

<P>
  Обратите внимание, что если у вас клавиатура перключена в "русский режим",
то в третей строчке сообщения должно быть название Cyrillic кода клавиши

<P>
  Кстати, <B>xev</B> - "неправильная" программа. Если сделать ее "правильной",
добавив в начале вызов (и "пересобрав" ее)
<PRE>
setlocale(LC_CTYPE, "");
</PRE>
то она будет показывать и результат трансляции Cyrillic кодов в <B>koi8-r</B>
(ну, или <B>iso8859-5</B>), например -

<PRE>
KeyPress event, serial 21, synthetic NO, window 0x5800001,
    root 0x25, subw 0x0, time 3744190622, (533,270), root:(610,437),
    state 0x2000, keycode 38 (keysym 0x6c6, <B>Cyrillic_ef</B>), same_screen YES,
    XLookupString gives 1 characters:  <B>"ф"</B>

KeyRelease event, serial 21, synthetic NO, window 0x5800001,
    root 0x25, subw 0x0, time 3744190755, (533,270), root:(610,437),
    state 0x2000, keycode 38 (keysym 0x6c6, <B>Cyrillic_ef</B>), same_screen YES,
    XLookupString gives 1 characters:  <B>"ф"</B>
</PRE>


<P>
  Ну и, наконец, надо убедится, что у вас не XFree86 3.3.3 (хотя с этого
надо было начинать :-).
<BR>(Надо бы написать простенький "тестер", который проверяет правильность
работы <B>*LookupString</B> при заведомо правильной <B>encoding_name</B>. Но пока сойдет
"подправленная" <B>xev</B>. Она, кстати, использует только <B>XLookupString.</B>)

<P>
  Итак, если
<UL>
	<LI> у вас стоят "кириллические" шрифты;
	<LI> программа <B>testXlc</B> показала, что название "системной" и "иксовой" locale
	совпадают, и значение <B>"encodingName" - KOI8-R</B>;
	<LI> <B>xev</B> показывает Cyrillic коды;
	<LI> "поправленный" <B>xev</B> транслирует их в нормальные <B>koi8-r</B> коды;
</UL>
	то система у вас настроена.
И "правильные" программы должны работать нормально.

<P>  А вот что делать с "неправильными" программами - разговор отдельный...

<H3><A HREF="problems1.html">Что делать с "неправильными" программами?</A></H3>

<HR>
<P>
(Если мои советы вам не помогли (или есть какие-то "непонятки"), можете
обращаться ко мне "мейлом".
<BR>Но я не хотел бы видеть вопросы типа - "я все сделал, как написано, но
все равно не работает". Будет лучше, если вы подробно напишете о проделанных
тестах и их результатах.)

<hr>
<p>Иван Паскаль <a href=mailto:pascal@tsu.ru> pascal@tsu.ru </a>

</BODY>
</HTML>
