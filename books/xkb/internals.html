<HTML>
<HEAD>
 <TITLE>Немного о "внутренностях" XKB.</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

   <H2>Немного о "внутренностях" XKB.</H2>

<UL>
	<LI><A HREF="internals.html#codes">Основные термины - коды и символы.</A>
	<LI><A HREF="internals.html#two-part">Две части XKB и "проблема совместимости".</A>
	<LI><A HREF="internals.html#symbols">Таблица символов</A>
	<LI><A HREF="internals.html#actions">Таблица "действий".</A>
	<LI><A HREF="internals.html#state-group">Состояние XKB: номер группы.</A>
	<LI><A HREF="internals.html#wrap">"Метод выравнивания" номера группы.</A>
	<LI><A HREF="internals.html#mods">Модификаторы.</A>
	<LI><A HREF="internals.html#state-mods">Состояние XKB: модификаторы.</A>
	<LI><A HREF="internals.html#types">Вычисление "уровня" (shift level). Типы клавиш.</A>
	<LI><A HREF="internals.html#key">Какая еще информация хранится для каждого скан-кода.</A>
	<UL>
		<LI><A HREF="internals.html#key-type">Тип клавиши.</A>
		<LI><A HREF="internals.html#key-wrap">Метод "выравнивания" номера группы.</A>
		<LI><A HREF="internals.html#key-behavior">"Поведение" клавиши.</A>
		<LI><A HREF="internals.html#key-explicit">Набор "исключений".</A>
		<LI><A HREF="internals.html#key-mods">Реальный и виртуальный модификаторы.</A>
	</UL>
	<LI><A HREF="internals.html#indicators">Индикаторы.</A>
	<LI><A HREF="internals.html#compat">Таблица "совместимости".</A>
	<LI><A HREF="internals.html#radio">Радио-группы. (Radio Groups)</A>
	<LI><A HREF="internals.html#overlay">Перекрытия (Overlay).</A>
	<LI><A HREF="internals.html#controls">Набор управляющих флагов (XKB Controls).</A>
	<LI><A HREF="internals.html#bell">Расширенные возможности "пищалки" (Bell).</A>
</UL>

  <H3><A NAME="codes">Основные термины - коды и символы.</A></H3>

<P>
  Основное назначение модуля XKB - преобразовывать скан-коды нажимаемых
клавиш в коды символов.

<P>
  Обычно, в документации скан-коды называются <B>keycodes</B>, а коды символов -
просто "символы" (<B>symbols</B>).

<P>
  Естественно, "символы" - это не обязательно коды "печатных" символов
(букв, цифр, знаков препинания и т.п.). Это могут быть также "управляющие"
коды (Esc, Enter, Backspace и т.п.) или коды, которые никак не отображаются,
но влияют на внутренне состояние самого XKB (переключение РУС/ЛАТ, Control,
Shift, Alt и т.п.) и, следовательно на то, какой символ будет выбран при
нажатии обычных "буквенных" клавиш.

  <H3><A NAME="two-part">Две части XKB и "проблема совместимости".</A></H3>

<P>
  Прежде всего, надо сказать несколько слов о том, как происходит
преобразование скан-кодов в символы при работе X-Window без модуля XKB.

<P>
  При нажати кнопки (и при отпускании) "клавиатурный модуль" X-сервера
посылает сообщение ("сообщение о событии" - event) прикладной программе.

<P>
  В этом сообщении указывается только скан-код нажатой кнопки
и "состояние клавиатуры" - набор битовых "флагов", который отражает
состояние клавиш-модификаторов (<B>Shift, Control, Alt, CapsLock</B> и т.п.).

<P>
  Поэтому, "клиентская" программа должна сама решить - какой символ,
соответствующий скан-коду, надо выбрать при таком сочетании
битов-модификаторов.

<P>
  Естественно, для этого программа может воспользоваться таблицей,
хранящейся в X-сервере, в которой для каждого скан-кода перечислены
возможные символы. (Эта таблицу можно менять с помощью утилиты <B>xmodmap</B>).

<P>
  Разумеется, при создании программ, никто не пишет каждый раз программу
для интерпретации скан-кодов. Для этих целей существуют специальные
подпрограммы в библиотеке Xlib. 
<BR>  Конечно, Xlib используется не только для этого. Это библиотека
"низкоуровневых" процедур для работы с X-сервером. И, если даже
программа пользуется "высокоуровневыми" библиотеками-"тулкитами" (Xaw,
Motif, Qt, gtk и т.п.), библиотека Xlib служит "базовой" для этих
"тулкитов".

<P>
  Итак. Процедуры из Xlib, зная скан-код и "состояние клавиатуры",
в соответствии с таблицей символов (которую они обычно "запрашивают" у
X-сервера при старте программы) выбирают подходящий символ.

<P>
  Модуль XKB точно также сообщает программе только скан-код и свое "состояние".
Но в отличии от "старого" модуля (обычно говорят - "<B>core protocol</B>", будем его
называть для краткости  - "core-модуль") XKB имеет более сложную таблицу
символов, другой набор "модификаторов"
и некоторые дополнительные параметры "состояния клавиатуры" (обо всех этих
отличиях мы поговорим по ходу рассмотрения "внутренностей" XKB).

<P>
  Поэтому, для полноценной работы с XKB, библиотека Xlib должна содержать
модифицированные процедуры интерпретации скан-кодов (процедуры "знакомые"
с XKB - XKB-aware).
<BR>  Естественно, все "иксы", у которых X-сервер "укомплектован" модулем XKB,
имеют и соответствующую библиотеку Xlib.

<P>
  Таким образом, XKB фактически делится на две части - модуль, встроенный
в X-сервер, и набор подпрограмм, входящих в библиотеку Xlib.

<P>
  Однако, никто не запрещает использовать программы, которые были "слинкованы"
со старой библиотекой Xlib, "не подозревающей" о существовании XKB.

<P>
  При этом и возникает "проблема совместимости". То есть, модуль XKB должен
уметь общаться как со "своей" Xlib, так и со "старой" (работающей в
соответствии с "core protocol").
<BR>  Естественно, "общение" не ограничивается только передачей сообщений о
нажатии/отпускании клавиш. Процедуры Xlib могут обращаться к X-серверу
с различными запросами (например - взять таблицу символов) и командами
(например, поменять в этой таблице расположение символов).
<BR>  На все эти запросы и команды модуль XKB должен реагировать так, чтобы
даже "старая" Xlib могла работать правильно (насколько это возможно).

  <H3><A NAME="symbols">Таблица символов</A></H3>

<P>
  Для каждого скан-кода в XKB хранится двумерная таблица (массив) символов.
"Координатами" в этой таблицы являются "номер группы" или просто - "группа"
(<B>group</B>) и "уровень" (<B>shift level</B>). Обычно, разные группы используются
для разных языков (а точнее - алфавитов), а уровень разделяет символы
на "большие/маленькие" буквы (ну, то что меняется при нажатии <B>Shift</B>).
<BR>  Хотя, никто не мешает использовать деление на "группы" и "уровни"
как-нибудь по другому.

<P>
  Надо заметить, что эта двумерная таблица очень гибкая. В том смысле,
что в одной и той же "раскладке клавиатуры" разные кнопки (скан-коды)
могут иметь разное количество групп и уровней. Более того, одна и та же
кнопка может иметь разное количество уровней в разных группах (например,
первая группа имеет только один уровень, а вторая делится на три уровня).
К тому же у конкретной кнопки могут отсутствовать некоторые группы и уровни
(например, могут быть определены символы для группы второй и четвертой,
а для первой и третей - нет). Естественно, если какая-то комбинация
уровня и группы для данного скан-кода не определена, то никаких символов
XKB в такой ситуации выдавать не будет.

<P>
  Наконец, надо сказать, что групп может быть от одной до четырех, а
уровней - до 64.

<P>
  Заметим, что в core-модуле каждому скан-коду соответсвует одномерный
"вектор" символов (длиной до 256). И, хотя понятие группы в нем также
существует, но...
<BR>  Группа состоит только из двух уровней. И строго определены только
две группы.
<BR> В "векторе символов" первые два символа относятся к первой группе
(два уровня одной группы), вторые два - относятся ко второй группе.

  <H3><A NAME="actions">Таблица "действий".</A></H3>

<P>
  Кроме "таблицы символов" к скан-коду может быть "привязана" аналогичная
"таблица действий" (<B>actions</B>). Эта таблица также делится на группы и уровни,
а в ее ячейках располагаются вызовы внутренних процедур XKB которые
меняют его состояние (в конечном счете - группу и уровень).

<P>
  Надо только отметить, что "таблица действий" своими размерами и формой
должна соответствовать "таблице символов" для этого же скан-кода.
<BR>  То есть, если определена ячейка "таблицы действий" для какого-то сочетания
группы и уровня, то для этого же сочетания в "таблице сиволов" ячейка
должна быть "заполнена" каким-нибудь символом (обычно "непечатным").

<P>
  Заметим, что в core-модуле понятия "действие" вообще нет.

  <H3><A NAME="state-group">Состояние XKB: номер группы.</A></H3>

<P>
  Текуший номер группы хранится в "таблице состояния" XKB.
<BR>  Точнее, внутри XKB имеются три ячейки
<UL>
<LI> <B>locked group</B> - некий аналог нажатия клавиши <B>CapsLock</B>, но для групп 
<LI> <B>latched group</B> - аналог действия клавиши <B>Shift</B>, но, опять же, для групп
<LI> <B>base group</B> - еще дополнительное смещение для "номера группы"
</UL>
  Обычно, содержимое этих переменных меняется с помощью "действий"
(<B>actions</B>), которые связываются с подходящими клавишами (их скан-кодами).

<P>
  Наконец, существует понятие "эффективная" или "действующая" (<B>effective</B>)
группа. Именно ее значение используется для выбора символа (и, возможно,
действия) в таблице символов. Но это значение не хранится, а каждый раз
вычисляется как сумма трех вышеуказанных переменных.

  <H3><A NAME="wrap">"Метод выравнивания" номера группы.</A></H3>

<P>
  Естественно, при таком суммировании может получиться число, больше
чем количество заданных групп. Чтобы получить из него какой-нибудь
допустимый номер группы, XKB может использовать три разных метода.

<UL>
<LI>  <B>Wrap</B> ("заворачивание") - получившееся число делится на количество групп
и берется остаток от деления. Этот метод используется по умолчанию.
<LI>  <B>Clamp</B> ("удержание в границах") - если получилось число большее чем номер
последней группы, то берется этот самый "номер последней группы", если же
получилось число менше, чем номер самой первой группы, то берется первая
группа.
<LI>  <B>Redirect</B> ("перенаправление" или, точнее - "замена") - если используется
этот метод, то в "состоянии XKB" должен быть определен еще один
дополнительный параметр - номер группы "куда перенаправить" (или - "чем
заменить"). Если получившееся число выходит за пределы допустимых значений
для групп, оно просто заменяется этой самой "чем заменить". Кстати, если
и этот номер не уложится в допустимые границы, то XKB подставит первую
группу.
</UL>

  <H3><A NAME="mods">Модификаторы.</A></H3>

<P>
  Кроме переменных, содержащих номера групп, "состояние XKB" определяется
"флажками" - модификаторами. Эти битовые флаги меняются при нажатии
клавиш <B>Shift, CapsLock, Alt, Control</B> и т.п. и, естественно, влияют на
выбор подходящего символа из таблиц.

<P>
   Как я уже упоминал, "core protocol" (протокол "общения" между "традиционным"
клавиатурным модулем и Xlib)
тоже имеет "набор модификаторов" (который и сообщается прикладной программе
при нажатии кнопок). Эти модификаторы (8 бит) называются <B>Shift, Lock, Control,
Mod1-Mod5</B>. В зависимости от их состояния, Xlib выбирает подходящий символ
и может выполнять дополнительные действия - делать из обычных символов
"управляющие" ("контроловые"), менять "большие/маленькие" буквы и т.п.
<BR>   Кроме того, "клиентская" программа может сама (помимо Xlib) по-своему
интерпретировать эти модификаторы и менять свое "поведение".

<P>
   Поэтому, хотя XKB имеет больше модификаторов и его "поведение"
(действия, выполняемые при определенной комбинации модификаторов) можно
гибко перестраивать (как при старте, так и в процессе работы), модуль XKB
вынужден эмулировать "классический" набор модификаторов, специально для
"старых" клиентских программ (и "старой" Xlib).

<P>
  Итак. Модификаторы core protocol'а в XKB называются "реальными" (<B>real</B>)
модификаторами и их названия такие же как в core protocol.

<P>
  Кроме того, XKB имеет еще 16 своих внутренних модификаторов,
которые называются "виртуальными" (<B>virtual</B>) модификаторами.
<BR>  Эти модификаторы выполняют несколько функций
<UL>
<LI> по их состоянию "вычисляется" <B>shift level</B> для выбора нужного символа;
<LI> часть их отображается ("мапируется") в "реальные" модификаторы для
эмуляции "классического" набора модификаторов;
<LI> по их состоянию "вычисляется" состояние индикаторов (см. ниже);
<LI> и, кроме того, они могут влиять на выполнение некоторых других действий
XKB (вычисление номера группы и т.п.).
</UL>

  <H3><A NAME="state-mods">Состояние XKB: модификаторы.</A></H3>

<P>
  Также как и "номер группы", набор битов-модификаторов внутри XKB
существует в трех экземплярах (в трех переменных)
<UL>
<LI> <B>locked modifiers</B>
<LI> <B>latched modifiers</B>
<LI> <B>base modifiers</B>
</UL>
  Содержимое этих переменных (также как и "групповых") может меняться
с помощью "действий" (<B>actions</B>).

<P>
  Как и для "номеров групп", для модификаторов существует понятие
"эффективный" набор модификаторов, который определяется как сумма
трех указанных переменных. Однако, в отличии от групп, здесь происходит
не арифметическое, а "логическое" суммирование (поскольку речь идет
не о числах, а наборах битов) - побитная операция <B>ИЛИ</B> над всеми тремя
переменными. Соответственно, никаких дополнительных "выравниваний"
(как для значения номера группы) не требуется.

  <H3><A NAME="types">Вычисление "уровня" (shift level). Типы клавиш.</A></H3>

<P>
  В отличии от "номера группы" "уровень" не запоминается в состоянии XKB,
а "вычисляется" из состояния модификаторов.
<BR>  При этом, для различных клавиш зависимость уровня от модификаторов
может быть различным.

<P>
  Для того, чтобы обеспечить такую гибкость, в XKB существут понятие
"тип клавиши".

<P>
  В каждом описании типа клавиши задается некая функция - какие модификаторы
"принимать к рассмотрению" и какой уровень должен получится при определенном
сочетании модификаторов.
<BR>  Соответственно, у каждой клавиши (скан-кода) кроме таблицы символов
имеется "идентификатор типа" - к какому из заданных типов относится данная
клавиша.

<P>
  Естественно, при нажатии клавиши, XKB (точнее, процедуры Xlib) определяет -
к какому типу она относится и, по описанию типа и текущему состоянию
модификаторов, "вычисляет" - из какого "уровня" следует выбрать символ для
этого скан-кода.

<P>
  Надо отметить, что, хотя и описания типов и принадлежность каждой
клавиши к определенному типу можно гибко менять, в XKB "по умолчанию"
задан основной набор типов и "расписаны" идентификаторы типов для всех
клавиш. Поэтому, обычно нет необходимости задавать эти параметры
в файлах конфигурации XKB.

  <H3><A NAME="key">Какая еще информация хранится для каждого скан-кода.</A></H3>

<P>
  Кроме таблицы символов (и, возможно, "действий") с каждым скан-кодом
связаны еще несколько переменных
<UL>
  <LI> уже упоминавшийся "тип клавиши";
  <LI> метод "выравнивания" номера группы, специфичный для данной клавиши;
  <LI> "поведение" клавиши;
  <LI> набор "исключений";
  <LI> реальный модификатор (modmap) и виртуальный модификатор (vmodmap),
связанные с этой клавишей.
</UL>

  <H4><A NAME="key-type">Тип клавиши.</A></H4>

<P>
  "Тип клавиши" указывает - к какому типу относится данная клавиша.
То есть - по какому правилу вычислять shift level для данной клавиши.

  <H4><A NAME="key-wrap">Метод "выравнивания" номера группы.</A></H4>

<P>
  Поскольку разные клавиши могут иметь разное количество групп, может
возникнуть ситуация, когда вычисленный и "выровненный" эффективный номер
группы все-таки не попадает в дапазон допустимых групп для данной клавиши.

<P>
  В этом случае эффективный номер группы может дополнительно "выравниваться",
специально для данной клавиши.

<P>
  Возможные методы точно такие же, как и <A HREF="internals.html#wrap">"глобальные"</A>. По умолчанию
используется метод Wrap.

  <H4><A NAME="key-behavior">"Поведение" клавиши.</A></H4>

<P>
   Эта переменная состоит из двух частей - набора флагов и дополнительного
аргумента. Обычно аргумент не нужен. Но некоторые флаги подразумевают
дполнительный числовой аргумент, а смысл этого аргумента зависит от флага.

<P>
  Флаги определяют
<UL>
  <LI> нужен ли "автоповтор" для этой клавиши (Строго говоря, флаг "автоповтор"
хранится в другом месте, а не в переменной "поведение". Но в данном
случае это не так уж важно.)
  <LI> обычная эта клавиша или "залипающая" (то есть, по первому нажатию
клавша "залипает" и отпускается при повторном нажатии). При этом "залипание"
клавиши может отрабатываться самим "железом" или эмулироваться модулем XKB.
  <LI> принадлежность этой клавиши к какой-нибудь <A HREF="internals.html#radio">"радио-группе"</A>. При этом
дополнительный аргумент указывает номер такой "радио-группы".
  <LI> принадлежит ли эта клавиша к <A HREF="internals.html#overlay">"перекрывающейся группе"</A> (<B>overlay</B>).
Таких групп может быть всего две. К какой из групп принадлежит данная клавиша -
определяется <A HREF="internals.html#controls">"управляющими флагами"</A> <B>overlay1</B> и <B>overlay2</B>, а дополнительный
аргумент указывает - какой скан-код должна эмулировать клавиша, если
включен "режим перекрытия".
</UL>

  <H4><A NAME="key-explicit">Набор "исключений".</A></H4>

<P>
  Это битовая маска, которая указывает - какая информация, связанная
с клавишей, "задана точно" (<B>explicit</B>) и не должна изменяться в некоторых
случаях. Дело в том, что в core protocol определены команды, с помощью которых
программы могут менять "раскладку клавиатуры" внутри клавиатурного модуля
X-сервера. Естественно, эти комады меняют только "привязку" символов,
поскольку другие "свойства" скан-кодов в core protocol'е не определены.

<P>
  Для того, чтобы XKB мог при этом поменять и "привязку" других "свойств",
в нем предусмотрен специальный механизм - "интерпретации" символов
(об этом см.ниже).

<P>
  Так вот. Набор "исключений" может защитить информацию, связанную с
конкретным скан-кодом, именно от таких косвенных изменений.
<BR>  Если прикладная программа будет пользоваться соответствующим запросами
XKB модуля (а не core protocol), такой защиты не требуется.

<P>
  Итак, с помощью этой маски можно запретить
<UL>
<LI> изменение типа клавиши (количество уровней) для каждой группы (можно
установить запрет для каждой группы поотдельности);
<LI> изменения, которые могут произойти при применнии "интерпретации",
при этом можно запретить -
<UL>
  <LI> вообще все изменения, вызываемые "интерпретацией";
  <LI> изменение флагов "автоповтор" и "залипание";
  <LI> изменение набора виртуальных модификаторов.
</UL>
</UL>

  <H4><A NAME="key-mods">Реальный и виртуальный модификаторы.</A></H4>

<P>
  Обратите внимание, что с каждым скан-кодом связаны две разные переменные
(<B>modmap</B> и <B>vmodmap</B>), одна для реальных модификаторов, другая - для виртуальных.

<P>
  Набор реальных модификаторов служит для эмуляции "традиционного" набора
модификаторов (в соответствии с core protocol), а набор виртуальных
модификаторов может служить аргументами для "действий", связанных с этой
клавишей.

<P>
   Надо заметить, что изменения набора виртуальных модификаторов (<B>base,
locked</B> и <B>latched</B>) делается с помощью соответствующих "действий". Естественно,
одним из аргуметов этого "действия" должен быть модификатор (или несколько
модификаторов), которые нужно установить/сбросить в соответствующих
"переменных состояния". Так вот, при описании "действия", модификаторы можно
указать явно, а можно просто сослаться на <B>vmodmap</B> (то есть -
"установить модификаторы, привязанные к этой клавише").

<P>
  А вот изменение модификатора в "эмулируемом наборе модификаторов"
происходит автоматически при нажатии/отпускании клавиши. Естественно,
устанавливаются/сбрасываются именно те модификаторы, которые указаны
в наборе реальных модификаторов (<B>modma</B>p).

<P>
  Кроме того, эти два набора служат для установления соответствия между
реальными и виртуальными модификаторами. Надо заметить, что виртуальный
модификатор не имеет никакого смысла, если не связан с каким-нибудь
реальным модификатором.

  <H3><A NAME="indicators">Индикаторы.</A></H3>

<P>
  Как известно, на клавиатуре кроме "кнопок" имеется несколько "лампочек"-
индикаторов. Управление этими индикаторами тоже входит в обязанности XKB.
<BR>  В XKB может существовать до 32 индикаторов.
<BR>Естественно, на клавиатуре отображаются только первые 3-4 из них.
Эти индикаторы называются в XKB "физическими", а остальные - "виртуальными".
Состояние виртуальных модификаторов может быть считано из XKB и отображаться
на экране специальными программами (<B>xkbvleds</B>, <B>mxkbledpanel</B>).

<P>
  Каждый индикатор может быть связан с компонентом "состояниея XKB"
(модификатором, номером группы, "управляющим флагом") и, соответственно,
состояние индикатора будет автоматически отражать состояние своего
"компонента состояния XKB".

<P>
  Причем, в XKB существуют специальные запросы, которыми прикладная программа
может управлять состянием какого-нибудь индикатора ("зажигать"/"гасить" его).
Заметьте, речь идет о том, что программа может просто включать/выключать
"лампочку", а не менять состояние клавиатуры, которое "отслеживается"
этой "лампочкой".

<P>
  Поэтому, с каждым индикатором связан набор флагов, который определяет
<UL>
<LI> можно ли прикладной программе управлять самим этим индикатором (или для его
включения/выключения обязательно надо изменить "состояние клавиатуры";
<LI> "привязан" ли этот индикатор к "состоянию клавиатуры" или он
включается/выключается только прикладными программами;
<LI> и, наконец, будет ли такое включение/выключение иметь "обратную связь".
То есть, можно настроить индикаторы так, что включение/выключение "лампочки"
прикладной программой будет вызывать автоматически соответствующие изменения
"состояния клавиатуры" (модификаторов, номера группы, управляющих флагов).
</UL>

  <H3><A NAME="compat">Таблица "совместимости".</A></H3>

<P>
  Как уже упоминалось, XKB вынужден решать "проблему совместимости" с
программами, которые не подозревают о существовании XKB и обращаются
с запросами к "core-модулю" X-сервера.

<P>
  Естественно, модуль XKB может обработать эти запросы, но основная
проблема, возникающая при этом, состоит в том, что в модуле XKB вводятся
некоторые новые понятия (новые относительно core protocol'а), которые никак
не отражены в "традиционных" запросах к клавиатурному модулю.

<UL>
<LI>  Во-первых, в XKB больше модификаторов и их поведение может гибко
перестраиваться. Поэтому, как уже упоминалось, для совместимости модулю
XKB приходится поддерживать восемь "традиционных" модификаторов и
осуществлять отображение (преобразование) своих модификаторов в
"традиционные".

<P>
  Более того. Поскольку XKB вынужден поддерживать "традиционный" формат
"сообщения о нажатии" клавиши, в котором передается "состояние" клавиатурного
модуля, состоящее из набора реальных модификаторов. Даже если модуль XKB
общается с XKB-совместимой Xlib, он вынужден, для передачи ей информации
о состоянии своих виртуальных модификаторов, "превращать" их в реальные.
<BR>  (Поэтому, кстати, виртуальный модификатор не оказывает никакого эффекта,
если он не "отображен" в какой-нибудь реальный).

<LI>  Во-вторых, в core protocol нет понятия "номер группы". Точнее понятие
"группа" там есть, но... Как уже говорилось - групп всего две, переключаются
они символом <B>Mode_Switch</B> и в "состоянии клавиатуры" переключение на
"дополнительную" группу отображается одним из модификаторов <B>Mod1-Mod5</B> -
тем, который связан с символом <B>Mode_Switch</B> (с помощью <B>xmodma</B>p).

<P>
  Таким образом, в "традиционном" протоколе номер группы отображается
одним битом-модификатором - "основная группа/альтернативная группа",
а в модуле XKB, в "состоянии клавиатуры" явно существует двухбитное
поле - "номер группы" (которое, к тому же, не "перекрывается" с набором
модификаторов).

<P>
  Кроме того, в "традиционном" модуле клавиатуры каждая группа состоит
ровно из двух "уровней". Хотя при этом допускается, что каждому скан-коду
может быть сопоставлен одномерный массив символов длиной до 256. Первые
четыре ячейки в нем соответствуют "двум группам, в каждой по два уровня".
Остальные ячейки "клиентская" программа может выбирать сама, в зависимости
от состояния модификаторов Mod1-Mod5.

<P>
  Поэтому, для совместимости модуль XKB, при общении со "старыми" программами,
вынужден ...
<UL>
<LI>Во-первых, "размазывать" свои двумерные массивы символов в "традиционные"
одномерные (честно говоря, я так и не понял общий алгоритм этого действия,
кроме тривиального случая, когда двумерный массив состоит из двух групп
и двух уровней).
<LI>Во-вторых, отображать свой "номер группы" в состояние какого-нибудь
"реального" модификатора.
</UL>

<LI>  Наконец, в core-модуле отсутствуют "действия" - основной механизм,
обеспечивающий "гибкость поведения" XKB. В связи с этим возникает
проблема - "старая" программа может поменять "привязку" символов к скан-кодам,
но, поскольку она не подозревает о том, что к скан-кодам могут быть
"привязаны" также и "действия", может возникнуть ситуация, когда такая
программа переместить, например, символ "переключатель РУС/ЛАТ" на другую
клавишу, а соответствующее "действие" (которое в XKB реально осуществляет
это переключение) останется на старом месте.

<P>
  Для решения этой проблемы в XKB хранится таблица "интерпретаций"
(<B>interpretation</B>) управляющих символов. Эта таблица связывает коды символов
и вызовы соответствующих "действий" (<B>actions</B>). Естественно, в этой таблице
присутствуют только специальные "управляющие" символы ( <B>Caps_Lock, Shift,
Num_Lock, "переключатель РУС/ЛАТ"</B> и т.п.).

<P>
  Кроме самих символов и "действий" в таблице интерпретаций хранится также
дополнительная информация - список "реальных модификаторов" и "критерий
соответствия" ("любой из модификаторов", "все указанные модификаторы",
"только указанные модификаторы" и т.п.).

<P>
  Каждый раз при изменении "привязки" символа (учтите, что это изменение
может происходить при старте X-сервера, как часть "начальной настройки"
сервера) модуль XKB проверяет - присутствует ли в этот символ в "таблице
интерпретаций". И если символ там есть, то XKB, "присвоив" этот символ
требуему скан-коду, добавляет этому скан-коду и соответствующее "действие".
Дополнительная информация (модификаторы и "критерий соответствия") тоже
может использоваться при "поиске" подходящего места для "действия".

<P>
  Кроме того, применение "интерпретации" может поменять некоторую другую
информацию, связанную со скан-кодом - флаги, отвечающие за "автоповтор"
и "залипание" клавиши и "список виртуальных модификаторов".

<P>
  Напомню, что у каждого скан-кода может быть указан набор "исключений",
который защитит информацию, связанную со скан-кодом от применения
"интерпретации".

<P>
  Надо отметить, что помещать все "действия" в "таблицу интерпретаций",
а не присваивать их непосредственно скан-кодам - является "хорошим тоном".
Поскольку в "таблице интерпретаций" "действие" связывается с символом,
а не со скан-кодом, и, к тому же, "перенос" "действий" из "таблицы
интерпретаций" в соответствуюшие таблицы "действий" скан-кодов XKB выполняет
каждый раз при загрузке конфигурации (в том числе и при старте X-сервера),
модуль XKB сам найдет подходящее место для соответствующего "действия"
и, таким образом, корректно "свяжет" символы и действия (в таблицах,
назначенных скан-кодам).
</UL>

  <H2>Еще несколько определений.</H2>

  <H3><A NAME="radio">Радио-группы. (Radio Groups)</A></H3>

<P>
  Модуль XKB позволяет объединять несколько клавиш в "радио-группу".
То есть, клавиши одной ради-огруппы являются взаимозависимыми.
При нажатии одно из клавиш группы все остальные из этой группы "отжимаются".

<P>
  Естественно, нажатая клавиша остается "залипшей", пока не будет нажата
другая клавиша из этой группы. Принадлежность конкретной клавиши к
некоторой радио-группе задается в поле "поведение клавиши".

<P>
 Там же можно определить дополнительное свойство - можно ли "отжать"
все клавиши радио-группы. Обычное определение радио-группы подразумевает,
что одна из клавиш группы должна быть нажата, а чтобы отжать ее, надо нажать
другую клавишу в группе (естественно, теперь она будет "залипшей").
Если задано свойство "могут быть отжаты все", то "залипшую" клавишу группы
можно "отжать" просто повторным нажатием (при этом никакая другая клавиша
группы не окажется "залипшей").

<P>
 В XKB можно объявить до 128 радио-групп (хотя это может зависить от
конкретной реализации XKB).

  <H3><A NAME="overlay">Перекрытия (Overlay).</A></H3>

<P>
  В модуле XKB можно для некоторых клавиш (группы клавиш) задать набор
"альтернативных" скан-кодов. То есть, при нажатии такой клавиши клавиатура
выдает некоторый скан-код, который и должен быть интерпретирован XKB
(выбрать подходящий символ), но, если включен режим замены скан-кода
на "альтернативный", то XKB прежде всего заменяет этот скан-код
соответствующим "альтернативным", а потом уже новый скан-код пытается
интерпретировать.

<P>
  Такая группа называется "перекрытием" (<B>overlay</B>). Их может быть всего
две. Принадлежность конкретной клавиши к конкретной группе-"перекрытию"
и "альтернативный" скан-код задаются в поле "поведение клавиши".

<P>
  Это свойство используется для клавиатур, у которых очень маленький
набор клавиш (например в "лаптопах"). Например, на такой клавиатуре
может полностью отсутствовать "дополнительная цифровая клавиатура"
(<B>keypad</B>). Поскольку некоторые приложения могут потребовать, чтобы
какие-то действия в них вызывались нажатием кнопок именно на <B>keypad</B>,
модуль XKB может эмулировать эту дополнительную клавиатуру, используя,
например, "цифровые" кнопки на основной клавиатуре.

  <H3><A NAME="controls">Набор управляющих флагов (XKB Controls).</A></H3>

<P>
  Кроме номера группы и набора модификаторов, в XKB существует аналогичный
набор для "управляющих флагов". Правда, в отличии от номера группы
и набора модификаторов, которые "размазаны" по трем переменным
(<B>base, locked, latched</B>), набор управляющих флагов только один. 

<P>
  В "управляющие флаги" входят все те "флажки", которые не попали в
"набор модификаторов".
<BR>  Эти флаги управляют
<UL>
<LI> включением режима "перекрытия" части клавиатуры;
<LI> включением режима, в котором движение "указателя мыши" и нажатие
кнопок на "мышке" эмулируется соответствующими кнопками клавиатуры;
<LI> поведением "пищалки" (Bell);
<LI> и некоторыми другими сойствами XKB.
</UL>

<P>
  "Управляющие флаги" (как и номера групп и модификаторы) меняются
соответствущими "действиями", привязанными к подходящим клавишам.

   <H3><A NAME="bell">Расширенные возможности "пищалки" (Bell).</A></H3>

<P>
  Вообще-то, эта часть XKB имеет малое отношение к клавиатуре.
<BR>Более того, для пользователей компьютеров, в которых клавиатура, дисплей
и "спикер" - независимые устройства, такое совмещение может показаться очень
странным. Но поскольку, в некоторых архитектурах динамик "пищалки" находится
в клавиатуре и издает звук (<B>key_click</B>) при каждом нажатии клавиши,
в "иксах" считается, что управление "пищалкой" - дело клавиатурного модуля.

<P>
  Надо отметить, что управление "пищалкой" заложено еще в традиционном (core)
модуле клавиатуры. С помощью стандартных запросов к X-серверу, приложение
может регулировать параметры <B>key_click</B>'а (высоту тона, длительность и
громкость), а также вызвать этот <B>click</B> при необходимости.

<P>
  В XKB разработчики пошли еще дальше и предусмотрели возможность вместо
простого "писка" проигрывать "музыкальные фрагменты". Естественно,
обеспечить такое "музыкальное сопровождение" для клавиатурного модуля слишком
сложная задача. Во-первых нужна "база данных" различных звуков (хотя бы просто
в виде набора аудио-файлов), а во-вторых музыка может воспроизводится
различными "железками" (звуковыми картами), каждая из которых требует
"особого подхода" (драйвера).

<P>
  Поэтому, по замыслу разработчиков, выбором конкретного звука и его
воспроизведением должна заниматься отдельная программа (назовем ее -
"музыкальная приставка"). А модуль XKB вместо "писка" просто генерирует
специальное сообщение (<B>event</B>), которое так же как и обычные <B>event</B>'ы
X-сервера могут быть доставлены любой программе. "Музыкальная приставка"
только должна при старте сообщить X-серверу, что ее интересует определенная
разновидность <B>event</B>'ов (в данном случае - <B>bell-event</B>'ы от модуля XKB).

<P>
  Естественно, если такая "музыкальная приставка" существует, ее возможности
не ограничиваются воспроизведением "писков" разной частоты и длительности.
Она может проигрывать множество разных музыкальных фрагментов из своей
"базы данных".
<BR>  Поэтому, в сообщениях XKB указывается не "параметры писка", а просто
некое "имя звука" (<B>bell name</B>). Естественно, "музыкальная приставка"
должна иметь какой-то конфигурационный файл, в котором для каждого
"имени звука" назначен свой музыкальный фрагмент.

<P>
  Соответственно, теперь любое приложение с помощью соответствующих
запросов к X-серверу (теперь уже не в core-формате, а в формате XKB),
может заказать не просто "писк" с определенным тоном и длительностью,
а любой звук, указав его имя (<B>bell name</B>).

<P>
  При этом XKB собственно является просто "ретранслятором". Он даже не
анализирует правильность "имени звука", а просто, получив запрос от любого
приложения, передает его в виде своего <B>event</B>'а "музыкальной приставке".

<P>
  Естественно, в такой схеме XKB кажется даже лишним. Приложение могло бы
и само общаться с "музыкальной приставкой". Но не забудьте, что сама идеология
"иксов" допускает, что приложение, X-сервер и "музыкальная приставка"
могут быть запущены на различных машинах. Поэтому, нормальное приложение
должно было бы, кроме соединения с X-сервером, найти еще и "музыкальную
приставку" и установить с ней контакт.

<P>
  В схеме с XKB, любое приложение отправляет свои "просьбы" тому же самому
X-серверу (с которым ему и так приходится общаться), а уж администратор
сервера определяет - кто и как будет обслуживать эти запросы. Кроме того,
при этом вводится некоторый стандарт на общение между приложением и
"звуковой приставкой" (разве что, кроме самих "имен звуков").

<P>
Надо заметить также, что XKB не только ретранслирует запросы, но и сам может
"заказать звук" при некоторых изменениях своего внутреннего состояния
(состояния индикаторов, флагов и т.п.).

<hr>
<p>Иван Паскаль <a href=mailto:pascal@tsu.ru> pascal@tsu.ru </a>
</BODY>
</HTML>
