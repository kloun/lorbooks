<HTML>
<HEAD>
 <TITLE>"Вариации на тему" переключатели "рус/лат" (и еще раз - "рус").</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

  <H2>"Вариации на тему" переключатели "рус/лат" (и еще раз - "рус").</H2>

<UL>
	<LI><A HREF="example3.html#1">Первый способ - простой и неудобный.</A>
	<LI><A HREF="example3.html#2">Второй способ (через модификатор).</A>
	<LI><A HREF="example3.html#3">Третий способ (через дополнительную переменную номера группы).</A>
	<LI><A HREF="example3.html#final">"Заключительный аккорд" - "отцепляемся" от скан-кодов.</A>
</UL>
<P>
  Предположим, что вы выполнили предыдущий пример или еще откуда-нибудь
взяли (сделали) раскладку клавиатуры с тремя группами.

<P>
  И вам не нравится способ переключения между группами - три положения
у одного переключателя "лат/рус/рус".

<P>
  <H4>Что можно сделать?</H4>

<P>
  Ну, во-первых, давайте вообще забудем пока про символ <B>ISO_Next_Group</B>,
к которому "прицеплено" такое неудобное "действие". (Вообще-то, семантику
<B>ISO_Next_Group</B> можно и переделать, но пока отложим этот вопрос).


<P>
  Для простоты рассмотрения будем считать, что переключение у вас делается
одной клавишей (обычно - это <B>CapsLock</B>),а не комбинацией клавиш (типа - 
<B>Shift+Shift</B> или <B>Alt+Shift</B>).

<P>
  Напомню, что непосредственно в описании клавиши можно указать "действия",
причем, разные для разных групп.


<P>
  Кстати. Напомню, что, во-первых, большинство  изменений мы будем делать
в файле типа <B>xkb_symbols</B>. А, во-вторых, поскольку эти изменения не просто
дополняют существующие определения клавиш, а изменяют их радикально, то
лучше всего добавлять их в "общую конфигурацию" не "приплюсовыванием",
а отдельной инструкцией <B>replace</B>, например -

<PRE>
xkb_symbols {	include "en_US(pc104)"
		replace "new.symbols" };
</PRE>

(Вообще-то, можно "способ добавления" <B>replace</B> указывать в файле перед каждой
инструкцией. Но это, почему-то, не всегда срабатывает.)

  <H3><A NAME="1">Первый способ - простой и неудобный.</A></H3>



<P>
  Самый тривиальный способ - сделать две клавиши-переключатели, каждая с двумя
состояниями. Одна клавиша переключает <B>"лат./старый рус."</B>, другая -
<B>"лат/новый рус."</B>. Или в терминах "номер группы", первая клавиша переключает
<B>"group1/group2"</B>, другая - <B>"group1/group3"</B>.


<P>
  Выберем два скан-кода и "подвесим" на них "действия" -

<PRE>
key &lt;...&gt; { actions[Group1]= [ LockGroup(group=2) ],
	    actions[Group2]= [ LockGroup(group=1) ] };

key &lt;...&gt; { actions[Group1]= [ LockGroup(group=3) ],
	    actions[Group3]= [ LockGroup(group=1) ] };

</PRE>

<P>
  Конечно, это - неполное описание. Надо добавить к первой клавише ее "поведение",
когда включена группа 3, на тот случай, если мы нажмем ее в ситуации, когда с
помощью второго переключателя уже выбрана третья группа. И, соответственно,
"поведение" второй клавиши в состоянии "группа 2".

<P>
  Кроме того, в описании должна быть кроме таблицы "действий" еще и таблица
символов. В нашем случае можно использовать специальный "псевдосимвол" -
<B>NoSymbol</B>.

<P>
  Тогда полное описание будет выглядеть как

<PRE>
key &lt;...&gt; { [NoSymbol],[NoSymbol],[NoSymbol],
	    actions[Group1]= [ LockGroup(group=2) ],
	    actions[Group2]= [ LockGroup(group=1) ],
	    actions[Group3]= [ LockGroup(group=1) ] };

key &lt;...&gt; { [NoSymbol],[NoSymbol],[NoSymbol],
	    actions[Group1]= [ LockGroup(group=3) ],
	    actions[Group2]= [ LockGroup(group=1) ],
	    actions[Group3]= [ LockGroup(group=1) ] };
</PRE>

  Но, на мой взгляд, такой способ переключения еще более неудобный.
(Я же не обещал "хороших" решений :-).
<BR>  Поэтому, я его даже не пробовал и вам не предлагаю.

  <H3><A NAME="2">Второй способ (через модификатор).</A></H3>



<P>
  Более удобным мне представляется способ, когда наш привычный перключатель
(пусть это будет <B>CapsLock</B>) продолжает переключать "лат/рус". А вот - какой
именно "рус" (вторую или третью группу) он выберет - будет определяться
другой клавишей.

<P>
  Естественно, при этом каждый из переключателей имеет два состояния.
Основной переключатель - "лат/рус", дополнительный - "группа2/группа3".


<P>
  Другими словами, "поведение" основного переключателя должно меняться
в зависимости от того, нажимали ли мы дополнительный переключатель (и сколько
раз - четное или нечетное количество).


<P>
  Собственно эти два "поведения" я уже написал в предыдущем примере.
Только там были две разные клавиши, а нам надо соместить это на одной.
Кстати, можно заметить, что эти два описания отличаются только
в одной строчке - "переход из состояния Group1", остальные части описания
совпадают.


<P>
  Итак. Подзадача - как сделать так, чтобы "поведение" клавиши менялось
в зависмости от состяния какой-нибудь другой.

<P>
  Первое, что приходит в голову - с помощью какого-нибудь модификатора.
Напомню, что каждая группа может делиться на уровни (<B>shift level</B>),
а выбор конкретного уровня зависит от состояния модификаторов. Причем,
эту зависимость мы можем как угодно менять, сочиняя новые "типы" клавиш.


<P>
  Все, что нам надо - взять какой-нибудь модификатор (виртуальный),
сочинить "тип", в котором переход на второй уровень зависит только от данного
модификатора (чтобы наш основной перключатель реагировал только на этот
модификатор) и, наконец, разделить у нашего переключателя (основного)
первую группу на два уровня и "присвоить" им разные действия.

<P>
  Естественно, "установку/сброс" модификатора "повесить" (с помощью
соответствующих "действий") на второй переключатель.


<P>
  Итак. Описание основного переключателя теперь будет иметь вид

<PRE>
key &lt;...&gt; { type[Group1]=".....",
	    [NoSymbol, NoSymbol], [NoSymbol], [NoSymbol],
	    actions[Group1]= [ LockGroup(group=2), LockGroup(group=3)],
	    actions[Group2]= [ LockGroup(group=1) ],
	    actions[Group3]= [ LockGroup(group=1) ] };
</PRE>

("тип" придумаем немного позже).


<P>
  Теперь надо "сочинить" модификатор и новый тип. И здесь нас ждет "засада".
Дело в том, что <B>xkbcomp</B> (по крайней мере в нынешнем состоянии) не позволяет
объявить новый виртуальный модификатор. Можно использовать только те, которые
в нем уже предопределены.

<P>
  К счастью, среди его модификаторов уже есть подходящий - <B>LevelThree</B>.
А подходящий он потому, что
<UL>
 <LI> во-первых, он практически не используется (по крайней мере в "русских"
конфигурациях),
 <LI> а во-вторых, есть уже подходящий тип, с использованием этого модификатора,
и нам не придется его описывать.
</UL>


<P>
  Таким образом, берем модификатор <B>LevelThree</B> и тип <B>"THREE_LEVEL"</B> -

<PRE>
type "THREE_LEVEL" {
	modifiers = Shift+LevelThree;
	map[None] = Level1;
	map[Shift] = Level2;
	map[LevelThree] = Level3;
	map[Shift+LevelThree] = Level3;
	level_name[Level1] = "Base";
	level_name[Level2] = "Shift";
	level_name[Level3] = "Level3";
};
</PRE>


<P>
  Напомню, что он уже должен быть в нашей "полной конфигурации" по умолчанию.
Только обратите внимание, что он определяет не два, а три уровня. Причем,
"наш" модификатор "посылает" на третий уровень. Но ничего страшного в этом
нет. Мы просто сдвинем второе "действие" на третий уровень, а второй можно
заполнить "заглушкой" - <B>NoAction()</B> или сделать его таким же как и первый
уровнь (обратите внимание - второй уровень, это - когда прижат <B>Shift</B>).


<P>
  Таким образом, наш основной переключатель (давайте уже определимся, что
это будет <B>&lt;CAPS&gt;</B>), приобретает вид

<PRE>
key &lt;CAPS&gt; { type[Group1]="THREE_LEVEL",
	[NoSymbol, NoSymbol, NoSymbol], [NoSymbol], [NoSymbol],
	actions[Group1]= [ LockGroup(group=2), NoAction(), LockGroup(group=3)],
	actions[Group2]= [ LockGroup(group=1)],
	actions[Group3]= [ LockGroup(group=1)] };
</PRE>


<P>
  Теперь можно заняться второй клавишей, которая будет "поднимать/опускать"
модификатор <B>LevelThree</B>. Конечно, это может быть не одиночная клавиша, а
какая-нибудь комбинация клавиш. Но для простоты, сначала возьмем отдельную
клавишу. Я на своей клавиатуре ("Микрософтовской") использовал для этого
клавишу "<B>Menu</B>" (скан-код <B>&lt;MENU&gt;</B>). Но, если у вас такой клавиши нет, то
можно задействовать одну из парных клавиш (<B>Shift, Control, Alt</B>).


<P>
  Итак. Сочиняем "поведение" клавиши <B>&lt;MENU&gt;</B>.
<BR>  Прежде всего - я думаю, что вам не хочется держать ее все время нажатой,
пока это нужно. То есть, нам надо, чтобы по первому нажатию она "подняла"
модификатор, а по второму - опустила.

<P>
  Как раз это делает "действие" <B>LockMods</B> (в переменной <B>locked modifiers</B>).
Напомню, что <B>SetMods</B> и <B>LatchMods</B> "держат" модификаторы только пока нажата
клавиша.

<P>
  Итак, используем "действие" <B>LockMods</B> -

<PRE>
key &lt;MENU&gt; 	{ [ NoSymbol ],
		actions[Group1]=[ LockMods(modifiers=LevelThree) ]};
</PRE>

(Описывать все три группы не обязательно. Если номер группы больше, чем
допустимо для клавиши, XKB будет его "выравнивать", пока не попадет в
допустимый диапазон.)


<P>
  Теперь остается одна тонкость. Дело в том, что сам по себе виртуальный
модификатор работать не будет, если он не связан с каким-нибудь реальным
модификатором. Напомню, что при общении модуля XKB с процедурами Xlib,
передается только "эмулируемый набор модификаторов" (то есть - реальные
модификаторы). И, хотя выполнение "действий" происходит внутри модуля XKB,
а не в Xlib, чтобы не возникало "разногласий" между XKB и Xlib по поводу
"состояния", необходимо "связать" виртуальный модификатор с каким-нибудь
реальным.


<P>
  Поэтому, последним шагом будет - связать с клавишей какой-нибудь
реальный модификатор (с помошью объявления <B>modifier_map</B>). И вот здесь
нас ждет вторая "засада". В полной конфигурации все модификаторы (даже
"безымянные" - <B>Mod1-Mod5</B>) уже расписаны. То есть, каждый уже соединен
с какой-нибудь клавишей и, соответственно, каким-нибудь символом.

<P>
  Самое неприятное то, что клиентские приложения могут реагировать на эти
модификаторы и менять свое поведение. Поэтому, если мы свяжем наш <B>LevelTree</B>,
например, с модификатором <B>Mod5</B>, который соответствует символу <B>Scroll_Lock</B>,
то, при "поднятии" модификатора <B>LevelThree</B>, приложения будут считать, что
нажата кнопка <B>ScrollLock</B>. А вот как они будут вести себя при этом - кто как.


<P>
  Здесь надо немного пояснить - как реагируют программы на "безымянные"
модификаторы. Поскольку этими модификаторам явно никакая функция не
соответствует, программы ориентируются на символы, которые с ними связаны.

<P>
  То есть, если программа обнаружит, что в "состоянии" модификаторов
взведен модификатор <B>Mod1</B>, она попытается найти соответствующий ему
символ. Обычно это - <B>Alt_L</B> и <B>Alt_R</B>, то есть любая из клавиш <B>Alt</B>.
Соответственно, программа считает, что нажата клавиша <B>Alt</B> и ведет себя
в соответствии со своим пониманием этой клавиши.


<P>
  Поэтому, чтобы избежать всяких "побочных" эффектов, нам надо не только
связать модификатор с нашей клавишей <B>&lt;MENU&gt;</B>, но и "отцепить" этот реальный
модификатор от других. Как я уже говорил в примере "добавление новой группы",
"отцепить" модификатор, который был объявлен где-то "в глубинах" <B>includ'ов</B>,
очень трудно. но, к счастью, они там привязываются не к скан-кодам, а к
символам. Поэтому, если мы в своей конфигурации просто уберем эти символы
из описаний скан-кодов, то связка "модификатор-символ" просто "повиснет
в воздухе" и таким образом нам удасться "отцепить" модификатор.


<P>
  Итак. Давайте возьмем реальный модификатор <B>Mod5</B>. Он используется только
для символа <B>Scroll_Lock</B>, а этот символ, в свою очередь, "подвешен" только
на клавишу <B>ScrollLock </B>(скан-код <B>&lt;SCLK&gt;</B>). Да и клавиша эта не самая
"часто используемая".


<P>
  Теперь нам надо добавить в описание клавиши <B>&lt;MENU&gt;</B> виртуальный модификатор
<B>LevelThree</B>. Добавить инструкцию <B>modifier_map</B>, который свяжет <B>Mod5</B> с нашей
клавишей. И, наконец, переопределить клавишу <B>&lt;SCLK&gt;</B>, чтобы в ней не было
упоминания и символе <B>Scroll_Lock</B>.

<PRE>
key &lt;MENU&gt; 	{ virtualMods = LevelThree,
		[ NoSymbol],
		actions[Group1]=[ LockMods(modifiers=LevelThree) ]};

modifier_map Mod5 { &lt;MENU&gt; };

key SCLK { [NoSymbol] };
</PRE>

  Вот теперь можно пробовать - что получилось.


<P>
  Конечно, это не самое лучшее решение.
<UL>
<LI>Во-первых, из-за того, что мы заняли реальный модификатор <B>Mod5</B> (кстати,
и отмена <B>ScrollLock</B> не во всех случаях спасает).
<LI>Во-вторых, наш дополнительный переключатель сам группы не меняет, а только
"машет флагом". Поэтому, если переключение "из лат. в рус" работает
всегда, то для переключения "из одного рус. в другой рус." надо не только
нажать дополнительный преключатель, но и "щелкнуть" основным.
<LI>Ну и, наконец, если мы захотим задействовать все четыре группы, то
решение будет еще сложнее (понадобится как минимум два виртуальных
модификатора, с которыми и так "напряженка").
</UL>

  Поэтому рассмотрим еще один способ -

  <H3><A NAME="3">Третий способ (через дополнительную переменную номера группы).</A></H3>



<P>
  Вспомним еще раз - в чем проблема. В том, что основной переключатель
должен переходит из одного состояния (текущая группа - Group1), в два
разных, в зависимости от состояния какой-то другой клавиши.

<P>
  Но ведь можно "запомнить" состояние дополнительного переключателя
нет только с помощью модификатора.


<P>
  Напомню, что номер группы может храниться в трех внутренних переменных
XKB - <B>locked, latched</B> и <B>base group</B>, значение которых можно менять
независимо. Причем для выбора символа у клавиши используется суммарное
значение этих переменных - <B>effective group</B>.

<P>
  Напомню также, что благодаря "методу выравнивания номера группы"
(см. <A HREF="internals.html#wrap">"Внутренности":Метод выравнивания..."</A>),
если суммарное значение
окажется больше, чем количество существующих групп на единицу, то опять
получится первая группа и т.д.


<P>
  Таким образом, можно заставить дополнительный переключатель "запоминать"
номер "альтернативной" группы в дополнительной "групповой" переменной,
например - <B>base group</B>. А основной переключатель пусть манипулирует
значением в другой переменной, например - <B>locked group</B>.


<P>
  Итак. Пусть дополнительный переключатель запоминает - какая из "русских"
групп нам требуется (2 или 3), например, в переменной <B>base group</B>.

<P>
  Тогда основной переключатель, чтобы перейти из "лат" в из "рус"
раскладок должен просто обнулить <B>locked group</B>. А для того, чтобы вернуться
обратно в "лат", надо в <B>locked group</B> записать "добавку", достаточно большую,
чтобы "метод выравнивания" "завернул" значение обратно к "лат" раскладке.

<P>
  Таким образом мы нашу проблему (переход из Group1 в два разных состояния)
решаем. Правда теперь у на появляется проблема - как вернуться обратно
из разных состояний в одно и ту же группу. Но она то, решается очень просто.
Поскольку клавиатура при этом находится в разных состояниях (Group2 и Group3),
то мы без проблем "подвешиваем" на клавишу два разных "действия", каждое
со своим значением "добавки".


<P>
  Прежде чем переходить написанию конфигурации клавишь, давайте проясним
вопрос: что значит "обнулить" переменную с номером группы, и - какие
"добавки" нам понадобятся.

<P>
  Надо сказать об одной тонкости - хотя в "конфигах" группы нумеруются -
1,2,3..., внутри XKB это означает - 0,1,2...
<BR>  То есть, group1 - на самом деле 0, group2 - 1 и т.д.


<P>
  Итак. Давайте сначала рассмотрим задачу во внутренних значениях XKB (0,1,2).
<BR>Тогда у нас
<UL>
<LI> первая группа ("лат") - 0
<LI> вторая группа ("старый рус.") - 1
<LI> третья группа ("новый рус.") - 2
<LI> максимальный номер группы - 2
</UL>
При этом
<UL>
<LI> если к 1 добавить 2 - получится снова 0 (3 на единицу больше, чем
"максимальный номер группы")
<LI> аналогично, если к 2 добавить 1 - снова вернемся к группе 0.
</UL>


<P>
  Тогда алгоритм работы переключателей мог бы быть таким -
<UL>
<LI> в дополнительной переменной (<B>base group</B>) запоминается номер одной из
русских раскладок - то есть, 1 или 2;
<LI> для того, чтобы перейти из состояния, когда текущая группа "лат",
в выбранную "рус", надо просто в <B>locked group</B> записать 0; 
<LI> а для того, чтобы вернуться в "лат" из состояния "рус." надо в переменную
<B>base group</B> записать -
<UL>
  <LI> 2, если текущая группа 1;
  <LI> 1, если текущая группа 2.
</UL>
</UL>


<P>
  Однако, не все так просто. Если мы попытаемся воплотить это в конфигурацию
клавиши, то нарвемся на очередную "засаду".

<P>
  Дело в том, что значения номера группы "запоминаются" только в <B>locked group</B>.
В других переменных (<B>base</B> и <B>latched</B>) они "держаться" только пока соответствующая
клавиша нажата и "испаряются" оттуда, если клавишу отпустить.


<P>
  Правда, у нас есть одна "лазейка". Мы можем изменить поведение клавиши
(той, что будет менять <B>base group</B>) и сделать ее "залипающей". Тогда XKB при
первом нажатии/отжатии клавиши выполнит только ту задачу, которая выполняется
при нажатии клавиши, а при повторном нажатии/отжатии наоборот - только то,
что выполняется при отжатии клавиши.

<P>
  Только обратите внимание, что когда мы ее все-таки "отожмем" там
получится 0. То есть, мы не сможем держать там "2 или 3", а только "2 или 0",
"1 или 0" и т.п.


<P>
  Ну и ладно. Придется в ней держать не "номер алтернативной раскладки",
а только "добавку" к номеру. То есть - не "2 или 3", а "0 или 1".


<P>
  Тoгда нам придется слегка подправить наш алгоритм -
<UL>
<LI> в дополнительной переменной (<B>base group</B>) запоминается "смещение" от
первой "русской" раскладки  - 0 или 1;
<LI> для того, чтобы перейти из состояния "лат", в нужную "рус", надо в
<B>locked group</B> записать 1;
<LI> для того, чтобы вернуться в "лат" из состояния "рус." надо в переменную
<B>base group</B> записать -
<UL>
  <LI> если текущая группа 1 (в base 0) - 0;
  <LI> если текущая группа 2 (в base 1) - 2.
</UL>
</UL>


<P>
  Теперь, переходя к обозначениям из "конфигов" (<B>group1, group2</B> и т.д.),
получим -
<UL>
  <LI> дополнительный переключатель:
    <UL>
     <LI> ну, 0 или <B>Group1</B> там получится автоматически при "отжатии" клавиши
     <LI> "запоминать" в <B>base group</B> надо <B>Group2</B>,
    </UL>
  <LI> основной переключатель:
    <UL>
     <LI> "действие" для <B>Group1</B> - записать в <B>locked group</B> значение <B>Group2</B>
     <LI> для <B>Group2</B> - записать <B>Group1</B>
     <LI> для <B>Group3</B> - записать <B>Group3</B>
    </UL>
</UL>


<P>
  Сочиняем описание клавиш (пусть это будут те же <B>&lt;CAPS&gt;</B> и <B>&lt;MENU&gt;</B>)

<PRE>
key &lt;CAPS&gt; { [NoSymbol],[NoSymbol],[NoSymbol],
	    actions[Group1]= [ LockGroup(group=2) ],
	    actions[Group2]= [ LockGroup(group=1) ],
	    actions[Group3]= [ LockGroup(group=3) ] };

key &lt;MENU&gt; 	{ [ NoSymbol ], locks= yes
		actions[Group1]=[ SetGroup(group=2) ]};
</PRE>

(обратите внимание - мы для дополнительного переключателя опять описываем
только одну группу. Все равно он может "перещелкивать" только два состояния,
и делать его "чувствительным" к текущей группе нет смысла.)


<P>
  Можно пробовать.


<P>
  Правда, надо признаться, что этот метод тоже не лишен недостатков.
Если вы начнете менять альтернативную раскладку, когда основной переключатель
стоит в положении <B>"какой-нибудь рус."</B> - все будет нормально.

<P>
  Но вот если "пощелкать" им, когда основной переключатель стоит в состоянии
<B>"лат"</B>, то результаты будут несколько "странные" (вы можете сами их
"просчитать"), поскольку "состояние лат." на самом деле - "хитро"  подобранная
сумма двух переменных (<B>base</B> и <B>locked</B>).

<P>
  С другой стороны, с этим можно примириться. Скорее всего в реальной работе
вы будете "подгонять" русскую раскладку, когда основной переключатель стоит
в сотоянии <B>"рус"</B>, а не готовить ее заранее (когда основной переключатель в
состоянии <B>"лат"</B>).


<P>
  Замечу также, что это не единственный вариант переключения "с помощью
двух переменных group". Можно, например, сделать так, чтобы дополнительный
переключатель работал с <B>locked group</B>, а основной - с <B>base group</B> (если
посмотреть исходный алгоритм, то там у основного переключателя есть состояние
когда он "держит" в "своей" переменной 0). Но этот вариант не лучше в смысле
"побочных эффектов", а в описании, пожалуй, сложнее.


<P>
  Поэтому, пока не этом и остановимся.
<BR>Тем более, что у нас остался еще -

  <H3><A NAME="final">"Заключительный аккорд" - "отцепляемся" от скан-кодов.</A></H3>



<P>
   Как я уже говорил - не очень хорошо, когда "действия" назначаются прямо
 в описании клавиши (в файлах <B>xkb_symbols</B>).

<P>
   Во всяком случае, при этом трудно распространить наше решение на случай,
когда роль основного или дополнительного переключателей (или обоих) выполняет
не одиночная клавиша, а комбинация клавиш.


<P>
  Обычно "хорошим тоном" является - привязать "действия" к каким-нибудь
сиволам (через "интерпретации"), а в описании клавиш использовать только
символы.


<P>
  Давайте проделаем это для любого из примеров, например, последнего.


<P>
  Единственная проблема - надо подобрать подходящии символы. Дело в том, что
брать коды обычных символов (даже "экзотических" - типа "умлаутов") не очень
хорошо. Потому, что при нажатии клавиши XKB будет не только выполнять
соответствующие "действия", но и выдавать в прикладную программу эти
символы. А программа, соответственно, будет пытаться их напечатать.


<P>
  К счастью, в наборе символов есть группа кодов, которые должны
использоваться только для внутренних нужд XKB и игнорироваться прикладными
программами. Вы можете найти их в файле <B>{XROOT}/include/X11/keysymdef.h</B>
их названия начинаются на <B>XK_ISO_</B>.
  Например,
<PRE>
XK_ISO_First_Group
XK_ISO_First_Group_Lock
XK_ISO_Last_Group
XK_ISO_Prev_Group_Lock
</PRE>
и т.п.


<P>
  Конечно, там нет символов из названия которых следует, что по этому символу
<B>"записать в locked group число 3"</B>. Но мы можем изменить семантику любого из
символов (тем более, что и не для каждого из этих символов задана семантика
в "конфигах" XKB).


<P>
  Давайте сначала выясним - сколько нам надо символов. Для этого посчитаем -
сколько у нас различных действий в описании обоих переключателей.
 
<PRE>
LockGroup(group=1)
LockGroup(group=2)
LockGroup(group=3)
SetGroup(group=2)
</PRE>
  Итого - 4 штуки.


<P>
  Давайте подберем им символы. Конечно, можно взять любые из тех о которых
говорилось выше. Но, чтобы лучше в них ориентироваться, подберем такие,
чтобы их название хоть немного походили на соответствующие действия.

<P>
  Обратите внимание, чтов  названиях присутствуют - <B>First_Group, Last_Group,
Next_Group</B> и <B>Prev_Group</B>.

<P>
  Давайте считать, что для нашего случая
<UL>
<LI><B>First_Group</B> - group=<B>1</B>
<LI><B>Next_Group</B> - group=<B>2</B>
<LI><B>Last_Group</B> - group=<B>3</B>
</UL>


<P>
  Тогда логично выбрать

<UL>
<LI>для <B>LockGroup(group=1) - ISO_First_Group_Lock</B>
<LI>для <B>LockGroup(group=2) - ISO_Next_Group_Lock</B>
<LI>для <B>LockGroup(group=3) - ISO_Last_Group_Lock</B>
<LI>для <B>SetGroup(group=2)  - ISO_Group_Lock</B>
</UL>


<P>
  Составим соответствующие "интерпретации". Напомню, что это нужно делать
в файле типа <B>xkb_compat</B> и, соответственно, "приплюсовать" это файл к строчке
в "полной" конфигурации, которая описывает именно <B>xkb_compat</B>
(а не <B>xkb_symbols</B>).


<P>
  Итак, наша "добавка" к <B>xkb_compat</B> (не забудьте ее "приплюсовать" куда надо) -

<PRE>
xkb_compat {
  interpret ISO_First_Group_Lock { action=LockGroup(group=1); };
  interpret ISO_Next_Group_Lock  { action=LockGroup(group=2); };
  interpret ISO_Last_Group_Lock  { action=LockGroup(group=3); };
  interpret ISO_Group_Lock       { action=SetGroup(group=2); locking = True;}; 

  group 2 = AltGr;
  group 3 = AltGr;
};
</PRE>
(Последнии две инструкции, "по идее" не нужны, поскольку уже должны быть
в "общей конфигурации". Но почему-то они иногда "теряются".)


<P>
  А описание символов (в <B>xkb_symbols</B>) теперь будут выглядеть как

<PRE>
key &lt;CAPS&gt; {	[ ISO_Next_Group_Lock ],
		[ ISO_First_Group_Lock ],
		[ ISO_Last_Group_Lock ] };

key &lt;MENU&gt; 	{ [ ISO_Group_Lock ] };
</PRE>


<P>
  Можно пробовать.


<P>
  На этом наши эксперименты на тему переключателей не заканчиваются.
<BR>  Дальше мы рассмотрим еще более сложный случай (и другие механизмы) -

  <H3><A HREF="example4.html">Еще несколько "переключателей".</A></H3>


<hr>
<p>Иван Паскаль <a href=mailto:pascal@tsu.ru> pascal@tsu.ru </a>
</BODY>
</HTML>
