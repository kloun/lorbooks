<HTML>
<HEAD>
 <TITLE>Файл, типа xkb_compat.</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">


   <H2>Файл, типа xkb_compat.</H2>

<P>
  В этом файле описывается поведение клавиш модификаторов - какие
изменения происходят в состоянии клавиатуры (изменения битов-модификаторов
и "номера группы") при нажатии этих клавиш.

<P>
  Напомню, что внутри XKB существует структура (таблица) - <B>Xkb Compability Map</B>,
которая состоит из двух частей
<UL>
<LI>набора (массива) "интерпретаций" (<B>interpret</B>)
<LI>четырех переменных, которые определяют - какие "реальные" модификаторы
(модификаторы "традиционного" клаватурного модуля X-сервера) будут
отображать изменение "номера группы".
</UL>

<B></B>  Если прикладные программы обращаются к X-серверу не специальными
XKB-запросами, а запросами к "традиционному" клавиатурному модулю
X-сервера, которые должны поменять "привязку" кодов символов (или реальных
модификаторов) к скан-кодам, то модуль XKB, выполнив требуемый перенос,
пытается также пренести и "действия", "привязанные" к скан-кодам
(и некоторые другие параметры клавиши).
<BR>  Для выполнения такого "переноса" и используется <B>Xkb Compability Map</B>.

<P>
  В файле типа xkb_compat могут встречаться объявления

<UL>
	<LI><A HREF="gram-compat.html#vmodDec">Объявление виртуальных модификаторов.</A>
	<LI><A HREF="gram-compat.html#interpret">Описание "интерпретации".</A>
	<LI><A HREF="gram-compat.html#group">Объявление "отображения номера группы в модификатор".</A>
	<LI><A HREF="gram-compat.html#indicator">Описание поведения индикатора.</A>
	<LI><A HREF="gram-compat.html#defaults">Объявление "умолчания".</A>
</UL>

  <H3><A NAME="vmodDec">Объявление виртуальных модификаторов.</A></H3>

<P>
  Как и в файле типа <B>xkb_types</B>, прежде всего должны быть объявлены
виртуальные модификаторы, которые могут встречаться в дальнейших
описаниях. Реальные модификаторы (если они также используются)
описывать не надо, поскольку, они имеют стандартные названия. А вот
виртуальные модификаторы могут иметь произвольные названия, поэтому,
для правильной интерпретации остальных записей необходимо сообщить
программе, которая будет "разбирать" этот файл, что соответствующие
слова являются названиями виртуальных модификаторов.

<P>
  Объявление виртуальных модификаторов имеет вид
<PRE>
'virtual_modifiers' список модификаторов ';'
</PRE>
  Например,
<PRE>
virtual_modifiers NumLock, AltGr ;
</PRE>

 <H3><A NAME="interpret"> Описание "интерпретации".</A></H3>

<P>
  Каждая "интерпретация" (<B>interpretation</B>) устанавливает соответствие
между кодом какго-нибудь "управляющего" символа (<B>symbol</B>) и "действием"
(<B>action</B>), которое должен будет выполнить модуль XKB при нажатии клавиши
к которой "привязан" этот символ.

<P>
  Полностью внутренняя структура, описывающая интерпретацию, состоит из
<UL>
<LI> кода символа
<LI> "действия"
<LI> набора реальных модификаторов
<LI> "критерия соответствия" модификаторам
<LI> флагов ("автоповтор" и "залипание")
<LI> виртуального модификатора для клавиши
</UL>

<P>
  Естественно, не все эти поля обязательно должны быть заполнены.

<P>
  Итак, поле "код символа", естественно, определяет символ, к которому
"привязывается" "действие", а поле "действие" - само это "действие".

<P>
  Также, в "интерпретации" могут быть заданы поля "реальные модификаторы"
и "критерий соответствия".

<P>
  Для чего нужны эти поля?
<BR>  Напомню, что к любому скан-коду может быть "привязан" один или несколько
реальных модификаторов. При поиске подходящего места для "действия",
XKB может использовать не только код символа, но и расположение этих
реальных модификаторов.

<P>
   Если эти поля НЕ заданы, то XKB, при изменнии "привязки" символа к
скан-коду, просто перенесет туда же соответствующее "действие".

<P>
  А вот если эти поля заданы, то прежде чем выполнить перенос, XKB
сравнивает набор реальных модификаторов, привязанных к скан-коду и
набор реальных модификаторов, указанный в "интерпретации". "Критерий
соответствия" определяет - как сравнивать эти два набора (см. ниже).
<BR> Если условие выполняется, "действие" переносится.

<P>
  Кстати, если используются эти два поля (набор модификаторов и "критерий
соответствия"), то кода символа может в интерпретации и не быть.

<P>
  При этом, поиск подходящего места делается XKB только на сравнении
наборов модификаторов. Например - найти тот скан-код, к которому
"привязан" реальный модификатор <B>Lock</B>, и перенести туда "действие",
независимо от того, какой код символа соответствует этому скан-коду.

<P>
  Итак. Поле "реальные модификаторы" представляет собой просто один или
несколько битов модификаторов.
<BR>  А "критерий соответствия" представляет собой одно из условий
<UL>
<LI> <B>AnyOfOrNone</B> (<B>любой из... или ни одного</B>) - практически означает, что поле
"модификаторов" не имеет никагого смысла, условие выполняется, если
совпадает любой из модификаторов или никакой;
<LI> <B>NoneOf</B> (<B>ни один из...</B>) - у скан-кода не должно быть ни одного из
указанных модификаторов;
<LI> <B>AnyOf</B> (<B>любой из...</B>) - у скан-кода должен быть хотя бы один из указанных
модификаторов;
<LI> <B>AllOf</B> (<B>все из...</B>) - должны совпасть все указанные модификаторы;
<LI> <B>Exactly</B> (<B>точно</B>) - то же, что и <B>AllOf</B>, но при этом у скан-кода не должно
быть ни одного модификатора, не попавшего в список.
</UL>
  Кроме того, вместе с любым из перечисленных "критериев" может быть
указан "критерий"
<UL>
<LI> <B>LevelOneOnly</B> (<B>только первый уровень</B>) - условие выполняется, если
символ привязывается к первому уровню первой группы в соответствующем
скан-коде. Выполнение этого условия также требуется, для переноса
"флагов" и "виртуального модификатора".
</UL>

<P>
  Естественно, "по умолчанию" поле модификаторов пустое, а "критерий" -
"<B>любой из.. или ни одного</B>".

<P>
  Поле флагов и виртуальный модификатор (он должен быть только один),
могут быть тоже "перенесены" в описание скан-кода, если символ "переносится"
в первый уровень первой группы таблицы, привязанной к скан-коду.

<P>
  Флаги добавляются в поле "поведение клавиши", а модификатор в поле
"виртуальные модификаторы" (эти поля есть у каждого описания скан-кода).

<P>
  "По умолчанию" поле "флаги" содержит флаг "автоповтор", а поле
"виртуальный модификатор" - пустое.

  Итак. Описание "интерпретации" имеет вид

<PRE>
'interpret' символ '{' описание  '};'
</PRE>
или
<PRE>
'interpret' символ '+' модификатор '{' описание  '};'
</PRE>
или
<PRE>
'interpret' символ '+' критерий '(' модификаторы ') {' описание  '};'
</PRE>

  Например
<PRE>
interpret  Nun_Lock {...};
interpret  ISO_Level2 + Shift {...};
interpret  ISO_Lock + AnyOf(Lock+shift) {...};
</PRE>

<P>
  Если в заголовке указан только код символа, критерий - <B>AnyOfOrNone</B>,
поле модификаторов - пустое.

<P>
  Если указан, код символа и название модификатора (не указан "критерий"),
то "критерий" - <B>Exactly</B>.

<P>
  Если указан "критерий", то в скобках вместо списка модификаторов может
стоять слово <B>all</B>. Понятно, что это означает - все модификаторы.

<P>
  Кроме того, вместо "критерия" и списка модификаторов может использоваться
слово <B>Any</B>. Это означает - <B>AnyOf(all)</B>.

<P>
  Наконец, как уже говорилось, если есть набор модификаторов и "критерий",
то кода символа может и не быть ("привязка" осуществляется путем сравнения
наборов модификаторов). В этом случае, вместо кода символа также ставится
слово - <B>Any</B>.
<BR>  Например,

<PRE>
interpret Any + Any {...};
</PRE>

означает, что эта "интерпретация" применяется ко всем клавишам, у которых
есть реальные модификаторы.

<P>
  Внутри описания "интерпретации" могут быть строчки типа оператора
присваивания

<UL>
<LI><A HREF="gram-compat.html#usemodmap">useModMapMods = ...; или useModMap = ...;</A>
<LI><A HREF="gram-compat.html#repeat">repeat = ...;</A>
<LI><A HREF="gram-compat.html#repeat">locking = ...;</A>
<LI><A HREF="gram-compat.html#vmod">virtualModifier = ...; или virtualMod = ...;</A>
<LI><A HREF="gram-compat.html#action">action = ...;</A>
</UL>

<H4><A NAME="usemodmap">useModMapMods</A></H4>

<P>
  Служит для указания "критерия" <B>LevelOneOnly</B>.
Если справа стоит слово "<B>level1</B>" или "<B>levelone</B>", то "критерий" проверяется.
Если слова "<B>anylevel</B>" или "<B>any</B>" - игнорируется. Кстати, "по умолчанию" он
игнорируется, так что строчки вида

<PRE>
useModMapMods = anylevel;
</PRE>

особого смысла не имеют.

  <H4><A NAME="repeat">repeat и locking</A></H4>

<P>
  Устанавливают значения для флагов "автоповтор" и "залипание".
Справа от присваивания должно быть логическое значение - <B>True</B> или <B>False</B>.
<BR>Например,
<PRE>
repeat = True;
locking = False;
</PRE>

  <H4><A NAME="vmod">virtualModifier</A></H4>

<P>
  Указывает виртуальный модификатор. Напомню, что этот модификатор
тоже може быть добавлен к описанию скан-кода, если символ переносится
в "первый уровень первой группы" таблицы значений для скан-кода. 

<P>
  Справа от присваивания просто указывается название виртуального
модификатора.
<BR>  Например,
<PRE>
virtualModifier = AltGr;
</PRE>

  <H4><A NAME="action">action</A></H4>

<P>
  Описывает "действие". Подробнее об этом читайте 
<A HREF="gram-action.html">"Описание действий"</A>.
<BR>  Здесь замечу, что "действие" также может быть "пустым".
Если "интерпретация" нужна для того, чтобы перенести не "действие",
а только "флаги" или "виртуальный модификатор", то ее описание
может выглядеть как

<PRE>
interpret ... {
  repeat = False;
  locking = True;
  action = NoAction();
};
</PRE>

  <H3><A NAME="group">Объявление "отображения номера группы в модификатор".</A></H3>

<P>
  Напомню, что в "состоянии XKB" (которое может быть "считано" прикладной
программой) есть специальное двухбитное поле, в котором указан текущий номер
группы. В "традиционном" "состоянии клавиатуры" такого поля нет, а смена
группы индицируется одним из модификаторов.

<P>
  Поэтому, для программ, понимающих только "традиционное состояние клавиатуры",
XKB преобразует номер группы в активное состояние какого-нибудь модификатора.

<P>
  Для каждого из четырех номеров групп может быть объявлен отдельный
модификатор (хотя обычно, используется один для всех групп, отличных от первой).

<P>
  Это объявление имеет очень простой вид.
<PRE>
'group' номер группы '=' модификатор ';'
</PRE>
  Например,
<PRE>
group 2 = AltGr;
</PRE>

  <H3><A NAME="indicator">Описание поведения индикатора.</A></H3>

<P>
  В файлах типа <B>xkb_compat</B> также описывается "поведение индикаторов",
хотя к "таблице совместимости" (<B>compability</B>) они отношения не имеют.

<P>
  Напомню, что в XKB можно определить до 32 индикаторов. Первые 3-4
(в зависимости от типа клавиатуры) отображаются реальными "лампочками"
на клавиатуре, а остальные считаются "виртуальными" и могут отображаться
специальными программами.

<P>
  В файле типа <B>xkb_keycodes</B> индикаторам даются символические имена
(связыватся номера индикаторов и "имя индикатора").

<P>
  А в файле <B>xkb_compat</B> описывается - как эти индикаторы ведут себя
в зависимости от "состояния клавиатуры". Напомню, что...
<BR>  Во-первых, индикаторы могут отображать состояние
<UL>
 <LI> модификаторов,
 <LI> номера группы,
 <LI> управляющих флагов.
</UL>
Причем, поскольку первые два из перечисленных "компонентов состояния XKB"
"размазаны" по трем переменным (<B>base, locked, latched</B>), поведение
индикаторы можно связать с любой из указанных переменных или с их
"эффективным" (суммарным) значением.

<P>
  Надо отметить, что один и тот же индикатор может одновременно "отслеживать"
изменения и "своего" модификатора, и какого-нибудь номера группы, и
управляющего флага (хотя, зачем это нужно?).

<P>
  Во-вторых, индикатор может не только "отслеживать" состяние XKB, но и
включаться/выключаться прикладными программами. При этом, в описании
индикатора можно разрешить/запретить такое включение/выключение или
установить "обратную связь" (то есть, при включении/выключении индикатора
будут происходить соответствующие изменения в состоянии XKB).

<P>
  Итак. Описание поведения индикатора имеет вид

<PRE>
'indicator' имя_индикатора '{' описание  '};'
</PRE>

<P>
  Здесь "<B>имя_индикатора</B>" - это то символическое имя (строка символов
в двойных кавычках), которое было дано ему в файле <B>xkb_keycodes</B>.

<P>
  А "<B>описание</B>" обычно имеет вид оператора присваивания (исключение -
логические переменные-флаги, которые могут принимать значения только
<B>True/False</B>).

<P>
  В этих "описаниях" могут встретиться строчки типа
<UL>
<lI><A HREF="gram-compat.html#mods-group-ctrl">modifiers = ...; или mods  = ...;</A>
<LI><A HREF="gram-compat.html#mods-group-ctrl">groups = ...;</A>
<LI><A HREF="gram-compat.html#mods-group-ctrl">controls = ...; или  ctrls = ...;</A>
<LI><A HREF="gram-compat.html#which">whichModState = ...; или whichModifierState  = ...;</A>
<LI><A HREF="gram-compat.html#which">whichGroupState = ...;</A>
<LI><A HREF="gram-compat.html#explicit">allowExplicit = ...;</A>
<LI><A HREF="gram-compat.html#driveskbd">drivesKeyboard = ...;</A> (имеет кучу "синонимов", см. ниже)
<LI><A HREF="gram-compat.html#index">index = ...;</A>
</UL>

 <H4><A NAME="mods-group-ctrl">modifiers, groups и controls</A></H4>

<P>
  Определяют - какие компоненты "состояния" должен отслеживать индикатор.
<BR>  Естественно, справа от знака присваивания должен быть ...
<UL>
<LI> для <B>modifiers</B> - название модификатора или нескольких модификаторов через
знак "+";
<LI> для <B>groups</B> - номера групп;
<LI> для <B>controls</B> - название "управляющего флага" (флагов).
</UL>

<P>
  Надо отметить, что номер группы можно задавать
<UL>
<LI> просто числовым значением
<LI> в виде - <B>group1, group2</B> и т.п.;
<LI> можно использовать слова "<B>none</B>" (0) и "<B>all</B>" (0xFF);
<LI> и, наконец, с помощью простых арифметических выражений, например,
<B>All-1</B> ("все, кроме первой")
</UL>

 <H4><A NAME="which">whichModState и whichGroupState</A></H4>

<P>
  Поскольку набор модификаторов и номер группы "размазаны" по трем
переменным (<B>base, locked, latched</B>), эти инструкции уточняют - в каких
переменных надо отслеживать модификаторы и номер группы, соответственно.

<P>
  Справа от присваивания может быть слово
<UL>
<LI> <B>base</B> - отслеживать изменение в переменных <B>base</B> (<B>base Group</B>
 или <B>base Modifiers</B>, соответственно)
<LI> <B>locked</B> - то же самое, в переменных <B>locked</B>
<LI> <B>latched</B> - то же самое, в переменных <B>latched</B>
<LI> <B>effective</B> - отслеживать изменения "эффективных" номера групп или
модификаторов (то есть в суммарных значениях всех трех переменных)
<LI> <B>any</B> - отслеживать изменения во всех трех переменных (то есть, индикатор
будет включаться/выключаться, если указанное значение модификатора или группы
будет меняться в любой из трех переменных); надо заметить, что для
модификаторов (<B>whichModState</B>) это значение эквивалентно <B>effective</B>, поскольку
"включение" модификатора в любой из трех переменных, неизбежно "включит"
его и в "эффективном" наборе модификаторов;
<LI> <B>none</B> - "ни в каком"; особого смысла не имеет, поскольку при этом просто
не отслеживаются модификаторы и/или номер группы.
</UL>
  По умолчанию (то есть, если <B>which...State</B> явно не указаны) подразумевается
<B>effective</B>.

  <H4><A NAME="explicit">allowExplicit</A></H4>

<P>
  Логический флаг, который разрешает (запрещает) прикладным программам
включать/выключать индикатор. Обратите внимание, конечно, для
включения/выключения индикатора прикладная программа посылает специальные
запросы к XKB. Но XKB по этим командам только меняет (если это разрешено)
только состояние индикатора, не затрагивая свое "состояние". Естественно,
при этом состояние индикатор может не соответствовать состоянию XKB.

<P>
  Поскольку <B>allowExplicit</B> является логической переменной, справа от
присваивания должно быть только <B>True</B> или <B>False</B>.

<P>
  Можно также использовать другую форму этой инструкции.
Так, просто указание
<PRE>
allowExplicit;
</PRE>
эквивалентно
<PRE>
allowExplicit = True;
</PRE>
а строчка
<PRE>
!allowExplicit;
</PRE>
эквивалентна
<PRE>
allowExplicit = False;
</PRE>
  По умолчанию этот "флажок" - <B>True</B>. То есть, прикладным программам разрешено
менять состяние индикатора, помимо "состояния клавиатуры".

 <H4><A NAME="driveskbd">drivesKeyboard</A></H4>

<P>
  Имеет много синонимов - <B>drivesKbd, ledDrivesKbd, ledDrivesKkeyboard,
indicatorDrivesKbd, indicatorDrivesKeyboard</B>.

<P>
  Это тоже логический флаг, который заставляет XKB устанавливать "обратную
связь" между индикатором и "состянием клавиатуры". То есть, если это флаг
"взведен" (и разрешено <B>allowExplicit</B>), то, при изменении прикладной программой
состяния индикатора, XKB должен изменить и связанные с ним компоненты
"состяния клавиатуры".

<P>
  Обратите внимание, что
<UL>
<LI> меняться должны те компонеты, которые заданы инструкциями <B>modifiers</B>,
<B>group</B> и <B>controls</B> (обычно задан только один из компонентов);
<LI> инструкции <B>whichModState</B> и <B>whichGroupState</B> указывают - в каких из
трех переменных (<B>base, locked, latched</B>) следует поменять модификатор или
группу.
</UL>

<P>
  При этом, если "<B>which...state</B>" - <B>none, base</B> или <B>any</B>, никакого эффекта
не будет. А <B>effective</B> эквивалентно <B>locked</B>. Напомню, что по умолчанию
подразумевается значение <B>effective</B>, следовательно - если инструкций
вида "<B>which...state</B>" в описании нет, то изменения будут делаться в
<B>locked Group</B> или <B>locked Modifiers</B>, соответственно.

<P>
  Как и в случае с флагом <B>allowExplicit</B>, объявление <B>drivesKeyboard</B>
должно иметь вид
<PRE>
drivesKeyboard = True; ( эквивалент - drivesKeyboard;)
</PRE>
или
<PRE>
drivesKeyboard = False; ( эквивалент - !drivesKeyboard;)
</PRE>

  <H4><A NAME="index">index</A></H4>

<P>
  Позволяет указать номер индикатора (физического или виртуально).
Вообще-то, номер индикатора связывается с "именем индикатора" в файле
типа <B>xkb_keycodes</B>. Но можно указать его явно здесь.

  <H3><A NAME="defaults">Объявление "умолчания".</A></H3>

<P>
  Это объявление является воспомогательным и позволяет определить какое-нибудь
поле (инструкцию) для всех записей типа <B>interpret</B> или <B>indicator</B>. Естественно,
обычно эти объявления помещаются в начале файла (или блока в файле).

<P>
  Они меют вид оператора присваивания, где в левой части указывается
конструкция типа "поля структуры" в языке C.
<BR>  Например,
<PRE>
indicator.allowExplicit = False;
</PRE>
что означает - во всех дальнейших описаниях индикаторов (<B>indicator</B>)
подразумевается "<B>allowExplicit = False;</B>", если конечно, эта инструкция
не указана явно.

<P>
  Первым словом в левой части (то, что до точки) должно быть
<UL>
<LI> <B>interpret</B> - "умолчания" для описания "интерпретаций";
<LI> <B>indicator</B> - "умолчания" для описания индикаторов;
<LI> <B>название "действия"</B>, встречающегося в описаниях <B>interpret</B> - задает
"умолчание" для соответствующих полей "действия", которое может встретиться
в дальнейших описаниях "интерпретаций".
</UL>

<hr>
<p>Иван Паскаль <a href=mailto:pascal@tsu.ru> pascal@tsu.ru </a>
</BODY>
</HTML>
