<HTML>
<HEAD>
 <TITLE>Файл типа xkb_types.</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

  <H2>Файл типа xkb_types.</H2>

<P>
   В этом файле описывается - каким образом вычисляется "уровень" (<B>shift level</B>)
в таблице символов (<B>symbols</B>) для каждой клавиши.

<P>
  Напомню, что с каждой клавишей (скан-кодом) в XKB связан двумерный массив
символов. "Координатами" в этом массиве являются "номер группы" (<B>group</B>)
и "уровень" (<B>shift level</B>). То есть, когда нажата какая-то кнопка и XKB
должен выбрать подходящий символ для данной клавиши, этот символ выбирается
из массива в соответствии с текущими "номером группы" и "уровнем".

<P>
  Обычно, разные "номера групп" используется для разных национальных языков
(точнее - алфавитов), а разные "уровни" используются для больших/маленьких
букв (в общем-то, все знают - что меняется при нажатии кнопки <B>Shift</B>).
Хотя заметим, что XKB позволяет иметь до четырех групп и до 64 (!) "уровней"
(в то же время, если не ошибаюсь, <B>xkbcomp</B> допускает номер "уровня" только
до 8).

<P>
  Так вот. Если изменение "номера группы" описывается в файле <B>xkb_compat</B>,
то зависимость "уровня" от нажатия клавиш-модификаторов (<B>Shift, Control,
Alt</B> и т.п.) описывается как-раз в файлах <B>xkb_types</B>.

<P>
  Точнее, в этих файлах описываются "типы" клавиш. Каждый тип имеет название
(в общем-то, произвольное), а в "описании типа" определяется - как вычислять
"уровень" для клавиш этого типа.

<P>
  Соответственно, в файлах <B>xkb_symbols</B>, где скан-кодам "приписываются"
необходимые массивы возможных символов для каждой клавиши, указывается
и тип этой кнопки. Правда, принадлежность каждой клавиши к конкретному
типу, уже определена "по умолчанию" в модуле XKB (и соответственно,
определены четыре типа "по умолчанию"). Поэтому, не ищите в файлах
<B>xkb_symbols</B> явного указания типа, они используются только в том случае,
когда хочется изменить "поведение" клавиши.

<P>
 Итак. В файле <B>xkb_types</B> могут встретиться объявления

<UL>
	<LI><A HREF="gram-types.html#vmodDec">Объявление виртуальных модификаторов.</A>
	<LI><A HREF="gram-types.html#type">Объявление типа.</A>
</UL>

  <H3><A NAME="vmodDec">Объявление виртуальных модификаторов.</A></H3>

<P>
  Это объявление просто перечисляет - какие виртуальные модификаторы далее
могут использоватся в объявлениях типов.

<P>
  Напомню, что в самом X-сервере (не в модуле XKB) определенны восемь
модификаторов - <B>Shift, Lock, Control, Mod1-Mod5</B>, которые в терминах XKB
называются "реальными" (<B>real</B>). В дополнение к ним XKB может иметь еще своих
16 модификаторов, которые, соответственно в нем именуются "виртуальными"
(<B>virtual</B>). Обычно, в XKB вводятся виртуальные модификаторы <B>NumLock,
ScrollLock, Alt, AltGr</B> и т.п.
<BR>  Назначение модификаторов на конкретные клавиши делается в файле <B>xkb_symbols</B>.

<P>
  Так вот. В описаниях типа могут фигурировать как реальные, так и виртуальные
модификаторы. Поскольку, "реальные" определены "по умолчанию", никаких
специальных объявлений для них не требуется. А вот названия "виртуальных"
желательно объявить, прежде чем описывать типы.

<P>
  Объявление виртуальных модификаторов имеет очень простой вид

<PRE>
'virtual_modifiers' список_модификаторов  ';'
</PRE>

где <B>"список_модификаторов"</B> - просто перечисление используемых модификаторов
через запятую.
<B></B>  Например, строчка

<PRE>
virtual_modifiers NumLock, Alt;
</PRE>

говорит о том, что в описаниях типов могут встречаться кроме реальных
модификаторов (<B>Shift, Lock</B> и т.д.), также модификаторы
<B>NumLock</B> и <B>Alt</B>.

  <H3><A NAME="type">Объявление типа.</A></H3>

<P>
  Эти объявления выглядят как

<PRE>
'type' ИмяТипа '{' Инструкции '};'
</PRE>

<P>
  <B>"ИмяТипа"</B> - это призвольная константа типа STRING (то есть строка
символов в "двойных кавычках"). Это имя потом может использоваться в
<B>xkb_symbols</B> для явного указания типа клавиши.

<P>
  А <B>"Инструкции"</B> это несколько объявлений (они выглядят как "присваивание"
переменной некоторого значения), кадое заканчивается "точкой с запятой".

<P>
  В описании типа могут всречаться инструкции

<UL>
	<LI><A HREF="gram-types.html#modifiers">modifiers = ...;</A>
	<LI><A HREF="gram-types.html#map">map[...] = ...;</A>
	<LI><A HREF="gram-types.html#level_name">level_name[...] = ...;</A>
	<LI><A HREF="gram-types.html#preserve">preserve[...] = ...;</A>
</UL>

 <H4><A NAME="modifiers">modifiers</A></H4>

<P>
  Просто перечисляет, какие модификаторы (реальные и виртуальные) влияют
на выбор "уровня" в данном типе. Если модификаторов несколько, они
перечисляются через знак '+'.
<BR>  Например,
<PRE>
modifiers = NumLock;
</PRE>
или
<PRE>
modifiers = Shift+Lock;
</PRE>

 <H4><A NAME="map">map[...]</A></H4>

<P>
  Как-раз описывает - какой "уровень" выбирается в зависимости от состояния
(активности) модификатора. В квадратных скобках указывается модификатор
или их комбинация (через знак '+'), а справа от "знака присваивания" -
соответствующий "уровень" (<B>Level1, Level2</B> ...). Кроме того, в качестве
модификатора (внутри скобок) может встречаться специальное слово <B>"None"</B>,
что, как не трудно догадаться, означает отсутствие (точнее - неактивное
состояние) модификаторов.
<BR>  Например,

<PRE>
map[None] = Level1;
</PRE>
если модификатор (модификаторы) не активен, то используется "уровень" 1,

<PRE>
map[Shift] = Level2;
</PRE>
если активен модификатор <B>Shift</B>, то выбирается "уровень" 2,

<PRE>
map[Control+Alt] = Level3;
</PRE>
если активны сразу два модификатора - <B>Control</B> и <B>Alt</B>, то выбрать "уровень" 3.

<P>
  Обратите внимание, что в последнем примере каждый из модификаторов
<B>Control</B> и <B>Alt</B>, по-отдельности могут никак не влиять на изменения "уровня",
(а только нажатые вместе). В этом случае в описании типа не будет строчек c
<B>map[Control]</B> и <B>map[Alt]</B>.
<BR>  А вот <B>map[None]</B>, как правило, присутствует в каждом типе.

<H4><A NAME="level_name">level_name[...]</A></H4>

<P>
  Эта инструкция присваивает призвольное символьное имя для каждого "уровня",
допустимого для данного типа. Соответственно, в квадратных скобка
указывается "уровень" (<B>Level1, Level2</B> ...), а справа от "присваивания"
константа типа STRING, которая и является названием этого уровня.
<BR>  Например,

<PRE>
level_name[Level1] = "Base";
level_name[Level2] = "Shifted";
</PRE>

(вместо слова level_name можно использовать levelname).
<BR>  Надо заметить, что для функционирования XKB это названия (и, соответственно,
вся эта инструкция) не имеет никакого значения. Они могут использоваться
прикладными программами, которые показывают состояние клавиатуры.

  <H4><A NAME="preserve">preserve[...]</A></H4>

<P>
  Здесь требуются некоторые пояснения.
<BR>  Напомню, что X-сервер передает прикладной программе сообщение о событии
(нажатии/отпускании клавиши) в котором указывается скан-код клавиши
и слово - "состояние" состоящее из набора модификаторов.

<P>
  Для перевода этого сообщения в символ используются соответствующие
подпрограммы Xlib.

<P>
  Естественно, эти программы в используют в качестве аргументов и скан-код
и "состояние". Причем, отдельные подпрограммы (их там несколько) могут
для принятия решения использовать не все модификаторы из "состояния".

<P>
  Для того, чтобы избежать нежелательных эффектов, когда несколько таких
подпрограмм обрабатывают сообщение последовательно, каждая подпрограмма
обычно "вычищает" "использованные" модификаторы из слова-"состояния".

<P>
  Но, в то же время, бывают ситуации, когда это нежелательно и какой-нибудь
модификатор должен "приниматься во внимание" несколькими подпрограммами.
<BR>(Что это за ситуации - я сам не знаю.)

<P>
  Для таких случаев и используется инструкция preserve - "сохранить"
(имеется ввиду - сохранять модификатор в "состоянии").

<P>
  В этой инструкции в квадратных скобках указывется модификатор (или
комбинация модификаторов), такой же, как в одной из инструкции <B>map[...]</B>,
а справа от "присваивания" - модификатор (или набор модификаторов),
который нужно сохранять.

<P>
  Обратите внимание, что в скобках обязательно должна быть комбинация
(или модификатор), точно такая же как и в одной из инструкций <B>map[...]</B>.
<BR> Дело в том, что инструкция <B>preserve[...]</B> не является самостоятельной
инструкцией, а представляет собой "продолжение" соответствующей инструкции
<B>map[...]</B>. Поэтому, по "комбинации в скобках" XKB "сшивает" эти две
инструкции.
<BR>  А вот в правой части может быть только часть этих модификаторов
(или даже один). То есть, в обработке будут учитываться все модификаторы
из левой части, а сохраняться только те, которые указаны в правой.

<P>
  Надо сказать, что в правой части инструкции <B>preserve</B> может, также,
стоять и <B>"None"</B>, что означает, что "ничего сохранять не нужно".
<BR>Но, поскольку "по умолчанию" и так ничего не сохраняется, то такие инструкции
особого смысла не имеют и их можно не писать.

  <H3><A NAME="default_types">Предопределенные типы.</A></H3>

<P>
  В модуле XKB "по умолчанию" определены четыре типа и, соответственно,
каждая клавиша "по умолчанию" приписана к одному из этих четырех типов.

<UL>
<LI> <B>"ONE_LEVEL"</B> - клавиши, которые имею только одно значение, независимо от
состояния модификаторов (<B>Enter, Escape, Space</B> и т.п.)

<LI> <B>"TWO_LEVEL"</B> - клавиши с двумя уровнями (но не "буквенные"), второй уровень
выбирается модификатором <B>Shift</B> (но не зависит от <B>Lock</B>). Это, в основном,
клавиши на основной клавиатуре с цифрами и "специальными" символами
(1/!, 2/@, 3/# и т.д.)

<LI> <B>"ALPHABETIC"</B> - "буквенные" клавиши. Они имеют два уровня (прописные/строчные),
но в отличии от клавиш типа <B>"TWO_LEVEL"</B> зависят не только от <B>Shift</B>, но и от
<B>Lock</B>.

<LI> <B>"KEYPAD"</B> - клавиши на "дополнительной цифровой клавиатуре" (<B>keypad</B>). Тоже
имеют два уровня, зависят от состояния <B>NumLock</B> и <B>Shift</B>.
</UL>

<P>
  Надо заметить, что, если клавиша отнесена к соответствующему типу,
в ее описании (в <B>xkb_symbols</B>) массив значений должен иметь необходимое
количество "уровней".

<P>
  Как следствие этого, хотя вы можете переопределить любой из
"предопределенных" типов (поменяв в нем модификаторы или названия
уровней), но при этом нельзя менять в них количество уровней.
<BR>  Если вам хочется иметь для каких-то клавиш большее количество уровней,
придется сочинить для них новый тип (напомню, что назвать его можно
как угодно).

<P>
  Примеры описаний типов, можно посмотреть в соответствущих файлах в
директории <B>{XKBROOT}/types/</B>, поэтому я здесь их приводить не буду.

<P>
  А пример составления нового типа и его использования можно
посмотреть в разделе <A HREF="example1.html">"Примеры":"Новый тип для клавиши Enter"</A>.

<hr>
<p>Иван Паскаль <a href=mailto:pascal@tsu.ru> pascal@tsu.ru </a>

</BODY>
</HTML>
