<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from shellutils.texi on January, 31  2002 -->

<TITLE>Утилиты оболочки GNU - 5. Условия</TITLE>
</HEAD>
<BODY >
 [<A HREF="shellutils_toc.html">Содержание</A>] &#160; [<A HREF="shellutils_4.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="shellutils_6.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC16">5. Условия</A></H1>

<P>
<A NAME="IDX101"></A>


<P>
   Эта глава описывает команды, которые преимущественно полезны из-за
их кода возврата, чем их вывода. Т.о., они часто используются как
условия в выражениях `if', или как последная команда в канале.




<H2><A NAME="SEC17">5.1 `false': Ничего не делать, неуспешно</A></H2>

<P>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>


<P>
   `false' ничего не делает за исключением того, что возвращает 
значение 1, означающий "ошибка". Она может использоваться для занимания
места в скриптах, где необходима неуспешная команда.
    
   `false' игнорирует <I>все</I> аргументы коммандной строки, даже `--help'
и `--version', т.к. в противном случае изметится ожидаемое поведение, на
которое некоторые программисты расчитывают. 


<P>
   Эта версия `false' реализована на C и поэтому более защищена и
быстра, чем скрипт, и может безопасно использоваться как фиктивный
командный интерпретарор для выключенных профилей пользователей. 




<H2><A NAME="SEC18">5.2 `true': Ничего не делать, успешно</A></H2>

<P>
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>


<P>
   `true' ничего не делает кроме как возращает значение 0,
означающее "успех". Она может использоваться для занимания места в 
скриптах, где необходима неуспешная команда, но встроенная команда
`:' (двоеточие) делает то же быстрее.


<P>
   `true' игнорирует <I>все</I> аргументы коммандной строки, даже `--help'
и `--version', т.к. в противном случае изметится ожидаемое поведение, на
которое некоторые программисты расчитывают. 


<P>
   Эта версия `true' реализована на C и поэтому более защищена и
быстра, чем скрипт, и может безопасно использоваться как фиктивный
командный интерпретарор для выключенных профилей пользователей. 




<H2><A NAME="SEC19">5.3 `test': Проверяет типы файлов и сравнивает значения</A></H2>

<P>
<A NAME="IDX106"></A>
<A NAME="IDX107"></A>


<P>
   `test' возвращает значение 0 (истина) или 1 (ложь) в зависимости
от вполнения условного выражение ВЫРАЖ. Каждая часть выражения должна
быть отдельным аргументом.


<P>
   `test' может выполнять проверки состояния файлов, строковые операции
и операции сравнения чисел.


<P>
   Поскольку большинство командных оболочек имеют встроенную команду
с таким именем,  использование неуточненного имени команды в скрипте
или интерактивно может привести к функциональных отличиям от данного
описания.


<P>
   Кроме параметров описанных ниже, `test' понимает взятые в отдельности
`--help' или `--version'. раздел <A HREF="shellutils_2.html#SEC2">2. Общие параметры</A>. Единственный не 
параметрический аргумент также допустим: `test' возвращает истину, если
аргумент не пустой.




<H3><A NAME="SEC20">5.3.1 Проверка типов файлов</A></H3>

<P>
<A NAME="IDX108"></A>


<P>
   Эти параметры проверяют отдельные типы файлов. (Все является файлом,
но не все файлы одинаковы!)


<P>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<DL COMPACT>

<DT><SAMP>`-b ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и является специальным болчным устройством.
x@item -c ФАЙЛ
Истинно, если ФАЙЛ существует и является специальным символьным устройством.
<DT><SAMP>`-d ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и является каталогом.
<DT><SAMP>`-f ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ вуществует и является простым файлом.
<DT><SAMP>`-h ФАЙЛ'</SAMP>
<DD>
<DT><SAMP>`-L ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и является символической ссылкой.
<DT><SAMP>`-p ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и является именованным каналом.
<DT><SAMP>`-S ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и является сокетом.
<DT><SAMP>`-t [ФД]'</SAMP>
<DD>
Истинно, если ФД открыт на терминале. Если ФД опущен, он считается 
равным 1 (стандартный вывод).
</DL>



<H3><A NAME="SEC21">5.3.2 Проверка прав доступа</A></H3>

<P>
<A NAME="IDX118"></A>


<P>
   Эти параметры проверяют отдельные правва доступа.


<P>
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<A NAME="IDX126"></A>
<DL COMPACT>

<DT><SAMP>`-g ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и имеет включенный бит установки
идентификатора группы.
<DT><SAMP>`-k ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ имеет установленный "липкий" бит.
<DT><SAMP>`-r ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и он читаемый.
<DT><SAMP>`-u ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и имеет включенный бит установки 
идентификатора пользователя.
<DT><SAMP>`-w ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и доступен для записи.
<DT><SAMP>`-x ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и является исполняемым.
<DT><SAMP>`-O ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и принадлежит текущему эффективному
идентификатору пользователя.
<DT><SAMP>`-G ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и принадлежит текущему эффективному
идентификатору группы.
</DL>



<H3><A NAME="SEC22">5.3.3 Проверка файловых характеристик</A></H3>

<P>
<A NAME="IDX127"></A>


<P>
   Эти параметры проверяют другие файловые характеристики.


<P>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
<A NAME="IDX132"></A>
<DL COMPACT>

<DT><SAMP>`-e ФАЙЛ'</SAMP>
<DD>
Истинно, если файл существует.
<DT><SAMP>`-s ФАЙЛ'</SAMP>
<DD>
Истинно, если ФАЙЛ существует и его размер больше нуля.
<DT><SAMP>`ФАЙЛ1 -nt ФАЙЛ2'</SAMP>
<DD>
Истинно, если ФАЙЛ1 новее (согласно дате изменения) чем ФАЙЛ2.
<DT><SAMP>`ФАЙЛ1 -ot ФАЙЛ2'</SAMP>
<DD>
Истинно, если ФАЙЛ1 старее (согласно дате изменения) чем ФАЙЛ2.
<DT><SAMP>`ФАЙЛ1 -ef ФАЙЛ2'</SAMP>
<DD>
Истинно, если ФАЙЛ1 и ФАЙЛ2 имеют одинаковые номера устройств и
i-узлов, т.е. являются жесткими ссылками друг на друга.
</DL>



<H3><A NAME="SEC23">5.3.4 Строковые тесты</A></H3>

<P>
<A NAME="IDX133"></A>


<P>
   Эти параметры проверяют характеристики строк. Строки не закавычены
для `test', хотя Вам может понадобиться закавычить их для защиты символов
со специальным значением для командной оболочки, например, пробелов.


<P>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<A NAME="IDX137"></A>
<DL COMPACT>

<DT><SAMP>`-z СТРОКА'</SAMP>
<DD>
Истинно, если длина СТРОКИ равна нулю. 
<DT><SAMP>`-n СТРОКА'</SAMP>
<DD>
<DT><SAMP>`СТРОКА'</SAMP>
<DD>
Истинно, если длина СТРОКИ не равна нулю. 
<DT><SAMP>`СТРОКА1 = СТРОКА2'</SAMP>
<DD>
Истинно, если строки равны.
<DT><SAMP>`СТРОКА1 != СТРОКА2'</SAMP>
<DD>
Истинно, если строки не равны.
</DL>



<H3><A NAME="SEC24">5.3.5 Численные тесты</A></H3>

<P>
<A NAME="IDX138"></A>


<P>
   Сравнения чисел. Аргументы дожны быть полностью числовыми
(возможно отрицательными), или специальным выражением `-l СТРОКА',
которая определяет длину СТРОКИ.


<P>
<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>
<A NAME="IDX142"></A>
<A NAME="IDX143"></A>
<A NAME="IDX144"></A>
<DL COMPACT>

<DT><SAMP>`АРГ1 -eq АРГ2'</SAMP>
<DD>
<DT><SAMP>`АРГ1 -ne АРГ2'</SAMP>
<DD>
<DT><SAMP>`АРГ1 -lt АРГ2'</SAMP>
<DD>
<DT><SAMP>`АРГ1 -le АРГ2'</SAMP>
<DD>
<DT><SAMP>`АРГ1 -gt АРГ2'</SAMP>
<DD>
<DT><SAMP>`АРГ1 -ge АРГ2'</SAMP>
<DD>
Эти двоичные арифметические операторы возращают истину, если АРГ1 равен,
не равен, меньше, меньше или равен, больше, больще или равен чем
АРГ2, соответсвенно.
</DL>

<P>
Например:



<PRE>
     test -1 -gt -2 &#38;&#38; echo yes
     =&#62; yes
     test -l abc -gt 1 &#38;&#38; echo yes
     =&#62; yes
     test 0x100 -eq 1
     error--&#62; test: ожидалось целочисленное выражение перед -eq
</PRE>



<H3><A NAME="SEC25">5.3.6 Связки для `test'</A></H3>

<P>
<A NAME="IDX145"></A>


<P>
   Обычные логические связки.


<P>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<DL COMPACT>

<DT><SAMP>`! ВЫРАЖ'</SAMP>
<DD>
Истинно, если ВЫРАЖ ложно.
<DT><SAMP>`ВЫРАЖ1 -a ВЫРАЖ2'</SAMP>
<DD>
Истинно, если оба ВЫРАЖ1 и ВЫРАЖ2 истинны.
<DT><SAMP>`ВЫРАЖ1 -o ВЫРАЖ2'</SAMP>
<DD>
Истинно, если ВЫРАЖ1 или ВЫРАЖ2 истинны.
</DL>



<H2><A NAME="SEC26">5.4 `expr': Вычисление выражений</A></H2>

<P>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>


<P>
   expr вычисляет выражение и пишет результат на стандартный
вывод. Каждая лексема выражение должна быть отдельным аргументом.


<P>
   Операнды могут быть числами или строками. `expr' преобразует все,
что находится в позиции операнда, к целому числу или строке в зависимости
от применяемой операции.


<P>
   Строки не закавычены для `test', хотя Вам может понадобиться 
закавычить их для защиты символов со специальным значением для командной 
оболочки, например, пробелов.


<P>
   Операторы могут быть заданы как инфиксные символы или префиксные 
ключевые слова. Скобки обычным образом для группировки (Вам нужно закавычить
скобки, для защиты их от вычисления командной оболочкой).


<P>
   Возвращаемое значение:


<DL COMPACT>

<DT><SAMP>`0'</SAMP>
<DD>
Если выражение не пустое и не нуль
<DT><SAMP>`1'</SAMP>
<DD>
Если выражение пустое или нуль
<DT><SAMP>`2'</SAMP>
<DD>
Неверное выражение
</DL>



<H3><A NAME="SEC27">5.4.1 Строковые выражения</A></H3>

<P>
<A NAME="IDX151"></A>


<P>
   `expr' подерживает проверку по шаблону и другие строковые операторы.
Они имеют более низкий приоритет чем арифметические операторы и операторы
отношения.


<P>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>
<A NAME="IDX160"></A>
<A NAME="IDX161"></A>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>
<DL COMPACT>

<DT><SAMP>`СТРОКА : РЕГВЫР'</SAMP>
<DD>
Выполнить проверку по шаблону. Аргументы преобразуются в строки и
второй считается (простым, как в GNU `grep') регулярным выражением,
с неявно предваренным `^'. Первый аргумент проверяется на это регулярное
выражение.

Если проверка прошла успешно и РЕГВЫР содержит `\(' and `\)', 
выражение `:' возвращает часть СТРОКИ, которая соответсвует
подвыражению; в противном случае оно возвращает числа соответствующих
символов.

Иесли проверка оказалась неуспешной, выражение `:' возвращает пустую
строку, если РЕГВЫР содержит `\(' and `\)', иначе 0.

Только первая пара `\( ... \)' используется в возвращаемом значении;
дополнительные пары имеют смысл только для группировки операторов
регулярных выражений.

В регулярном выражении `\+', `\?', и `\|' являются операторами, 
которые соответствуют соврадению один или более, нуль или более, 
нуль или один раз, или разделяет альтернативы. SunOS `expr'ы трактуют
их как регулярные символы. (POSIX допускает иное  поведение.) 

<DT><SAMP>`match СТРОКА РЕГВЫР'</SAMP>
<DD>
Альтернативный способ поверки по шаблону. Это тоже самое, что и 
`СТРОКА : РЕГВЫР'.

<DT><SAMP>`substr СТРОКА ПОЗИЦИЯ ДЛИНА'</SAMP>
<DD>
Возвращает подстроку СТРОКи начинающуюся в ПОЗИЦИИ с максимальной 
длмной ДЛИНА. Если ПОЗИЦИЯ или ДЛИНА отрицательны, равны нулю,
или не числа, возвращается пустая строка.

<DT><SAMP>`index СТРОКА НАБОР-СИМВОЛОВ'</SAMP>
<DD>
Возвращает первую позицию в троке, где первый символ из НАБОРа-СИМВОЛОВ
найден. Если символы из НАБОРа-СИМВОЛОВ не найдены в СТРОКе, возврашается 0.

<DT><SAMP>`length СТРОКА'</SAMP>
<DD>
Возвращает длину СТРОКи

<DT><SAMP>`quote ЛЕКСЕМА'</SAMP>
<DD>
Интерпретировать ЛЕКСЕМу как строку, даже если это ключевое слово как MATCH
или оператор как `/'. Это делает возможным проверять `expr length quote "$x"' 
или `expr quote "$x" : '.*/\(.\)" и заставлять `expr' делать то, что нужно,
даже если значение $x, например, `/' или `index'. Этот опрератор является
расширением GNU. Он отключен, если переменная окружения `POSIXLY_CORRECT'
установлена.
</DL>

<P>
   Чтобы заставить `expr' интерпретировать ключевые слова как строки,
Вы должны использовать оператор `quote'.




<H3><A NAME="SEC28">5.4.2 Арифметические выражения</A></H3>

<P>
<A NAME="IDX165"></A>


<P>
   `expr' поддерживает обычные арифметические операторы, в порядке
возрастания приоритета. Строковые операторы имеют более низкий
приоритет, связки более высокий.


<P>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<DL COMPACT>

<DT><SAMP>`+ -'</SAMP>
<DD>
Сложение и вычитание. Оба аргумента преобразуются в числа; ошибка выдается
если это невозможно.
<DT><SAMP>`* / %'</SAMP>
<DD>
Умножение, деление, остаток от деления. Оба аргумента преобразуются в числа; ошибка выдается
если это невозможно.
</DL>



<H3><A NAME="SEC29">5.4.3 Свзяки для `expr'</A></H3>

<P>
<A NAME="IDX171"></A>


<P>
   `expr' поддерживает обычные логические связки и отношение. Они
имеют более высокий приоритет, чем строковые или арифметические 
операторы. Вот список в порядке возрастания приоритета.


<P>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
<A NAME="IDX176"></A>
<A NAME="IDX177"></A>
<A NAME="IDX178"></A>
<A NAME="IDX179"></A>
<DL COMPACT>

<DT><SAMP>`|'</SAMP>
<DD>
Возвращает первый аргумент, если он не пустой и не 0, в противном 
случае второй аргумент.
<DT><SAMP>`&#38;'</SAMP>
<DD>
Возвращает свой первый аргумент, если он не пустой или 0,
иначе 0.
<DT><SAMP>`&#60; &#60;= = == != &#62;= &#62;'</SAMP>
<DD>
Сравнивает аргументы и возвращает 1 если отношение верно, 0 в противном
случае. `==' это синоним для `='. `expr' сначала пытает преобразовать
оба аргумента в числа и использовать численное сравнение, если это не
удается сделать, используется лексическое сравнение.
</DL>



<H3><A NAME="SEC30">5.4.4 Примеры использования `expr'</A></H3>

<P>
<A NAME="IDX180"></A>


<P>
   Вот несколько примеров использования кавычек для метасимволов
командных оболочек.


<P>
   Чтобы сложить 1 и переменную оболочки `foo' в оболочках совместимых
с Борновыми:

<PRE>
     foo='expr $foo + 1'
</PRE>

<P>
   Чтобы напечатать имя файла, хранимого в `$fname', без пути, который
может не содержать `/':

<PRE>
     expr $fname : '.*/\(^.*\)' '^|' $fname
</PRE>

<P>
   Пример, показывающий, что `\+' это оператор:

<PRE>
     expr aaa : 'a\+'
     =&#62; 3

     expr abc : 'a\(.\)c'
     =&#62; b
     expr index abcdef cz
     =&#62; 3
     expr index index a
     error--&#62; expr: syntax error
     expr index quote index a
     =&#62; 0
</PRE>

<P></P><HR>
 [<A HREF="shellutils_toc.html">Содержание</A>] &#160; [<A HREF="shellutils_4.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="shellutils_6.html">Вперед</A>] &#160;

</BODY>
</HTML>
