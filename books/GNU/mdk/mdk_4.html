<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on June, 9  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>GNU MIX Development Kit (mdk): Учебник по MIX и MIXAL</TITLE>

<META NAME="description" CONTENT="GNU MIX Development Kit (mdk): Учебник по MIX и MIXAL">
<META NAME="keywords" CONTENT="GNU MIX Development Kit (mdk): Учебник по MIX и MIXAL">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC10"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_3.html#SEC9"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_3.html#SEC3"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 2. Учебник по MIX и MIXAL </H1>
<!--docid::SEC10::-->
<P>

В серии книг <CITE>Искусство программирования</CITE> Д. Кнута для иллюстрации
алгоритмов и умений, необходимых каждому серьёзному программисту, автор
использует виртуальный компьютер MIX (вместе с соответствующим набором
двоичных инструкций). Как для любого реального компьютера, существует
символический язык ассемблера, на котором можно программировать MIX --
язык ассемблера MIX, MIX assembly language, сокращённо MIXAL. В следующих
подразделах вы найдёте учебник, который даст вам основы архитектуры MIX
и научит программировать MIX на языке MIXAL.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC11">2.1 Компьютер MIX</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Архитектура и набор инструкций</TD></TR>
</TABLE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;компьютера&nbsp;MIX.
<br>
<TABLE BORDER=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC26">2.2 MIXAL</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Язык ассемблера MIX.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Компьютер MIX"></A>
<HR SIZE="6">
<A NAME="SEC11"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC10"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC10"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC10"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.1 Компьютер MIX </H2>
<!--docid::SEC11::-->
<P>

В этом разделе вы найдёте описание компьютера MIX, его компонентов
и набора инструкций.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC12">2.1.1 Архитектура MIX</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC13">2.1.2 Набор инструкций MIX</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Архитектура MIX"></A>
<HR SIZE="6">
<A NAME="SEC12"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC10"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.1 Архитектура MIX </H3>
<!--docid::SEC12::-->
<P>

Основной единицей информации в компьютере MIX является <EM>байт</EM>, в
котором хранится положительное значение в диапазоне от 0 до 63.
Имейте в виду, что байт MIX может быть представлен шестью битами, а не
восемью, как <EM>регулярный</EM> байт. Если иное не оговорено специально,
слово <EM>байт</EM> будет обозначать 6-битный байт MIX.
</P><P>

<EM>Слово</EM> MIX определяется как набор из пяти байтов и знака. Байты
слова нумеруются от 1 до 5, первым является старший байт. Знак обозначается
индексом 0. Графически,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> -----------------------------------------------
|   0   |   1   |   2   |   3   |   4   |   5   |
 -----------------------------------------------
|  +/-  | байт  | байт  | байт  | байт  | байт  |     
 -----------------------------------------------
</pre></td></tr></table>Примеры слов MIX: <SAMP>`- 12 00 11 01 63'</SAMP>, <SAMP>`+ 12 11 34 43 00'</SAMP>.
</P><P>

Вы можете ссылаться на часть слова, используя <EM>спецификацию поля</EM>
(<EM>fspec</EM>) в виде: "(<VAR>L</VAR>:<VAR>R</VAR>)", где <VAR>L</VAR> обозначает
первый байт, а <VAR>R</VAR> -- последний байт поля. Когда <VAR>L</VAR> равно нулю,
поле включает знак слова. Спецификация может также быть представлена
одним числом <CODE>F</CODE>, вычисляемым как <CODE>F = 8*L + R</CODE> (так, спецификация
<SAMP>`(1:3)'</SAMP>, обозначающая первые три байта слова, представляется числом 11).
</P><P>

Компьютер MIX сохраняет информацию в <EM>регистрах</EM>, хранящих либо слово,
либо два байта и знак (см. ниже), и в <EM>ячейках памяти</EM>, каждая из
которых содержит слово. Если быть точным, компьютер MIX имеет 4000
ячеек памяти с адресами от 0 до 3999 (т.е., для адресации ячейки памяти
достаточно двух байтов) и следующие регистры:
</P><P>

<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>
</P><P>

<DL COMPACT>
<DT><CODE>rA</CODE>
<DD>Регистр A. Регистр общего назначения, хранящий слово. Обычно его
содержимое служит операндом арифметических операций и инструкций
сохранения в памяти.
<DT><CODE>rX</CODE>
<DD>Регистр X. Регистр общего назначения, хранящий слово. Часто выступает
как расширение или замена <SAMP>`rA'</SAMP>.
<DT><CODE>rJ</CODE>
<DD>Регистр J (jump, переход). Этот регистр содержит положительное двухбайтовое
значение, обычно представляющее адрес перехода.
<DT><CODE>rI1</CODE>, <CODE>rI2</CODE>, <CODE>rI3</CODE>, <CODE>rI4</CODE>, <CODE>rI5</CODE>, <CODE>rI6</CODE>
<DD>Индексные регистры. Эти шесть регистров могут сохранять двухбайтовое
значение со знаком. Их содержимое используется как индексирующее значение
при вычислении эффективных адресов памяти.
</DL>
<P>

<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
Кроме того, компьютер MIX содержит:
</P><P>

<UL>
<LI>
<EM>Триггер переполнения</EM> (один бит со значениями <EM>включен</EM>
и <EM>выключен</EM>). В настоящем руководстве этот триггер обозначается OV.
<LI>
<EM>Индикатор сравнения</EM> (имеющий три значения: <EM>РАВНО</EM>,
<EM>БОЛЬШЕ</EM> и <EM>МЕНЬШЕ</EM>). В настоящем руководстве этот индикатор
обозначается CM, а его возможные значения сокращаются <EM>E</EM> (equal),
<EM>G</EM> (greater) и <EM>L</EM> (less).
<LI>
Блочные устройства ввода/вывода. Каждое устройство обозначено <CODE>un</CODE>,
где <CODE>n</CODE> пробегает значения от 0 до 20. В определении Кнута,
устройства от <CODE>u0</CODE> до <CODE>u7</CODE> -- носители на магнитной ленте,
от <CODE>u8</CODE> до <CODE>u15</CODE> -- диски и барабаны, <CODE>u16</CODE> -- устройство
чтения перфокарт, <CODE>u17</CODE> -- устройство записи перфокарт, <CODE>u18</CODE>
-- строчный принтер, <CODE>u19</CODE> -- текстовый терминал, и <CODE>u20</CODE> --
перфоленточное устройство. Наша реализация отображает эти устройства
в дисковые файлы, кроме <CODE>u19</CODE>, представляющего собой стандартный
вывод.
</UL>
<P>

Как замечено выше, компьютер MIX взаимодействует с внешним миров
с помощью набора устройств ввода/вывода, которые могут быть к нему
"подключены". Компьютер обменивается информацией, используя блоки
слов, длина которых зависит от устройства (see section <A HREF="mdk_8.html#SEC60">6.3 Блочные устройства MIX</A>). Эти слова
интерпретируются устройством либо как двоичная информация (для устройств
0-16), либо как представление печатаемых литер (устройства 17-20).
В последнем случае каждый байт MIX отображается в литеру в соответствии
со следующей таблицей:
</P><P>

<TABLE>
<TR><TD>00 </TD><TD>  </TD><TD> 01 </TD><TD> A </TD><TD> 02 </TD><TD> B </TD><TD> 03 </TD><TD> C</TD>
</TR>
<TR><TD>04 </TD><TD> D </TD><TD> 05 </TD><TD> E </TD><TD> 06 </TD><TD> F </TD><TD> 07 </TD><TD> G</TD>
</TR>
<TR><TD>08 </TD><TD> H </TD><TD> 09 </TD><TD> I </TD><TD> 10 </TD><TD> d </TD><TD> 11 </TD><TD> J</TD>
</TR>
<TR><TD>12 </TD><TD> K </TD><TD> 13 </TD><TD> L </TD><TD> 14 </TD><TD> M </TD><TD> 15 </TD><TD> N</TD>
</TR>
<TR><TD>16 </TD><TD> O </TD><TD> 17 </TD><TD> P </TD><TD> 18 </TD><TD> Q </TD><TD> 19 </TD><TD> R</TD>
</TR>
<TR><TD>20 </TD><TD> s </TD><TD> 21 </TD><TD> p </TD><TD> 22 </TD><TD> S </TD><TD> 23 </TD><TD> T</TD>
</TR>
<TR><TD>24 </TD><TD> U </TD><TD> 25 </TD><TD> V </TD><TD> 26 </TD><TD> W </TD><TD> 27 </TD><TD> X</TD>
</TR>
<TR><TD>28 </TD><TD> Y </TD><TD> 29 </TD><TD> Z </TD><TD> 30 </TD><TD> 0 </TD><TD> 31 </TD><TD> 1</TD>
</TR>
<TR><TD>32 </TD><TD> 2 </TD><TD> 33 </TD><TD> 3 </TD><TD> 34 </TD><TD> 4 </TD><TD> 35 </TD><TD> 5</TD>
</TR>
<TR><TD>36 </TD><TD> 6 </TD><TD> 37 </TD><TD> 7 </TD><TD> 38 </TD><TD> 8 </TD><TD> 39 </TD><TD> 9</TD>
</TR>
<TR><TD>40 </TD><TD> . </TD><TD> 41 </TD><TD> , </TD><TD> 42 </TD><TD> ( </TD><TD> 43 </TD><TD> )</TD>
</TR>
<TR><TD>44 </TD><TD> + </TD><TD> 45 </TD><TD> - </TD><TD> 46 </TD><TD> * </TD><TD> 47 </TD><TD> /</TD>
</TR>
<TR><TD>48 </TD><TD> = </TD><TD> 49 </TD><TD> $ </TD><TD> 50 </TD><TD> &#60; </TD><TD> 51 </TD><TD> &#62;</TD>
</TR>
<TR><TD>52 </TD><TD> @ </TD><TD> 53 </TD><TD> ; </TD><TD> 54 </TD><TD> : </TD><TD> 55 </TD><TD> '</TD>
</TR></TABLE>
Значение 0 представляет пробел. Буквы нижнего регистра (d, s, p)
в этой таблице обозначают литеры, не представимые как литеры ASCII
(соответственно, прописные дельта, сигма и гамма), байтам в диапазоне
56-63 литеры не сопоставлены.
<P>

Наконец, компьютер MIX имеет виртуальный центральный процессор,
управляющий вышеперечисленными компонентами, который может выполнять
богатый набор инструкций (составляющих его машинный язык, похожий
на используемые в реальных центральных процессорах), включая арифметические
и логические операции, инструкции помещения значения в память, сравнения
и перехода. Являясь типичным компьютером фон Неймана, ЦП MIX последовательно
(если только не встречается инструкция перехода) извлекает из памяти двоичные
инструкции и сохраняет адрес следующей выполняемой инструкции во
внутреннем регистре, называемом <EM>счётчиком положения</EM> (в других
архитектурах также известен как программный счётчик).
</P><P>

Следующий раздел, See section <A HREF="mdk_4.html#SEC13">2.1.2 Набор инструкций MIX</A>, даёт полное описание
доступных двоичных инструкций MIX.
</P><P>

<A NAME="Набор инструкций MIX"></A>
<HR SIZE="6">
<A NAME="SEC13"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC14"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC10"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.2 Набор инструкций MIX </H3>
<!--docid::SEC13::-->
<P>

В следующих подразделах полностью описан набор инструкций компьютера
MIX. Мы начнём с описания структуры двоичной инструкции и используемой
для ссылки на её поля нотации. Остальные подразделы посвящены описанию
собственно инструкций, которые может использовать программист MIX.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC14">2.1.2.1 Структура инструкции</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC15">2.1.2.2 Команды загрузки</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC16">2.1.2.3 Команды запоминания</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC17">2.1.2.4 Арифметические команды</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC18">2.1.2.5 Команды пересылки адреса</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC19">2.1.2.6 Команды сравнения</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC20">2.1.2.7 Команды перехода</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC21">2.1.2.8 Команды ввода/вывода</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC22">2.1.2.9 Команды преобразования</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC23">2.1.2.10 Команды сдвига</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC24">2.1.2.11 Прочие команды</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC25">2.1.2.12 Временные характеристики</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Структура инструкции"></A>
<HR SIZE="6">
<A NAME="SEC14"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC15"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.1 Структура инструкции </H4>
<!--docid::SEC14::-->
<P>

<EM>Инструкции</EM> MIX кодируются словами со следующей структурой полей:
</P><P>

<TABLE>
<TR><TD><EM>Поле</EM> </TD><TD> <EM>fspec</EM> </TD><TD> <EM>Описание</EM></TD>
</TR>
<TR><TD>ADDRESS </TD><TD> (0:2)</TD>
</TD><TD> Первые два байта и знак являются полем <EM>адреса</EM>. Вместе
с полем INDEX они обозначают используемый инструкцией адрес памяти.
</TR>
<TR><TD>INDEX </TD><TD> (3:3)</TD>
</TD><TD> Третий байт -- <EM>индекс</EM>, обычно используемый для модификации
адреса<A NAME="DOCF4" HREF="mdk_fot.html#FOOT4">(4)</A>.
</TR>
<TR><TD>MOD </TD><TD> (4:4)</TD>
</TD><TD> Четвёртый байт используется либо как модификатор кода операции,
либо как спецификация поля.
</TR>
<TR><TD>OPCODE </TD><TD> (5:5)</TD>
</TD><TD> Последний (младший) байт слова определяет код операции.
</TR></TABLE>
<P>

или, графически,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> ------------------------------------------------
|   0   |   1   |   2   |   3   |   4   |   5    |
 ------------------------------------------------
|        ADDRESS        | INDEX |  MOD  | OPCODE |     
 ------------------------------------------------
</pre></td></tr></table></P><P>

Для каждой инструкции <SAMP>`M'</SAMP> обозначает адрес памяти, получаемый
после модификации поля ADDRESS байтом INDEX, а <SAMP>`V'</SAMP> -- содержимое
описываемого байтом MOD поля ячейки памяти с адресом <SAMP>`M'</SAMP>.
Например, предположим, что содержимое регистров и ячеек памяти MIX
таково:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[rI2] = + 00 63
[31] = - 10 11 00 11 22
</pre></td></tr></table>где <SAMP>`[n]'</SAMP> обозначает содержимое n-й ячейки памяти, а <SAMP>`[rI2]'</SAMP>
-- содержимое регистра <SAMP>`rI2'</SAMP><A NAME="DOCF5" HREF="mdk_fot.html#FOOT5">(5)</A>. Рассмотрим двоичную инструкцию
<SAMP>`I = - 00 32 02 11 10'</SAMP>. Для этой инструкции:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>ADDRESS = - 00 32 = -32
INDEX = 02 = 2
MOD = 11 = (1:3)
OPCODE = 10

M = ADDRESS + [rI2] = -32 + 63 = 31
V = [M](MOD) = (- 10 11 00 11 22)(1:3) = + 00 00 10 11 00
</pre></td></tr></table></P><P>

Обратите внимание, при вычислении <SAMP>`V'</SAMP>, используя слово и спецификацию
поля, мы применяем к выбранным <SAMP>`MOD'</SAMP> байтам левое заполнение, чтобы
получить в качестве результата целое слово.
</P><P>

В следующих подразделах мы присвои каждой инструкции MIX мнемонику
или символическое имя. Например, мнемоникой инструкции с <SAMP>`OPCODE'</SAMP>
10 будет <SAMP>`LD2'</SAMP>. Таким образом, вышеприведённую инструкцию можно
переписать:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>LD2  -32,2(1:3)
</pre></td></tr></table>а в общем случае:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>MNEMONIC  ADDRESS,INDEX(MOD)
</pre></td></tr></table>Некоторые инструкции идентифицируются и полем OPCODE, и полем MOD.
В этих случаях в символическом представлении MOD будет отсутствовать.
Если ADDRESS или INDEX равны нулю, они также могут быть опущены.
Наконец, значение MOD по умолчанию составляет (0:5) (означающее
всё слово).
</P><P>

<A NAME="Команды загрузки"></A>
<HR SIZE="6">
<A NAME="SEC15"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC14"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC16"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.2 Команды загрузки </H4>
<!--docid::SEC15::-->
<P>

Для загрузки содержимого памяти в регистр могут использоваться
следующие инструкции:
</P><P>

<DL COMPACT>
<A NAME="IDX18"></A>
<DT><CODE>LDA</CODE>
<DD><A NAME="IDX19"></A>
Поместить в rA содержимое ячейки памяти M.
OPCODE = 8, MOD = fspec. <CODE>rA &#60;- V</CODE>.
<A NAME="IDX20"></A>
<DT><CODE>LDX</CODE>
<DD><A NAME="IDX21"></A>
Поместить в rX содержимое ячейки памяти M.
OPCODE = 15, MOD = fspec. <CODE>rX &#60;- V</CODE>.
<A NAME="IDX22"></A>
<DT><CODE>LDi</CODE>
<DD><A NAME="IDX23"></A>
Поместить в rIi содержимое ячейки памяти M.
OPCODE = 8 + i, MOD = fspec. <CODE>rIi &#60;- V</CODE>.
<A NAME="IDX24"></A>
<DT><CODE>LDAN</CODE>
<DD><A NAME="IDX25"></A>
Поместить в rA содержимое ячейки памяти M с противоположным знаком.
OPCODE = 16, MOD = fspec. <CODE>rA &#60;- -V</CODE>.
<A NAME="IDX26"></A>
<DT><CODE>LDXN</CODE>
<DD><A NAME="IDX27"></A>
Поместить в rX содержимое ячейки памяти M с противоположным знаком.
OPCODE = 23, MOD = fspec. <CODE>rX &#60;- -V</CODE>.
<A NAME="IDX28"></A>
<DT><CODE>LDiN</CODE>
<DD><A NAME="IDX29"></A>
Поместить в rIi содержимое ячейки памяти M с противоположным знаком.
OPCODE = 16 + i, MOD = fspec. <CODE>rIi &#60;- -V</CODE>.
</DL>
<P>

Во всех вышеперечисленных инструкиях поле <SAMP>`MOD'</SAMP> выбирает байты
из ячейки памяти с адресом <SAMP>`M'</SAMP>, загружаемые в нужный регистр
(указанный <SAMP>`OPCODE'</SAMP>).  Например, слово <SAMP>`+ 00 13 01 27 11'</SAMP>
представляет собой инструкцию:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>LD3    13,1(3:3)
 ^      ^ ^  ^
 |      | |  |
 |      | |   --- MOD = 27 = 3*8 + 3
 |      |  --- INDEX = 1
 |       --- ADDRESS = 00 13
  --- OPCODE = 11
</pre></td></tr></table>Предположим, что перед выполнением этой инструкции компьютер MIX находился
в следующем состоянии:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[rI1] = - 00 01
[rI3] = + 24 12
[12] = - 01 02 03 04 05
</pre></td></tr></table>Поскольку, в этом случае <SAMP>`M = 13 + [rI1] = 12'</SAMP>,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>V = [M](3:3) = (- 01 02 03 04 05)(3:3)
  = + 00 00 00 00 03
</pre></td></tr></table>(имейте в виду, что указанное поле заполняется слева нулевыми байтами
до полного слова).  Отсюда, состояние MIX после выполнения инструкции
будет:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[rI1] = - 00 01
[rI3] = + 00 03
[12] = - 01 02 03 04 05
</pre></td></tr></table></P><P>

Чтобы ещё проиллюстрировать команды загрузки, приведём таблицу,
показывающую содержимое <SAMP>`rX'</SAMP> после различных инструкций <SAMP>`LDX'</SAMP>:
</P><P>

<DL COMPACT>
<DT><SAMP>`LDX 12(0:0)     [rX] = - 00 00 00 00 00'</SAMP>
<DD><DT><SAMP>`LDX 12(0:1)     [rX] = - 00 00 00 00 01'</SAMP>
<DD><DT><SAMP>`LDX 12(3:5)     [rX] = + 00 00 03 04 05'</SAMP>
<DD><DT><SAMP>`LDX 12(3:4)     [rX] = + 00 00 00 03 04'</SAMP>
<DD><DT><SAMP>`LDX 12(0:5)     [rX] = - 01 02 03 04 05'</SAMP>
<DD></DL>
<P>

<A NAME="Команды запоминания"></A>
<HR SIZE="6">
<A NAME="SEC16"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC15"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC17"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.3 Команды запоминания </H4>
<!--docid::SEC16::-->
<P>

Следующие инструкции обратны операциям загрузки -- они используются
для запоминания поля регистра в памяти. Здесь MOD обозначает поле
ячейки памяти, которое должно быть перезаписано байтами из регистра.
Берутся самые правые байты регистра.
</P><P>

<DL COMPACT>
<A NAME="IDX30"></A>
<DT><CODE>STA</CODE>
<DD><A NAME="IDX31"></A>
Запомнить rA. OPCODE = 24, MOD = fspec. <CODE>V &#60;- rA</CODE>.
<A NAME="IDX32"></A>
<DT><CODE>STX</CODE>
<DD><A NAME="IDX33"></A>
Запомнить rX. OPCODE = 31, MOD = fspec. <CODE>V &#60;- rX</CODE>.
<A NAME="IDX34"></A>
<DT><CODE>STi</CODE>
<DD><A NAME="IDX35"></A>
Запомнить rIi. OPCODE = 24 + i, MOD = fspec. <CODE>V &#60;- rIi</CODE>.
<A NAME="IDX36"></A>
<DT><CODE>STJ</CODE>
<DD><A NAME="IDX37"></A>
Запомнить rJ. OPCODE = 32, MOD = fspec. <CODE>V &#60;- rJ</CODE>.
<A NAME="IDX38"></A>
<DT><CODE>STZ</CODE>
<DD><A NAME="IDX39"></A>
Запомнить ноль. OPCODE = 33, MOD = fspec. <CODE>V &#60;- 0</CODE>.
</DL>
<P>

Для примера, рассмотрим инструкцию <SAMP>`STA 1200(2:3)'</SAMP>. Она
заставит MIX взять байты 4 и 5 регистра A и скопировать и в байты
2 и 3 ячейки памяти 1200 (помните, что в этих инструкциях MOD задаёт
поле <EM>адреса памяти</EM>). Остальные байты ячейки памяти сохраняют своё
значение. Так, если до выполнения инструкции:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[1200] = - 20 21 22 23 24
[rA] = + 01 02 03 04 05
</pre></td></tr></table>то в конце концов будет:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[1200] = - 20 04 05 23 24
[rA] = + 01 02 03 04 05
</pre></td></tr></table></P><P>

Ещё один пример: <SAMP>`ST2 1000(0)'</SAMP> установит знак <SAMP>`[1000]'</SAMP>
равным знаку <SAMP>`[rI2]'</SAMP>.
</P><P>

<A NAME="Арифметические команды"></A>
<HR SIZE="6">
<A NAME="SEC17"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC16"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC18"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.4 Арифметические команды </H4>
<!--docid::SEC17::-->
<P>

Следующие инструкции осуществляют арифметические операции над регистрами
rA и rX и содержимым памяти.
</P><P>

<DL COMPACT>
<A NAME="IDX40"></A>
<DT><CODE>ADD</CODE>
<DD><A NAME="IDX41"></A>
Прибавить и установить OV при переполнении. OPCODE = 1, MOD = fspec. 
<CODE>rA &#60;- rA +V</CODE>.
<A NAME="IDX42"></A>
<DT><CODE>SUB</CODE>
<DD><A NAME="IDX43"></A>
Вычесть и установить OV при переполнении. OPCODE = 2, MOD = fspec.
<CODE>rA &#60;- rA - V</CODE>.
<A NAME="IDX44"></A>
<DT><CODE>MUL</CODE>
<DD><A NAME="IDX45"></A>
Умножить V на rA и поместить 10-байтовое произведение в rAX.
OPCODE = 3, MOD = fspec. <CODE>rAX &#60;- rA x V</CODE>.
<A NAME="IDX46"></A>
<DT><CODE>DIV</CODE>
<DD><A NAME="IDX47"></A>
rAX рассматривается как 10-байтовое число и делится на V.
OPCODE = 4, MOD = fspec. <CODE>rA &#60;- rAX / V</CODE>, <CODE>rX</CODE> &#60;- остаток.
</DL>
<P>

Во всех вышеперечисленных инструкциях одним из операндов бинарной
арифметической операции является <SAMP>`[rA]'</SAMP>, другим -- <SAMP>`V'</SAMP>
(заданное поле ячейки памяти с адресом <SAMP>`M'</SAMP>), заполненное нулевыми
байтами слева до полного слова. В операциях умножения и деления
регистр <SAMP>`X'</SAMP> играет роль правого расширения регистра <SAMP>`A'</SAMP>,
так что мы можем работать с 10-байтовыми числами, старшие байты
которых располагаются в <SAMP>`rA'</SAMP> (знаком 10-байтового числа является
знак <SAMP>`rA'</SAMP>, знак <SAMP>`rX'</SAMP> игнорируется).
</P><P>

Сложение и вычитание слов MIX может приводить к переполнению,
поскольку результат сохраняется в регистре, содержащем только 5 байтов
(и знак). Если это происходит, в <SAMP>`rA'</SAMP> помещается результат
операции по модулю 1 073 741 823 (максимальное значение, хранимое
в слове MIX) и устанавливается триггер переполнения.
</P><P>

<A NAME="Команды пересылки адреса"></A>
<HR SIZE="6">
<A NAME="SEC18"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC17"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC19"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.5 Команды пересылки адреса </H4>
<!--docid::SEC18::-->
<P>

В этих инструкциях <SAMP>`M'</SAMP> (адрес после модификации) используется как
число, а не как адрес ячейки памяти. Соответственно, <SAMP>`M'</SAMP> может
иметь любое допустимое для слова значение (т.е. не ограничено диапазонов
адресов памяти 0-3999).
</P><P>

<DL COMPACT>
<A NAME="IDX48"></A>
<DT><CODE>ENTA</CODE>
<DD><A NAME="IDX49"></A>
Загрузить <SAMP>`M'</SAMP> в [rA]. OPCODE = 48, MOD = 2. <CODE>rA &#60;- M</CODE>.
<A NAME="IDX50"></A>
<DT><CODE>ENTX</CODE>
<DD><A NAME="IDX51"></A>
Загрузить <SAMP>`M'</SAMP> в [rX]. OPCODE = 55, MOD = 2. <CODE>rX &#60;- M</CODE>.
<A NAME="IDX52"></A>
<DT><CODE>ENTi</CODE>
<DD><A NAME="IDX53"></A>
Загрузить <SAMP>`M'</SAMP> в [rIi]. OPCODE = 48 + i, MOD = 2. <CODE>rIi &#60;- M</CODE>.
<A NAME="IDX54"></A>
<DT><CODE>ENNA</CODE>
<DD><A NAME="IDX55"></A>
Загрузить <SAMP>`-M'</SAMP> в [rA]. OPCODE = 48, MOD = 3. <CODE>rA &#60;- -M</CODE>.
<A NAME="IDX56"></A>
<DT><CODE>ENNX</CODE>
<DD><A NAME="IDX57"></A>
Загрузить <SAMP>`-M'</SAMP> в [rX]. OPCODE = 55, MOD = 3. <CODE>rX &#60;- -M</CODE>.
<A NAME="IDX58"></A>
<DT><CODE>ENNi</CODE>
<DD><A NAME="IDX59"></A>
Загрузить <SAMP>`-M'</SAMP> в [rIi]. OPCODE = 48 + i, MOD = 3. <CODE>rIi &#60;- -M</CODE>.
<A NAME="IDX60"></A>
<DT><CODE>INCA</CODE>
<DD><A NAME="IDX61"></A>
Увеличить [rA] на <SAMP>`M'</SAMP>. OPCODE = 48, MOD = 0. <CODE>rA &#60;- rA + M</CODE>.
<A NAME="IDX62"></A>
<DT><CODE>INCX</CODE>
<DD><A NAME="IDX63"></A>
Увеличить [rX] на <SAMP>`M'</SAMP>. OPCODE = 55, MOD = 0. <CODE>rX &#60;- rX + M</CODE>.
<A NAME="IDX64"></A>
<DT><CODE>INCi</CODE>
<DD><A NAME="IDX65"></A>
Увеличить [rIi] на <SAMP>`M'</SAMP>. OPCODE = 48 + i, MOD = 0. <CODE>rIi &#60;- rIi + M</CODE>.
<A NAME="IDX66"></A>
<DT><CODE>DECA</CODE>
<DD><A NAME="IDX67"></A>
Уменьшить [rA] на <SAMP>`M'</SAMP>. OPCODE = 48, MOD = 1. <CODE>rA &#60;- rA - M</CODE>.
<A NAME="IDX68"></A>
<DT><CODE>DECX</CODE>
<DD><A NAME="IDX69"></A>
Уменьшить [rX] на <SAMP>`M'</SAMP>. OPCODE = 55, MOD = 0. <CODE>rX &#60;- rX - M</CODE>.
<A NAME="IDX70"></A>
<DT><CODE>DECi</CODE>
<DD><A NAME="IDX71"></A>
Уменьшить [rIi] на <SAMP>`M'</SAMP>. OPCODE = 48 + i, MaOD = 0. <CODE>rIi &#60;- rIi - M</CODE>.
</DL>
<P>

В вышеперечисленных инструкциях поле <SAMP>`ADDRESS'</SAMP> (модифицированное)
играет роль непосредственного операнда, и позволяет напрямую
устанавливать содержимое регистров MIX без перенаправления к ячейкам
памяти (в реальных процессорах это означает, что они выполняются быстрее,
чем обсуждавшиеся ранее инструкции, операнды которых берутся из памяти).
Так, если вы хотите поместить в <SAMP>`rA'</SAMP> значение -2000 (- 00 00 00 31 16),
вы можете использовать двоичную инструкцию + 31 16 00 03 48, или,
символически,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>ENNA 2000
</pre></td></tr></table>В сочетании с командами запоминания (<SAMP>`STA'</SAMP>, <SAMP>`STX'</SAMP> и т.д.)
эти инструкции позволяют устанавливать конкретные значения содержимого
ячеек памяти.
</P><P>

Имейте в виду, что в командах пересылки адреса поле <SAMP>`MOD'</SAMP> -- не
спецификатор поля, а служит для определения (вместе с <SAMP>`OPCODE'</SAMP>)
конкретной выполняемой операции.
</P><P>

<A NAME="Команды сравнения"></A>
<HR SIZE="6">
<A NAME="SEC19"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC18"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC20"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.6 Команды сравнения </H4>
<!--docid::SEC19::-->
<P>

До сих пор мы изучали, как перемещать значения между регистрами и
ячейками памяти MIX, а также как осуществлять арифметические операции
над этими значениями. Но для написания нетривиальных программ нужны и
другие возможности. Одна из наиболее общих -- возможность сравнивать
два значения, которая, вместе с переходами, позволит обрабатывать условные
операторы.
</P><P>

Следующие инструкции сравнивают значение регистра с <SAMP>`V'</SAMP> и
соответствующим образом устанавливают индикатор CM  (т.е.,
<SAMP>`E'</SAMP>, <SAMP>`G'</SAMP> или <SAMP>`L'</SAMP>, "равно", "больше" или "меньше"
соответственно).
</P><P>

<DL COMPACT>
<A NAME="IDX72"></A>
<DT><CODE>CMPA</CODE>
<DD><A NAME="IDX73"></A>
Сравнить [rA] с V. OPCODE = 56, MOD = fspec.
<A NAME="IDX74"></A>
<DT><CODE>CMPX</CODE>
<DD><A NAME="IDX75"></A>
Сравнить [rX] с V. OPCODE = 63, MOD = fspec.
<A NAME="IDX76"></A>
<DT><CODE>CMPi</CODE>
<DD><A NAME="IDX77"></A>
Сравнить [rIi] с V. OPCODE = 56 + i, MOD = fspec.
</DL>
<P>

Как объяснено выше, эти инструкции изменяют значение индикатора сравнения
MIX. Вы можете спросить, как можно использовать это значение.
Для этого служат команды перехода, описанные в следующем подразделе.
</P><P>

<A NAME="Команды перехода"></A>
<HR SIZE="6">
<A NAME="SEC20"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC19"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC21"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.7 Команды перехода </H4>
<!--docid::SEC20::-->
<P>

Компьютер MIX содержит внутренний регистр, называемый <EM>счётчиком
положения</EM>, сохраняющий адрес следующей инструкции, которая должна быть
получена из памяти и обработан виртуальным процессором.  Вы не можете
напрямую изменять содержимое этого внутреннего регистра инструкцией
загрузки: после получения текущей инструкции он автоматически
увеличивается на 1 самим MIX. Тем не менее, существует набор инструкций
(называемых инструкциями перехода), которые могут изменять содержимое
счётчика положения при выполнении некоторого условия.  При этом
значение адреса инструкции, которая выполнялась бы следующей, если бы
не было перехода, помещается в <SAMP>`rJ'</SAMP> (кроме <CODE>JSJ</CODE>), а значение
счётчика положения устанавливается равным <SAMP>`M'</SAMP> (таким образом, следующая
инструкция берётся по этому новому адресу). Позднее вы можете вернуться
к отправной точке перехода, читая адрес, сохранённый в <SAMP>`rJ'</SAMP>.
</P><P>

Компьютер MIX имеет следующие инструкции перехода:
</P><P>

Эти инструкции выполняют обязательный переход по указанному адресу.
Используйте <SAMP>`JSJ'</SAMP>, если адрес возврата вам не нужен.
</P><P>

<DL COMPACT>
<A NAME="IDX78"></A>
<DT><CODE>JMP</CODE>
<DD><A NAME="IDX79"></A>
Безусловный переход. OPCODE = 39, MOD = 0.
<A NAME="IDX80"></A>
<DT><CODE>JSJ</CODE>
<DD><A NAME="IDX81"></A>
Безусловный переход без изменения rJ. OPCODE = 39, MOD = 1.
</DL>
<P>

Эти инструкции для принятия решения о переходе проверяют триггер
переполнения.
</P><P>

<DL COMPACT>
<A NAME="IDX82"></A>
<DT><CODE>JOV</CODE>
<DD><A NAME="IDX83"></A>
Выполнить переход при установленном OV (OV сбрасывается). OPCODE = 39, MOD = 2.
<A NAME="IDX84"></A>
<DT><CODE>JNOV</CODE>
<DD><A NAME="IDX85"></A>
Выполнить переход при сброшенном OV (OV остаётся сброшенным). OPCODE = 39, MOD = 3.
</DL>
<P>

В следующих инструкциях переход обусловлен содержимым флага сравнения:
</P><P>

<DL COMPACT>
<A NAME="IDX86"></A>
<DT><CODE>JL</CODE>
<DD><A NAME="IDX87"></A>
Выполнить переход, если <CODE>[CM] = L</CODE>. OPCODE = 39, MOD = 4.
<A NAME="IDX88"></A>
<DT><CODE>JE</CODE>
<DD><A NAME="IDX89"></A>
Выполнить переход, если <CODE>[CM] = E</CODE>. OPCODE = 39, MOD = 5.
<A NAME="IDX90"></A>
<DT><CODE>JG</CODE>
<DD><A NAME="IDX91"></A>
Выполнить переход, если <CODE>[CM] = G</CODE>. OPCODE = 39, MOD = 6.
<A NAME="IDX92"></A>
<DT><CODE>JGE</CODE>
<DD><A NAME="IDX93"></A>
Выполнить переход, если <CODE>[CM]</CODE> не равно <CODE>L</CODE>. OPCODE = 39, MOD = 7.
<A NAME="IDX94"></A>
<DT><CODE>JNE</CODE>
<DD><A NAME="IDX95"></A>
Выполнить переход, если <CODE>[CM]</CODE> не равно <CODE>E</CODE>. OPCODE = 39, MOD = 8.
<A NAME="IDX96"></A>
<DT><CODE>JLE</CODE>
<DD><A NAME="IDX97"></A>
Выполнить переход, если <CODE>[CM]</CODE> не равно <CODE>G</CODE>. OPCODE = 39, MOD = 9.
</DL>
<P>

Вы можете также осуществлять переход в зависимости от значений
регистров MIX, используя следующие инструкции:
</P><P>

<DL COMPACT>
<A NAME="IDX98"></A>
<DT><CODE>JAN</CODE>
<DD><A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<DT><CODE>JAZ</CODE>
<DD><A NAME="IDX101"></A>
<A NAME="IDX102"></A>
<DT><CODE>JAP</CODE>
<DD><A NAME="IDX103"></A>
<A NAME="IDX104"></A>
<DT><CODE>JANN</CODE>
<DD><A NAME="IDX105"></A>
<A NAME="IDX106"></A>
<DT><CODE>JANZ</CODE>
<DD><A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<DT><CODE>JANP</CODE>
<DD><A NAME="IDX109"></A>
Выполнить переход, если содержимое rA, соответственно, отрицательно,
равно нулю, положитнльно, неотрицательно, не равно нулю или неположительно.
OPCODE = 40, MOD = 0, 1, 2, 3, 4, 5.
<A NAME="IDX110"></A>
<DT><CODE>JXN</CODE>
<DD><A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<DT><CODE>JXZ</CODE>
<DD><A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<DT><CODE>JXP</CODE>
<DD><A NAME="IDX115"></A>
<A NAME="IDX116"></A>
<DT><CODE>JXNN</CODE>
<DD><A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<DT><CODE>JXNZ</CODE>
<DD><A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<DT><CODE>JXNP</CODE>
<DD><A NAME="IDX121"></A>
Выполнить переход, если содержимое rX, соответственно, отрицательно,
равно нулю, положительно, неотрицательно, не равно нулю или неположительно.
OPCODE = 47, MOD = 0, 1, 2, 3, 4, 5.
<A NAME="IDX122"></A>
<DT><CODE>JiN</CODE>
<DD><A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<DT><CODE>JiZ</CODE>
<DD><A NAME="IDX125"></A>
<A NAME="IDX126"></A>
<DT><CODE>JiP</CODE>
<DD><A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<DT><CODE>JiNN</CODE>
<DD><A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<DT><CODE>JiNZ</CODE>
<DD><A NAME="IDX131"></A>
<A NAME="IDX132"></A>
<DT><CODE>JiNP</CODE>
<DD><A NAME="IDX133"></A>
Выполнить переход, если содержимое rIi, соответственно, отрицательно,
равно нулю, положительно, неотрицательно, не равно нулю или неположительно.
OPCODE = 40 + i, MOD = 0, 1, 2, 3, 4, 5.
</DL>
<P>

<A NAME="Команды ввода/вывода"></A>
<HR SIZE="6">
<A NAME="SEC21"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC20"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC22"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.8 Команды ввода/вывода </H4>
<!--docid::SEC21::-->
<P>

Как объясняется в предыдущих разделах (see section <A HREF="mdk_4.html#SEC12">2.1.1 Архитектура MIX</A>),
компьютер MIX может взаимодействовать с большим количеством блочных
устройств.  Для этого в вашем распоряжении имеются следующие инструкции:
</P><P>

<DL COMPACT>
<A NAME="IDX134"></A>
<DT><CODE>IN</CODE>
<DD><A NAME="IDX135"></A>
Пересылает блок слов с указанного устройства в память, начиная с адреса M.
OPCODE = 36, MOD = номер устройства.
<A NAME="IDX136"></A>
<DT><CODE>OUT</CODE>
<DD><A NAME="IDX137"></A>
Пересылает блок слов из памяти (начиная с адреса M) на указанное устройство.
OPCODE = 37, MOD = номер устройства.
<A NAME="IDX138"></A>
<DT><CODE>IOC</CODE>
<DD><A NAME="IDX139"></A>
Выполняет управляющую команду (заданную M) к указанному устройству.
OPCODE = 35, MOD = номер устройства.
<A NAME="IDX140"></A>
<DT><CODE>JRED</CODE>
<DD><A NAME="IDX141"></A>
Выполнить переход по адресу M, если указанное устройство готово к работе.
OPCODE = 38, MOD = номер устройства.
<A NAME="IDX142"></A>
<DT><CODE>JBUS</CODE>
<DD><A NAME="IDX143"></A>
Выполнить переход по адресу M, если заданное устройство занято.
OPCODE = 34, MOD = номер устройства.
</DL>
Во всех вышеперечисленных инструкциях значение <SAMP>`MOD'</SAMP> должно быть
в диапазоне 0-20, поскольку оно обозначает целевое устройство операции.
Инструкция <SAMP>`IOC'</SAMP> имеет смысл только для ленточных устройств
(<SAMP>`MOD'</SAMP> = 0-7 или 20): она сдвигает маркер чтения/записи на число
слов, заданное <SAMP>`M'</SAMP> (если оно равно нулю, лента перематывается на
начало)<A NAME="DOCF6" HREF="mdk_fot.html#FOOT6">(6)</A>.
<P>

<A NAME="Команды преобразования"></A>
<HR SIZE="6">
<A NAME="SEC22"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC21"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC23"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.9 Команды преобразования </H4>
<!--docid::SEC22::-->
<P>

Следующие инструкции осуществляют преобразования между числовыми значениями
и их литерными представлениями.
</P><P>

<DL COMPACT>
<A NAME="IDX144"></A>
<DT><CODE>NUM</CODE>
<DD><A NAME="IDX145"></A>
Преобразует rAX, содержимое которого рассматривается как литерное
представляение числа, в его числовое значение и помещает его в rA.
OPCODE = 5, MOD = 0.
<A NAME="IDX146"></A>
<DT><CODE>CHAR</CODE>
<DD><A NAME="IDX147"></A>
Преобразует число, помещённое в rA, в литерное представление и
помещает его в rAX.
OPCODE = 5, MOD = 1.
</DL>
Цифры в MIX представляются диапазоном значений 30-39 (цифры 0-9).
Так, если содержимое <SAMP>`rA'</SAMP> и <SAMP>`rX'</SAMP> равно, например,
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[rA] = + 30 30 31 32 33
[rX] = + 31 35 39 30 34
</pre></td></tr></table>это представляет число 0012315904, и <SAMP>`NUM'</SAMP> поместит это значение
в <SAMP>`rA'</SAMP> (т.е., <SAMP>`[rA]'</SAMP> будет равно + 0 46 62 52 0 = 12315904).
<SAMP>`CHAR'</SAMP> осуществляет обратную операцию.
</P><P>

<A NAME="Команды сдвига"></A>
<HR SIZE="6">
<A NAME="SEC23"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC22"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC24"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.10 Команды сдвига </H4>
<!--docid::SEC23::-->
<P>

Следующие инструкции осуществляют побайтовый сдвиг содержимого <SAMP>`rA'</SAMP>
и <SAMP>`rX'</SAMP>.
</P><P>

<DL COMPACT>
<A NAME="IDX148"></A>
<DT><CODE>SLA</CODE>
<DD><A NAME="IDX149"></A>
<A NAME="IDX150"></A>
<DT><CODE>SRA</CODE>
<DD><A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<DT><CODE>SLAX</CODE>
<DD><A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<DT><CODE>SRAX</CODE>
<DD><A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<DT><CODE>SLC</CODE>
<DD><A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<DT><CODE>SRC</CODE>
<DD><A NAME="IDX159"></A>
Сдвинуть rA или rAX налево или направо или сдвинуть rAX циклически
(см. пример ниже) налево или направо. M задаёт число байтов, на
которое проивзодится сдвиг.
OPCODE = 6, MOD = 0, 1, 2, 3, 4, 5.
</DL>
Если, скажем, вначале <SAMP>`[rA]'</SAMP> = - 01 02 03 04 05, при выполнении
инструкций сдвига содержимое <SAMP>`rA'</SAMP> будет меняться следующим образом:
<P>

<TABLE>
<TR><TD>SLA 2 </TD><TD> [rA] = - 03 04 05 00 00</TD>
</TR>
<TR><TD>SRA 1 </TD><TD> [rA] = - 00 01 02 03 04</TD>
</TR>
<TR><TD>SLC 3 </TD><TD> [rA] = - 04 05 01 02 03</TD>
</TR>
<TR><TD>SRC 24 </TD><TD> [rA] = - 05 01 02 03 04</TD>
</TR></TABLE>
Имейте в виду, что операции сдвига не влияют на знаки.  С другой
стороны, <SAMP>`SLAX'</SAMP> и <SAMP>`SRAX'</SAMP> рассматривают <SAMP>`rA'</SAMP> и <SAMP>`rX'</SAMP>
как один 10-байтовый регистр (опять-так, игнорируя знаки), поэтому,
если вначале <SAMP>`[rA]'</SAMP> = + 01 02 03 04 05 и <SAMP>`[rX]'</SAMP> =
- 06 07 08 09 10, выполнение <SAMP>`SLAX 3'</SAMP> даст:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[rA] = + 04 05 06 07 08  [rX] = - 09 10 00 00 00
</pre></td></tr></table></P><P>

<A NAME="Прочие команды"></A>
<HR SIZE="6">
<A NAME="SEC24"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC23"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC25"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.11 Прочие команды </H4>
<!--docid::SEC24::-->
<P>

Наконец, приведём список трёх остальных инструкций MIX,
не описанных в предыдущих подразделах:
</P><P>

<DL COMPACT>
<A NAME="IDX160"></A>
<DT><CODE>MOVE</CODE>
<DD><A NAME="IDX161"></A>
Переместить MOD слов с адреса M по адресу, хранящемуся в rI1.
OPCODE = 7, MOD = число слов.
<A NAME="IDX162"></A>
<DT><CODE>NOP</CODE>
<DD><A NAME="IDX163"></A>
Нет операции. OPCODE = 0, MOD = 0.
<A NAME="IDX164"></A>
<DT><CODE>HLT</CODE>
<DD><A NAME="IDX165"></A>
Останов. Прекратить разбор инструкций. OPCODE = 5, MOD = 2.
</DL>
Эффект выполнения <SAMP>`NOP'</SAMP> ограничивается увеличением счётчика
положения. <SAMP>`HLT'</SAMP> обычно обозначает завершение выполнения
программы.
<P>

<A NAME="Временные характеристики"></A>
<HR SIZE="6">
<A NAME="SEC25"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC24"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 2.1.2.12 Временные характеристики </H4>
<!--docid::SEC25::-->
<P>

<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
</P><P>

При написании программ на MIXAL (или любых других программ)
нас часто интересует время их выполнения. Приблизительно, нас
интересует ответ на вопрос: как долго будет выполняться программа?
Конечно, это время выполнения является функцией от объёма входных
данных, и ответ на наш вопрос обычно даётся в виде асимптотического
поведения функции от объёма входных данных.  В любом случае, для
вычисления асимпотического приближения нам нужна мера времени выполнения
одной инструкции на нашем (виртуальном) процессоре. Поэтому с каждой
инструкцией MIX связано время выполнения, заданное в относительных
единицах (в реальных компьютерах значение этой единицы зависит от
аппаратной конфигурации). Когда наша виртуальная машина MIX
выполняет программы, она может (по желанию) выводить значение времени
выполнения на основе времени выполнения каждой отдельной инструкции.
</P><P>

В следующей таблице приведены значения времени выполнения (в вышеупомянутых
относительных единицах) инструкций MIX.
</P><P>

<TABLE>
<TR><TD><CODE>NOP</CODE> </TD><TD> 1 </TD><TD> <CODE>ADD</CODE> </TD><TD> 2 </TD><TD> <CODE>SUB</CODE></TD>
</TD><TD> 2 </TD><TD> <CODE>MUL</CODE> </TD><TD> 10
</TR>
<TR><TD><CODE>DIV</CODE> </TD><TD> 12 </TD><TD> <CODE>NUM</CODE> </TD><TD> 10 </TD><TD> <CODE>CHAR</CODE></TD>
</TD><TD> 10 </TD><TD> <CODE>HLT</CODE> </TD><TD> 10
</TR>
<TR><TD><CODE>SLx</CODE> </TD><TD> 2 </TD><TD> <CODE>SRx</CODE> </TD><TD> 2 </TD><TD> <CODE>LDx</CODE></TD>
</TD><TD>  2 </TD><TD> <CODE>STx</CODE> </TD><TD> 2 
</TR>
<TR><TD><CODE>JBUS</CODE> </TD><TD> 1 </TD><TD> <CODE>IOC</CODE> </TD><TD> 1 </TD><TD> <CODE>IN</CODE></TD>
</TD><TD>  1</TD><TD> <CODE>OUT</CODE> </TD><TD> 1
</TR>
<TR><TD><CODE>JRED</CODE> </TD><TD> 1 </TD><TD> <CODE>Jx</CODE> </TD><TD> 1 </TD><TD> <CODE>INCx</CODE></TD>
</TD><TD>  1 </TD><TD> <CODE>DECx</CODE> </TD><TD> 1 
</TR>
<TR><TD><CODE>ENTx</CODE> </TD><TD> 1 </TD><TD> <CODE>ENNx</CODE> </TD><TD> 1 </TD><TD> <CODE>CMPx</CODE></TD>
</TD><TD>  1 </TD><TD> <CODE>MOVE</CODE> </TD><TD> 1+2F  
</TR></TABLE>
<P>

В таблице 'F' обозначает число перемещаемых блоков (заданное полем
<CODE>FSPEC</CODE> инструкции), <CODE>SLx</CODE> и SRx -- сокращения для операций
побайтового сдвига, <CODE>LDx</CODE> обозначает все операции загрузки,
<CODE>STx</CODE> -- все операции запоминания, <CODE>Jx</CODE> обозначает
все операции перехода, и т.д. для остальный сокращений.
</P><P>

<A NAME="MIXAL"></A>
<HR SIZE="6">
<A NAME="SEC26"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC25"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC27"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC10"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.2 MIXAL </H2>
<!--docid::SEC26::-->
<P>

В предыдущих разделах мы перечислили все существующие двоичные инструкции
MIX.  Как мы показали, каждая инструкция представляется словом,
которое достаётся из памяти и обрабатывается виртуальным центральным
процессором MIX. Как и в случае реальных компьютеров, MIX может
декодировать инструкции в двоичном формате (так называемый машинный
язык), но программист-человек, пишущий программу на машинном языке,
вряд ли весело проведёт время. К счастью, MIX можно программировать
на языке ассемблера, MIXAL, предоставляющем способ написания понимаемых
воображаемым компьютером MIX двоичных инструкций в символьном виде.
Если вы ранее использовали языки ассемблера, вы найдёте в MIXAL очень
много знакомого. Исходные файлы MIXAL транслируются в машинный язык
ассемблером MIX, создающим двоичный файл (реальная программа MIX),
который может быть непосредственно загружен в память MIX и последовательно
выполнен.
</P><P>

В этом разделе мы опишем MIXAL, язык ассемблера MIX.  Реализации
ассемблера MIX и эмулятора компьютера MIX, входящие в состав MDK,
описаны позднее (see section <A HREF="mdk_5.html#SEC33">3. Начало работы</A>).
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC27">2.2.1 Базовая структура программы</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Написание базовых программ на MIXAL.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC28">2.2.2 Директивы MIXAL</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Директивы ассемблера.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC29">2.2.3 Выражения</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC30">2.2.4 W-выражения</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Вычисление w-выражений.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC31">2.2.5 Локальные символы</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="mdk_4.html#SEC32">2.2.6 Литеральные константы</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Базовая структура"></A>
<HR SIZE="6">
<A NAME="SEC27"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC28"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.1 Базовая структура программы </H3>
<!--docid::SEC27::-->
<P>

Ассемблер MIX читает файлы MIXAL построчно, создавая, при необходимости,
двоичную инструкцию, связанную с определённым адресом в памяти.  Чтобы
следить за текущим адресом, ассемблер поддерживает внутренний счётчик
положения, увеличиваемый при каждой компиляции инструкции.  Кроме
инструкция MIX в файл MIXAL можно включать директивы ассемблера
(или псевдоинструкции), предназначенные для самого ассемблера (например,
указывающие, где начинается и заканчивается программа, или переопределяющие
счётчик положения, см. ниже).
</P><P>

Инструкции MIX и директивы ассемблера<A NAME="DOCF7" HREF="mdk_fot.html#FOOT7">(7)</A> записываются на MIXAL (одна на строку
исходного файла) в соответствии со следующим шаблоном:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[LABEL]   MNEMONIC  [OPERAND]   [COMMENT]
</pre></td></tr></table></P><P>

где <SAMP>`ОПЕРАНД'</SAMP> имеет вид:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>[ADDRESS][,INDEX][(MOD)]
</pre></td></tr></table></P><P>

Элементы, заключённые в круглые скобки могут отсутствовать.
</P><P>

<DL COMPACT>
<DT><CODE>LABEL</CODE>
<DD>-- алфавитно-цифровой идентификатор (<EM>символ</EM>), получающий текущее
значений счётчика положения, и может быть использован в последующих
выражениях,
<DT><CODE>MNEMONIC</CODE>
<DD>-- литерал, обозначающий код операции инструкции (например, <CODE>LDA</CODE>,
<CODE>STA</CODE>, see section <A HREF="mdk_4.html#SEC13">2.1.2 Набор инструкций MIX</A>) или псевдоинструкцию
ассемблера (например, <CODE>ORIG</CODE>, <CODE>EQU</CODE>),
<DT><CODE>ADDRESS</CODE>
<DD>-- выражение, описывающее поле адреса инструкции,
<DT><CODE>INDEX</CODE>
<DD>-- выражение, описывающее поле индекса инструкции, по умолчанию 0 (т.е.
индекс не используется). Может использоваться только если присутствует
<CODE>ADDRESS</CODE>,
<DT><CODE>MOD</CODE>
<DD>-- выражение, описывающее поле модификатора инструкции. Значение по
умолчанию, если выражение опущено, зависит от <CODE>OPCODE</CODE>,
<DT><CODE>COMMENT</CODE>
<DD>любое количество пробелов после операнда обозначает начало комментария,
т.е. любой текст, отделённый пробелами от операнда ассемблером игнорируется
(имейте в виду, что пробелы внутри поля <SAMP>`OPERAND'</SAMP> недопустимы).
</DL>
<P>

Обратите внимание, что между полями <CODE>ADDRESS</CODE>, <CODE>INDEX</CODE> и
<CODE>MOD</CODE>, если они присутствуют, пробелы <EM>недопустимы</EM>.
Для разделения метки, кода операции и операнда в инструкции используются
пробелы<A NAME="DOCF8" HREF="mdk_fot.html#FOOT8">(8)</A>.
</P><P>

Мы уже перечислили мнемоники, сопоставленные каждой инструкции MIX.
Приведём пример инструкций MIXAL, представляющих инструкции MIX:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>HERE     LDA  2000         HERE представляет текущий счётчик положения
         LDX  HERE,2(1:3)  это комментарий
         JMP  1234
</pre></td></tr></table></P><P>

<A NAME="Директивы MIXAL"></A>
<HR SIZE="6">
<A NAME="SEC28"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC27"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC29"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.2 Директивы MIXAL </H3>
<!--docid::SEC28::-->
<P>

Инструкция MIXAL может быть либо одной из машинных инструкций MIX
(see section <A HREF="mdk_4.html#SEC13">2.1.2 Набор инструкций MIX</A>), либо одной из следующих псевдоинструкций
ассемблера:
</P><P>

<DL COMPACT>
<A NAME="IDX170"></A>
<DT><CODE>ORIG</CODE>
<DD><A NAME="IDX171"></A>
Устанавливает значение адреса памяти, по которому будет расположена
после компиляции следующая инструкция.
<A NAME="IDX172"></A>
<DT><CODE>EQU</CODE>
<DD><A NAME="IDX173"></A>
Используется для определения значения символа, например,
<CODE>SYM  EQU  2*200/3</CODE>.
<A NAME="IDX174"></A>
<DT><CODE>CON</CODE>
<DD><A NAME="IDX175"></A>
Значение заданного выражения непосредственно копируется в память по
текущему адресу.
<A NAME="IDX176"></A>
<DT><CODE>ALF</CODE>
<DD><A NAME="IDX177"></A>
Принимает в качестве операнда пять литер, составляющих пять байтов слова,
которое непосредственно копирует в память по текущему адресу.
<A NAME="IDX178"></A>
<DT><CODE>END</CODE>
<DD><A NAME="IDX179"></A>
Обозначает конец программы.  Операнд этой инструкции содержит адрес,
с которого начинается выполнение программы.
</DL>
<P>

Операндом <CODE>ORIG</CODE>, <CODE>EQU</CODE>, <CODE>CON</CODE> и <CODE>END</CODE> может
быть любое выражение, задающее слово MIX-константу, т.е. либо простое
выражение MIXAL (состоящее из чисел, символов и бинарных операций,
see section <A HREF="mdk_4.html#SEC29">2.2.3 Выражения</A>), либо w-выражение (see section <A HREF="mdk_4.html#SEC30">2.2.4 W-выражения</A>).
</P><P>

Любая программа на MIXAL должна содержать директиву <CODE>END</CODE> с двоякой
целью: во-первых, она обозначает точку прекращения работы ассемблера,
и во-вторых, её (обязательный) операнд указывает начальный адрес
скомпилированной программы (адрес, по которому виртуальная машина MIX
должна начать разбор инструкций после загрузки программы).  Также
является обычной практикой (хотя и не обязательно) включать в программу
по крайней мере одну директиву <CODE>ORIG</CODE>, чтобы обозначить начальное
значение счётчика положения ассемблера (помните, что он содержит адрес,
связанные с каждой скомпилированной инструкцией MIX). Таким образом,
минимальной программой на MIXAL будет:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>          ORIG  2000    установить начальный адрес компиляции
          NOP           эта инструкция будет загружена по адресу 2000
          HLT           а эта по адресу 2001
          END   2000    конец программы, начало по адресу 2000
эта строка не анализируется ассемблером
</pre></td></tr></table>Ассемблер создаст две двоичные инструкции (<CODE>NOP</CODE> (+ 00 00 00 00 00)
и <CODE>HLT</CODE> (+ 00 00 02 05)), которые будут загружены по адресам
2000 и 2001. Выполнение программы начнётся с адреса 2000.  Каждая
программа на MIXAL должна также содержать инструкцию <CODE>HLT</CODE>,
которая означает конец выполнения программы (но не компиляции программы).
</P><P>

Директива <CODE>EQU</CODE> позволяет определять символические имена заданных
значений.  Например, мы можем переписать вышеприведённую программу
следующим образом:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>START     EQU   2000
          ORIG  START
          NOP
          HLT
          END   START
</pre></td></tr></table>что даст тот же самый скомпилированный код.  Символические константы
(или, коротко, символы) могут определяться неявно, если их поместить
в поле <CODE>LABEL</CODE> инструкции MIXAL.  В этом случае перед компиляцией
строки ассемблер присвоит символу значение счётчика положения. Поэтому
третий способ записи нашей тривиальной программы:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>          ORIG  2000
START     NOP
          HLT
          END   START
</pre></td></tr></table></P><P>

Директива <CODE>CON</CODE> позволяет непосредственно задавать содержимое,
находящееся в памяти по адресу, указанному счётчиком положения. Например,
если ассемблер встретит следующий участок кода:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>          ORIG  1150
          CON   -1823473
</pre></td></tr></table>он поместит в ячейку памяти 1150 значение - 00 06 61 11 49
(соответствующее десятичному значению -1823473).
</P><P>

Наконец, директива <CODE>ALF</CODE> позволяет задавать содержимое памяти
как набор пяти литер (в кавычках), которые транслируются ассемблером
в соответствующие значения байтов, создавая, таким образом, двоичное
слово, размещаемое в соответствующей ячейке памяти.  Эта директива
полезна, если вам нужно поместить по адресу памяти сообщения для печати,
как в следующем примере:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>          OUT  MSG       MSG здесь ещё не определено (ссылка вперёд)
MSG       ALF  "THIS "   MSG определяется здесь
          ALF  "IS A "
          ALF  "MESSA"
          ALF  "GE.  "
</pre></td></tr></table>Этот участок кода также показывает использование <EM>ссылок вперёд</EM>,
что означает использование символа (в этом примере <CODE>MSG</CODE>) до его
реального определения.  Ассемблер MIXAL может обрабатывать ссылки вперёд
с некоторыми ограничениями, описанными в следующем разделе
(see section <A HREF="mdk_4.html#SEC29">2.2.3 Выражения</A>).
</P><P>

<A NAME="IDX180"></A>
</P><P>

Любая строка, начинающаяся со звёздочки, считается комментарием и
игнорируется ассемблером.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>* Это комментарий: эта строка игнорируется.
    * Это ошибка: * должна быть в первой колонке.
</pre></td></tr></table></P><P>

Как показано в предыдущем разделе, комментарии могут также быть расположены
после поля <CODE>OPERAND</CODE> инструкции, отделённые от него пробелами:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>LABEL     LDA   100  Это также комментарий
</pre></td></tr></table></P><P>

<A NAME="Выражения"></A>
<HR SIZE="6">
<A NAME="SEC29"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC28"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC30"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.3 Выражения </H3>
<!--docid::SEC29::-->
Поля <CODE>ADDRESS</CODE>, <CODE>INDEX</CODE> и <CODE>MOD</CODE> инструкции MIXAL могут
быть выражениями, состоящими из чисел, идентификаторов и знаков бинарных
операций (<CODE>+ - * / // :</CODE>). <CODE>+</CODE> и <CODE>-</CODE> могут также использоваться
как знаки унарных операций.  Операторы выполняются слева направо, других
правил приоритета операторов нет, и использовать скобки для группировки
нельзя.  Отдельная звёздочка обозначает текущее положение в памяти. Так,
например:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     4+2**
</pre></td></tr></table></P><P>

обозначает 6 (4+2), умноженное на текущее положение в памяти. Пробелы
внути выражений не допускаются.
</P><P>

Специальная бинарная операция <CODE>:</CODE> имеет то же значения, что и в
спецификациях полей, т.е.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>A:B = 8*A + B
</pre></td></tr></table>в то время как <CODE>A//B</CODE> обозначает деление 10-байтового числа
<CODE>A</CODE> 00 00 00 00 00 (A, дополненное справа пятью нулевыми байтами,
или, что то же самое, умноженное на 64 в пятой степени), разделённое
на <CODE>B</CODE>.  Примеры выражений:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>18-8*3 = 30
14/3 = 4
1+3:11 = 4:11 = 43
1//64 = (01 00 00 00 00 00)/(00 00 00 01 00) = (01 00 00 00 00)
</pre></td></tr></table>Имейте в виду, что любое выражение MIXAL вычисляет слово MIX (по определению).
</P><P>

Все символы, встречающиеся в выражениях, должны бы предварительно определены.
Ссылки вперёд допускаются только если встречаются отдельно (или с унарной
операцией) в части <CODE>ADDRESS</CODE> инструкции MIXAL, например:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>* OK: отдельная ссылка вперёд 
         STA  -S1(1:5)
* ERROR: ссылка вперёд в выражении
         LDX  2-S1
S1       LD1  2000
</pre></td></tr></table></P><P>

<A NAME="W-выражения"></A>
<HR SIZE="6">
<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.4 W-выражения </H3>
<!--docid::SEC30::-->
<P>

Помимо описанных выше (see section <A HREF="mdk_4.html#SEC29">2.2.3 Выражения</A>) выражений, ассемблер MIXAL
может обрабатывать в качестве операндов директив <CODE>ORIG</CODE>, <CODE>EQU</CODE>,
<CODE>CON</CODE> и <CODE>END</CODE> (see section <A HREF="mdk_4.html#SEC28">2.2.2 Директивы MIXAL</A>) так называемые
<EM>w-выражения</EM>. Общий вид w-выражения таков:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     WEXP = EXP[(EXP)][,WEXP]
</pre></td></tr></table>где <CODE>EXP</CODE> обозначает выражение, а квадратные скобки отмечают
необязательные элементы. Таким образом, w-выражение состоит из выражения,
за которым следует необязательное выражение в круглых скобках, а затем
любое число аналогичных конструкций, разделённых запятыми. Примеры
w-выражений:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>2000
235(3)
S1+3(S2),3000
S1,S2(3:5),23
</pre></td></tr></table></P><P>

W-выражения вычисляются слева направо следующим образом:
</P><P>

<UL>
<LI>
Вначале общему результату <SAMP>`w'</SAMP> присвоить значение 0.
<LI>
Взять первое выражение разделённого запятыми списка и вычислить его.
Например, при вычислении w-выражения <SAMP>`S1+2(2:4),2000(S2)'</SAMP>,
в первую очередь вычисляется <SAMP>`S1+2'</SAMP>. Пусть <SAMP>`S1'</SAMP> равно 265230,
тогда <SAMP>`S1+2 = 265232 = + 00 01 00 48 16'</SAMP>.
<LI>
Вычислить выражение в круглых скобках, сводя его к спецификации поля
вида <SAMP>`L:R'</SAMP>.  В нашем предыдущем примере выражение в круглых скобках
уже имеет нужный вид: 2:4.
<LI>
Подставить вместо байтов общего результата <SAMP>`w'</SAMP>, обозначенных
спецификацией поля, байты из значения предыдущего выражения. В нашем
примере <SAMP>`w = + 00 00 00 00 00'</SAMP>, и мы должны подставить вместо
второго, третьего и четвёртого байтов байты из 265232. Мы берём три
младших байта: 00 48 и 16 и ставим их во вторую, третью и четвёртую
позиции <SAMP>`w'</SAMP>, получая <SAMP>`w = + 00 00 48 16 00'</SAMP>.
<LI>
Повторить эту операцию для остальных выражений, работая в новым значением
<SAMP>`w'</SAMP>. В нашем примере, если, скажем <SAMP>`S2 = 1:1'</SAMP>, мы должны
подставить вместо первого байта <SAMP>`w'</SAMP> младший байт 2000, т.е. 16
(поскольку 2000 = + 00 00 00 31 16), и поэтому мы получим
<SAMP>`265232(1:4),2000(1:1) = + 16 00 48 16 00 = 268633088'</SAMP>.
</UL>
<P>

Ещё один пример -- в w-выражении
<TABLE><tr><td>&nbsp;</td><td class=example><pre>1(1:2),66(4:5)
</pre></td></tr></table>мы сначала возьмём два младших байта 1 (00 и 01) и поместим их в первую
и вторую позицию результата (получая <SAMP>`+ 00 01 00 00 00'</SAMP>),
а потом возьмем два байта из 66 (01 и 02) и поместим их в четвёртую
и пятую позиции результата, получая <SAMP>`+ 00 01 00 01 02'</SAMP> (262210).
Процесс повторяется для каждого нового разделённого запятыми примера.
Например,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>1(1:1),2(2:2),3(3:3),4(4:4) = 01 02 03 04 00
</pre></td></tr></table></P><P>

Как указано выше, w-выражения могут встречаться только в операндах
директив MIXAL, принимающих константное значений (<CODE>ORIG</CODE>, <CODE>EQU</CODE>,
<CODE>CON</CODE> и <CODE>END</CODE>). Ссылки вперёд в w-выражениях <EM>не
допускаются</EM> (т.е., все символы, встречающиеся в w-выражении должны
быть определены до их использования).
</P><P>

<A NAME="Локальные символы"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.5 Локальные символы </H3>
<!--docid::SEC31::-->
<P>

Помимо определённых пользователем символов, программисты на MIXAL
могут использовать так называемые <EM>локальные символы</EM>, т.е.
символы вида <CODE>[1-9][HBF]</CODE>. Локальный символ <CODE>nB</CODE> ссылается
на адрес, где в последний раз в качестве метки служило <CODE>nH</CODE>,
а <CODE>nF</CODE> -- на следующее появление <CODE>nH</CODE>.  В отличие от
определённых пользователем символов, <CODE>nH</CODE> может встречаться
в части <CODE>LABEL</CODE> различных инструкций MIXAL сколько угодно раз.
Следующий код даёт пример использования локальных символов:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>* строка 1
1H    LDA  100
* строка 2: 1B ссылается на адрес строки 1, 3F ссылается на адрес строки 4
      STA  3F,2(1B//2)
* строка 3: переопределение 1H
1H    STZ
* строка 4: 1B ссылается на адрес строки 3
3H    JMP  1B
</pre></td></tr></table></P><P>

Имейте в виду, что локальный символ <CODE>B</CODE> никогда не ссылается на
определение его собственной строки. Так, в следующей программе:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>		ORIG 1999
ST		NOP
3H		EQU 69
3H		ENTA 3B локальный символ 3B ссылается на 3H в предыдущей строке
		HLT
		END ST
</pre></td></tr></table>содержимым <SAMP>`rA'</SAMP> будет 69, а не 2001.  При использовании локальных
символов в сочетании и псевдоинструкцией <CODE>ORIG</CODE> существует
особый трюк. Рассмотрим<A NAME="DOCF9" HREF="mdk_fot.html#FOOT9">(9)</A>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>		ORIG 1999 
ST		NOP
3H		CON 10
		ENT1 *
		LDA 3B
** rI1 = 2001, rA = 10. До сих пор всё нормально!
3H		ORIG 3B+1000
** в этой точке 3H равно 2003
** а счётчик положений равен 3000.
		ENT2 *
		LDX 3B
** rI2 содержит 3000, rX содержит 2003.
		HLT
		END ST
</pre></td></tr></table></P><P>

<A NAME="Литеральные константы"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC26"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.6 Литеральные константы </H3>
<!--docid::SEC32::-->
<P>

MIXAL допускает введение <EM>литеральных констант</EM>, которые автоматически
помещаются ассемблером в память по адресам после конца программы.
Литеральные константы обозначаются <CODE>=wexp=</CODE>, где <CODE>wexp</CODE> --
w-выражение (see section <A HREF="mdk_4.html#SEC30">2.2.4 W-выражения</A>).  Например, код:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>L         EQU   5
          LDA   =20-L=
</pre></td></tr></table></P><P>

вынуждает ассемблер добавить после конца программы инструкцию,
содержащую 15 (<SAMP>`20-L'</SAMP>) и ассемблировать вышеприведённый код
как инструкцию <CODE>LDA a</CODE>, где <CODE>a</CODE> обозначает адрес,
по которому помещается значение 15.  Другими словами, скомпилированный
код эквивалентен следующему:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>L         EQU  5
          LDA  a
<small>...</small>
a         CON  20-L    
          END  start
</pre></td></tr></table></P><P>

<A NAME="Начало работы"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_4.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_5.html#SEC33"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="mdk_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
on <I>June, 9  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
