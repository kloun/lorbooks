<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://www.geocities.com/SiliconValley/Office/6533/gm.htm -->
<!-- 62 * 39 --><HTML><HEAD><TITLE>Эффективное использование GNU make</TITLE>
<BODY>
<H5>Версия 1.2 </H5>
<H1>Эффективное использование GNU Make </H1>
<H2>(C) <A href="mailto:ignatov@infosec.ru">Владимир Игнатов</A>, 2000 </H2>
<H3>Оглавление </H3>
<UL>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Intro">0. 
  Предисловие 
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Using_GNU_Make">1. 
  Моя методика использования GNU Make </A>
  <UL>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Project_example">1.1. 
    Пример проекта </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Tradition-style_makefile">1.2. 
    "Традиционный" способ построения make-файлов </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Automatic_obj_list">1.3. 
    Автоматическое построение списка объектных файлов </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Auto_depend">1.4. 
    Автоматическое построение зависимостей от заголовочных файлов </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Multi-dirs">1.5. 
    "Разнесение" файлов с исходными текстами по директориям </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Multi-config">1.6. 
    Сборка программы с разными параметрами компиляции </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Multi-config_multi-dirs">1.7. 
    "Разнесение" разных версий программы по отдельным директориям </A></LI></UL>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#GNU_Make">2. 
  GNU Make </A>
  <UL>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Two_kind_of_vars">2.1. 
    Две разновидности переменных </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Text_functions">2.2. 
    Функции манипуляции с текстом </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Template_rules">2.3. 
    Новый способ задания шаблонных правил </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#vpath">2.4. 
    Переменная <B>VPATH</B> </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#override">2.5. 
    Директива <B>override</B> </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#include">2.6. 
    Директива <B>include</B> </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#append_text">2.7. 
    Добавление текста в строку </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#auto_vars">2.8. 
    Автоматические переменные </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#rule_combining">2.9. 
    "Комбинирование" правил </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#default_makefile">2.10. 
    Make-файл, используемый по умолчанию </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#PHONY_target">2.11. 
    Специальная цель <B>.PHONY</B> </A></LI></UL>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Make">3. 
  Утилита <B>make</B> </A>
  <UL>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Rules">3.1. 
    Правила </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Make_alg">3.2. 
    Алгоритм работы <B>make</B> </A>
    <UL>
      <LI><A 
      href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Choose_default_goal">3.2.1. 
      Выбор <I>главной цели</I> 
      <LI><A 
      href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Process_target">3.2.2. 
      Достижение <I>цели</I> 
      <LI><A 
      href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Process_rule">3.2.3. 
      Обработка <I>правил</I> 
      <LI><A 
      href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Process_dependency">3.2.4. 
      Обработка <I>зависимостей</I> 
      <LI><A 
      href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Process_commands">3.2.5. 
      Обработка <I>команд</I> </LI></UL>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Phony_vs_filenames">3.3. 
    Абстрактные цели и имена файлов </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Make_example">3.4. 
    Пример работы <B>make</B> </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Another_make_example">3.5. 
    Еще один пример работы <B>make</B> </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#vars">3.6. 
    Переменные </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#automatic_vars">3.7. 
    Автоматические переменные </A>
    <LI><A 
    href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pattern_rules">3.8. 
    Шаблонные правила </A></LI></UL>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_A">Приложение 
  A. Редактирование make-файлов в разных операционных системах </A>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_B">Приложение 
  B. Организация иерархии каталогов в сложных проектах </A>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_C">Приложение 
  C. Компилятор <B>GCC</B> </A>
  <LI><A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_D">Приложение 
  D. "Гипотический" проект - текстовой редактор </A></LI></UL>
<H2><A name=Intro></A>0. Предисловие </H2>В этой книге я описываю свой опыт 
работы с утилитой <B>GNU Make</B> и, в частности, мою методику подготовки 
make-файлов. Я считаю свою методику довольно удобной, поскольку она 
предполагает: 
<UL><!-- преимущества моего способа -->
  <LI>Автоматическое построение списка файлов с исходными текстами 
  <LI>Автоматическую генерацию зависимостей от включаемых файлов (с помощью 
  компилятора <B>GCC</B>) 
  <LI>"Параллельную" сборку отладочной и рабочей версий программы </LI></UL>Моя 
книга построена несколько необычным образом. Как правило, книги строятся по 
принципу "от простого - к сложному". Для новичков это удобно, но может вызвать 
затруднение у профессионалов. Опытный программист будет вынужден "продираться" 
сквозь книгу, пропуская главы с известной ему информацией. Я решил построить 
книгу по другому принципу. Вся "квинтэссенция" книги, ее "главная идея", 
содержится в первой главе. Остальные главы носят более или менее дополнительный 
характер. 
<P>В начале каждой главы я кратко описываю, о чем в ней будет вестись речь, и 
какими знаниями нужно обладать, чтобы успешно воспринять излагаемый в главе 
материал. Для тех, кто чувствует, что недостаточно хорошо ориентируется в 
предмете разговора, я указываю на дополнительные главы, с которыми следует 
предварительно ознакомиться. 
<P>Для работы я использовал <B>GNU Make</B> версии 3.79.1. Некоторые старые 
версии <B>GNU Make</B> (например версия 3.76.1 из дистрибутива <B>Slackware 
3.5</B>) могут неправильно работать с примером "традиционного" строения 
make-файла (по-видимому, они "не воспринимают" старую форму записи шаблонных 
правил). 
<H2><A name=Using_GNU_Make></A>1. Моя методика использования GNU Make </H2>В 
этой главе я описываю свой способ построения make-файлов для сборки проектов с 
использование программы <B>GNU Make</B> и компилятора <A 
href="http://www.gnu.org/software/gcc"><B>GCC</B> (<I>GNU Compiler 
Collection</I>) </A>. Предполагается, что вы хорошо знакомы с утилитой <B>GNU 
Make</B>. Если это не так, то прочтите сначала <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#GNU_Make">главу 
2 - "<I><B>GNU Make</B></I>" </A>. 
<H3><A name=Project_example></A>1.1. Пример проекта </H3>
<P>В качестве примера я буду использовать "гипотический" проект - текстовой 
редактор. Он состоит из нескольких файлов с исходным текстом на языке <B>C++</B> 
(<I>main.cpp</I>, <I>Editor.cpp</I>, <I>TextLine.cpp</I>) и нескольких 
включаемых файлов (<I>main.h</I>,<I>Editor.h</I>, <I>TextLine.h</I>). Если вы 
имеете доступ в интернет то "электронный" вариант приводимых в книге примеров 
можно получить на моей домашней страничке по адресу <A 
href="http://www.geocities.com/SiliconValley/Office/6533"><I>www.geocities.com/SiliconValley/Office/6533</I> 
</A>. Если интернет для вас недоступен, то в <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_D">Приложении 
<I>D</I></A> приведены листинги файлов, которые используются в примерах. 
<H3><A name=Tradition-style_makefile></A>1.2. "Традиционный" способ построения 
make-файлов </H3>
<P>В первом примере make-файл построен "традиционным" способом. Все исходные 
файлы собираемой программы находятся в одном каталоге: 
<UL>
  <LI>example_1-traditional / 
  <UL>
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI><I>Editor.cpp</I> 
    <LI><I>Editor.h</I> 
    <LI><I>TextLine.cpp</I> 
    <LI><I>TextLine.h</I> 
    <LI><I>Makefile</I> </LI></UL></LI></UL>Предполагается, что для компиляции 
программы используется компилятор <B>GCC</B>, и объектные файлы имеют расширение 
"<I>.o"</I>. Файл <I>Makefile</I> выглядит так: <!-- пример "традиционного" строения make-файла --><PRE>    
    #
    #   example_1-traditional/Makefile
    #
    #   Пример "традиционного" строения make-файла 
    #

    iEdit: main.o Editor.o TextLine.o 
        gcc $^ -o $@

    .cpp.o:
        gcc -c $&lt;

    main.o:     main.h Editor.h TextLine.h
    Editor.o:   Editor.h TextLine.h
    TextLine.o: TextLine.h </PRE>Первое правило заставляет <B>make</B> 
перекомпоновывать программу при изменении любого из объектных файлов. Второе 
правило говорит о том, что объектные файлы зависят от соответствующих исходных 
файлов. Каждое изменение файла с исходным текстом будет вызывать его 
перекомпиляцию. Следующие несколько правил указывают, от каких заголовочных 
файлов зависит каждый из объектных файлов. Такой способ построения make-файла 
мне кажется неудобным потому что: 
<UL><!-- недостатки традиционного способа -->
  <LI>Требуется "явно" перечислять все объектные файлы, из которых компонуется 
  программа 
  <LI>Требуется "явно" перечислять, от каких именно заголовочных файлов зависит 
  тот или иной объектный файл 
  <LI>Исполняемый файл программы помещается в "текущую" директорию. Если мне 
  нужно иметь несколько различных вариантов программы (например, отладочный и 
  рабочий), то каждый раз при переходе от одного варианта к другому требуется 
  полная перекомпиляция программы во избежание нежелательного "смешивания" 
  разных версий объектных файлов. </LI></UL>Видно, что традиционный способ 
построения make-файлов далек от идеала. Единственно чем этот способ может быть 
удобен - своей "совместимостью". По-видимому, с таким make-файлом будут 
нормально работать даже самые "древние" или "экзотические" версии <B>make</B> 
(например, <B>nmake</B> фирмы <B>Microsoft</B>). Если подобная "совместимость" 
не нужна, то можно сильно облегчить себе жизнь, воспользовавшись широкими 
возможностями утилиты <B>GNU Make</B>. Попробуем избавиться от недостатков 
"традиционного" подхода. 
<H3><A name=Automatic_obj_list></A>1.3. Автоматическое построение списка 
объектных файлов </H3>"Ручное" перечисление всех объектных файлов, входящих в 
программу - достаточно нудная работа, которая, к счастью, может быть 
автоматизирована. Разумеется "простой трюк" вроде: <!-- трюк с *.o -->
<P><PRE>    iEdit: *.o
        gcc $&lt; -o $@</PRE>
<P>не сработает, так как будут учтены только <I>существующие</I> в данный момент 
объектные файлы. Я использую чуть более сложный способ, который основан на 
предположении, что <I>все</I> файлы с исходным текстом должны быть 
скомпилированы и скомпонованы в собираемую программу. Моя методика состоит из 
двух шагов: 
<UL><!-- мой способ -->
  <LI>Получить список всех файлов с исходным текстом программы (всех файлов с 
  расширением <I>cpp</I>). Для этого можно использовать функцию <B>wildcard</B>. 

  <LI>Преобразовать список исходных файлов в список объектных файлов (заменить 
  расширение "<I>.cpp</I>" на расширение "<I>.o</I>"). Для этого можно 
  воспользоваться функцией <B>patsubst</B>. </LI></UL>Следующий пример содержит 
модифицированную версию make-файла: 
<UL>
  <LI>example_2-auto_obj / 
  <UL>
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI><I>Editor.cpp</I> 
    <LI><I>Editor.h</I> 
    <LI><I>TextLine.cpp</I> 
    <LI><I>TextLine.h</I> 
    <LI><I>Makefile</I> </LI></UL></LI></UL>Файл <I>Makefile</I> теперь выглядит 
так: <!-- пример "усовершенстованного" make-файла --><PRE>    #
    #   example_2-auto_obj/Makefile
    #
    #   Пример автоматического построения списка объектных файлов
    #

    iEdit: $(patsubst %.cpp,%.o,$(wildcard *.cpp))
        gcc $^ -o $@ 

    %.o: %.cpp
        gcc -c $&lt;

    main.o:     main.h Editor.h TextLine.h
    Editor.o:   Editor.h TextLine.h
    TextLine.o: TextLine.h </PRE>
<P>Список объектных файлов программы строится автоматически. Сначала с помощью 
функции <B>wildcard</B> получается список всех файлов с расширением 
"<I>.cpp</I>", находящихся в директории проекта. Затем, с помощью функции 
<B>patsubst</B>, полученный таким образом список исходных файлов, преобразуется 
в список объектных файлов. Make-файл теперь стал более универсальным - с 
небольшими изменениями его можно использовать для сборки разных программ. 
<H3><A name=Auto_depend></A>1.4. Автоматическое построение зависимостей от 
заголовочных файлов </H3>"Ручное" перечисления зависимостей объектных файлов от 
заголовочных файлов - занятие еще более утомительное и неприятное чем "ручное" 
перечисление объектных файлов. Указывать такие зависимости обязательно нужно - в 
процессе разработки программы заголовочные файлы могут меняться довольно часто 
(описания классов, например, традиционно размещаются в заголовочных файлах). 
Если не указывать зависимости объектных файлов от соответствующих заголовочных 
файлов, то может сложиться ситуация, когда разные объектные файлы программы 
будут скомпилированы с использованием разных версии одного и того же 
заголовочного файла. А это, в свою очередь, может привести к частичной или 
полной потере работоспособности собранной программы. 
<P>Перечисление зависимостей "вручную" требует довольно кропотливой работы. 
Недостаточно просто открыть файл с исходным текстом и перечислить имена всех 
заголовочных файлов, подключаемых с помощью <I>#include</I>. Дело в том, что 
одни заголовочные файлы могут, в свою очередь, включать в себя другие 
заголовочные файлы, так что придется отслеживать всю "цепочку" зависимостей. 
<P>Утилита <B>GNU Make</B> не сможет самостоятельно построить список 
зависимостей, поскольку для этого придется "заглядывать" внутрь файлов с 
исходным текстом - а это, разумеется, лежит уже за пределами ее "компетенции". К 
счастью, трудоемкий процесс построения зависимостей можно автоматизировать, если 
воспользоваться помощью компилятора <B>GCC</B>. Для совместной работы с 
<B>make</B> компилятор <B>GCC</B> имеет несколько опций: 
<P><!-- ключи GCC для генерации зависимостей -->
<TABLE border=1><!-- заголовок -->
  <TBODY>
  <TR>
    <TD>Ключ компиляции </TD>
    <TD>Назначение </TD></TR>
  <TR>
    <TD><I>-M</I> </TD>
    <TD>Для каждого файла с исходным текстом препроцессор будет выдавать на 
      стандартный выход список зависимостей в виде правила для программы 
      <B>make</B>. В список зависимостей попадает сам исходный файл, а также все 
      файлы, включаемые с помощью директив <I>#include &lt;имя_файла&gt;</I> и 
      <I>#include "имя_файла"</I>. После запуска препроцессора компилятор 
      останавливает работу, и генерации объектных файлов не происходит. </TD></TR>
  <TR>
    <TD><I>-MM</I> </TD>
    <TD>Аналогичен ключу <I>-M</I>, но в список зависимостей попадает только 
      сам исходный файл, и файлы, включаемые с помощью директивы <I>#include 
      "имя_файла"</I> </TD></TR>
  <TR>
    <TD><I>-MD</I> </TD>
    <TD>Аналогичен ключу <I>-M</I>, но список зависимостей выдается не на 
      стандартный выход, а записывается в отдельный файл зависимостей. Имя этого 
      файла формируется из имени исходного файла путем замены его расширения на 
      "<I>.d</I>". Например, файл зависимостей для файла <I>main.cpp</I> будет 
      называться <I>main.d</I>. В отличие от ключа <I>-M</I> компиляция проходит 
      обычным образом, а не прерывается после фазы запуска препроцессора. </TD></TR>
  <TR>
    <TD><I>-MMD</I> </TD>
    <TD>Аналогичен ключу <I>-MD</I>, но в список зависимостей попадает только 
      сам исходный файл, и файлы, включаемые с помощью директивы <I>#include 
      "имя_файла"</I> </TD></TR></TBODY></TABLE>
<P>Как видно из таблицы компилятор может работать двумя способами - в одном 
случае компилятор выдает только список зависимостей и заканчивает работу (опции 
<I>-M</I> и <I>-MM</I>). В другом случае компиляция происходит как обычно, 
только в дополнении к объектному файлу генерируется еще и файл зависимостей 
(опции <I>-MD</I> и <I>-MMD</I>). Я предпочитаю использовать второй вариант - он 
мне кажется более удобным и экономичным потому что: 
<UL><!-- преимущества отдельных файлов зависимостей -->
  <LI>При изменении какого-либо из исходных файлов будет построен заново лишь 
  один соответствующий ему файл зависимостей 
  <LI>Построение файлов зависимостей происходит "параллельно" с основной работой 
  компилятора и практически не отражается на времени компиляции </LI></UL>
<P>Из двух возможных опций <I>-MD</I> и <I>-MMD</I>, я предпочитаю первую потому 
что: 
<UL><!-- преимущества отдельных файлов зависимостей -->
  <LI>С помощью директивы <I>#include &lt;имя_файла&gt;</I> я часто включаю не 
  только "стандартные", но и свои собственные заголовочные файлы которые могут 
  иногда меняться (например, заголовочные файлы моей прикладной библиотеки 
  <I>LIB</I>). 
  <LI>Иногда бывает полезно взглянуть на <I>полный</I> список включаемых в 
  модуль заголовочных файлов, в том числе и "стандартных". </LI></UL>
<P>После того как файлы зависимостей сформированы, нужно сделать их доступными 
утилите <B>make</B>. Этого можно добиться с помощью директивы <B>include</B>. <PRE>    include $(wildcard *.d) </PRE>
<P>Обратите внимание на использование функции <B>wildcard</B>. Конструкция <PRE>    include *.d </PRE>будет правильно работать только в том случае, если в 
каталоге будет находиться хотя бы один файл с расширением "<I>.d</I>". Если 
таких файлов нет, то <B>make</B> аварийно завершится, так как потерпит неудачу 
при попытке "построить" эти файлы (у нее ведь нет на этот счет ни каких 
инструкций!). Если же использовать функцию <B>wildcard</B>, то при отсутствии 
искомых файлов, эта функция просто вернет пустую строку. Далее, директива 
<B>include</B> с аргументом в виде пустой строки, будет проигнорирована, не 
вызывая ошибки. Теперь можно составить новый вариант make-файла для моего 
"гипотического" проекта: 
<UL>
  <LI>example_3-auto_depend / 
  <UL>
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI><I>Editor.cpp</I> 
    <LI><I>Editor.h</I> 
    <LI><I>TextLine.cpp</I> 
    <LI><I>TextLine.h</I> 
    <LI><I>Makefile</I> </LI></UL></LI></UL>Вот как выглядит <I>Makefile</I> из 
этого примера: <!-- пример "усовершенстованного" make-файла --><PRE>    #
    #   example_3-auto_depend/Makefile
    # 
    #   Пример автоматического построения зависимостей от заголовочных файлов
    #

    iEdit: $(patsubst %.cpp,%.o,$(wildcard *.cpp))
        gcc $^ -o $@ 

    %.o: %.cpp
        gcc -c -MD $&lt;

    include $(wildcard *.d) </PRE>После завершения работы <B>make</B> директория 
проекта будет выглядеть так: 
<UL>
  <LI>example_3-auto_depend / 
  <UL>
    <LI><I>iEdit</I> 
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI><I>main.o</I> 
    <LI><I>main.d</I> 
    <LI><I>Editor.cpp</I> 
    <LI><I>Editor.o</I> 
    <LI><I>Editor.d</I> 
    <LI><I>Editor.h</I> 
    <LI><I>TextLine.cpp</I> 
    <LI><I>TextLine.o</I> 
    <LI><I>TextLine.d</I> 
    <LI><I>TextLine.h</I> 
    <LI><I>Makefile</I> </LI></UL></LI></UL>Файлы с расширением "<I>.d</I>" - это 
сгенерированные компилятором <B>GCC</B> файлы зависимостей. Вот, например, как 
выглядит файл <I>Editor.d</I>, в котором перечислены зависимости для файла 
<I>Editor.cpp</I>: <PRE>    Editor.o: Editor.cpp Editor.h TextLine.h </PRE>Теперь при изменении 
любого из файлов - <I>Editor.cpp</I>, <I>Editor.h</I> или <I>TextLine.h</I>, 
файл <I>Editor.cpp</I> будет перекомпилирован для получения новой версии файла 
<I>Editor.o</I>. 
<P>Имеет ли описанная методика недостатки? Да, к сожалению, имеется один 
недостаток. К счастью, на мой взгляд, не слишком существенный. Дело в том что 
утилита <B>make</B> обрабатывает make-файл "в два приема". Сначала будет 
обработана директива <B>include</B> и в make-файл будут включены файлы 
зависимостей, а затем, на "втором проходе", будут уже выполняться необходимые 
действия для сборки проекта. 
<P>Получается что для "текущей" сборки используются файлы зависимостей, 
сгенерированные во время "предыдущей" сборки. Как правило, это не вызывает 
проблем. Сложности возникнут лишь в том случае, если какой-нибудь из 
заголовочных файлом по какой-либо причине прекратил свое существование. 
Рассмотрим простой пример. Предположим, у меня имеются файлы <I>main.cpp</I> и 
<I>main.h</I>: 
<P>Файл <I>main.cpp</I>: <PRE>    #include "main.h"

    void main()
    {
    } </PRE>
<P>Файл <I>main.h</I>: <PRE>    // main.h</PRE>В таком случае, сформированный компилятором файл 
зависимостей <I>main.d</I> будет выглядеть так: <PRE>    main.o: main.cpp main.h</PRE>Теперь, если я переименую файл 
<I>main.h</I> в <I>main_2.h</I>, и соответствующим образом изменю файл 
<I>main.cpp</I>, 
<P>Файл <I>main.cpp</I>: <PRE>    #include "main_2.h"

    void main()
    {
    } </PRE>то очередная сборка проекта окончится неудачей, поскольку файл 
зависимостей <I>main.d</I> будет ссылаться на не существующий более заголовочный 
файл <I>main.h</I>. 
<P>Выходом в этой ситуации может служить удаление файла зависимостей 
<I>main.d</I>. Тогда сборка проекта пройдет нормально и будет создана новая 
версия этого файла, ссылающаяся уже на заголовочный файл <I>main_2.h</I>: <PRE>    main.o: main.cpp main_2.h</PRE>
<P>При переименовании или удалении какого-нибудь "популярного" заголовочного 
файла, можно просто заново пересобрать проект, удалив предварительно все 
объектные файлы и файлы зависимостей. 
<H3><A name=Multi-dirs></A>1.5. "Разнесение" файлов с исходными текстами по 
директориям </H3>Приведенный в предыдущем параграфе make-файл вполне 
работоспособен и с успехом может быть использован для сборки небольших программ. 
Однако, с увеличением размера программы, становится не очень удобным хранить все 
файлы с исходными текстами в одном каталоге. В таком случае я предпочитаю 
"разносить" их по разным директориям, отражающим логическую структуру проекта. 
Для этого нужно немного модифицировать make-файл. Чтобы неявное правило <PRE>   %.o: %.cpp
        gcc -c $&lt; </PRE>
<P>осталось работоспособным, я использую переменную <B>VPATH</B>, в которой 
перечисляются все директории, где могут располагаться исходные тексты. В 
следующем примере я поместил файлы <I>Editor.cpp</I> и <I>Editor.h</I> в каталог 
<I>Editor</I>, а файлы <I>TextLine.cpp</I> и <I>TextLine.h</I> в каталог 
<I>TextLine</I>: 
<UL>
  <LI>example_4-multidir / 
  <UL>
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI>Editor / 
    <UL>
      <LI><I>Editor.cpp</I> 
      <LI><I>Editor.h</I> </LI></UL>
    <LI>TextLine / 
    <UL>
      <LI><I>TextLine.cpp</I> 
      <LI><I>TextLine.h</I> </LI></UL>
    <LI><I>Makefile</I> </LI></UL></LI></UL>Вот как выглядит <I>Makefile</I> для 
этого примера: <!-- make-файл с VPATH --><PRE>    #
    #   example_4-multidir/Makefile
    # 
    #   Пример "разнесения" исходных текстов по разным директориям
    #

    source_dirs := . Editor TextLine

    search_wildcards := $(addsuffix /*.cpp,$(source_dirs)) 

    iEdit: $(notdir $(patsubst %.cpp,%.o,$(wildcard $(search_wildcards))))
        gcc $^ -o $@ 

    VPATH := $(source_dirs)
     
    %.o: %.cpp
        gcc -c -MD $(addprefix -I,$(source_dirs)) $&lt;

    include $(wildcard *.d) </PRE>
<P>По сравнению с предыдущим вариантом make-файла он претерпел следующие 
изменения: 
<UL><!-- изменения -->
  <LI>Для хранения списка директорий с исходными текстами я завел отдельную 
  переменную <I>source_dirs</I>, поскольку этот список понадобится указывать в 
  нескольких местах. 
  <LI>Шаблон поиска для функции <B>wildcard</B> (переменная 
  <I>search_wildcards</I>) строится "динамически" исходя из списка директорий 
  <I>source_dirs</I> 
  <LI>Используется переменная <B>VPATH</B> для того, чтобы шаблонное правило 
  могло искать файлы исходных текстов в указанном списке директорий 
  <LI>Компилятору разрешается искать заголовочные файлы во всех директориях с 
  исходными текстами. Для этого используется функция <B>addprefix</B> и флажок 
  <I>-I</I> компилятора <B>GCC</B>. 
  <LI>При формировании списка объектных файлов, из имен исходных файлов 
  "убирается" имя каталога, где они расположены (с помощью функции 
  <B>notdir</B>) </LI></UL>
<H3><A name=Multi-config></A>1.6. Сборка программы с разными параметрами 
компиляции </H3>Часто возникает необходимость в получении нескольких вариантов 
программы, которые были скомпилированы по-разному. Типичный пример - отладочная 
и рабочая версии программы. В таких случаях я использую простую методику: 
<UL><!--  -->
  <LI>Все варианты программы собираются с помощью одного и того же make-файла. 
  <LI>Необходимые настройки компилятора "попадают" в make-файл через параметры, 
  передаваемые программе <B>make</B> в командной строке. </LI></UL>Для каждой 
конфигурации программы я делаю маленький командный файл, который вызывает 
<B>make</B> с нужными параметрами: 
<UL>
  <LI>example_5-multiconfig / 
  <UL>
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI>Editor / 
    <UL>
      <LI><I>Editor.cpp</I> 
      <LI><I>Editor.h</I> </LI></UL>
    <LI>TextLine / 
    <UL>
      <LI><I>TextLine.cpp</I> 
      <LI><I>TextLine.h</I> </LI></UL>
    <LI><I>Makefile</I> 
    <LI><I>make_debug</I> 
    <LI><I>make_release</I> </LI></UL></LI></UL>Файлы <I>make_debug</I> и 
<I>make_release</I> - это командные файлы, используемые для сборки 
соответственно отладочной и рабочей версий программы. Вот, например, как 
выглядит командный файл <I>make_release</I>: <PRE>    make  compile_flags="-O3 -funroll-loops -fomit-frame-pointer" </PRE>Обратите 
внимание, что строка со значением переменной <I>compile_flags</I> заключена в 
кавычки, так как она содержит пробелы. Командный файл <I>make_debug</I> выглядит 
аналогично: <PRE>    make  compile_flags="-O0 -g" </PRE>
<P>Вот как выглядит <I>Makefile</I> для этого примера: <!-- make-файл с vpath --><PRE>    #
    #   example_5-multiconfig/Makefile
    # 
    #   Пример получения нескольких версий программы с помощью одного make-файла 
    #

    source_dirs := . Editor TextLine

    search_wildcards       := $(addsuffix /*.cpp,$(source_dirs)) 
    override compile_flags += -pipe

    iEdit: $(notdir $(patsubst %.cpp,%.o,$(wildcard $(search_wildcards))))
        gcc $^ -o $@ 

    VPATH := $(source_dirs)
     
    %.o: %.cpp
        gcc -c -MD $(addprefix -I,$(source_dirs)) $(compile_flags) $&lt;

    include $(wildcard *.d) </PRE>
<P>Переменная <I>compile_flags</I> получает свое значение из командной строки и, 
далее, используется при компиляции исходных текстов. Для ускорения работы 
компилятора, к параметрам компиляции добавляется флажок <B>-pipe</B>. Обратите 
внимание на необходимость использования директивы <B>override</B> для изменения 
переменной <I>compile_flags</I> внутри make-файла. 
<H3><A name=Multi-config_multi-dirs></A>1.7. "Разнесение" разных версий 
программы по отдельным директориям </H3>В том случае если я собираю несколько 
вариантов одной и той же программы (например, отладочную и рабочую версию), 
становится неудобным помещать результаты компиляции в один и тот же каталог. При 
переходе от одного варианта к другому приходится полностью перекомпилировать 
программу во избежание нежелательного "смешивания" объектных файлов разных 
версий. 
<P>Для решения этой проблемы я помещаю результаты компиляции каждой версии 
программы в свой отдельный каталог. Так, например, отладочная версия программы 
(включая все объектные файлы) помещается в каталог <I>debug</I>, а рабочая 
версия программы - в каталог <I>release</I>: 
<UL>
  <LI>example_6-multiconfig-multidir / 
  <UL>
    <LI>debug / 
    <LI>release / 
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI>Editor / 
    <UL>
      <LI><I>Editor.cpp</I> 
      <LI><I>Editor.h</I> </LI></UL>
    <LI>TextLine / 
    <UL>
      <LI><I>TextLine.cpp</I> 
      <LI><I>TextLine.h</I> </LI></UL>
    <LI><I>Makefile</I> 
    <LI><I>make_debug</I> 
    <LI><I>make_release</I> </LI></UL></LI></UL>
<P>Главная сложность заключалась в том, чтобы заставить программу <B>make</B> 
помещать результаты работы в разные директории. Попробовав разные варианты, я 
пришел к выводу, что самый легкий путь - использование флажка <I>--directory</I> 
при вызове <B>make</B>. Этот флажок заставляет утилиту перед началом обработки 
make-файла, сделать каталог, указанный в командной строке, "текущим". 
<P>Вот, например, как выглядит командный файл <I>make_release</I>, собирающий 
рабочую версию программы (результаты компиляции помещается в каталог 
<I>release</I>): <PRE>    mkdir  release
    make    compile_flags="-O3 -funroll-loops -fomit-frame-pointer" \
          --directory=release \
          --makefile=../Makefile </PRE>
<P>Команда <I>mkdir</I> введена для удобства - если удалить каталог 
<I>release</I>, то при следующей сборке он будет создан заново. В случае 
"составного" имени каталога (например, <I>bin/release</I>) можно дополнительно 
использовать флажок <I>-p</I>. Флажок <I>--directory</I> заставляет <B>make</B> 
перед началом работы сделать указанную директорию <I>release</I> текущей. Флажок 
<I>--makefile</I> укажет программе <B>make</B>, где находится make-файл проекта. 
По отношению к "текущей" директории <I>release</I>, он будет располагаться в 
"родительском" каталоге. 
<P>Командный файл для сборки отладочного варианта программы (<I>make_debug</I>) 
выглядит аналогично. Различие только в имени директории, куда помещаются 
результаты компиляции (<I>debug</I>) и другом наборе флагов компиляции: <PRE>    mkdir   debug
    make    compile_flags="-O0 -g" \
          --directory=debug \
          --makefile=../Makefile </PRE>Вот окончательная версия make-файла для 
сборки "гипотического" проекта текстового редактора: <!-- "окончательный" пример make-файла --><PRE>    #
    #   example_6-multiconfig-multidir/Makefile
    # 
    #   Пример "разнесения" разных версий программы по отдельным директориям
    #

    program_name := iEdit 
    source_dirs  := . Editor TextLine

    source_dirs      := $(addprefix ../,$(source_dirs))
    search_wildcards := $(addsuffix /*.cpp,$(source_dirs))

    $(program_name): $(notdir $(patsubst %.cpp,%.o, $(wildcard $(search_wildcards) ) ) )
        gcc $^ -o $@ 

    VPATH := $(source_dirs) 

    %.o: %.cpp
        gcc -c -MD $(compile_flags) $(addprefix -I,$(source_dirs)) $&lt;

    include $(wildcard *.d) </PRE>
<P>В этом окончательном варианте я "вынес" имя исполняемого файла программы в 
отдельную переменную <I>program_name</I>. Теперь для того чтобы адаптировать 
этот make-файл для сборки другой программы, в нем достаточно изменить всего лишь 
несколько первых строк. 
<P>После запуска командных файлов <I>make_debug</I> и <I>make_release</I> 
директория с последним примером выглядит так: 
<UL>
  <LI>example_6-multiconfig-multidir / 
  <UL>
    <LI>debug / 
    <UL>
      <LI><I>iEdit</I> 
      <LI><I>main.o</I> 
      <LI><I>main.d</I> 
      <LI><I>Editor.o</I> 
      <LI><I>Editor.d</I> 
      <LI><I>TextLine.o</I> 
      <LI><I>TextLine.d</I> </LI></UL>
    <LI>release / 
    <UL>
      <LI><I>iEdit</I> 
      <LI><I>main.o</I> 
      <LI><I>main.d</I> 
      <LI><I>Editor.o</I> 
      <LI><I>Editor.d</I> 
      <LI><I>TextLine.o</I> 
      <LI><I>TextLine.d</I> </LI></UL>
    <LI><I>main.cpp</I> 
    <LI><I>main.h</I> 
    <LI>Editor / 
    <UL>
      <LI><I>Editor.cpp</I> 
      <LI><I>Editor.h</I> </LI></UL>
    <LI>TextLine / 
    <UL>
      <LI><I>TextLine.cpp</I> 
      <LI><I>TextLine.h</I> </LI></UL>
    <LI><I>makefile</I> 
    <LI><I>make_debug</I> 
    <LI><I>make_release</I> </LI></UL></LI></UL>Видно, что объектные файлы для 
рабочей и отладочной конфигурации программы помещаются в разные директории. Туда 
же попадают готовые исполняемые файлы и файлы зависимостей. 
<P>В этой главе я изложил свою методику работы с make-файлами. Остальные главы 
носят более или менее "дополнительный" характер. 
<UL>
  <LI>В <A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_A"><I>Приложении 
  A </I></A>я описываю проблемы, которые могут возникнуть при редактировании 
  make-файлов в разных операционных системах 
  <LI>В <A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_B"><I>Приложении 
  B </I></A>я описываю свой личный способ организации дерева каталогов для 
  сложных проектов. 
  <LI>В <A 
  href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#pril_C"><I>Приложении 
  C </I></A>я делюсь некоторыми мыслями по поводу использования компилятора 
  <B>GCC</B> </LI></UL>
<H2><A name=GNU_Make></A>2. GNU Make </H2>В этой главе я кратко опишу некоторые 
возможности программы <B>GNU Make</B>, которыми я пользуюсь при написании своих 
make-файлов, а также укажу на ее отличия от "традиционных" версий <B>make</B>. 
Предполагается, что вы знакомы с принципом работы подобных программ. В противном 
случае сначала прочтите <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Make">главу 3 - 
<I>Утилита <B>make</B></I> </A>. 
<P><B>GNU Make</B> - это версия программы <B>make</B> распространяемая <B>Фондом 
Свободного Программного Обеспечения</B> (<B>Free Software Foundation</B> - 
<B>FSF</B>) в рамках проекта <B>GNU</B> (<A href="http://www.gnu.org/"> 
<I>www.gnu.org</I> </A>). Получить самую свежую версию программы и документации 
можно на "домашней страничке" программы <A 
href="http://www.gnu.org/software/make"><I>www.gnu.org/software/make 
</I></A>либо на страничке <B>Paul D. Smith</B> - одного из авторов <B>GNU 
Make</B> (<A href="http://www.paulandlesley.org/gmake"> 
<I>www.paulandlesley.org/gmake</I></A>). 
<P>Программа <B>GNU Make</B> имеет очень подробную и хорошо написанную 
документацию, с которой я настоятельно рекомендую ознакомиться. Если у вас нет 
доступа в интернет, то пользуйтесь документацией в формате <I>Info</I>, которая 
должна быть в составе вашего дистрибутива <B>Linux</B>. Будьте осторожны с 
документацией в формате man-странички (<I>man make</I>) - как правило, она 
содержит лишь отрывочную и сильно устаревшую информацию. 
<H3><A name=Two_kind_of_vars></A>2.1. Две разновидности переменных </H3><B>GNU 
Make</B> поддерживает два способа задания переменных, которые несколько 
различаются по смыслу. Первый способ - традиционный, с помощью оператора 
'<B>=</B>': <PRE>    compile_flags = -O3 -funroll-loops -fomit-frame-pointer </PRE>Такой 
способ поддерживают все варианты утилиты <B>make</B>. Его можно сравнить, 
например, с заданием макроса в языке <B>Си</B>. <PRE>    #define  compile_flags  "-O3 -funroll-loops -fomit-frame-pointer" </PRE>Значение 
переменной, заданной с помощью оператора '<B>=</B>', будет вычислено в момент ее 
использования. Например, при обработке make-файла: <!-- переменные с = --><PRE>    var1 = one
    var2 = $(var1) two 
    var1 = three

    all: 
        @echo $(var2) </PRE>на экран будет выдана строка "three two". Значение 
переменной <I>var2</I> будет вычислено непосредственно в момент выполнения 
команды <I>echo</I>, и будет представлять собой <I>текущее</I> значение 
переменной <I>var1</I>, к которому добавлена строка <I>" two"</I>. Как следствие 
- одна и та же переменная не может одновременно фигурировать в левой и правой 
части выражения, так как это может привести к бесконечной рекурсии. <B>GNU 
Make</B> распознает подобные ситуации и прерывает обработку make-файла. 
Следующий пример вызовет ошибку: <PRE>    compile_flags = -pipe $(compile_flags)</PRE>
<P><B>GNU Make</B> поддерживает также и второй, новый способ задания переменной 
- с помощью оператора '<B>:=</B>': <PRE>    compile_flags := -O3 -funroll-loops -fomit-frame-pointer </PRE>В этом 
случае переменная работает подобно "обычным" текстовым переменным в каком-нибудь 
из языков программирования. Вот приблизительный аналог этого выражения на языке 
<B>C++</B>: <PRE>    string   compile_flags = "-O3 -funroll-loops -fomit-frame-pointer"; </PRE>Значение 
переменной вычисляется в момент обработки оператора присваивания. Если, 
например, записать <!-- переменные с := --><PRE>    var1 := one
    var2 := $(var1) two 
    var1 := three

    all:
        @echo $(var2) </PRE>то при обработке такого make-файла на экран будет 
выдана строка "one two". 
<P>Переменная может "менять" свое поведение в зависимости от того, какой из 
операторов присваивания был к ней применен последним. Одна и та же переменная на 
протяжении своей жизни вполне может вести себя и как "макрос" и как "текстовая 
переменная". 
<P>Все свои make-файлы я пишу с применением оператора '<B>:=</B>'. Этот способ 
кажется мне более удобным и надежным. Вдобавок это более эффективно, так как 
значение переменной не вычисляется заново каждый раз при ее использовании. 
Подробнее о двух способах задания переменных можно прочитать в документации на 
<B>GNU Make</B> в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC58">"<I>The Two 
Flavors of Variables</I>" </A>. 
<H3><A name=Text_functions></A>2.2. Функции манипуляции с текстом </H3>
<P>Утилита <B>GNU Make</B> содержит большое число полезных функций, 
манипулирующих текстовыми строками и именами файлов. В частности в своих 
make-файлах я использую функции <B>addprefix</B>, <B>addsuffix</B>, 
<B>wildcard</B>, <B>notdir</B> и <B>patsubst</B>. Для вызова функций 
используется синтаксис <PRE> $(имя_функции  параметр1, параметр2 ... ) </PRE>
<P>Функция <B>addprefix </B>рассматривает второй параметр как список слов 
разделенных пробелами. В начало каждого слова она добавляет строку, переданную 
ей в качестве первого параметра. Например, в результате выполнения make-файла: <PRE>    src_dirs := Editor TextLine
    src_dirs := $(addprefix ../../, $(src_dirs))

    all:
        @echo $(src_dirs)</PRE>на экран будет выведено <PRE>    ../../Editor ../../TextLine </PRE>
<P>Видно, что к каждому имени директории добавлен префикс "<I>../../</I>". 
Функция <B>addprefix</B> обсуждается в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC77">"Functions 
for File Names" </A>руководства по <B>GNU Make</B>. 
<P>Функция <B>addsuffix </B>работает аналогично функции <B>addprefix</B>, только 
добавляет указанную строку в конец каждого слова. Например, в результате 
выполнения make-файла: <PRE>    source_dirs := Editor  TextLine
    search_wildcards := $(addsuffix /*.cpp, $(source_dirs))

    all:
        @echo $(search_wildcards)</PRE>
<P>на экран будет выведено <PRE>    Editor/*.cpp  TextLine/*.cpp </PRE>
<P>Видно, что к каждому имени директории добавлен суффикс "<I>/*.cpp</I>". 
Функция <B>addsuffix</B> обсуждается в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC77">"Functions 
for File Names" </A>руководства по <B>GNU Make</B>. 
<P>Функция <B>wildcard </B>"расширяет" переданный ей шаблон или несколько 
шаблонов в список файлов, удовлетворяющих этим шаблонам. Пусть в директории 
<I>Editor</I> находится файл <I>Editor.cpp</I>, а в директории <I>TextLine</I> - 
файл <I>TextLine.cpp</I>: 
<UL>
  <LI>wildcard_example / 
  <UL>
    <LI>Editor / 
    <UL>
      <LI><I>Editor.cpp</I> </LI></UL>
    <LI>TextLine / 
    <UL>
      <LI><I>TextLine.cpp</I> </LI></UL>
    <LI><I>makefile</I> </LI></UL></LI></UL>Тогда в результате выполнения такого 
make-файла: <PRE>    search_wildcards := Editor/*.cpp  TextLine/*.cpp
    source_files := $(wildcard $(search_wildcards))

    all:
        @echo $(source_files)</PRE>
<P>на экран будет выведено <PRE>    Editor/Editor.cpp  TextLine/TextLine.cpp </PRE>
<P>Видно, что шаблоны преобразованы в списки файлов. Функция <B>wildcard</B> 
подробно обсуждается в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC24">"The 
Function <B>wildcard</B>" </A>руководства по <B>GNU Make</B>. 
<P>Функция <B>notdir </B>позволяет "убрать" из имени файла имя директории, где 
он находится. Например, в результате выполнения make-файла: <PRE>    source_files := Editor/Editor.cpp  TextLine/TextLine.cpp
    source_files := $(notdir $(source_files))

    all:
        @echo $(source_files)</PRE>
<P>на экран будет выведено <PRE>    Editor.cpp TextLine.cpp </PRE>Видно, что из имен файлов убраны "пути" к 
этим файлам. Функция <B>notdir</B> обсуждается в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC77">"Functions 
for File Names" </A>руководства по <B>GNU Make</B>. 
<P>Функция <B>patsubst </B>позволяет изменить указанным образом слова, 
подходящие под шаблон. Она принимает три параметра - шаблон, новый вариант слова 
и исходную строку. Исходная строка рассматривается как список слов, разделенных 
пробелом. Каждое слово, подходящее под указанный шаблон, заменяется новым 
вариантом слова. В шаблоне может использоваться специальный символ '%', который 
означает "любое количество произвольных символов". Если символ '%' встречается в 
новом варианте слова (втором параметре), то он заменяется текстом, 
соответствующим символу '%' в шаблоне. Например, в результате выполнения 
make-файла: <PRE>    source_files := Editor.cpp  TextLine.cpp 
    object_files := $(patsubst %.cpp, %.o, $(source_files))

    all:
        @echo $(object_files) </PRE>
<P>на экран будет выведено <PRE>    Editor.o  TextLine.o </PRE>
<P>Видно, что во всех словах окончание "<I>.cpp</I>" заменено на "<I>.o</I>". 
Функция <B>patsubst</B> имеет второй, более короткий вариант записи для тех 
случаев, когда надо изменить суффикс слова (например, заменить расширение в 
имени файла). Более короткий вариант выглядит так: <PRE>    $(имя_переменной:.старый_суффикс=.новый_суффикс) </PRE>Применяя 
"короткий" вариант записи предыдущий пример можно записать так: <PRE>    source_files := Editor.cpp  TextLine.cpp 
    object_files := $(source_files:.cpp=.o)

    all:
        @echo $(object_files)</PRE>
<P>Функция <B>patsubst</B> обсуждается в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC76">"Functions 
for String Substitution and Analysis"</A> руководства по <B>GNU Make</B>. 
<H3><A name=Template_rules></A>2.3. Новый способ задания шаблонных правил </H3>В 
"традиционных" вариантах <B>make</B> шаблонное правило задается с помощью 
конструкций, наподобие: <PRE>    .cpp.o:  
        gcc $^ -o $@ </PRE>То есть под действие правила попадают файлы с 
определенными расширениями ("<I>.cpp</I>" и "<I>.o</I>" в данном случае). 
<P><B>GNU Make</B> поддерживает более универсальный подход - с использованием 
шаблонов имен файлов. Для задания шаблона используется символ <B>'%'</B>, 
который означает "последовательность любых символов произвольной длины". Символ 
<B>'%'</B> в правой части правила заменяется текстом, который соответствует 
символу <B>'%'</B> в левой части. Пользуясь новой формой записи, приведенный 
выше пример можно записать так: <PRE>    %.o: %.cpp
        gcc $^ -o $@</PRE>
<P>В своих make-файлах я пользуюсь новой формой записи шаблонных правил, потому 
что считаю ее более удобной (шаблонные и нешаблонные правила теперь имеют 
аналогичный синтаксис) и универсальной (можно задавать не только файлы, 
отличающиеся своими расширениями). 
<H3><A name=vpath></A>2.4. Переменная <B>VPATH</B> </H3>С помощью переменной 
<B>VPATH</B> можно задать список каталогов, где шаблонные правила будут искать 
зависимости. В следующем примере: <PRE>    VPATH := Editor TextLine
    
    %.o: %.cpp
        gcc -c $&lt; </PRE><B>make</B> будет искать файлы с расширением 
"<I>.cpp</I>" сначала в текущем каталоге, а затем, при необходимости, в 
подкаталогах <I>Editor</I> и <I>TextLine</I>. Я часто использую подобную 
возможность, так как предпочитаю располагать исходные тексты в иерархии 
каталогов, отражающих логическую структуру программы. 
<P>Переменная <B>VPATH</B> описывается в главе "VPATH: Search Path for All 
Dependencies" руководства по <B>GNU Make</B>. На страничке <B>Paul D. Smith</B> 
есть статья под названием "How Not to Use VPATH" (<A 
href="http://paulandlesley.org/gmake/vpath.html"> 
paulandlesley.org/gmake/vpath.html</A>), в которой обсуждается "неправильный" 
стиль использования переменной <B>VPATH</B>. 
<H3><A name=override></A>2.5. Директива <B>override</B> </H3>Переменные в <B>GNU 
Make</B> могут создаваться и получать свое значение разными способами: 
<UL>
  <LI>Задаваться внутри make-файла 
  <LI>"Автоматически" создаваться программой <B>make</B> из переменных среды 
  <LI>Задаваться через командную строку при вызове программы <B>make</B> 
</LI></UL>Последний случай считается "специальным". Если переменная задана через 
командную строку, то внутри make-файла нельзя изменить ее значение "обычным" 
способом. Рассмотрим простой make-файл: <PRE>    compile_flags := -pipe $(compile_flags)
    
    all:
        echo $(compile_flags) </PRE>Предположим, что переменная 
<I>compile_flags</I> была задана через командную строку при запуске программы 
<B>make</B>: <PRE>    make  compile_flags="-O0 -g" </PRE>В результате обработки make-файла на 
экран будет выведена строка: <PRE>    -O0 -g </PRE>То есть попытка изменить значение переменной 
<I>compile_flags</I> внутри make-файла была проигнорирована. Если все-таки 
возникает необходимость в изменении переменной, которая была задана с помощью 
командной строки, нужно использовать директиву <B>override</B>. Директива 
помещается перед именем переменной, которая должна быть изменена: <PRE>    override compile_flags := -pipe $(compile_flags)

    all:
        echo $(compile_flags) </PRE>Теперь в результате обработки make-файла на 
экран будет выдана строка: <PRE>    -pipe -O0 -g </PRE>
<H3><A name=append_text></A>2.6. Добавление текста в строку </H3>Часто возникает 
необходимость добавить текст к существующей переменной. Для этой цели служит 
оператор "<I>+=</I>". Добавляемый текст может быть как текстовой константой, так 
и иметь ссылки на другие переменные: <PRE>    compile_flags += -pipe
    compile_flags += $(flags) </PRE>
<P>При использовании этого оператора, "тип" переменной (см. раздел <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Two_kind_of_vars">2.1 
"Две разновидности переменных"</A>) не меняется - "макросы" остаются 
"макросами", а "текстовые переменные" по-прежнему остаются таковыми. 
<P>Если переменная задана с помощью командной строки, то по-прежнему для 
изменения ее значения внутри make-файла нужно использовать директиву 
<B>override</B>. В следующем примере предполагается, что переменная 
<I>compile_flags</I> задана в командной строке: <PRE>    override compile_flags += -pipe
    override compile_flags += $(flags) </PRE>
<H3><A name=include></A>2.7. Директива <B>include</B> </H3>С помощью директивы 
<B>include</B> можно включать в обрабатываемый make-файл другие файлы. Работает 
она аналогично директиве <B>#include</B> в языках C и C++. Когда встречается эта 
директива, обработка "текущего" make-файла приостанавливается и <B>make</B> 
временно "переключается" на обработку указанного в директиве файла. Директива 
<B>include</B> может оказаться полезной для включения в make-файл каких-либо 
"общих", или автоматически сгенерированных другими программами фрагментов. 
<P>В директиве <B>include</B> могут быть указаны одно или несколько имен файлов, 
разделенных пробелами. В качестве имен файлов можно использовать шаблоны: <PRE>    include common.mak

    include main.d Editor.d TextLine.d

    include *.d </PRE>Указанные в директиве файлы должны существовать - иначе 
<B>make</B> предпримет попытку "создать" их, а при невозможности этого 
достигнуть, выдаст сообщение об ошибке. Директива <B>include</B> с пустым 
списком файлов: <PRE>    include </PRE>просто игнорируется. 
<H3><A name=auto_vars></A>2.8. Автоматические переменные </H3>Программа <B>GNU 
Make</B> поддерживает большое число автоматических переменных. В своих 
make-файлах я использую следующие автоматические переменные: 
<P><!-- table - некоторые автоматические переменные -->
<TABLE border=1><!-- заголовок -->
  <TBODY>
  <TR>
    <TD>Имя автоматической переменной </TD>
    <TD>Значение </TD></TR>
  <TR>
    <TD>$@ </TD>
    <TD>Имя цели обрабатываемого правила </TD></TR>
  <TR>
    <TD>$&lt; </TD>
    <TD>Имя первой зависимости обрабатываемого правила </TD></TR>
  <TR>
    <TD>$^ </TD>
    <TD>Список всех зависимостей обрабатываемого правила </TD></TR></TBODY></TABLE>
<P>Полный список автоматических переменных приводится в разделе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC97">"Automatic 
Variables"</A> руководства по <B>GNU Make</B>. 
<H3><A name=rule_combining></A>2.9. "Комбинирование" правил </H3>В make-файле 
могут встречаться несколько правил, имеющих одинаковую цель. В таком случае они 
как бы "комбинируются вместе". Например, следующие два правила: <PRE>    TextLine.o: TextLine.cpp
        gcc -c $&lt;
    
    TextLine.o: TextLine.h </PRE>эквивалентны правилу: <PRE>    TextLine.o: TextLine.cpp TextLine.h
        gcc -c $&lt; </PRE>
<P>Шаблонные и нешаблонные правила также могут "комбинироваться": <PRE>    %.o: %.cpp
        gcc -c $&lt;
    
    TextLine.o: TextLine.h </PRE>
<P>Обратите внимание на то, что в обоих пример только в одном из правил указаны 
исполняемые команды - именно они и будут при необходимости выполняться. При 
наличии команд в обоих правилах, <B>make</B> выдаст предупреждающее сообщение и 
"в расчет" будут приниматься только команды из последнего правила. 
<H3><A name=default_makefile></A>2.10. Make-файл, используемый по умолчанию 
</H3>Если при вызове программы <B>GNU Make</B> не указывать явно, какой 
make-файл следует обрабатывать, то она пытается найти и обработать файлы 
<I>GNUmakefile</I>, <I>makefile</I> и <I>Makefile</I> (именно в таком порядке). 
Руководство по <B>GNU Make</B> рекомендует имя <I>Makefile</I> для make-файлов, 
используемых по умолчанию. При "алфавитной" сортировке имен файлов в директории, 
такое имя будет располагаться ближе к началу списка. 
<H3><A name=PHONY_target></A>2.11. Специальная цель <B>.PHONY</B> </H3>В 
традиционных реализациях, у программы <B>make</B> нет надежного способа узнать, 
чем именно является цель, указанная в правиле. Цель может быть как именем 
действия, так и именем файла. Исходя только из "внешнего вида" правила, 
различить эти случаи невозможно. Утилита <B>make</B> просто ищет на диске файл с 
именем, которое указано в качестве цели. Если такой файл существует, то цель 
считается именем файла. 
<P>Для целей, которые являются именами действий, такой подход не очень хорош. 
Во-первых, имя такой цели может случайно совпасть с именем какого-либо файла или 
директории. И, во-вторых, <B>make</B> просто нерационально тратит свое время, 
занимаясь поиском несуществующих файлов. 
<P>В утилите <B>GNU Make</B> имеется способ явного объявления целей 
абстрактными. Для этого используется механизм "специальных целей". 
<I>Специальная цель</I> - это имя, которое имеет специальное значение, когда 
используется в качестве цели. Для того, например, чтобы объявить перечисленные 
цели абстрактными, достаточно поместить их в правило со специальной целью 
<B>.PHONY</B>. В следующем примере цель <I>clean</I> объявляется абстрактной: <PRE>    .PHONY: clean
    
    clean:
        rm *.o *.d </PRE>Все возможные специальные цели описаны в главе <A 
href="http://www.gnu.org/manual/make-3.77/html_mono/make.html#SEC35">Special 
Built-in Target Names"</A> руководства по <B>GNU Make</B>. 
<H2><A name=Make></A>3. Утилита <B>make</B> </H2>Утилита <B>make</B>, входящая в 
состав практически всех <I>Unix</I>-подобных операционных систем - это 
традиционное средство, применяемое для сборки программных проектов. Она является 
универсальной программой для решения широкого круга задач, где одни файлы должны 
автоматически обновляться при изменении других файлов. 
<P>При запуске программа <B>make</B> читает файл с описанием проекта (make-файл) 
и, интерпретируя его содержимое, предпринимает необходимые действия. Файл с 
описанием проекта представляет собой текстовой файл, где описаны отношения между 
файлами проекта, и действия, которые необходимо выполнить для его сборки. 
<H3><A name=Rules></A>3.1. Правила </H3>
<P>Основным "строительным элементом" make-файла являются <I>правила</I> 
(<I>rules</I>). В общем виде правило выглядит так: <!-- общий вид правил make --><PRE>    &lt;цель_1&gt; &lt;цель_2&gt; ... &lt;цель_n&gt;: &lt;зависимость_1&gt; &lt;зависимость_2&gt; ... &lt;зависимость_n&gt; 
        &lt;команда_1&gt;
        &lt;команда_2&gt;
        ...
        &lt;команда_n&gt; </PRE><I>Цель</I> (<I>target</I>) - это некий желаемый 
результат, способ достижения которого описан в правиле. <I>Цель</I> может 
представлять собой имя файла. В этом случае правило описывает, каким образом 
можно получить новую версию этого файла. В следующем примере: <!-- пример правила --><PRE>    iEdit: main.o Editor.o TextLine.o 
        gcc  main.o Editor.o TextLine.o -o iEdit</PRE>
<P><I>целью</I> является файл <I>iEdit</I> (исполняемый файл программы). Правило 
описывает, каким образом можно получить новую версию файла <I>iEdit</I> 
(скомпоновать из перечисленных объектных файлов). 
<P><I>Цель</I> также может быть именем некоторого действия. В таком случае 
правило описывает, каким образом совершается указанное действие. В следующем 
примере <I>целью</I> является действие <I>clean</I> (очистка). <!-- пример phony target --><PRE>    clean: 
        rm *.o iEdit</PRE>Подобного рода цели называются <I>псевдоцели</I> 
(<I>pseudotargets</I>) или <I>абстрактные цели</I> (<I>phony targets</I>). 
<P><I>Зависимость</I> (<I>dependency</I>)- это некие "исходные данные", 
необходимые для достижения указанной в правиле <I>цели</I>. Можно сказать что 
<I>зависимость</I> - это "предварительное условие" для достижения цели. 
<I>Зависимость</I> может представлять собой имя файла. Этот файл должен 
существовать, для того чтобы можно было достичь указанной цели. В следующем 
правиле: <!-- пример правила --><PRE>    iEdit: main.o Editor.o TextLine.o 
        gcc  main.o Editor.o TextLine.o -o iEdit</PRE>
<P>файлы <I>main.o</I>, <I>Editor.o</I> и <I>TextLine.o</I> являются 
<I>зависимостями</I>. Эти файлы должны существовать для того, чтобы стало 
возможным достижение цели - построение файла <I>iEdit</I>. 
<P><I>Зависимость</I> также может быть именем некоторого действия. Это действие 
должно быть предварительно выполнено перед достижением указанной в правиле цели. 
В следующем примере зависимость <I>clean_obj</I> является именем действия 
(удалить объектные файлы программы): <!-- пример phony target --><PRE>    clean_all:  clean_obj
        rm iEdit
        
    clean_obj:  
        rm *.o </PRE>
<P>Для того чтобы цель <I>clean_all</I> была достигнута, нужно сначала выполнить 
действие (достигнуть цели) <I>clean_obj</I>. 
<P><I>Команды</I> - это действия, которые необходимо выполнить для обновления 
либо достижения <I>цели</I>. В следующем примере: <!-- пример правила --><PRE>    iEdit: main.o Editor.o TextLine.o 
        gcc  main.o Editor.o TextLine.o -o iEdit</PRE>
<P><I>командой</I> является вызов компилятора <B>GCC</B>. Утилита <B>make</B> 
отличает строки, содержащие команды, от прочих строк make-файла по наличию 
символа табуляции (символа с кодом 9) в начале строки. В приведенном выше 
примере строка: <PRE>    gcc  main.o Editor.o TextLine.o -o iEdit</PRE>должна начинаться с 
символа табуляции. 
<H3><A name=Make_alg></A>3.2. Алгоритм работы <B>make</B> </H3>Типичный 
make-файл проекта содержит несколько правил. Каждое из правил имеет некоторую 
цель и некоторые зависимости. Смыслом работы <B>make</B> является достижение 
цели, которую она выбрала в качестве <I>главной цели</I> (<I>default goal</I>). 
Если главная цель является именем действия (то есть абстрактной целью), то смысл 
работы <B>make</B> заключается в выполнении соответствующего действия. Если же 
главная цель является именем файла, то программа <B>make</B> должна построить 
самую "свежую" версию указанного файла. 
<H4><A name=Choose_default_goal></A>3.2.1 Выбор <I>главной цели</I> </H4>
<P><I>Главная цель</I> может быть прямо указана в командной строке при запуске 
<B>make</B>. В следующем примере <B>make</B> будет стремиться достичь цели 
<I>iEdit</I> (получить новую версию файла <I>iEdit</I>): <PRE>    make iEdit</PRE>А в этом примере <B>make</B> должна достичь цели 
<I>clean</I> (очистить директорию от объектных файлов проекта): <PRE>    make clean</PRE>Если не указывать какой-либо цели в командной строке, 
то <B>make</B> выбирает в качестве главной первую, встреченную в make-файле 
цель. В следующем примере: <!-- пример правила --><PRE>    iEdit: main.o Editor.o TextLine.o
        gcc  main.o Editor.o TextLine.o -o iEdit
    
    main.o: main.cpp
        gcc -c main.cpp 
            
    Editor.o: Editor.cpp
        gcc -c Editor.cpp

    TextLine.o: TextLine.cpp
        gcc -c TextLine.cpp

    clean:
        rm *.o</PRE>из четырех перечисленных в make-файле целей (<I>iEdit</I>, 
<I>main.o</I>, <I>Editor.o</I>, <I>TextLine.o</I>, <I>clean</I>) по умолчанию в 
качестве главной будет выбрана цель <I>iEdit</I>. Схематично, "верхний уровень" 
алгоритма работы <B>make</B> можно представить так: <PRE>    make()
    {
        главная_цель = ВыбратьГлавнуюЦель()

        ДостичьЦели( главная_цель )  
    }</PRE>
<H4><A name=Process_target></A>3.2.2 Достижение <I>цели</I> </H4>После того как 
<I>главная цель</I> выбрана, <B>make</B> запускает "стандартную" процедуру 
достижения цели. Сначала в make-файле ищется правило, которое описывает способ 
достижения этой цели (функция <I>НайтиПравило</I>). Затем, к найденному правилу 
применяется обычный алгоритм обработки правил (функция 
<I>ОбработатьПравило</I>). <PRE>    ДостичьЦели( Цель )
    {
        правило = НайтиПравило( Цель )

        ОбработатьПравило( правило ) 
    }</PRE>
<H4><A name=Process_rule></A>3.2.3 Обработка <I>правил</I> </H4>Обработка 
правила разделяется на два основных этапа. На первом этапе обрабатываются все 
<I>зависимости</I>, перечисленные в правиле (функция 
<I>ОбработатьЗависимости</I>). На втором этапе принимается решение - нужно ли 
выполнять указанные в правиле команды (функция <I>НужноВыполнятьКоманды</I>). 
При необходимости, перечисленные в правиле команды выполняются (функция 
<I>ВыполнитьКоманды</I>). <PRE>    ОбработатьПравило( Правило )
    {
        ОбработатьЗависимости( Правило )
        
        если НужноВыполнятьКоманды( Правило )
            {
            ВыполнитьКоманды( Правило )
            } 
    }</PRE>
<H4><A name=Process_dependency></A>3.2.4 Обработка <I>зависимостей</I> 
</H4>Функция <I>ОбработатьЗависимости</I> поочередно проверяет все перечисленные 
в правиле зависимости. Некоторые из них могут оказаться <I>целями</I> 
каких-нибудь правил. Для этих зависимостей выполняется обычная процедура 
достижения цели (функция <I>ДостичьЦели</I>). Те зависимости, которые не 
являются целями, считаются именами файлов. Для таких файлов проверяется факт их 
наличия. При их отсутствии, <B>make</B> аварийно завершает работу с сообщением 
об ошибке. <PRE>    ОбработатьЗависимости( Правило )
    {
        цикл от i=1 до Правило.число_зависимостей
            {
            если ЕстьТакаяЦель( Правило.зависимость[ i ] )
                {
                ДостичьЦели( Правило.зависимость[ i ] ) 
                }
            иначе
                {
                ПроверитьНаличиеФайла( Правило.зависимость[ i ] ) 
                } 
            } 
    }</PRE>
<H4><A name=Process_commands></A>3.2.5 Обработка <I>команд</I> </H4>На стадии 
обработки команд решается вопрос - нужно ли выполнять описанные в правиле 
команды или нет. Считается, что нужно выполнять команды если: 
<UL><!-- перечень -->
  <LI>Цель является именем действия (абстрактной целью) 
  <LI>Цель является именем файла и этого файла не существует 
  <LI>Какая-либо из зависимостей является абстрактной целью 
  <LI>Цель является именем файла и какая-либо из зависимостей, являющихся именем 
  файла, имеет более позднее время модификации чем цель. </LI></UL>В противном 
случае (если ни одно из вышеприведенных условий не выполняется) описанные в 
правиле команды не выполняются. Алгоритм принятия решения о выполнении команд 
схематично можно представить так: <!-- НужноВыполнятьКоманды() --><PRE>    НужноВыполнятьКоманды( Правило )
    {                                                       
        если Правило.Цель.ЯвляетсяАбстрактной()
            return  true 
       
        //  цель является именем файла

        если ФайлНеСуществует( Правило.Цель )
            return  true 

        цикл от i=1 до Правило.Число_зависимостей
            {
            если Правило.Зависимость[ i ].ЯвляетсяАбстрактной()
                return  true
            иначе
                //  зависимость является именем файла
                {
                если ВремяМодефикации( Правило.Зависимость[ i ] )  &gt;
                     ВремяМодефикации( Правило.Цель )
                    return  true 
                }
            }

        return  false 
    }</PRE>
<H3><A name=Phony_vs_filenames></A>3.3. Абстрактные цели и имена файлов 
</H3>Каким образом <B>make</B> отличает имена действий от имен файлов? 
Традиционные варианты <B>make</B> поступают просто. Сначала ищется файл с таким 
именем. Если файл найден, то считается что цель или зависимость являются именем 
файла. 
<P>В противном случае считается, что данное имя является либо именем 
несуществующего файла, либо именем действия. Различия между этими двумя 
вариантами не делается, поскольку оба случая обрабатываются одинаково. 
<P>Подобный подход не слишком хорош по следующим соображениям. Во-первых, 
утилита <B>make</B> не слишком рационально расходует время, занимаясь поиском 
несуществующих имен файлов, которые на самом деле являются именами действий. 
Во-вторых, при подобном подходе, имена действий не должны совпадать с именами 
каких-либо файлов или директорий. Иначе подобный алгоритм даст сбой, и make-файл 
будет работать неправильно. 
<P>Некоторые версии <B>make</B> предлагают свои варианты решения этой проблемы. 
Так, например, в утилите <B>GNU Make</B> имеется механизм (<I>специальная 
цель</I> <B>.PHONY</B>), с помощью которого можно указать, что данное имя 
является именем действия. 
<H3><A name=Make_example></A>3.4. Пример работы <B>make</B> </H3>Рассмотрим, как 
утилита <B>make</B> будет обрабатывать такой make-файл: <!-- пример правила --><PRE>    iEdit: main.o Editor.o TextLine.o 
        gcc  main.o Editor.o TextLine.o -o iEdit
    
    main.o: main.cpp
        gcc -c main.cpp 
            
    Editor.o: Editor.cpp
        gcc -c Editor.cpp

    TextLine.o: TextLine.cpp
        gcc -c TextLine.cpp

    clean:
        rm *.o</PRE>Предположим, что в директории с проектом находятся следующие 
файлы: 
<UL>
  <LI>main.cpp 
  <LI>Editor.cpp 
  <LI>TextLine.cpp </LI></UL>Предположим также, что программа <B>make</B> была 
вызвана следующим образом: <PRE>    make</PRE>Цель не указана в командной строке, поэтому запускается 
алгоритм выбора цели (функция <I>ВыбратьГлавнуюЦель</I>). Главной целью 
становится файл <I>iEdit</I> (первая цель из первого правила). 
<P>Цель <I>iEdit</I> передается функции <I>ДостичьЦели</I>. Эта функция ищет 
правило, которое описывает обрабатываемую цель. В данном случае, это первое 
правило make-файла. Для найденного правила запускается процедура обработки 
(функция <I>ОбработатьПравило</I>). 
<P>Сначала поочередно обрабатываются описанные в правиле зависимости (функция 
<I>ОбработатьЗависимости</I>). Первая зависимость - объектный файл 
<I>main.o</I>. Поскольку в make-файле есть правило с такой целью (функция 
<I>ЕстьТакаяЦель</I> возвращает true), то для цели <I>main.o</I> запускается 
процедура <I>ДостичьЦели</I>. 
<P>Функция <I>ДостичьЦели</I> ищет правило, где описана цель <I>main.o</I>. Эта 
цель описана во втором правиле make-файла. Для этого правила запускается функция 
<I>ОбработатьПравило</I>. 
<P>Функция <I>ОбработатьПравило</I> запускает процесс обработки зависимостей 
(функция <I>ОбработатьЗависимости</I>). Во втором правиле указана единственная 
зависимость - <I>main.cpp</I>. Такой цели в make-файле не существует, поэтому 
считается, что зависимость <I>main.cpp</I> является именем файла. Далее, 
проверяется наличие этого файла на диске (функция <I>ПроверитьНаличиеФайла</I>) 
- такой файл существует. На этом процесс обработки зависимостей завершается. 
<P>После обработки зависимостей, функция <I>ОбработатьПравило</I> принимает 
решение о том, нужно ли выполнять указанные в правиле команды (функция 
<I>НужноВыполнятьКоманды</I>). Цели правила (файла <I>main.o</I>) не существует, 
поэтому команды нужно выполнять. Функция <I>ВыполнитьКоманды</I> запускает 
указанную в правиле команду (компилятор <B>GCC</B>), в результате чего создается 
файл <I>main.o</I>. 
<P>Цель main.o достигнута (объектный файл main.o построен). Теперь <B>make</B> 
возвращается к обработке остальных зависимостей первого правила. Зависимости 
<I>Editor.o</I> и <I>TextLine.o</I> обрабатываются аналогично. Для них 
выполняются те же действия, что и для зависимости <I>main.o</I>. 
<P>После того, как все зависимости (<I>main.o</I>, <I>Editor.o</I> и 
<I>TextLine.o</I>) обработаны, решается вопрос о необходимости выполнения 
указанных в правиле команд (функция <I>НужноВыполнятьКоманды</I>). 
<P>Поскольку цель (<I>iEdit</I>) является именем файла, который в данный момент 
не существует, то принимается решение выполнить описанную в правиле команду 
(функция <I>ВыполнитьКоманды</I>). 
<P>Содержащаяся в правиле команда запускает компилятор <B>GCC</B>, в результате 
чего создается исполняемый файл <I>iEdit</I>. Главная цель (<I>iEdit</I>)таким 
образом достигнута. На этом программа <B>make</B> завершает свою работу. 
<H3><A name=Another_make_example></A>3.5. Еще один пример работы <B>make</B> 
</H3>Рассмотрим, как будет действовать утилита <B>make</B>, если для обработки 
описанного в предыдущей главе make-файла, она будет вызвана следующим образом: <PRE>    make clean</PRE>Цель явно указана в командной строке, поэтому главной 
целью становится абстрактная цель <I>clean</I>. Цель <I>clean</I> передается 
функции <I>ДостичьЦели</I>. Эта функция ищет правило, которое описывает 
обрабатываемую цель. Это будет пятое правило make-файла. Для найденного правила 
запускается процедура обработки (функция <I>ОбработатьПравило</I>). 
<P>Поскольку в правиле не указано каких-либо зависимостей, <B>make</B> сразу 
переходит к этапу обработки указанных в правиле команд. Цель является именем 
действия, поэтому команды нужно выполнять. 
<P>Указанные в правиле команды выполняются, и цель <I>clean</I>, таким образом, 
считается достигнутой. На этом программа <B>make</B> завершает работу. 
<H3><A name=vars></A>3.6. Переменные </H3>Возможность использования переменных 
внутри make-файла - очень удобное и часто используемое свойство <B>make</B>. В 
традиционных версиях утилиты, переменные ведут себя подобно макросам языка Си. 
Для задания значения переменной используется оператор присваивания. Например, 
выражение: <PRE>    obj_list = main.o Editor.o TextLine.o</PRE>присваивает переменной 
<I>obj_list</I> значение "<I>main.o</I> <I>Editor.o</I> <I>TextLine.o</I>" (без 
кавычек). Пробелы между символом '<B>=</B>' и началом первого слова 
игнорируются. Следующие за последним словом пробелы также игнорируются. Значение 
переменной можно использовать с помощью конструкции: <PRE>    $(имя_переменной)</PRE>
<P>Например, при обработке такого make-файла: <PRE>    dir_list = . .. src/include

    all:
        echo $(dir_list)</PRE>на экран будет выведена строка: <PRE>    . .. src/include</PRE>
<P>Переменные могут не только содержать текстовые строки, но и "ссылаться" на 
другие переменные. Например, в результате обработки make-файла: <PRE>    optimize_flags = -O3
    compile_flags  = $(optimize_flags) -pipe
    
    all:
        echo $(compile_flags)</PRE>
<P>на экран будет выведено: <PRE>    -O3 -pipe</PRE>
<P>Во многих случаях использование переменных позволяет упростить make-файл и 
повысить его наглядность. Для того чтобы облегчить модификацию make-файла, можно 
разместить "ключевые" имена и списки в отдельных переменных и поместить их в 
начало make-файла: <PRE>    program_name = iEdit
    obj_list     = main.o Editor.o TextLine.o
    
    $(program_name): $(obj_list)
        gcc $(obj_list) -o $(program_name)  

    ... </PRE>
<P>Адаптация такого make-файла для сборки другой программы сведется к изменению 
нескольких начальных строк. 
<H3><A name=automatic_vars></A>3.7. Автоматические переменные 
</H3><I>Автоматические переменные</I> - это переменные со специальными именами, 
которые "автоматически" принимают определенные значения перед выполнением 
описанных в правиле команд. Автоматические переменные можно использовать для 
"упрощения" записи правил. Такое, например, правило: <PRE>  iEdit: main.o Editor.o TextLine.o
        gcc  main.o Editor.o TextLine.o -o iEdit</PRE>с использованием 
автоматических переменных можно записать следующим образом: <PRE>  iEdit: main.o Editor.o TextLine.o
        gcc  $^  -o $@</PRE>Здесь <I>$^</I> и <I>$@</I> являются автоматическими 
переменными. Переменная <I>$^</I> означает "список зависимостей". В данном 
случае при вызове компилятора <B>GCC</B> она будет ссылаться на строку 
"<I>main.o</I> <I>Editor.o</I> <I>TextLine.o</I>". Переменная <I>$@</I> означает 
"имя цели" и будет в этом примере ссылаться на имя "<I>iEdit</I>". 
<P>Иногда использование автоматических переменных совершенно необходимо - 
например, в шаблонных правилах (о них пойдет речь в следующей главе). 
<H3><A name=pattern_rules></A>3.8. Шаблонные правила </H3><I>Шаблонные 
правила</I> (<I>implicit rules</I> или <I>pattern rules</I>) - это правила, 
которые могут быть применены к целой группе файлов. В этом их отличие от обычных 
правил - описывающих отношения между конкретными файлами. 
<P>Традиционные реализации <B>make</B> поддерживают так называемую "суффиксную" 
форму записи шаблонных правил: <PRE>    .&lt;расширение_файлов_зависимостей&gt;.&lt;расширение_файлов_целей&gt;:
        &lt;команда_1&gt;
        &lt;команда_2&gt;
        ...
        &lt;команда_n&gt; </PRE>Например, следующее правило говорит о том, что 
все файлы с расширением "<I>o</I>" зависят от соответствующих файлов с 
расширением "<I>cpp</I>": <PRE>    .cpp.o:
        gcc -c $^ </PRE>Обратите внимание на использование автоматической 
переменной <I>$^</I> для передачи компилятору имени файла-зависимости. Поскольку 
шаблонное правило может применяться к разным файлам, использование 
автоматических переменных - это единственный способ узнать для каких файлов 
сейчас задействуется правило. 
<P>Шаблонные правила позволяют упростить make-файл и сделать его более 
универсальным. Рассмотрим простой проектный файл: <PRE>    iEdit: main.o Editor.o TextLine.o
        gcc $^ -o $@
         
    main.o: main.cpp
        gcc -c $^

    Editor.o: Editor.cpp
        gcc -c $^

    TextLine.o: TextLine.cpp
        gcc -c $^ </PRE>Все исходные тексты программы обрабатываются одинаково - 
для них вызывается компилятор <B>GCC</B>. С использованием шаблонных правил, 
этот пример можно переписать так: <PRE>    iEdit: main.o Editor.o TextLine.o
        gcc $^ -o $@
         
    .cpp.o:
        gcc -c $^</PRE>Когда <B>make</B> ищет в файле проекта правило, 
описывающее способ достижения искомой цели (см. главу <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Process_target">3.2.2. 
"Достижение <I>цели</I>"</A>, функция <I>НайтиПравило</I>), то в расчет 
принимаются и шаблонные правила. Для каждого из них проверяется - нельзя ли 
задействовать это правило для достижения искомой цели. 
<H2><A name=pril_A></A>Приложение A. Редактирование make-файлов в разных 
операционных системах </H2>Если, наряду с операционной системой <B>Linux</B>, вы 
работаете с операционными системами фирмы <B>Microsoft</B> (<B>DOS</B>, 
<B>Windows</B>), то при редактировании make-файлов в разных системах могут 
возникнуть определенные трудности. 
<P>Проблема состоит в том, что принятый в <I>Unix</I>-подобных операционных 
системах формат хранения текстовых файлов, несколько отличается от формата 
<B>DOS</B>/<B>Windows</B>. В <B>Unix</B> каждая строка текстового файла 
заканчивается символом "перевод строки" (код <I>0x0A</I>). В <B>DOS</B> и 
<B>Windows</B> текстовые строки разделяются парой символов - "возврат каретки", 
"перевод строки" (<I>0x0D</I>, <I>0x0A</I>). 
<P><I>Linux</I>-версия программы <B>GNU Make</B> будет нормально работать с 
make-файлами, написанными в среде <B>Linux</B>. Версия утилиты <B>GNU Make</B> 
для <B>Windows</B> также будет нормально работать с make-файлами, 
подготовленными в среде <B>Windows</B>. Проблема возникнет лишь в том случае, 
если попытаться обработать <I>Linux</I>-версией программы <B>GNU Make</B> 
текстовой файл, подготовленный в среде <B>DOS</B> или <B>Windows</B>. Подобная 
ситуация может возникнуть "нечаянно" - достаточно лишь "сохранить" make-файл для 
среды <B>Linux</B> в текстовом редакторе <B>DOS</B>/<B>Windows</B>, чтобы он 
оказался "испорчен". 
<P>В отличие от компилятора <B>GCC</B>, который просто игнорирует символы 
"возврат каретки", <B>GNU Make</B> рассматривает их как "обычные" символы, 
которые вполне могут быть частью имени. В результате все слова, находящиеся в 
конце строк, искажаются, так как сзади к ним добавляется невидимый символ 
"возврат каретки". В следующем примере имя файла <I>TextLine.o</I> будет 
искажено (его длина будет составлять одиннадцать символов из-за невидимого 
"возврата строки"): <PRE>    iEdit: main.o Editor.o TextLine.o
        gcc $^ -o $@ </PRE>
<P>Разумеется, на диске не найдется файла с таким "странным" именем и make-файл 
будет работать неверно. Дело осложняется еще и тем, что выдаваемые на экран 
диагностические сообщения также искажаются (при выводе на экран символ "возврат 
каретки" возвращает курсор в начало строки) и зачастую представляют собой лишь 
бессмысленные "обрывки" слов. 
<P>Описанную проблему можно решить разными способами. Организационный метод 
решения - никогда не пытаться редактировать make-файл, находясь в "чужеродной" 
для него среде. Другой возможный подход - "принудительно" удалять из make-файла 
символы "возврат каретки" (либо "вручную" - текстовым редактором, либо с помощью 
подходящей программы). 
<H2><A name=pril_B></A>Приложение B. Организация иерархии каталогов в сложных 
проектах </H2>Для сложных проектов, состоящих из большого количества файлов, я 
предпочитаю более сложную организацию каталогов, чем та, которая приводилась в 
качестве примера в разделе 1.7. <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Multi-config_multi-dirs">"Разнесение 
разных версий программы по отдельным директориям"</A>. Основная идея заключается 
в том, чтобы файлы с разным "назначением" помещались в разные каталоги. В моих 
проектах дерево каталогов выглядит примерно так: 
<UL>
  <LI>имя_проекта / 
  <UL>
    <LI>bin / 
    <UL>
      <LI>linux_debug / 
      <LI>linux_release / 
      <LI>windows_debug / 
      <LI>windows_release / </LI></UL>
    <LI>doc / 
    <UL>
      <LI><I>README.txt</I> </LI></UL>
    <LI>project / 
    <UL>
      <LI><I>Makefile</I> 
      <LI><I>make_debug</I> 
      <LI><I>make_release</I> </LI></UL>
    <LI>src / </LI></UL></LI></UL>В каталог <I>bin</I> помещаются результаты 
компиляции - объектные и исполняемые файлы, библиотеки и тому подобное. Этот 
каталог можно "безболезненно" удалить - при следующей компиляции он будет 
автоматически создан заново. В этом каталоге каждая из возможных конфигураций 
программы имеет свою отдельную директорию. Как правило, я делаю четыре 
конфигурации программы - для каждой из двух операционных систем (<B>Linux</B> и 
<B>Windows</B>) имеется отладочная и рабочая версии программы. 
<P>В директорию <I>doc</I> я помещаю различные текстовые файлы - документацию, 
замечания, список ошибок и тому подобное. Здесь же располагается и файл 
<I>README.txt</I>. 
<P>В каталоге <I>project</I> находится make-файл проекта и командные файлы, 
используемые для сборки программы в разных конфигурациях. 
<P>В каталог <I>src</I> я помещаю исходные тексты программы. Внутри директории 
<I>src</I> имеется своя иерархия каталогов, отражающая логическую структуру 
программы. 
<P>Вот пример make-файла, который работает с подобной структурой директорий 
проекта: <PRE>    #
    #   example_7-complex/project/Makefile 
    # 
    #   Пример проекта со "сложной" структурой директорий 
    #

    program_name := iEdit
    source_dirs  := . Editor TextLine 
    include_dirs := /c/aproj/lib  /c/aproj/lib/linux
    link_flags   := -static 
    
    source_dirs  := $(addprefix ../../src/, $(source_dirs) )
    source_files := $(wildcard $(addsuffix /*.cpp, $(source_dirs) ) )
    object_files := $(notdir $(source_files) )
    object_files := $(object_files:.cpp=.o)
    
    $(program_name): $(object_files)
        gcc $^ -o $@ $(link_flags) -pipe 
        
    VPATH := $(source_dirs)
    
    %.o: %.cpp 
        gcc $&lt; -c $(compile_flags) $(addprefix -I, $(include_dirs)) $(addprefix -I, $(source_dirs)) -MD -pipe 2&gt;log
    
    include $(wildcard *.d) </PRE>Список директорий, где располагаются файлы с 
исходными текстами (<I>source_dirs</I>), задается относительно каталога 
<I>src</I>. Вот как выглядит командный файл, собирающий отладочную версию 
программы: <PRE>    mkdir -p ../bin/linux_debug
    make  compile_flags="-O0 -g" \
          --directory=../bin/linux_debug \
          --makefile=../../project/Makefile</PRE>Командный файл, собирающий 
рабочую версию программы выглядит аналогично: <PRE>    mkdir -p ../bin/linux_release
    make  compile_flags="-O3 -funroll-loops -fomit-frame-pointer" \
          --directory=../bin/linux_release \
          --makefile=../../project/Makefile</PRE>
<H2><A name=pril_C></A>Приложение C. Компилятор GCC </H2><B>GNU Compiler 
Collection</B> (<B>GCC</B>) - это семейство компиляторов с языков <B>C</B>, 
<B>C++</B> и <B>Object-C</B>, которые объединены общей технологией и 
распространяются в рамках проекта <B>GNU</B>. Домашняя страничка компилятора 
находится по адресу <A 
href="http://www.gnu.org/software/gcc/gcc.html">www.gnu.org/software/gcc/gcc.html</A> 

<P>Этот компилятор является "стандартным" средством для компиляции всех 
программ, входящих в проект <B>GNU</B>. <B>GCC</B> также является основным 
компилятором операционной системы <B>Linux</B> - с его помощью компилируется 
ядро системы. 
<H3>Версии компилятора </H3>Компилятор GCC развивается весьма динамично - 
программа улучшается, исправляются обнаруженные ошибки, добавляются новые 
возможности. Всегда желательно знать с какой версией компиляторы вы в данный 
момент работаете. Возможно, что эта версия еще не поддерживает нужные вам 
возможности или содержит ошибки, которые могут повлиять на работоспособность 
компилируемой программы. Узнать версию компилятора <B>GCC</B> можно с помощью 
ключа <B>-v</B>: <PRE>    gcc -v </PRE>
<H3>Отладка </H3>"Стандартным" средством для отладки программ, скомпилированных 
компилятором <B>GCC</B>, является отладчик <B>GDB</B>. Этот отладчик свободно 
распространяется в рамках проекта <B>GNU</B>. Домашняя страничка отладчика 
находится по адресу <A 
href="http://www.gnu.org/software/gdb/gdb.html">www.gnu.org/software/gdb/gdb.html</A>. 

<P>Для подготовки отладочной версии программы с помощью компилятора <B>GCC</B>, 
достаточно отключить оптимизацию и включить генерацию отладочной информации. Для 
этого я использую следующие опции компиляции: 
<P><!-- Таблица опций компиляции GCC-debug -->
<TABLE border=1>
  <TBODY>
  <TR>
    <TD>-g </TD>
    <TD>Генерировать отладочную информацию </TD></TR>
  <TR>
    <TD>-O0 </TD>
    <TD>Отключить оптимизацию </TD></TR></TBODY></TABLE>
<P>Отладчик <B>GDB</B> имеет текстовой интерфейс командной строки. Мне этот 
интерфейс кажется не очень удобными, поэтому я пользуюсь графической оболочкой 
<B>DataDisplayDebugger</B> (<B>DDD</B>). Эта оболочка является надстройкой над 
"текстовыми" отладчиками, реализующей для них удобный графический интерфейс. 
Программа <B>DDD</B> также входит в проект <B>GNU</B>. Ее домашняя страничка 
находится по адресу <A 
href="http://www.gnu.org/software/ddd">http://www.gnu.org/software/ddd</A>. 
<B>DataDisplayDebugger</B> работает в среде <B>X-Windows</B>. 
<H3>Рабочий вариант </H3>При компиляции рабочего варианта программы, я включаю 
максимальную оптимизацию по скорости. Возможно это приводит к некоторому 
увеличению размера программы, но я считаю это не слишком важным. Вряд ли 
кто-нибудь заметит увеличение размера программы на пять-десять килобайт. В то же 
время быстродействия программам всегда не хватает. 
<P>Компилятор <B>GCC</B> имеет большое количество опций, управляющих процессом 
кодогенерации и оптимизации, с которыми вы можете экспериментировать, добиваясь 
максимального быстродействия программы. Для своих проектов я использую следующие 
настройки: 
<P><!-- table - GCC release switches -->
<TABLE border=1><!-- заголовок -->
  <TBODY>
  <TR>
    <TD>Ключ </TD>
    <TD>Назначение </TD></TR>
  <TR>
    <TD>-O3 </TD>
    <TD>Максимальная оптимизация </TD></TR>
  <TR>
    <TD>-fomit-frame-pointer </TD>
    <TD>Не использовать указатель на стековый фрейм. Компилятор будет 
      адресовать переменные в стеке с помощью регистра <I>ESP</I> а регистр 
      <I>EBP</I> "высвобождается" для использования в качестве регистра общего 
      назначения. </TD></TR>
  <TR>
    <TD>-mcpu=pentium </TD>
    <TD>Оптимизировать код для процессора <B>Pentium</B> (однако программа по 
      прежнему будет работать даже на <I>i386</I>) </TD></TR></TBODY></TABLE>
<H3>Обработка исключений </H3>Если вы используете механизм <I>исключений</I> 
(<I>exceptions</I>) языка <B>C++</B>, то при компиляции должна быть включена 
соответствующая опция: 
<P><!-- table - GCC common switches -->
<TABLE border=1><!-- заголовок -->
  <TBODY>
  <TR>
    <TD>Ключ компиляции </TD>
    <TD>Назначение </TD></TR>
  <TR>
    <TD>-fexceptions </TD>
    <TD>Включить поддержку механизма исключительных ситуаций языка <B>C++</B> 
    </TD></TR></TBODY></TABLE>
<H3>Статическая и динамическая компоновка </H3>По умолчанию компилятор компонует 
собранную программу с динамическими версиями стандартных библиотек. Это не 
всегда удобно. Для того чтобы стандартные библиотеки компоновались статически, 
нужно использовать опцию <B>--static</B>. В этом случае генерируется полностью 
"статический" код, который для своей работы не требует наличия каких-либо 
загружаемых библиотек. 
<H3>Получение листинга </H3>Часто бывает полезным иметь ассемблерный листинг 
кода, генерируемого компилятором. С помощью такого листинга можно: 
<UL>
  <LI>Посмотреть, как те или иные опции оптимизации отражаются на генерируемом 
  коде 
  <LI>Посмотреть, каким образом компилятор обрабатывает те или иные конструкции 
  языка программирования 
  <LI>Выявлять ошибки, связанные с неправильной работой кодогенерации в 
  компиляторе 
  <LI>Узнать, какие в точности опции были включены при компиляции программы 
</LI></UL>Для получения ассемблерного листинга, я использую следующие опции 
компилятора <B>GCC</B>: 
<P><!-- table - GCC listing switches -->
<TABLE border=1><!-- заголовок -->
  <TBODY>
  <TR>
    <TD>Ключ компиляции </TD>
    <TD>Назначение </TD></TR>
  <TR>
    <TD><I>-S</I> </TD>
    <TD>Остановиться после стадии компиляции, перед стадией ассемблирования. 
    </TD></TR>
  <TR>
    <TD><I>-fverbose-asm</I> </TD>
    <TD>Генерировать дополнительные комментарии в ассемблерном листинге. Какие 
      именно "дополнительные комментарии" будут помещены в текст листинга, 
      зависит от версии компилятора. </TD></TR></TBODY></TABLE>
<P>Обратите внимание на то, что указание флажка <B>-S</B> просто "останавливает" 
компилятор после фазы генерации ассемблерного листинга, то есть процесс 
компиляции прерывается. Как следствие - процесс сборки программы и процесс 
генерации ассемблерных листингов "несовместимы" между собой. Можно либо получать 
листинги, либо собирать программу, но не то и другое одновременно. Для получения 
листингов я обычно создаю отдельный командный файл, который среди прочих опций 
компиляции содержит флажки <B>-S</B> и <B>-fverbose-asm</B>. 
<P>Весьма полезная возможность компилятора - помещать в листинг список всех 
опций компиляции, которые были включены в данный момент. Дело в том, что 
включение одних опций (например <B>-O3</B>) может "автоматически" приводить к 
включению других опций, а документация к <B>GCC</B> не всегда точна в описании 
подобных зависимостей. Некоторые версии <B>GCC</B> всегда помещают в листинг 
список используемых опций, другие версии делают это только при наличии флажка 
<B>-fverbose-asm</B>. 
<H3>Переназначение ошибок в файл </H3>По умолчанию, компилятор GCC выдает ошибки 
в стандартный поток сообщений об ошибках (файл с дескриптором 2). Иногда это не 
очень удобно - сообщения об ошибках могут быть очень длинными и подробными, а 
"прокрутка" экрана назад не всегда доступна. Поэтому, я, обычно, перенаправляю 
сообщения компилятора в файл. Этот файл потом можно просмотреть любым 
стандартным средством. Вот, например, как может выглядеть правило для компиляции 
исходных текстов: <PRE>    %.o: %.cpp
        gcc -c $&lt; 2&gt;log</PRE>
<H3>Опция -pipe </H3>Компилятор <B>GCC</B> обрабатывает программу за несколько 
проходов, помещая промежуточные результаты компиляции во временные файлы. 
Процесс компиляцию можно ускорить, если воспользоваться опцией <B>-pipe</B>. При 
включении этой опции, различные этапы компиляции начинают "общаться" между собой 
не через временные файлы, а через каналы обмена (<I>pipes</I>). 
<H3>Тексты с символом "возврат каретки" </H3>В отличие от утилиты <B>GNU 
Make</B>, компилятор <B>GCC</B> вполне "лояльно" относится к наличию символов 
"возврат каретки" в компилируемых текстах - такие символы попросту игнорируются. 
Поэтому, проблем при компиляции исходных текстов, подготовленных в среде 
<B>DOS</B>/<B>Windows</B>, возникнуть не должно. 
<H2><A name=pril_D></A>Приложение D. "Гипотический" проект - текстовой редактор 
</H2>В первой главе <A 
href="http://www.geocities.com/SiliconValley/Office/6533/gm.htm#Using_GNU_Make">"Моя 
методика использования GNU Make" </A>в качестве примера рассматривается 
"гипотический" проект - текстовой редактор. Он состоит из трех файлов с исходным 
текстом на языке <B>C++</B> (<I>main.cpp</I>, <I>Editor.cpp</I> и 
<I>TextLine.cpp</I>), а также трех заголовочных файлов (<I>main.h</I>, 
<I>Editor.h</I>, <I>TextLine.h</I>). Ниже приведены листинги этих файлов. 
<P>Файл <I>main.cpp</I>: <PRE>    #include "main.h"

    void main()
    {
    } </PRE>
<P>Файл <I>main.h</I>: <PRE>    // main.h</PRE>
<P>Файл <I>Editor.cpp</I>: <PRE>    #include "Editor.h" </PRE>
<P>Файл <I>Editor.h</I>: <PRE>    #include "TextLine.h" </PRE>
<P>Файл <I>TextLine.cpp</I>: <PRE>    #include "TextLine.h" </PRE>
<P>Файл <I>TextLine.h</I>: <PRE>    // TextLine.h</PRE><!-- counter -->
<HR noShade SIZE=1>
<!--    
<table width=500 border=0>
<form method=post action="http://www.geocities.com/cgi-bin/search/isearch">
<tr><td valign=top width="50%"><font size=-1 face=arial><b>Didn't find what you're looking for?</b></font><br>
<input type="HIDDEN" name="FIELDS" value="url,title,abstract,size,date,score">
<input type="HIDDEN" name="DOMAIN" value="geocities.com">
</td><td valign=top width="50%" align=center>
<font face=arial size=-1><b>Want to start your own site?</font>
</td></tr><tr><td><input type="TEXT" size="24" name="QUERY" value=""> <input type="SUBMIT" value="Search"></td><td align=center valign=top><font face=arial size=-1><b><a href="http://geocities.yahoo.com/home/">Join Yahoo! GeoCities</a></b></font></td></tr></form></table>
<p><table border=0 cellspacing=0 cellpadding=2 width=500>
<tr><td valign=top><center><hr size=1 width="100%"><font face=verdana size=-2>Copyright c 1994-1999 <a href="http://www.yahoo.com">Yahoo!</a> Inc. All rights reserved.
</font></center></td></tr></table>
    --><!--LINE4--><IMG src="http://www.linux.org.ru/books/GNU/Gmake_files/counter.gif"> 
<P>
<CENTER></CENTER>Я буду рад услышать ваше мнение об этом тексте. Для этого можно 
воспользоваться гостевой книгой: 
<P><A href="http://www.geocities.com/cgi-bin/geoplus_apps/ans_entry">Sign 
Guestbook</A> <A 
href="http://www.geocities.com/SiliconValley/Office/6533/geobook.html">View 
Guestbook</A> 
<P><A href="http://www.geocities.com/SiliconValley/Office/6533">На главную 
страницу </A></P></BODY></HTML>
