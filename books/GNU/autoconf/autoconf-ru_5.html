<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from autoconf-ru.texi on 10 October 2000 -->

<TITLE>Autoconf - Написание тестов</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="autoconf-ru_1.html">first</A>, <A HREF="autoconf-ru_4.html">previous</A>, <A HREF="autoconf-ru_6.html">next</A>, <A HREF="autoconf-ru_19.html">last</A> section, <A HREF="autoconf-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC40" HREF="autoconf-ru_toc.html#TOC40">Написание тестов</A></H1>
<P>
@anchor{Writing Tests}


<P>
Если существующие тесты делают не то, что вам надо, то вы
можете написать собственные тесты. Эти макросы являются строительными
блоками для этих тестов. Они предоставляют другим макросам возможность
проверить доступность различных свойств и сообщить о результатах.


<P>
Эта глава содержит некоторые пожелания и описание того, почему
существующие тесты написаны так, а не иначе.  Вы также можете научиться
тому, как писать тесты Autoconf, разглядывая существующие тесты.  Если в
одном или нескольких тестах Autoconf что-нибудь пойдет не так, то эта
информация может помочь вам понять предположения, которые стоят за ними,
что, в свою очередь, может помочь вам определить наилучший способ решения
проблемы.


<P>
Эти макросы проверяют вывод системного компилятора C. Они не кэшируют
результаты тестов для последующего использования (see section <A HREF="autoconf-ru_6.html#SEC55">Кэширование результатов</A>), поскольку для генерации имени переменной кэша они не
имеют достаточно информации о том, что они проверяют. Также по некоторым
причинам они не печатают никаких сообщений. Проверки отдельных свойств
компилятора С вызывают эти макросы и кэшируют свои результаты, а также
выводят сообщения о том, что они проверяют.


<P>
Когда вы пишете тест свойства, который может быть применим для более чем
одного пакета программного обеспечения, то лучше всего будет описать его
как новый макрос. Для того, чтобы узнать, как это делается See section <A HREF="autoconf-ru_7.html#SEC59">Создание макросов</A>.




<H2><A NAME="SEC41" HREF="autoconf-ru_toc.html#TOC41">Исследование деклараций</A></H2>
<P>
@anchor{Examining Declarations}


<P>
Макрос <CODE>AC_TRY_CPP</CODE> используется для проверки существования
конкретных заголовочных файлов.  You can check for one at a time, or
more than one if you need several header files to all exist for some
purpose.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TRY_CPP</B> <I>(<VAR>includes</VAR>, [<VAR>action-if-true</VAR> [, <VAR>action-if-false</VAR>]])</I>
<DD><A NAME="IDX392"></A>
<A NAME="IDX393"></A>
<VAR>includes</VAR> содержит директивы <CODE>#include</CODE> языков C или C++, а также
объявления, над которыми выполняются подстановки переменных командного
процессора, обратных кавычек и обратных слэшей.  (В действительности, <VAR>includes</VAR>
может быть любой программой на C, но другие выражения, вероятно, бесполезны).
Если препроцессор не выдает сообщений об ошибках в
течении обработки директивы, то выполняется код командного процессора
<VAR>action-if-true</VAR>. В противном случае выполняется код
<VAR>action-if-false</VAR>.


<P>
Этот макрос использует переменную <CODE>CPPFLAGS</CODE>, а не <CODE>CFLAGS</CODE>,
поскольку <SAMP>`-g'</SAMP>, <SAMP>`-O'</SAMP> и т. п. не являются правильными ключами
для многих препроцессоров C.
</DL>


<P>
Вот как узнать, содержит ли конкретный заголовочный файл определенное
объявление, например, объявление типа, структуры, члена структуры или
функции. Используйте макрос <CODE>AC_EGREP_HEADER</CODE> вместо прямого
запуска команды <CODE>grep</CODE> для заголовочного файла; в некоторых
системах символ может быть объявлен в другом заголовочном файле, а не в
том, который вы проверяете в <SAMP>`#include'</SAMP>.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_EGREP_HEADER</B> <I>(<VAR>pattern</VAR>, <VAR>header-file</VAR>, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>])</I>
<DD><A NAME="IDX394"></A>
<A NAME="IDX395"></A>
Если вывод препроцессора, запущенного для системного заголовочного файла
<VAR>header-file</VAR> соответствует регулярному выражению <CODE>egrep</CODE>
<VAR>pattern</VAR>, то выполняются команды командного процессора
<VAR>action-if-found</VAR>, в противном случае выполняются команды
<VAR>action-if-not-found</VAR>.
</DL>


<P>
Для проверки символов препроцессора C, определенных в заголовочном
файле, либо предопределенных препроцессором C, используйте макрос
<CODE>AC_EGREP_CPP</CODE>. Вот пример последнего:



<PRE>
AC_EGREP_CPP(yes,
[#ifdef _AIX
  yes
#endif
], is_aix=yes, is_aix=no)
</PRE>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_EGREP_CPP</B> <I>(<VAR>pattern</VAR>, <VAR>program</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX396"></A>
<A NAME="IDX397"></A>
<VAR>program</VAR> является текстом программы на C или C++, для которой
выполняются подстановки переменных командного процессора, обратных
кавычек и обратных слэшей. Если вывод препроцессора, обрабатывавшего
<VAR>program</VAR>, соответствует регулярному выражению команды <CODE>egrep</CODE>
<VAR>pattern</VAR>, то выполняется код командного процессора
<VAR>action-if-found</VAR>, иначе выполняется <VAR>action-if-not-found</VAR>.


<P>
Этот макрос вызывает <CODE>AC_PROG_CPP</CODE> или <CODE>AC_PROG_CXXCPP</CODE> (в
зависимости от того, какой из языков является текущим, see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), если эти макросы еще не вызывались.
</DL>




<H2><A NAME="SEC42" HREF="autoconf-ru_toc.html#TOC42">Проверка синтаксиса</A></H2>
<P>
@anchor{Examining Syntax}


<P>
Для проверки синтаксических возможностей компиляторов C, C++ или Fortran
77, например, распознавания определенных ключевых слов, используется
макрос <CODE>AC_TRY_COMPILE</CODE>, который пробует откомпилировать маленькую
программу, которая использует заданную возможность.  Вы также можете
использовать этот макрос для проверки структур и полей структур, которые
присутствуют не во всех системах.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TRY_COMPILE</B> <I>(<VAR>includes</VAR>, <VAR>function-body</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX398"></A>
<A NAME="IDX399"></A>
Создает тестовую программу на C, C++ или Fortran 77 (в зависимости от того, 
какой язык является текущим, see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), для того, чтобы 
убедиться, что функция, чье тело состоит из <VAR>function-body</VAR> может 
быть скомпилирована.


<P>
Для C и C++, <VAR>includes</VAR> является любыми директивами <CODE>#include</CODE>, в
которых нуждается код в <VAR>function-body</VAR> (параметр <VAR>includes</VAR> будет 
проигнорирован, если текущим языком является Fortran 77). Этот макрос
при компиляции помимо переменной <CODE>CPPFLAGS</CODE>
также использует переменные <CODE>CFLAGS</CODE> или <CODE>CXXFLAGS</CODE>, если 
текущим языком является C или C++.  Переменная <CODE>FFLAGS</CODE> будет
использована при компиляции, если текущим языком является Fortran 77.


<P>
Если файл компилируется нормально, то выполняются команды
<VAR>action-if-found</VAR>, иначе выполняется <VAR>action-if-not-found</VAR>.


<P>
Этот макрос не пытается выполнить компоновку программы -- для этого вам
придется использовать макрос
<CODE>AC_TRY_LINK</CODE> (see section <A HREF="autoconf-ru_5.html#SEC43">Проверка библиотек</A>).
</DL>




<H2><A NAME="SEC43" HREF="autoconf-ru_toc.html#TOC43">Проверка библиотек</A></H2>
<P>
@anchor{Examining Libraries}


<P>
Для проверки библиотеки, функции или глобальной переменной скрипт
<CODE>configure</CODE> попытается скомпилировать и скомпоновать
небольшую программу, которая использует тестируемые возможности.  Этим
Autoconf отличается от Metaconfig, который обрабатывает файлы
библиотеки C, используя <CODE>nm</CODE> или <CODE>ar</CODE>, чтобы определить,
какие функции
доступны.  Попытка скомпоновать программу с функцией -- более надежный
вариант, поскольку он избавляет от необходимости обрабатывать различные
ключи командной строки и форматы выдачи результатов
программ <CODE>nm</CODE> и <CODE>ar</CODE>, а также выяснять расположение
стандартных библиотек. Этот подход также позволяет конфигурировать
кросс-компиляцию, а также проверять поведение функции во время
выполнения.  С
другой стороны, этот подход может оказаться значительно более медленным, чем однократное
сканирование библиотек.


<P>
Компоновщики в нескольких существующих системах не возвращают статус
ошибки, если не могут найти какие-либо символы при компоновке.  Эта ошибка делает
невозможным использование на таких системах скриптов настройки, созданных
Autoconf.  Однако, некоторым из них могут быть заданы ключи, которые
позволяют получить правильный статус завершения работы. 
Эту проблему в настоящий момент Autoconf не может обработать
автоматически. Если пользователь столкнется с таким, то он может
решить эту проблему установкой переменной среды <CODE>LDFLAGS</CODE>,
передавая компоновщику необходимые ключи командной строки (например,
<SAMP>`-Wl,-dn'</SAMP> на MIPS RISC/OS).


<P>
Макрос <CODE>AC_TRY_LINK</CODE> используется для компиляции тестовой программы
для проверки функций и глобальных переменных. Он также используется
макросом <CODE>AC_CHECK_LIB</CODE> для проверки библиотек
(see section <A HREF="autoconf-ru_4.html#SEC25">Файлы библиотек</A>), временно добавляя проверяемую библиотеку в
переменную <CODE>LIBS</CODE> и пытаясь скомпоновать маленькую программу.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TRY_LINK</B> <I>(<VAR>includes</VAR>, <VAR>function-body</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX400"></A>
<A NAME="IDX401"></A>
В зависимости от текущего языка (see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), создается
тестовая программа, для того чтобы выяснить, может ли быть
скомпилирована и скомпонована функция, чье тело состоит из аргумента
<VAR>function-body</VAR>.


<P>
Для C и C++, <VAR>includes</VAR> является любыми директивами <CODE>#include</CODE>, в
которых нуждается код в <VAR>function-body</VAR> (параметр <VAR>includes</VAR> будет 
проигнорирован, если текущим языком является Fortran 77). Этот макрос
при компиляции помимо переменной <CODE>CPPFLAGS</CODE>
также использует переменные <CODE>CFLAGS</CODE> или <CODE>CXXFLAGS</CODE>, если 
текущим языком является C или C++.  Переменная <CODE>FFLAGS</CODE> будет
использована при компиляции, если текущим языком является Fortran 77. 
Однако в любом случае при компоновке будут использованы
переменные <CODE>LDFLAGS</CODE> и <CODE>LIBS</CODE>.


<P>
Если файл компилируется и компонуется, то выполняются команды
<VAR>action-if-found</VAR>, в противном случае ---
<VAR>action-if-not-found</VAR>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TRY_LINK_FUNC</B> <I>(<VAR>function</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX402"></A>
<A NAME="IDX403"></A>
В зависимости от текущего языка see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), создается тестовая
программа для того, чтобы убедиться, что программа, чье тело состоит их
прототипа и вызова <VAR>function</VAR>, может быть скомпилирована и
скомпонована.


<P>
Если файл компилируется и компонуется без ошибок, то выполняется код
<VAR>action-if-found</VAR>, в противном случае выполняется
<VAR>action-if-not-found</VAR>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TRY_LINK_FUNC</B> <I>(<VAR>function</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX404"></A>
<A NAME="IDX405"></A>
Этот макрос пробует скомпилировать и скомпоновать маленькую программу,
которая компонуется с <VAR>function</VAR>. Если файл компилируется и
компонуется без ошибок, то запускается код командного процессора
<VAR>action-if-found</VAR>, в противном случае выполняется
<VAR>action-if-not-found</VAR>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_COMPILE_CHECK</B> <I>(<VAR>echo-text</VAR>, <VAR>includes</VAR>, <VAR>function-body</VAR>, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>])</I>
<DD><A NAME="IDX406"></A>
<A NAME="IDX407"></A>
Этот макрос является устаревшей версией <CODE>AC_TRY_LINK</CODE>.  Он
отличается тем, что выдает сообщение <SAMP>`checking for
<VAR>echo-text</VAR>'</SAMP> в поток стандартного вывода, в том случае, если аргумент
<VAR>echo-text</VAR> не является пустым.  Вместо этого макроса для выдачи
сообщений используйте <CODE>AC_MSG_CHECKING</CODE> и <CODE>AC_MSG_RESULT</CODE>
(see section <A HREF="autoconf-ru_6.html#SEC58">Выдача сообщений</A>).
</DL>




<H2><A NAME="SEC44" HREF="autoconf-ru_toc.html#TOC44">Проверка поведения во время выполнения</A></H2>
<P>
@anchor{Run Time}


<P>
Иногда вам необходимо определить, как система работает во время
выполнения программы, например, имеет ли заданная функция определенные
возможности или ошибки.  Старайтесь выполнять такие проверки
непосредственно во время выполнения программы, а не во время
конфигурирования.   Такие вещи, как расположение байтов в памяти машины
также следует проверять при
инициализации программы.


<P>
Если вам действительно необходимо протестировать поведение программы во
время выполнения при конфигурировании, то вы можете написать тестовую программу
для определения результатов, откомпилировать и запустить ее с помощью
макроса <CODE>AC_TRY_RUN</CODE>.  Если возможно, избегайте запуска тестовых программ,
поскольку их использование мешает пользователям
настраивать ваш пакет для кросс-компиляции.




<H3><A NAME="SEC45" HREF="autoconf-ru_toc.html#TOC45">Запуск тестовых программ</A></H3>
<P>
@anchor{Test Programs}


<P>
Используйте нижеописанный макрос, если вам нужно при конфигурировании
протестировать поведение системы во время исполнения.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TRY_RUN</B> <I>(<VAR>program</VAR>, [<VAR>action-if-true</VAR> [, <VAR>action-if-false</VAR> [, <VAR>action-if-cross-compiling</VAR>]]])</I>
<DD><A NAME="IDX408"></A>
<A NAME="IDX409"></A>
Аргумент <VAR>program</VAR> является текстом программы на языке C, для
которой выполняются подстановки переменных командного процессора, а
также обратных кавычек и обратных слэшей. Если она компилируется и
компонуется, и при выполнении возвращает код завершения 0, то
выполняется код командного процессора <VAR>action-if-true</VAR>. В противном
случае выполняются команды <VAR>action-if-false</VAR>; код завершения
тестовой программы доступен в переменной командного процессора
<SAMP>`$?'</SAMP>. При компиляции этот макрос использует переменные
<CODE>CFLAGS</CODE> или <CODE>CXXFLAGS</CODE>, <CODE>CPPFLAGS</CODE>, <CODE>LDFLAGS</CODE> и
<CODE>LIBS</CODE>.


<P>
Если используемый компилятор C не создает исполняемых файлов, которые
запускаются на той же системе, где выполняется скрипт <CODE>configure</CODE>, то
тестовая программа не запускается. Если задан аргумент
<VAR>action-if-cross-compiling</VAR>, то вместо программы запускается код,
заданный в этом аргументе.  В противном случае <CODE>configure</CODE>
выдает сообщение об ошибке и прекращает работу.
</DL>


<P>
Постарайтесь сделать значения по умолчанию пессимистическими, если
кросс-компиляция не позволяет проверить поведение времени выполнения.
Это можно сделать, передав макросу <CODE>AC_TRY_RUN</CODE> необязательный
последний аргумент.  <CODE>autoconf</CODE> выдает предупреждающее
сообщение при создании <CODE>configure</CODE> каждый раз, когда встречается
вызов макроса <CODE>AC_TRY_RUN</CODE> с незаданным аргументом
<VAR>action-if-cross-compiling</VAR>. Вы можете игнорировать это
предупреждение, хотя пользователи не смогут настроить ваш пакет для
кросс-компиляции. Несколько макросов, поставляемых в составе Autoconf,
выдают это предупреждающее сообщение.


<P>
Для конфигурирования для кросс-компиляции вы также можете выбрать значения
параметров, основываясь на каноническом имени системы (see section <A HREF="autoconf-ru_8.html#SEC67">Ручная настройка</A>). В качестве альтернативы, вы можете установить правильное
значение для целевой системы в кэш-файле с результатами тестов
(see section <A HREF="autoconf-ru_6.html#SEC55">Кэширование результатов</A>).


<P>
Для задания значений по умолчанию для вызовов макроса <CODE>AC_TRY_RUN</CODE>,
которые включены в другие макросы (включая те, которые поставляются с
Autoconf), вы можете вызвать макрос <CODE>AC_PROG_CC</CODE> до их вызова.
Затем, если переменная командного процессора <CODE>cross_compiling</CODE>
имеет значение <SAMP>`yes'</SAMP>, то используется альтернативный метод для
получения результатов, вместо вызова макросов.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_CROSS</B>
<DD><A NAME="IDX410"></A>
<A NAME="IDX411"></A>
Этот макрос является устаревшим; он ничего не делает.
</DL>




<H3><A NAME="SEC46" HREF="autoconf-ru_toc.html#TOC46">Рекомендации по написанию тестовых программ</A></H3>
<P>
@anchor{Guidelines}


<P>
Тестовые программы не должны выдавать никаких сообщений на  поток стандартного
вывода.  Они должны возвращать значение 0 в случае удачи и ненулевое
значение --- в противном случае, так что удачное выполнение можно легко отличить
от выдачи дампа при крахе программы или другого неудачного
выполнения; нарушение доступа к памяти и другие сбои возвращают
ненулевой статус завершения. Тестовые программы должны завершать работу
с помощью вызова функции <CODE>exit</CODE>, а не с помощью оператора
<CODE>return</CODE> из подпрограммы <CODE>main</CODE>, поскольку на некоторых
системах (по крайней мере, на старых машинах Sun) в подпрограмме
<CODE>main</CODE> игнорируется аргумент оператора <CODE>return</CODE>.


<P>
Тестовые программы могут использовать директивы <CODE>#if</CODE> или
<CODE>#ifdef</CODE> для проверки значений макросов препроцессора, определенных
уже проведенными тестами. Например, если вы вызовете
<CODE>AC_HEADER_STDC</CODE>, то далее в <TT>`configure.in'</TT> можно
использовать тестовую программу, которая в зависимости от условия
включает заголовочные файлы ANSI C:



<PRE>
#if STDC_HEADERS
# include &#60;stdlib.h&#62;
#endif
</PRE>

<P>
Если тестовой программе нужно использовать или создать файл
данных, то задавайте этому файлу имя, которое начинаются с
<TT>`conftest'</TT>, например, <TT>`conftestdata'</TT>.  Скрипт <CODE>configure</CODE> 
после выполнения тестовых программ а также в случае прерывания работы
скрипта 
удаляет эти файлы с помощью команды <SAMP>`rm -rf conftest*'</SAMP>.




<H3><A NAME="SEC47" HREF="autoconf-ru_toc.html#TOC47">Тестовые функции</A></H3>
<P>
@anchor{Test Functions}


<P>
Объявления функций в тестовой программе должны быть с помощью условной
компиляции объявлены как для компилятора C++, так и для компилятора C. 
На практике, однако, тестовые программы
редко нуждаются в функциях, которым передаются аргументы.



<PRE>
#ifdef __cplusplus
foo(int i)
#else
foo(i) int i;
#endif
</PRE>

<P>
Функции, которые объявляются в тестовых программах, должны быть также
объявлены с применением прототипов <SAMP>`extern "C"'</SAMP>, для использования
с компиляторами C++.  Убедитесь, что вы не включаете заголовочные файлы, содержащие
конфликтующие прототипы.



<PRE>
#ifdef __cplusplus
extern "C" void *malloc(size_t);
#else
char *malloc();
#endif
</PRE>

<P>
Если тестовая программа вызывает функцию с неправильными параметрами
(просто чтобы убедиться, что такая существует), то организуйте
программу таким образом, чтобы эта функция никогда не была вызвана.  Это
можно сделать путем вызова ее в другой функции, которая никогда не
вызывается.  Вы не можете сделать это, поместив вызов функции после
вызова функции <CODE>exit</CODE>, поскольку GCC версии 2 знает о том, что
функция <CODE>exit</CODE> никогда не возвращается в точку вызова, и оптимизирует
любой код, который следует за ней в том же блоке.


<P>
Если вы включаете какой-либо заголовочный файл, то убедитесь, что
функции, находящиеся в этих файлах, вызываются с правильным числом
параметров, даже если все эти параметры равны нулю.  Это нужно, чтобы
избежать ошибок компиляции из-за
несоответствия прототипов. GCC версии 2 имеет внутренние прототипы
нескольких функций, которые он встраивает в код автоматически; например, 
к таким относится
<CODE>memcpy</CODE>. Для того, чтобы избежать ошибок при их проверке, либо
передавайте этим функциям правильное количество аргументов, либо
повторно объявите эти функции с другим типом возвращаемого значения
(например, как <CODE>char</CODE>).




<H2><A NAME="SEC48" HREF="autoconf-ru_toc.html#TOC48">Переносимое программирование на языке командного процессора</A></H2>
<P>
@anchor{Portable Shell}


<P>
Есть определенные техники программирования скриптов командного
процессора, которых вам следует избегать, чтобы ваш код был переносим.  
Bourne shell и совместимые с ним процессора, такие как Bash и Korn,
развивались в течении многих лет, но для того, чтобы избежать
трудностей, не используйте возможностей, которые были добавлены после
выпуска UNIX версии 7, примерно в 1977 году.  Вы не должны использовать
функции командного процессора, псевдонимы (aliases), отрицательные классы
символов и другие возможности, которые присутствуют не во всех версиях
командных процессоров, совместимых с процессором Bourne; ограничьте себя
общим знаменателем. Даже <CODE>unset</CODE> не поддерживается всеми командными
процессорами! При указании интерпретатора ставьте пробел после символов
<SAMP>`#!'</SAMP>, например,



<PRE>
#! /usr/bin/perl
</PRE>

<P>
Если вы уберете пробел перед путевым именем, то системы типа
4.2BSD, такие как Sequent DYNIX, будут просто игнорировать эту строку,
поскольку они интерпретируют <SAMP>`#! /'</SAMP> как 4-х байтовое магическое
число.


<P>
Набор внешних программ, которые можно запускать из скрипта
<CODE>configure</CODE>, довольно мал.  See section `Utilities in Makefiles' in <CITE>GNU Coding Standards</CITE>,
ниже приведен список этих программ.
Это ограничение позволяет пользователям начать с небольшого количества
программ, постепенно компилируя остальные, и избежать слишком большого
числа зависимостей между пакетами.


<P>
Многие такие внешние утилиты обладают общим подмножеством переносимых
возможностей;
например, не полагайтесь на то, что команда <CODE>ln</CODE> имеет ключ
<SAMP>`-f'</SAMP>, а <CODE>cat</CODE> вообще имеет какие-либо ключи.  Скрипты <CODE>sed</CODE> не
должны содержать комментариев или использовать метки длиннее 8
символов. Не используйте <SAMP>`grep -s'</SAMP> для запрещения вывода, поскольку
<SAMP>`grep -s'</SAMP> на System V не запрещает вывод, а запрещает только
сообщения об ошибках. Вместо этого ключа лучше перенаправьте стандартные
потоки вывода и сообщений об ошибках (сообщения о несуществующих файлах)
программы <CODE>grep</CODE> на устройство <TT>`/dev/null'</TT>. Проверяйте код
возврата <CODE>grep</CODE>, чтобы узнать, произошло ли совпадение.




<H2><A NAME="SEC49" HREF="autoconf-ru_toc.html#TOC49">Тестирование значений и файлов</A></H2>
<P>
@anchor{Testing Values and Files}


<P>
Скрипты <CODE>configure</CODE> должны проверять различные свойства разных
файлов и строк.  Вот небольшой список проблем с переносимостью, которых
нужно избегать при написании проверок.


<P>
Программа <CODE>test</CODE> используется для выполнения многих проверок файлов
и строк. Она часто запускается альтернативным способом, через имя
<SAMP>`['</SAMP>, но использование этого имени в коде Autoconf приведет к
ошибкам, потому что этот символ является символом кавычек в <CODE>m4</CODE>.


<P>
Если вам необходимо выполнить несколько проверок, используя команду
<CODE>test</CODE>, то объединяйте их с помощью операторов командного
процессора <SAMP>`&#38;&#38;'</SAMP> и <SAMP>`||'</SAMP>, а не используйте операторы программы
<CODE>test</CODE> <SAMP>`-a'</SAMP> и <SAMP>`-o'</SAMP>. На System V приоритеты операторов
<SAMP>`-a'</SAMP> и <SAMP>`-o'</SAMP> неправильно соотносятся с приоритетами унарных
операторов; из-за этого POSIX не определяет эти операторы, так что их использование
приводит к непереносимому коду.  Если вы в одном выражении используете как
<SAMP>`&#38;&#38;'</SAMP>, так и <SAMP>`||'</SAMP>, то помните, что они имеют одинаковый
приоритет.


<P>
Скрипты <CODE>configure</CODE>, поддерживающие
кросс-компиляцию, не должны не делать ничего, что тестирует свойства
системы, на которой выполняется скрипт.  Но иногда вам может понадобиться
проверить, существует ли определенный файл. Чтобы сделать это
используйте команды <SAMP>`test -f'</SAMP> или <SAMP>`test -r'</SAMP>. Не используйте
команду <SAMP>`test -x'</SAMP>, поскольку 4.3BSD не поддерживает ее.


<P>
Другой непереносимой конструкцией программирования командного процессора
является



<PRE>
<VAR>var</VAR>=${<VAR>var</VAR>:-<VAR>value</VAR>}
</PRE>

<P>


<P>
Она предназначена для установки значения переменной <VAR>var</VAR> равным
<VAR>value</VAR>, но только в тех случаях, когда переменная еще не имеет
значения.  Если <VAR>var</VAR> уже было присвоено значение, даже равное
пустой строке, то оно остается неизменным.  Старые командные процессоры
BSD, включая Ultrix-версию <CODE>sh</CODE>, не воспринимают символ двоеточия,
выдают ошибку и прекращают работу. Переносимым эквивалентом данной
конструкции является



<PRE>
: ${<VAR>var</VAR>=<VAR>value</VAR>}
</PRE>



<H2><A NAME="SEC50" HREF="autoconf-ru_toc.html#TOC50">Множество вариантов</A></H2>
<P>
@anchor{Multiple Cases}


<P>
Некоторые операции выполняются несколькими разными способами в зависимости от
используемого варианта UNIX.  Их проверка требует "оператора выбора".
Autoconf напрямую не обеспечивает такой оператор, однако достаточно
легко эмулировать его, используя переменную командного
процессора для запоминания, найден ли уже пригодный способ.


<P>
Вот пример, который использует переменную <CODE>fstype</CODE> для отслеживания
того, остались ли варианты, которые необходимо проверить.



<PRE>
AC_MSG_CHECKING(как получить тип файловой системы)
fstype=no
# Порядок этих действий является важным.
AC_TRY_CPP([#include &#60;sys/statvfs.h&#62;
#include &#60;sys/fstyp.h&#62;], AC_DEFINE(FSTYPE_STATVFS) fstype=SVR4)
if test $fstype = no; then
AC_TRY_CPP([#include &#60;sys/statfs.h&#62;
#include &#60;sys/fstyp.h&#62;], AC_DEFINE(FSTYPE_USG_STATFS) fstype=SVR3)
fi
if test $fstype = no; then
AC_TRY_CPP([#include &#60;sys/statfs.h&#62;
#include &#60;sys/vmount.h&#62;], AC_DEFINE(FSTYPE_AIX_STATFS) fstype=AIX)
fi
# (остальные варианты пропущены в этом примере)
AC_MSG_RESULT($fstype)
</PRE>



<H2><A NAME="SEC51" HREF="autoconf-ru_toc.html#TOC51">Выбор языка</A></H2>
<P>
@anchor{Language Choice}


<P>
Пакеты, использующие одновременно и C, и C++, нуждаются в проверке
возможностей обоих компиляторов. Созданные Autoconf скрипты
<CODE>configure</CODE> по умолчанию выполняют проверку возможностей
компилятора C.  Нижеописанные макросы определяют, компилятор какого языка
будет использоваться в тестах, которые последуют за вызовом этого макроса в
<TT>`configure.in'</TT>.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_LANG_C</B>
<DD><A NAME="IDX412"></A>
<A NAME="IDX413"></A>
Выполняет тесты компиляции, используя переменные <CODE>CC</CODE> и <CODE>CPP</CODE>, 
а также используя расширение <TT>`.c'</TT> для тестовых программ.  Устанавливает
переменную командного процессора <CODE>cross_compiling</CODE> в значение,
вычисленное макросом <CODE>AC_PROG_CC</CODE>, если он был запущен, и в пустое
значение в противном случае.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_LANG_CPLUSPLUS</B>
<DD><A NAME="IDX414"></A>
<A NAME="IDX415"></A>
Выполняет тесты компиляции, используя переменные <CODE>CXX</CODE> и
<CODE>CXXPP</CODE>, а также используя расширение <TT>`.C'</TT> для тестовых
программ. Устанавливает переменную командного процессора
<CODE>cross_compiling</CODE> в значение, вычисленное макросом
<CODE>AC_PROG_CXX</CODE>, если он был запущен, и в пустое значение в противном
случае.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_LANG_FORTRAN77</B>
<DD><A NAME="IDX416"></A>
<A NAME="IDX417"></A>
Выполняет тесты компиляции, используя переменную <CODE>F77</CODE>, а также используя
расширение <TT>`.f'</TT> для тестовых программ. Устанавливает переменную
командного процессора <CODE>cross_compiling</CODE> в значение, вычисленное
макросом <CODE>AC_PROG_F77</CODE>, если он был запущен, и в пустое значение в
противном случае.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_LANG_SAVE</B>
<DD><A NAME="IDX418"></A>
<A NAME="IDX419"></A>
Запоминает в стеке значение текущего языка (установленное макросами
<CODE>AC_LANG_C</CODE>, <CODE>AC_LANG_CPLUSPLUS</CODE> или
<CODE>AC_LANG_FORTRAN77</CODE>).  Не изменяет значение текущего
языка. Используйте этот макрос и <CODE>AC_LANG_RESTORE</CODE> в макросах,
которым необходимо временно переключиться на конкретный язык.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_LANG_RESTORE</B>
<DD><A NAME="IDX420"></A>
<A NAME="IDX421"></A>
Выбирает язык, который был сохранен на вершине стека, где он был
сохранен макросом <CODE>AC_LANG_SAVE</CODE>, и удаляет его со стека. Этот
макрос эквивалентен вызову <CODE>AC_LANG_C</CODE>,
<CODE>AC_LANG_CPLUSPLUS</CODE> или <CODE>AC_LANG_FORTRAN77</CODE>, в зависимости от
того, который из них действовал во время последнего вызова
макроса <CODE>AC_LANG_SAVE</CODE>.


<P>
Не вызывайте этот макрос больше раз, чем было вызовов
<CODE>AC_LANG_SAVE</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_REQUIRE_CPP</B>
<DD><A NAME="IDX422"></A>
<A NAME="IDX423"></A>
Убеждается, что препроцессор, который должен сейчас использоваться, был
найден. Вызывает макрос <CODE>AC_REQUIRE</CODE> (see section <A HREF="autoconf-ru_7.html#SEC64">Требуемые макросы</A>)
с аргументом, равным либо <CODE>AC_PROG_CPP</CODE>, либо
<CODE>AC_PROG_CXXCPP</CODE>, в зависимости от того, какой язык был выбран.
</DL>


<P><HR><P>
Go to the <A HREF="autoconf-ru_1.html">first</A>, <A HREF="autoconf-ru_4.html">previous</A>, <A HREF="autoconf-ru_6.html">next</A>, <A HREF="autoconf-ru_19.html">last</A> section, <A HREF="autoconf-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
