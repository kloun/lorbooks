<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from bison.texi on June, 7  2003 -->

<TITLE>Bison 1.35 - 5. Интерфейс анализатора на C</TITLE>
</HEAD>
<BODY >
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_6.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_8.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC68">5. Интерфейс анализатора на C</A></H1>
<P>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>


<P>
Анализатор Bison -- это на самом деле функция на C, называющаяся
<CODE>yyparse</CODE>.  Здесь мы опишем соглашения по интерфейсу <CODE>yyparse</CODE> и
других необходимых ей функций.


<P>
Имейте в виду, что для своих внутренних целей анализатор использует множество
идентификаторов C, начинающихся с <SAMP>`yy'</SAMP> и <SAMP>`YY'</SAMP>.  Если вы используете
такой идентификатор (кроме тех, что описаны в настоящем руководстве) в действии
или дополнительном коде на C в файле грамматики, вероятно, вы столкнётесь с
неприятностями.




<H2><A NAME="SEC69">5.1 Функция анализатора <CODE>yyparse</CODE></A></H2>
<P>
<A NAME="IDX151"></A>


<P>
Вы вызываете функцию <CODE>yyparse</CODE> для запуска анализа.  Эта функция читает
лексемы, выполняет действия, и в конце концов завершает работу, когда встречает
конец входного текста или сталкивается с невосстановимой синтаксической
ошибкой.  Вы можете также написать действие, которое укажет <CODE>yyparse</CODE>
завершить работу немедленно, без продолжения чтения.


<P>
Если разбор завершён успешно (возврат вызван концом входного текста),
<CODE>yyparse</CODE> возвращает значение 0.


<P>
Значение 1 возвращается, если разбор не удался (возврат вызван синтаксической
ошибкой).


<P>
В действии вы можете потребовать немедленного возврата из <CODE>yyparse</CODE>,
используя следующие макросы:


<DL COMPACT>

<DT><CODE>YYACCEPT</CODE>
<DD>
<A NAME="IDX152"></A>
Немедленный возврат со значением 0 (сообщение об удачном разборе).

<DT><CODE>YYABORT</CODE>
<DD>
<A NAME="IDX153"></A>
Немедленный возврат со значением 1 (сообщение об ошибке).
</DL>



<H2><A NAME="SEC70">5.2 Функция лексического анализатора <CODE>yylex</CODE></A></H2>
<P>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>


<P>
Функция <EM>лексического анализатора</EM> <CODE>yylex</CODE> распознаёт лексемы во
входном потоке и передаёт их анализатору.  Bison не создаёт эту функцию
автоматически, вы должны написать её так, чтобы <CODE>yyparse</CODE> могла
вызывать её.  Эту функцию иногда называют лексическим сканером.


<P>
В простых программах <CODE>yylex</CODE> часто определяется в конце файла грамматики
Bison.  Если <CODE>yylex</CODE> определена в отдельном исходном файле, вам нужно
сделать доступными там макроопределения типов лексем.  Для этого используйте
параметр <SAMP>`-d'</SAMP> при запуске Bison, чтобы он записал эти макроопределения
в отдельный файл заголовка <TT>`<VAR>имя</VAR>.tab.h'</TT>, который вы можете включить
в другие исходные файлы, которым он нужен.  См. раздел <A HREF="bison_12.html#SEC96">10. Вызов Bison</A>.




<H3><A NAME="SEC71">5.2.1 Соглашения о вызове <CODE>yylex</CODE></A></H3>

<P>
Значение, возвращаемое <CODE>yylex</CODE> должно быть числовым кодом типа только что
встреченной лексемы, или 0 для обозначени конца входного текста.


<P>
Если в правилах грамматики на лексему ссылаются по имени, это имя становится
в файле анализатора макросом C, определением которого будет числовой код,
соответствующий этому типу лексемы.  Таким образом, <CODE>yylex</CODE> может
использовать для обозначения типа это имя.  См. раздел <A HREF="bison_6.html#SEC45">4.2 Символы, терминальные и нетерминальные</A>. 


<P>
Если в правилах грамматики на лексему ссылаются с помощью однолитерной
константы, числовой код этой литеры также является кодом типа лексемы.  Таким
образом <CODE>yylex</CODE> может просто вернуть код этой литеры.  Нулевая литера
не должна использоваться таким образом, потому что её код -- ноль, означающий
конец входного текста.


<P>
Приведём пример, иллюстрирующий это:



<PRE>
int
yylex (void)
{
  ...
  if (c == EOF)     /* Проверка конца файла. */
    return 0;
  ...
  if (c == '+' || c == '-')
    return c;      /* Полагаем, что тип лексемы `+' -- '+'. */
  ...
  return INT;      /* Вернуть тип лексемы. */
  ...
}
</PRE>

<P>
Этот интерфейс разрабатывался так, чтобы выход утилиты <CODE>lex</CODE> мог быть
без изменений использован как определение <CODE>yylex</CODE>.


<P>
Если грамматика использует строковые лексемы, есть два способа, которыми
<CODE>yylex</CODE> может определить коды их типов лексем:



<UL>
<LI>

Если грамматика определяет символические имена лексем как псевдонимы строковых
лексем, <CODE>yylex</CODE> может использовать эти символические имена как и все
остальные.  В этом случае использование  строковых лексем в файле грамматики
не окажет влияния на <CODE>yylex</CODE>.

<LI>

<CODE>yylex</CODE> может найти многолитерную лексему в таблице <CODE>yytname</CODE>.
Индекс лексемы в этой таблице -- это код типа лексемы. Имя многолитерной
лексемы записывается в <CODE>yytname</CODE> в виде: двойная кавычка, литеры лексемы,
вторая двойная кавычка.  Литеры лексемы никаким образом не экранируются, они
дословно переносятся в содержимое строки в таблице.

Приведём код поиска лексемы в <CODE>yytname</CODE>, полагая, что литеры лексемы
находятся в массиве <CODE>token_buffer</CODE>.


<PRE>
for (i = 0; i &#60; YYNTOKENS; i++)
  {
    if (yytname[i] != 0
        &#38;&#38; yytname[i][0] == '"'
        &#38;&#38; strncmp (yytname[i] + 1, token_buffer,
                    strlen (token_buffer))
        &#38;&#38; yytname[i][strlen (token_buffer) + 1] == '"'
        &#38;&#38; yytname[i][strlen (token_buffer) + 2] == 0)
      break;
  }
</PRE>

Таблица <CODE>yytname</CODE> создаётся только если вы используете объявление
<CODE>%token_table</CODE>.  См. раздел <A HREF="bison_6.html#SEC66">4.7.8 Обзор объявлений Bison</A>.
</UL>



<H3><A NAME="SEC72">5.2.2 Семантические значения лексем</A></H3>

<P>
<A NAME="IDX156"></A>
В обычном (не повторно входимом) анализаторе семантические значения лексем
должны помещаться в глобальную переменную <CODE>yylval</CODE>.  Если вы используете
единственный тип данных для семантических значений, <CODE>yylval</CODE> имеет этот
тип.  Так, если этот тип <CODE>int</CODE> (по умолчанию), вы можете написать в
<CODE>yylex</CODE>:



<PRE>
  ...
  yylval = value;  /* Поместить значение на вершину стека Bison. */
  return INT;      /* Вернуть тип лексемы. */
  ...
</PRE>

<P>
Если вы используете множественные типы данных, тип <CODE>yylval</CODE> -- объединение
типов, полученное из объявления <CODE>%union</CODE> (см. раздел <A HREF="bison_6.html#SEC61">4.7.3 Набор типов значений</A>).  Так, если вы сохраняете значение лексемы, вы должны
использовать правильный элемент объединения.  Если объявление <CODE>%union</CODE>
выглядит так:



<PRE>
%union {
  int intval;
  double val;
  symrec *tptr;
}
</PRE>

<P>
то код в <CODE>yylex</CODE> может выглядеть так:



<PRE>
  ...
  yylval.intval = value; /* Поместить значение на вершину */
                         /* стека Bison. */
  return INT;          /* Вернуть тип лексемы. */
  ...
</PRE>



<H3><A NAME="SEC73">5.2.3 Позиции лексем в тексте</A></H3>

<P>
<A NAME="IDX157"></A>
Если вы используете в действиях <SAMP>`@<VAR>n</VAR>'</SAMP>-свойства (см. раздел <A HREF="bison_6.html#SEC54">4.6 Отслеживание положений</A>) для отслеживания положений лексем и групп в тексте,
ваша функция <CODE>yylex</CODE> должна предоставить эту информацию.  Функция
<CODE>yyparse</CODE> ожидает, что положение только что разобранной лексемы в тексте
находится в глобальной переменной <CODE>yylloc</CODE>. Таким образом, <CODE>yylex</CODE>
должна поместить в эту переменную правильные данные.


<P>
По умолчанию значение <CODE>yylloc</CODE> -- это структура, и вам нужно только
проинициализировать её элементы, которые вы собираетесь использовать в
действиях.  Эти четыре элемента называются, <CODE>first_line</CODE>,
<CODE>first_column</CODE>, <CODE>last_line</CODE> и <CODE>last_column</CODE>.  Отметим, что
использование этих свойств делает анализатор заметно более медленным.


<P>
<A NAME="IDX158"></A>
Тип данных <CODE>yylloc</CODE> называется <CODE>YYLTYPE</CODE>.




<H3><A NAME="SEC74">5.2.4 Соглашения о вызове для чистых анализаторов</A></H3>

<P>
Если вы используете объявление Bison <CODE>%pure_parser</CODE>, требующее создания
чистого, повторно входимого анализатора, глобальные переменные взаимодействия
<CODE>yylval</CODE> и <CODE>yylloc</CODE> использовать нельзя (см. раздел <A HREF="bison_6.html#SEC65">4.7.7 Чистый (повторно входимый) анализатор</A>).  В таких
анализаторах эти две глобальные переменные замещаются указателями,
передаваемыми в качестве аргументов функции <CODE>yylex</CODE>.  Вы должны объявить
их, как здесь показано, и передавать информацию назад, помещая её по этим
указателям.



<PRE>
int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  ...
  *lvalp = value;  /* Поместить значение на вершину стека Bison.  */
  return INT;      /* Вернуть тип лексемы.  */
  ...
}
</PRE>

<P>
Если файл грамматики не использует конструкции <SAMP>`@'</SAMP> для ссылок на позиции
в тексте, тип <CODE>YYLTYPE</CODE> не будет определён.  В этом случае опустите второй
аргумент, <CODE>yylex</CODE> будет вызываться только с одним аргументом.


<P>
<A NAME="IDX159"></A>
Если вы используете повторно входимый анализатор, вы можете (необязательно)
передавать ему информацию о дополнительных параметрах повторно входимым
способом.  Для этого определите макрос <CODE>YYPARSE_PARAM</CODE> как имя переменной.
Это изменит функцию <CODE>yyparse</CODE> чтобы она принимала один аргумент с этим
именем типа <CODE>void *</CODE>.


<P>
При вызове <CODE>yyparse</CODE> передайте адрес объекта, приведя его к типу
<CODE>void *</CODE>.  Действия грамматики могут ссылаться на сожержимое объекта,
приводя значение указателя обратно к его правильному типу, и затем
разыменовывая его.  Приведём пример.  Напишите в анализаторе:



<PRE>
%{
struct parser_control
{
  int nastiness;
  int randomness;
};

#define YYPARSE_PARAM parm
%}
</PRE>

<P>
Затем вызовите анализатор следующим образом:



<PRE>
struct parser_control
{
  int nastiness;
  int randomness;
};

...

{
  struct parser_control foo;
  ...  /* Поместить правильные данные в <CODE>foo</CODE>.  */
  value = yyparse ((void *) &#38;foo);
  ...
}
</PRE>

<P>
В действиях грамматики используйте для обращения к данным выражения наподобие
следующего:



<PRE>
((struct parser_control *) parm)-&#62;randomness
</PRE>

<P>
<A NAME="IDX160"></A>
Если вы хотите передать данные дополнительных параметров функции <CODE>yylex</CODE>,
определите макрос <CODE>YYLEX_PARAM</CODE> тем же способом, что и для
<CODE>YYPARSE_PARAM</CODE>, как показано ниже:



<PRE>
%{
struct parser_control
{
  int nastiness;
  int randomness;
};

#define YYPARSE_PARAM parm
#define YYLEX_PARAM parm
%}
</PRE>

<P>
Затем вам следует определить <CODE>yylex</CODE>, чтобы она принимала дополнительный
аргумент -- значение <CODE>parm</CODE> (всего будет два или три аргумента, в
зависимости от того, передаётся ли аргумент типа <CODE>YYLTYPE</CODE>).  Вы можете
объявить аргумент как указатель на правильный тип объекта, или же объявить его
как <CODE>void *</CODE> и получать доступ к содержимому как показано выше.


<P>
Вы можете использовать <SAMP>`%pure_parser'</SAMP> и потребовать создания повторно
входимого анализатора, не используя при этом <CODE>YYPARSE_PARAM</CODE>.  Тогда
вам следует вызывать <CODE>yyparse</CODE> без аргументов, как обычно.




<H2><A NAME="SEC75">5.3 Функция сообщения об ошибках <CODE>yyerror</CODE></A></H2>
<P>
<A NAME="IDX161"></A>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>


<P>
Анализатор Bison обнаруживает <EM>ошибку разбора</EM> или <EM>синтаксическую
ошибку</EM> каждый раз, когда читает лексему, которая не может удовлетворять
никакому синтаксическому правилу.  Действие в грамматике может также явно
сообщить об ошибке, используя макрос <CODE>YYERROR</CODE> (см. раздел <A HREF="bison_7.html#SEC76">5.4 Специальные возможности, используемые в действиях</A>).


<P>
Анализатор Bison рассчитывает сообщить об ошибке, вызывая функцию сообщения
об ошибке <CODE>yyerror</CODE>, которую должны предоставить вы.  Она вызывается
функцией <CODE>yyparse</CODE> каждый раз при обнаружении синтаксической ошибки,
и принимает один аргумент.  В случае ошибки разбора это обычно строка 
<CODE>"parse error"</CODE>.


<P>
<A NAME="IDX166"></A>
Если вы определите макрос <CODE>YYERROR_VERBOSE</CODE> в секции объявлений Bison
(см. раздел <A HREF="bison_6.html#SEC42">4.1.2 Секция объявлений Bison</A>), Bison будет давать
более подробные и обстоятельные строки сообщений об ошибках, вместо обычного
<CODE>"parse error"</CODE>.  Не имеет значения, какое определение вы используете
для <CODE>YYERROR_VERBOSE</CODE>, только то, определили ли вы его.


<P>
Анализатор может обнаружить ещё один тип ошибки -- переполнение стека.  Это
происходит, когда входной текст содержит конструкции слишком большой глубины
вложенности.  Маловероятно, что вы столкнётесь с этим, поскольку анализатор
Bison расширяет свой стек автоматически до очень больших пределов.  Но если
переполнение всё же происходит, <CODE>yyparse</CODE> вызывает обычным образом
<CODE>yyerror</CODE>, за исключением того, что аргументом будет строка
<CODE>"parser stack overflow"</CODE>.


<P>
Следующего определения достаточно для простых программ:



<PRE>
void
yyerror (char *s)
{
  fprintf (stderr, "%s\n", s);
}
</PRE>

<P>
После возвращения из <CODE>yyerror</CODE> в <CODE>yyparse</CODE> последняя попытается
произвести восстановление после ошибки, если в грамматике вы написали
подходящие правила восстановления после ошибок (см. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>).  Если восстановление невозможно, <CODE>yyparse</CODE> немедленно завершит
работу, вернув 1.


<P>
<A NAME="IDX167"></A>
Переменная <CODE>yynerrs</CODE> содержит число обнаруженных до сих пор синтаксических
ошибок.  Обычно эта переменная глобальная, но если вы требуете создания
чистого анализатора (см. раздел <A HREF="bison_6.html#SEC65">4.7.7 Чистый (повторно входимый) анализатор</A>), это локальная переменная, к которой могут иметь доступ
только действия.




<H2><A NAME="SEC76">5.4 Специальные возможности, используемые в действиях</A></H2>
<P>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>


<P>
Ниже представлена таблица конструкций Bison, переменных и макросов, которые
могут быть полезны в действиях.


<DL COMPACT>

<DT><SAMP>`$$'</SAMP>
<DD>
Играет роль переменной, содержащей семантическое значение группы, собираемой
текущим правилом.  См. раздел <A HREF="bison_6.html#SEC51">4.5.3 Действия</A>.

<DT><SAMP>`$<VAR>n</VAR>'</SAMP>
<DD>
Играет роль переменной, содержащей семантическое значение <VAR>n</VAR>-го
компонента текущего правила.  См. раздел <A HREF="bison_6.html#SEC51">4.5.3 Действия</A>.

<DT><SAMP>`$&#60;<VAR>тип_альт</VAR>&#62;$'</SAMP>
<DD>
Аналогична <CODE>$$</CODE>, но задаёт альтернативу <VAR>тип_альт</VAR> в объединении,
заданном объявлением <CODE>%union</CODE>.  См. раздел <A HREF="bison_6.html#SEC52">4.5.4 Типы данных значений в действиях</A>.

<DT><SAMP>`$&#60;<VAR>тип_альт</VAR>&#62;<VAR>n</VAR>'</SAMP>
<DD>
Аналогична <CODE><VAR>n</VAR></CODE>, но задаёт альтернативу <VAR>тип_альт</VAR> в объединении,
заданном объявлением <CODE>%union</CODE>.  См. раздел <A HREF="bison_6.html#SEC52">4.5.4 Типы данных значений в действиях</A>.

<DT><SAMP>`YYABORT;'</SAMP>
<DD>
Немедленно завершает работу <CODE>yyparse</CODE>, сообщая об ошибке.
См. раздел <A HREF="bison_7.html#SEC69">5.1 Функция анализатора <CODE>yyparse</CODE></A>.

<DT><SAMP>`YYACCEPT;'</SAMP>
<DD>
Немедленно завершает работу <CODE>yyparse</CODE>, сообщая об удачном разборе.
См. раздел <A HREF="bison_7.html#SEC69">5.1 Функция анализатора <CODE>yyparse</CODE></A>.

<DT><SAMP>`YYBACKUP (<VAR>лексема</VAR>, <VAR>значение</VAR>);'</SAMP>
<DD>
<A NAME="IDX170"></A>
Отмена сдвига лексемы.  Этот макрос допустим только в правилах, которые
выполняют свёртку единственного значения, и только когда нет предпросмотренной
лексемы.  Он устанавливает для предпросмотренной лексемы тип <VAR>лексема</VAR> и
семантическое значение <VAR>значение</VAR>. Затем он отбрасывает значение, которое
должно быть свёрнуто по этому правилу.

Если макрос используется, когда его применение недопустимо, как например, когда
уже есть предпросмотренная лексема, он сообщает о синтаксической ошибке
сообщением <SAMP>`cannot back up'</SAMP> и производит обычное восстановление после
ошибки.

В любом случае оставшаяся часть правила не выполняется.

<DT><SAMP>`YYEMPTY'</SAMP>
<DD>
<A NAME="IDX171"></A>
Значение, помещаемое в <CODE>yychar</CODE>, когда там нет предпросмотренной лексемы.

<DT><SAMP>`YYERROR;'</SAMP>
<DD>
<A NAME="IDX172"></A>
Немедленно вызывает синтаксическую ошибку.  Этот оператор запускает
восстановление после ошибки, как если бы ошибку обнаружил сам анализатор,
и не выводит никакого сообщения.  Если вы хотите вывести сообщение об ошибке,
перед оператором <SAMP>`YYERROR;'</SAMP> вызовите явно <CODE>yyerror</CODE>.  
См. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>.

<DT><SAMP>`YYRECOVERING'</SAMP>
<DD>
Этот макрос заменяет выражение, имеющее значение 1 когда анализатор выполняет
восстановление после синтаксической ошибки, и 0 всё остальное время.
См. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>.

<DT><SAMP>`yychar'</SAMP>
<DD>
Переменная, содержащая текущую предпросмотренную лексему (в чистом анализаторе
это на самом деле локальная для <CODE>yyparse</CODE> переменная).  Когда
предпросмотренной лексемы нет, в неё помещается значение <CODE>YYEMPTY</CODE>.
См. раздел <A HREF="bison_8.html#SEC78">6.1 Предпросмотренные лексемы</A>.

<DT><SAMP>`yyclearin;'</SAMP>
<DD>
Отбросить текущую предпросмотренную лексему.  Это полезно, прежде всего, в
правилах обработки ошибок.  См. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>.

<DT><SAMP>`yyerrok;'</SAMP>
<DD>
Немедленно взобновляет создание сообщений об ошибках для последующих
синтаксических ошибок.  Это полезно, прежде всего, в правилах обработки
ошибок.  См. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>.

<DT><SAMP>`@$'</SAMP>
<DD>
<A NAME="IDX173"></A>
Играет роль структурной переменной, содержащей информацию о позиции в тексте
группы, создаваемой текущим правилом.  См. раздел <A HREF="bison_6.html#SEC54">4.6 Отслеживание положений</A>.

<DT><SAMP>`@<VAR>n</VAR>'</SAMP>
<DD>
<A NAME="IDX174"></A>
Играет роль структурной переменной, содержащей информацию о позиции в тексте
<VAR>n</VAR>-го компонента текущего правила.  См. раздел <A HREF="bison_6.html#SEC54">4.6 Отслеживание положений</A>.

</DL>

<P></P><HR>
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_6.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_8.html">Вперед</A>] &#160;

</BODY>
</HTML>
