<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from bison.texi on June, 7  2003 -->

<TITLE>Bison 1.35 - 7. Восстановление после ошибок</TITLE>
</HEAD>
<BODY >
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_8.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_10.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC90">7. Восстановление после ошибок</A></H1>
<P>
<A NAME="IDX214"></A>
<A NAME="IDX215"></A>


<P>
Обычно программа, заканчивающая работу при ошибке разбора, неприемлема.
Например, компилятору следует восстановиться настолько, чтобы разобрать остаток
входного текста и проверить наличие в ней ошибок, калькулятор должен обработать
следующее выражение.


<P>
В простом интерактивном анализаторе команд, где каждый вход -- одна строка,
может быть достаточно разрешить <CODE>yyparse</CODE> вернуть 1 при ошибке, а
вызывающей программе -- проигнорировать остаток входной строки, в которой она
произошла (и затем вызвать <CODE>yyparse</CODE> снова).  Но это не годится для
компилятора, потому что в этом случае он забудет весь синтаксический контекст,
приведший к ошибке.  Синтаксическая ошибка глубоко внутри функции во входном
тексте компилятора не должна заставлять компилятор рассматривать следующую
строку как начало исходного файла.


<P>
<A NAME="IDX216"></A>
Вы можете определять способ восстановления после синтаксической ошибки,
составляя правила, распознающие специальную лексему <CODE>error</CODE>.  Это
терминальный символ, который всегда определён (вам не нужно объявлять его)
и зарезервирован для обработки ошибок.  Анализатор Bison генерирует лексему
<CODE>error</CODE> каждый раз, когда обнаружена синтаксическая ошибка.  Если вы
предусмотрели правило для распознавания этой лексемы в текущем контексте,
разбор может быть продолжен.


<P>
Например:



<PRE>
stmnts:  /* пустая строка */
        | stmnts '\n'
        | stmnts exp '\n'
        | stmnts error '\n'
</PRE>

<P>
Четвёртое правило в этом примере говорит, что ошибка, за которой следует
переход на новую строку, является допустимым дополнением для любого
<CODE>stmnts</CODE>.


<P>
Что случится, если синтаксическая ошибка будет обнаружена внутри <CODE>exp</CODE>?
Правило восстановления после ошибки, если его интерпретировать строго,
применимо к последовательности, состоящей в точности из <CODE>stmnts</CODE>,
<CODE>error</CODE> и перехода на новую строку.  Если ошибка обнаружена внутри
<CODE>exp</CODE>, вероятно, в стеке после последнего <CODE>stmnts</CODE> будут находиться
некоторые дополнительные лексемы и подвыражения, а до литеры новой строки
нужно будет прочитать ещё несколько лексем.  Поэтому это правило обычным
способом неприменимо.


<P>
Но Bison может принудительно привести ситуацию к правилу, отбрасывая часть
семантического контекта и часть входного текста.  Во-первых, он отбрасывает
состояния и объекты в стеке до тех пор, пока не вернётся к правилу, в котором
приемлема лексема <CODE>error</CODE> (это означает, что уже разобранные подвыражения
будут отброшены, вплоть до последнего завершённого <CODE>stmnts</CODE>).  В этот
момент может быть выполнен сдвиг лексемы <CODE>error</CODE>.  Потом, если нельзя
выполнить сдвиг старой предпросмотренной лексемы, анализатор читает лексемы и
отбрасывает их до тех пор, пока не найдёт подходящую лексему.  В данном
примере, Bison читает и отбрасывает входной текст, пока не обнаружит литеру
новой строки, так что можно применить четвёртое правило.


<P>
Выбор правил грамматики для ошибок -- это выбор стратегии восстановления
после ошибки.  Простая и полезная стратегия -- при обнаружении ошибки просто
пропустить остаток текущей входной строки или текущего оператора.



<PRE>
stmnt: error ';'  /* при ошибке пропускать, пока не будет считана ';' */
</PRE>

<P>
Также полезно восстанавливать до закрывающего ограничителя, соответствующего
уже разобранному открывающему ограничителю.  В противном случае закрывающий
ограничитель, вероятно, оказался бы без пары, и вызвал новое, ложное сообщение
об ошибке.



<PRE>
primary:  '(' expr ')'
        | '(' error ')'
        ...
        ;
</PRE>

<P>
Стратегии восстановления после ошибки неизбежно связаны с догадками.  Когда
догадка неверна, одна синтаксическая ошибка часто приводит к появлению других.
В вышеприведённом примере, правило восстановления после ошибки предполагает,
что ошибка вызвана неправильным входным текстом внутри одного <CODE>stmnt</CODE>.
Предположим, что вместо этого внутрь правильного <CODE>stmnt</CODE> вставлена
точка с запятой.  После того, как правило восстановления после ошибки
произведёт восстановление от первой ошибки, сразу же будет обнаружена другая
синтаксическая ошибка, поскольку текст, следующий за лишней точкой с запятой
также не является верным <CODE>stmnt</CODE>.


<P>
Чтобы предотвратить поток сообщений об ошибках, анализатор не будет выводить
сообщения об ошибках, произошедших вскоре после первой. Возобновит он их вывод
только после того, как будет успешно произведён сдвиг трёх лексем подряд.


<P>
Имейте в виду, что правила, принимающие лексему <CODE>error</CODE>, могут
содержать действия, так же как и любые другие правила.


<P>
<A NAME="IDX217"></A>
Вы можете возобновить вывод сообщений об ошибках немедленно, используя в
действиях макрос <CODE>yyerrok</CODE>.  Если вы сделаете это в правиле действии
правила обработки ошибки, сообщения об ошибках не будут подавляться.  Этот
макрос не требует аргументов, <SAMP>`yyerrok;'</SAMP> -- это правильный оператор C.


<P>
<A NAME="IDX218"></A>
Сразу после обнаружения ошибки предыдущая предпросмотренная лексема
анализируется заново.  Если это невозможно, можно использовать макрос
<CODE>yyclearin</CODE> для очистки этой лексемы.  Напишите оператор <SAMP>`yyclearin;'</SAMP>
в действии правила обработки ошибки.


<P>
Например, предположим, что при ошибке разбора вызывается подпрограмма обработки
ошибки, продвигающаяся по входному потоку до некоторой точки, где разбор
снова может быть начат.  Предыдующая предпросмотренная лексема должна быть
отброшена с помощью <SAMP>`yyclearin;'</SAMP>.


<P>
<A NAME="IDX219"></A>
Макрос <CODE>YYRECOVERING</CODE> обозначает выражение, значение которого равно 1,
если анализатор производит восстановление после синтаксической ошибки, и 0
всё остальное время.  Значение 1 обозначает, что сообщеия о новых
синтаксических ошибках в данный момент подавляются.


<P></P><HR>
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_8.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_10.html">Вперед</A>] &#160;

</BODY>
</HTML>
