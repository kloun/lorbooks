<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from bison.texi on June, 7  2003 -->

<TITLE>Bison 1.35 - 8. Обработка контекстных зависимостей</TITLE>
</HEAD>
<BODY >
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_9.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_11.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC91">8. Обработка контекстных зависимостей</A></H1>

<P>
Основной принцип Bison в том, чтобы сначала разбираются лексемы, а затем они
группируются в более крупные синтаксические единицы.  Во многих языках значение
лексемы зависит от её контекста.  Хотя это и нарушает принципы Bison,
существуют определённые приёмы (известные как <EM>кладжи</EM>), которые дают вам
возможность писать анализаторы Bison для таких языков.


<P>
(На самом деле, "кладж" -- это всякий приём, который решает поставленную
задачу, но не является ни чистым, ни надёжным.)




<H2><A NAME="SEC92">8.1 Семантическая информация в типах лексем</A></H2>

<P>
Язык C содержит контекстную зависимость -- способ использования идентификаторов
зависит от его текущего смысла.  Например, рассмотрим:



<PRE>
foo (x);
</PRE>

<P>
Это выглядит как оператор вызова функции, но если <CODE>foo</CODE> -- имя определения
типа, то на самом деле это объявление <CODE>x</CODE>.  Как анализатор Bison для C
может решить, как разбирать такой входной текст?


<P>
В GNU C используется метод, состоящий в том, чтобы иметь два разных типа
лексем: <CODE>IDENTIFIER</CODE> и <CODE>TYPENAME</CODE>.  Когда <CODE>yylex</CODE> обнаруживает
идентификатор, она ищёт текущее объявление идентификтора чтобы решить, какой
тип лексемы возвращать: <CODE>TYPENAME</CODE>, если идентификатор объявлен как
определение типа, и <CODE>IDENTIFIER</CODE> в противном случае.


<P>
Правила грамматики могут затем выражать контекстную зависимость выбором
типа лексемы при распознавании.  <CODE>IDENTIFIER</CODE> допустима в выражении,
а <CODE>TYPENAME</CODE> -- нет.  Объявление может начинаться с <CODE>TYPENAME</CODE>,
но не с <CODE>IDENTIFIER</CODE>.  В контекстах, где смысл идентификатора <EM>не
имеет значения</EM>, таких как в объявлениях, которые могут затенять имя
определения типа, принимаются как <CODE>TYPENAME</CODE>, так и <CODE>IDENTIFIER</CODE> --
для каждого из двух типов лексем есть своё правило.


<P>
Этот приём просто использовать, если решение, какой тип идентификаторов
допустим, принимается в месте, близком к тому, где разбирается этот 
идентификатор.  Но в C это не всегда так: C допускает, чтобы объявление
переопределяло имя определения типа, при условии, что явный тип был задан
ранее:



<PRE>
typedef int foo, bar, lose;
static foo (bar);        /* переопределить <CODE>bar</CODE>
                               как статическую переменную */
static int foo (lose);   /* переопределить <CODE>foo</CODE>
                               как функцию */
</PRE>

<P>
К сожалению, объявляемое имя отделено от самой объявляющей конструкции
сложной синтаксической структурой -- "объявлятелем".


<P>
В результате часть анализатора Bison для C должна быть продублирована с
изменением имён всех нетерминалов: одно для разбора объявления, в котором
имя определения типа может быть переопределено, и другое для разбора
объявлений, в которых это невозможно.  Приведём часть такого дублирования,
действия в котором опущены для краткости:



<PRE>
initdcl:
          declarator maybeasm '='
          init
        | declarator maybeasm
        ;

notype_initdcl:
          notype_declarator maybeasm '='
          init
        | notype_declarator maybeasm
        ;
</PRE>

<P>
Здесь <CODE>initdcl</CODE> может переопределить имя определения типа, а
<CODE>notype_initdcl</CODE> -- нет.  Та же разница между <CODE>declarator</CODE> и
<CODE>notype_declarator</CODE>.


<P>
Есть нечто общее между этим приёмом и лексической увязкой (описанной ниже),
в том, что информация, изменяющая ход лексического анализа, изменяется
во время разбора другим частями программы.  Различие в том, что здесь
эта информация глобальна, и используется в программе для других целей.
Истинная лексическая увязка имеет флаг специального назначения, управляемый
синтаксическим контекстом.




<H2><A NAME="SEC93">8.2 Лексическая увязка</A></H2>
<P>
<A NAME="IDX220"></A>


<P>
Одним из способов обработки контекстной зависимости является <EM>лексическая
увязка</EM> -- флаг, устанавливаемый действиями Bison, предназначенный для
изменения способа разбора лексем.


<P>
Например, предположим, что у нас есть язык, смутно похожий на C, но со
специальной конструкцией <SAMP>`hex (<VAR>шестнадцатеричное_выражение</VAR>)'</SAMP>.
После ключевого слова <CODE>hex</CODE> идёт выражение в скобках, в котором все
целые числа записаны в шестнадцатеричной системе счисления.  В частности,
при появлении в этом контекта лексема <SAMP>`a1b'</SAMP> должна рассматриваться как
целое, а не как идентификатор.  Вот как вы можете это сделать:



<PRE>
%{
int hexflag;
%}
%%
...
expr:   IDENTIFIER
        | constant
        | HEX '('
                { hexflag = 1; }
          expr ')'
                { hexflag = 0;
                   $$ = $4; }
        | expr '+' expr
                { $$ = make_sum ($1, $3); }
        ...
        ;

constant:
          INTEGER
        | STRING
        ;
</PRE>

<P>
Здесь мы полагаем, что <CODE>yylex</CODE> проверяет значение <CODE>hexflag</CODE>, когда
оно ненулевое, все числа рассматриваются как шестнадцатеричные, и лексемы,
начинающиеся в букв, разбираются как целые, если это возможно.


<P>
Объявление <CODE>hexflag</CODE>, показанное в секции объявлений C файла анализатора,
необходимо чтобы оно было доступно для действий (см. раздел <A HREF="bison_6.html#SEC41">4.1.1 Секция объявлений C</A>).  Вы также должны написать код <CODE>yylex</CODE> так, чтобы анализ
подчинялся этому флагу.




<H2><A NAME="SEC94">8.3 Лексическая увязка и восстановление после ошибок</A></H2>

<P>
Лексическая увязка предъявляет строгие требования ко всем имеющимся у вас
правилам восстановления после ошибок.  См. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>.


<P>
Причина этого в том, что целью правил восстановления после ошибок является
прервать анализ одной конструкии и возобновить анализ более крупных
конструкций.  Например, в языках типа C типичное правило восстановления
после ошибки пропускает лексемы до следующей точки с запятой, и затем
начинает разбор нового оператора, как здесь:



<PRE>
stmt:   expr ';'
        | IF '(' expr ')' stmt { ... }
        ...
        error ';'
                { hexflag = 0; }
        ;
</PRE>

<P>
Если внутри конструкции <SAMP>`hex (<VAR>выражение</VAR>)'</SAMP> есть синтаксическая
ошибка, будет применено это правило обработки ошибок, и тогда действия для
законченного <SAMP>`hex (<VAR>выражение</VAR>)'</SAMP> никогда не будут выполнены. Поэтому
<CODE>hexflag</CODE> останется установленным для всего остального входного текста
или до следующего ключевого слова <CODE>hex</CODE>, в результате чего идентификаторы
будут ошибочно интерпретироваться как целые числа.


<P>
Чтобы избежать этой проблемы, правило восстановления после ошибки само
сбрасывает <CODE>hexflag</CODE>.


<P>
Также могут существовать правила восстановления после ошибок, работающие
внутри выражений.  Например, может быть правило, применяющееся внутри
скобок и пропускающее всё до закрывающей скобки:



<PRE>
expr:   ...
        | '(' expr ')'
                { $$ = $2; }
        | '(' error ')'
        ...
</PRE>

<P>
Если это правило действует внутри конструкции <CODE>hex</CODE>, оно не приводит к
выходу из этой конструкии (поскольку оно применяется к самому внутреннем
уровню скобок внутри конструкции). Поэтому не нужно очищать флаг, оставшаяся
часть конструкции <CODE>hex</CODE> должна быть разобрана пока флаг всё ещё действует.


<P>
Что если существует правило восстановления после ошибок, которое может прервать
или не прерывать разбор конструкции <CODE>hex</CODE>, в зависимости от обстоятельств?
Способа написать правило, определяющее, был ли прерван разбор конструкции
<CODE>hex</CODE>, нет. Поэтому, если вы используете лексиечскую увязку, лучше быть
уверенным в том, что ваши правила восстановления после ошибок не таковы.
Каждое правило должно быть таким, что вы можете быть уверены в том, что оно
всегда будет или никогда не будет сбрасывать флаг.


<P></P><HR>
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_9.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_11.html">Вперед</A>] &#160;

</BODY>
</HTML>
