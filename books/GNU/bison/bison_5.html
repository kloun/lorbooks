<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from bison.texi on June, 7  2003 -->

<TITLE>Bison 1.35 - 3. Примеры</TITLE>
</HEAD>
<BODY >
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_4.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_6.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC16">3. Примеры</A></H1>
<P>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>


<P>
Сейчас мы приведём и объясним три простые программы, написанные
с использованием Bison: калькулятор обратной польской нотации, калькулятор
алгебраической (инфиксной) нотации, и многофункциональный калькулятор.  Все
три протестированы под BSD Unix 4.3, каждая из них даёт пригодный для
использования, хотя и ограниченный, интерактивный настольный калькулятор.


<P>
Эти примеры просты, но грамматики Bison для реальных языков программирования
пишутся таким же образом.




<H2><A NAME="SEC17">3.1 Калькулятор обратной польской нотации</A></H2>
<P>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>


<P>
Первый пример -- это простой калькулятор с двойной точностью для выражений в
<EM>обратной польской нотации</EM> (использующий постфиксные операции).  Этот
пример является хорошей отправной точкой, поскольку приоритеты операций не
используются.  Обработка приоритетов будет показана во втором примере.


<P>
Исходный код этого калькулятора называется <TT>`rpcalc.y'</TT>.  По соглашению
для входных файлов Bison используется расширение <SAMP>`.y'</SAMP>.




<H3><A NAME="SEC18">3.1.1 Объявления для <CODE>rpcalc</CODE></A></H3>

<P>
Это объявления C и Bison для калькулятора обратной польской нотации.  Как
и в C, комментарии помещаются между <SAMP>`/*...*/'</SAMP>.



<PRE>
/* Калькулятор обратной польской нотации. */

%{
#define YYSTYPE double
#include &#60;math.h&#62;
%}

%token NUM

%% /* Далее следуют правила грамматики и действия */
</PRE>

<P>
Секция объявлений C (см. раздел <A HREF="bison_6.html#SEC41">4.1.1 Секция объявлений C</A> содержит
две директивы препроцессора.


<P>
Директива <CODE>#define</CODE> определяет макрос <CODE>YYSTYPE</CODE>.  Это задаёт тип
данных C для семантических значений как лексем, так и групп (см. раздел <A HREF="bison_6.html#SEC49">4.5.1 Типы данных семантических значений</A>).  Анализатор Bison будет
использовать любой тип, заданный  <CODE>YYSTYPE</CODE>, а если вы не определили его
-- тип по умолчанию <CODE>int</CODE>.  Поскольку мы указали <CODE>double</CODE>, с каждой
лексемой и каждым выражением будет ассоциировано вещественное число.


<P>
Директива <CODE>#include</CODE> используется для объявления функции возведения
в степень <CODE>pow</CODE>.


<P>
Из второй секции, объявлений Bison, Bison получает информацию о типах лексем
(см. раздел <A HREF="bison_6.html#SEC42">4.1.2 Секция объявлений Bison</A>).  Здесь должен быть
объявлен любой терминальный символ, не являющийся однолитерной константой
(они, как правило, не нуждаются в объявлении).  В этом примере все
арифметические операции обозначаются однолитерными константами, поэтому
нужно объявить только терминальный символ <CODE>NUM</CODE>, тип лексемы для числовых
констант.




<H3><A NAME="SEC19">3.1.2 Правила грамматики для <CODE>rpcalc</CODE></A></H3>

<P>
Это правила грамматики для калькулятора обратной польской нотации.



<PRE>
input:    /* пусто */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM             { $$ = $1;         }
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        | exp exp '*'     { $$ = $1 * $2;    }
        | exp exp '/'     { $$ = $1 / $2;    }
      /* возведение в степень */
        | exp exp '^'     { $$ = pow ($1, $2); }
      /* унарный минус        */
        | exp 'n'         { $$ = -$1;        }
;
%%
</PRE>

<P>
Здесь определены группы "языка" rpcalc: выражение (названное <CODE>exp</CODE>),
строка ввода (<CODE>line</CODE>), и законченный входной текст (<CODE>input</CODE>).  У
каждого из этих нетерминальных символов имеется несколько альтернативных
правил, объединённых знаком <SAMP>`|'</SAMP>, читающимся "или".  В последующих
разделах объясняется, что означают эти правила.


<P>
Семантика языка определяется действиями, предпринимаемыми при распознавании
группы.  Действия -- это код на C, находящийся между фигурными скобками.
См. раздел <A HREF="bison_6.html#SEC51">4.5.3 Действия</A>.


<P>
Вы должны писать эти действия на C, однако Bison предоставляет способ
передачи семантических значений между правилами.  В каждом действии
псевдопеременная <CODE>$$</CODE> обозначает семантическое значение группы,
которую собирает это правило.  Присвоение <CODE>$$</CODE> значения -- основная
работа большинства действий.  На семантические значения компонентов правила
можно ссылаться как на <CODE>$1</CODE>, <CODE>$2</CODE> и т.д.




<H4><A NAME="SEC20">3.1.2.1 Объяснение <CODE>input</CODE></A></H4>

<P>
Рассмотрим определение <CODE>input</CODE>:



<PRE>
input:    /* пусто */
        | input line
;
</PRE>

<P>
Это определение читается следующим образом: "Законченный входной текст
представляет собой пустую строку либо законченный входной текст, за
которым следует входная строка".  Обратите внимание, что "законченный
входной текст" определяется в терминах самого себя.  Это определение
называется <EM>леворекурсивным</EM>, поскольку <CODE>input</CODE> всегда является
самым левым символом последовательности.  См. раздел <A HREF="bison_6.html#SEC47">4.4 Рекурсивные правила</A>.


<P>
Первая альтернатива пуста, поскольку между двоеточием и первым знаком
<SAMP>`|'</SAMP> нет символов. Это означает, что <CODE>input</CODE> может соответствовать
пустой входной строке (без лексем). Мы пишем так правило, потому что допустимо
нажатие клавиш <KBD>Ctrl-d</KBD> сразу после запуска калькулятора. По соглашению
пустая альтернатива ставится первой и в ней пишется комментарий
<SAMP>`/* пусто */'</SAMP>.


<P>
Второе альтернативное правило (<CODE>input line</CODE>) описывает любой
нетривиальный входной текст. Оно означет "После прочтения любого количества
строк, прочитать ещё одну, если это возможно".  Левая рекурсия заставляет
это правило выполняться в цикле.  Поскольку первая альтернатива соответствует
пустому входному тексту, цикл будет выполняться ноль или более раз.


<P>
Функция анализатора <CODE>yyparse</CODE> продолжает обработку входного текста
до тех пор, пока не будет обнаружена грамматическая ошибка или лексические
анализатор не скажет, что входных лексем больше нет -- мы условимся, что
это произойдёт по достижении конца файла.




<H4><A NAME="SEC21">3.1.2.2 Объяснение <CODE>line</CODE></A></H4>

<P>
Теперь рассмотрим определение <CODE>line</CODE>:



<PRE>
line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;
</PRE>

<P>
Первая альтернатива -- это лексема литеры новой строки, это означает,
что rpcalc принимает пустую строку (и игнорирует её, поскольку там нет
никакого правила).  Вторая альтернатива -- это выражение, за которым следует
литера новой строки.  Именно эта альтернатива несёт основную пользу rpcalc.
Семантическое значение группы <CODE>exp</CODE> -- это значение <CODE>$1</CODE>, потому
что искомое <CODE>exp</CODE> -- первый символ альтернативы.  Действие выводит это
значение, которое является результатом вычислений, заданных пользователем.


<P>
Это действие необычно, потому что оно не присваивает значения <CODE>$$</CODE>.
Вследствие этого семантическое значение <CODE>line</CODE> не инициализируется
(значение будет непредсказуемым). Было бы ошибкой в программе, если бы
это значение когда-либо использовалось, но мы не пользуемся им -- после того,
как rpcalc вывел значение введённой пользователем входной строки, оно больше
не нужно.




<H4><A NAME="SEC22">3.1.2.3 Объяснение <CODE>expr</CODE></A></H4>

<P>
Группа <CODE>exp</CODE> имеет несколько правил, по одному на каждый вид выражений.
Первое правило обрабатывает наиболее простым выражениям -- отдельным числам.
Второе обрабатывает выражение сложения, которые выглядит как два выражения,
за которыми следует знак `плюс'.  Третье обрабатывает вычитание и т.д.



<PRE>
exp:      NUM
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        ...
        ;
</PRE>

<P>
Мы используем <SAMP>`|'</SAMP> чтобы объединить все правила для <CODE>exp</CODE>, но мы
могли бы с тем же успехом написать их отдельно:



<PRE>
exp:      NUM ;
exp:      exp exp '+'     { $$ = $1 + $2;    } ;
exp:      exp exp '-'     { $$ = $1 - $2;    } ;
        ...
</PRE>

<P>
У большей части правил есть действия, вычисляющие значение выражения из
значений его частей.  Например, в правиле для сложения <CODE>$1</CODE> относится
к первому компоненту <CODE>exp</CODE>, а <CODE>$2</CODE> -- ко второму.  Третий компонент,
<CODE>'+'</CODE> не имеет осмысленного ассоциированного семантического значения,
но если бы он имел его, на него можно было ссылаться как на <CODE>$3</CODE>. Когда
<CODE>yyparse</CODE>, используя это правило, распознаёт выражение-сумму, сумма
значений двух подвыражений даст значение всего выражения.  См. раздел <A HREF="bison_6.html#SEC51">4.5.3 Действия</A>.


<P>
Вы не обязаны приписывать действие каждому правилу.  Когда у правила нет
действия, по умолчанию Bison копирует значение <CODE>$1</CODE> в <CODE>$$</CODE>.
Именно это происходит в первом правиле (используюшем <CODE>NUM</CODE>).


<P>
Показанный здесь способ форматирования -- рекомендуемое соглашение, но
Bison не требует этого.  Вы можете добавлять или изменять промежутки по
своему усмотрению. Например, такая запись:



<PRE>
exp   : NUM | exp exp '+' {$$ = $1 + $2; } | ...
</PRE>

<P>
означает то же, что и:



<PRE>
exp:      NUM
        | exp exp '+'    { $$ = $1 + $2; }
        | ...
</PRE>

<P>
Однако последняя намного более наглядна.




<H3><A NAME="SEC23">3.1.3 Лексический анализатор <CODE>rpcalc</CODE></A></H3>
<P>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>


<P>
Задачей лексического анализатора является низкоуровневый разбор --
преобразование литер или последовательностей литер входного текста в
лексемы.  Анализатор Bison получает эти лексемы, вызывая лексический
анализатор.  См. раздел <A HREF="bison_7.html#SEC70">5.2 Функция лексического анализатора <CODE>yylex</CODE></A>.


<P>
Для работы калькулятора обратной польской нотации нужен весьма простой
лексический анализатор.  Он пропускает пробелы и знаки табуляции, читает
числа как значения типа <CODE>double</CODE> и возвращает их как лексемы типа
<CODE>NUM</CODE>.  Любые другие литеры, не являющиеся частью числа, считаются
отдельными лексемами.  Имейте в виду, что код лексемы для таких однолитерных
лексем -- это сама литера.


<P>
Возвращаемое значение функции лексического анализатора -- это числовой код,
представляющий тип лексемы.  Текст, используемый в правилах Bison  для
обозначения типа лексемы, также является выражением C для числового кода
этого типа. Это может работать двумя способами.  Если тип лексемы является 
литерой, её числовым кодом будет ASCII-код этой литеры, вы можете использовать
в лексическом анализаторе в качестве числа ту же литеру.  Если тип лексемы --
идентификатор, этот идентификатор Bison определяет как макрос C,
определением которого будет подходящее число.  В этом примере, поэтому,
<CODE>NUM</CODE> становится макросом, используемым <CODE>yylex</CODE>. 


<P>
Семантическое значение лексемы (если оно у неё есть) сохраняется в глобальной
переменной <CODE>yylval</CODE>, где её и ищет анализатор Bison (тип данных
<CODE>yylval</CODE> -- <CODE>YYSTYPE</CODE>, определяемый в начале грамматики;
см. раздел <A HREF="bison_5.html#SEC18">3.1.1 Объявления для <CODE>rpcalc</CODE></A>).


<P>
Нулевой код типа лексемы возвращается, если обнаружен конец файла (Bison
считает указателем конца входного файла любые неположительные значения).


<P>
Ниже приведён код лексического анализатора:



<PRE>
/* Лексический анализатор возвращает вещественное число
   с двойной точностью в стеке и лексему NUM, или прочитанную
   литеру ASCII, если это не число. Все пробелы и знаки
   табуляции пропускаются, в случае конца файла возвращается 0. */

#include &#60;ctype.h&#62;

int
yylex (void)
{
  int c;

  /* пропустить промежутки  */
  while ((c = getchar ()) == ' ' || c == '\t')
    ;
  /* обработка чисел       */
  if (c == '.' || isdigit (c))
    {
      ungetc (c, stdin);
      scanf ("%lf", &#38;yylval);
      return NUM;
    }
  /* вернуть конец файла  */
  if (c == EOF)
    return 0;
  /* вернуть одну литеру */
  return c;
}
</PRE>



<H3><A NAME="SEC24">3.1.4 Управляющая функция</A></H3>
<P>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>


<P>
В соответствии c духом этого примера управляющая функция сведена к явному
минимуму.  Единственное требование -- она должна вызывать <CODE>yyparse</CODE>
чтобы запустить процесс разбора.



<PRE>
int
main (void)
{
  return yyparse ();
}
</PRE>



<H3><A NAME="SEC25">3.1.5 Подпрограмма сообщения об ошибках</A></H3>
<P>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>


<P>
Когда <CODE>yyparse</CODE> обнаруживает синтаксическую ошибку, она вызывает
функцию сообщения об ошибках <CODE>yyerror</CODE> для вывода сообщения об
ошибке (обычно, но не всегда, <CODE>"ошибка разбора"</CODE>). Предоставить эту
функцию должен программист (см. раздел <A HREF="bison_7.html#SEC68">5. Интерфейс анализатора на C</A>),
поэтому приведём используемое нами определение:



<PRE>
#include &#60;stdio.h&#62;

void
yyerror (const char *s)  /* вызывается yyparse в случае ошибки */
{
  printf ("%s\n", s);
}
</PRE>

<P>
После возврата из функции <CODE>yyerror</CODE> анализатор Bison може произвести
восстановление после ошибки и продолжить разбор, если грамматика содержит
подходящее правило ошибки (см. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>).  В противном
случае <CODE>yyparse</CODE> вернёт ненулевое значение. В этом примере мы не писали
никаких правил ошибки, поэтому любой неправильный входной текст приведёт
к завершению работы калькулятора.  Это поведение неудачно для настоящего
калькулятора, но вполне подходит для первого примера.




<H3><A NAME="SEC26">3.1.6 Запуск Bison для создания анализатора</A></H3>
<P>
<A NAME="IDX47"></A>


<P>
Перед запуском Bison для создания анализатора нам нужно решить, хранить
весь исходный код в одном или нескольких файлах. Для такого простого примера
проще всего будет поместить всё в один файл. Определение <CODE>yylex</CODE>,
<CODE>yyerror</CODE> и <CODE>main</CODE> находятся в конце файла, в секции 
"дополнительного кода на C" (см. раздел <A HREF="bison_4.html#SEC15">2.8 Обзор схемы грамматики Bison</A>).


<P>
В больших проектах, скорее всего, у вас будет несколько файлов с исходным
кодом, и вы будет использовать <CODE>make</CODE> для их перекомпиляции.


<P>
Если весь исходный код находится в одном файле, используйте следующую
команду для преобразования его в файл анализатора:



<PRE>
bison <VAR>имя_файла</VAR>.y
</PRE>

<P>
В этом примере файл называется <TT>`rpcalc.y'</TT> ("Reverse Polish CALCulator"
-- калькулятор обратной польской нотации).  Bison создаёт файл 
<TT>`<VAR>имя_файла</VAR>.tab.c'</TT>, убирая <SAMP>`.y'</SAMP> из названия исходного файла.
Выходной файл Bison содержит исходный код <CODE>yyparse</CODE>.  Дополнительные
функции (<CODE>yylex</CODE>, <CODE>yyerror</CODE> и <CODE>main</CODE>) в точности копируются
из входного файла в выходной.




<H3><A NAME="SEC27">3.1.7 Компиляция файла анализатора</A></H3>
<P>
<A NAME="IDX48"></A>


<P>
Так нужно компилировать и запускать файл анализатора:



<PRE>
# Перечислить файлы в текущем каталоге.
$ <KBD>ls</KBD>
rpcalc.tab.c  rpcalc.y

# Компиляция анализатора Bison.
# <SAMP>`-lm'</SAMP> указывает компилятору искать <CODE>pow</CODE> в
# математической библиотеке.
$ <KBD>cc rpcalc.tab.c -lm -o rpcalc</KBD>

# Снова перечислить файлы.
$ <KBD>ls</KBD>
rpcalc  rpcalc.tab.c  rpcalc.y
</PRE>

<P>
Файл <TT>`rpcalc'</TT> теперь содержит исполняемый код.  Вот пример сеанса 
работы с <CODE>rpcalc</CODE>.



<PRE>
$ <KBD>rpcalc</KBD>
<KBD>4 9 +</KBD>
13
<KBD>3 7 + 3 4 5 *+-</KBD>
-13
<KBD>3 7 + 3 4 5 * + - n</KBD>              Обратите внимание на унарный минус
                                       <SAMP>`n'</SAMP>
13
<KBD>5 6 / 4 n +</KBD>
-3.166666667
<KBD>3 4 ^</KBD>                            Возведение в степень
81
<KBD>^D</KBD>                               Признак конца файла
$
</PRE>



<H2><A NAME="SEC28">3.2 Калькулятор инфиксной нотации: <CODE>calc</CODE></A></H2>
<P>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
<A NAME="IDX51"></A>


<P>
Теперь мы модифицируем rpcalc для обработки инфиксных, а не постфиксных
операций.  Инфиксная нотация предполагает принцип приоритета операций и
необходимость обработки скобок произвольной глубины вложенности.  Вот код
Bison файла <TT>`calc.y'</TT> -- инфиксного настольного калькулятора.



<PRE>
/* Калькулятор для выражени в инфиксной нотации -- calc */

%{
#define YYSTYPE double
#include &#60;math.h&#62;
%}

/* Объявления BISON */
%token NUM
%left '-' '+'
%left '*' '/'
%left NEG     /* обращение -- унарный минус */
%right '^'    /* возведение в степень       */

/* Далее следует грамматика */
%%
input:    /* пустая строка */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM                { $$ = $1;         }
        | exp '+' exp        { $$ = $1 + $3;    }
        | exp '-' exp        { $$ = $1 - $3;    }
        | exp '*' exp        { $$ = $1 * $3;    }
        | exp '/' exp        { $$ = $1 / $3;    }
        | '-' exp  %prec NEG { $$ = -$2;        }
        | exp '^' exp        { $$ = pow ($1, $3); }
        | '(' exp ')'        { $$ = $2;         }
;
%%
</PRE>

<P>
Функции <CODE>yylex</CODE>, <CODE>yyerror</CODE> и <CODE>main</CODE> могут быь теми же,
что и раньше.


<P>
В этом коде показаны две новые важные возможности.


<P>
Во второй секции (объявления Bison) <CODE>%left</CODE> объявляет типы лексем
и говорит, что они обозначают левоассоциативные операции.  Объявления
<CODE>%left</CODE> и <CODE>%right</CODE> (правая ассоциативность) используются вместо
<CODE>%token</CODE>, использующегося для объявления имени типа лексемы без
ассоциативности (эти лексемы являются однолитерными константами, которые
обычно не требуют объявления.  Мы объявляем их здесь для указания
ассоциативности).


<P>
Приоритет операций определяется порядком строк с объявлениями -- чем больше
номер строки (чем ниже она на странице или на экране), тем выше приоритет.
Отсюда, возведение в степень имеет наивысший приоритет, далее идут унарный
минус (<CODE>NEG</CODE>), <SAMP>`*'</SAMP> и <SAMP>`/'</SAMP> и т.д.  См. раздел <A HREF="bison_8.html#SEC80">6.3 Приоритет операций</A>.


<P>
Другая новая возможность -- <CODE>%prec</CODE> в секции грамматики для операции
унарного минуса. <CODE>%prec</CODE> просто указывает Bison, что правило
<SAMP>`| '-' exp'</SAMP> имеет тот же приоритет, что и <CODE>NEG</CODE> -- в данном случае
следующий за наивысшим.  См. раздел <A HREF="bison_8.html#SEC85">6.4 Контекстно-зависимый приоритет</A>.


<P>
Вот пример работы с <TT>`calc.y'</TT>:



<PRE>
$ <KBD>calc</KBD>
<KBD>4 + 4.5 - (34/(8*3+-3))</KBD>
6.880952381
<KBD>-56 + 2</KBD>
-54
<KBD>3 ^ 2</KBD>
9
</PRE>



<H2><A NAME="SEC29">3.3 Простое восстановление после ошибок</A></H2>
<P>
<A NAME="IDX52"></A>


<P>
До сих пор это руководство не касалось вопроса <EM>восстановления после
ошибок</EM> -- как продолжить разбор после того, как анализатор обнаружил
синтаксическую ошибку.  Всё, что мы предпринимали -- это выдача сообщения
об ошибке функцией <CODE>yyerror</CODE>.  Вспомним, что по умолчанию после вызова
<CODE>yyerror</CODE> <CODE>yyparse</CODE> завершает работу.  Это значит, что неправильный
ввод приведёт к завершению работы калькулятора.  Сейчас мы покажем, как
исправить этот недостаток.


<P>
Язык Bison содержит зарезервированное слово <CODE>error</CODE>, которое можно
включить в правило грамматики.  В следующем примере оно добавлено к одной
из альтернатив <CODE>line</CODE>:



<PRE>
line:     '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;
</PRE>

<P>
Это добавление к грамматике допускает простое восстановление после
ошибок в случае ошибки разбора.  Если читается выражение, которое не может
быть вычислено, третьим правилом для <CODE>line</CODE> будет распознана ошибка, и
разбор продолжится (однако функция <CODE>yyerror</CODE> по-прежнему используется
для вывода сообщения).  Действие выполняет оператор <CODE>yyerrok</CODE>,
автоматически определяемый Bison макрос. Он означает, что восстановление после
ошибки завершено (см. раздел <A HREF="bison_9.html#SEC90">7. Восстановление после ошибок</A>).  Обратите внимания на
различие между <CODE>yyerrok</CODE> и <CODE>yyerror</CODE> -- ни то, ни другое не
опечатка.


<P>
Этот вид восстановления после ошибок работает с синтаксическими ошибками.
Есть другие виды ошибок, например, деление на ноль, вызывающее сигнал
исключения, обычно являющегося фатальным.  Настоящая программа калькулятора
должна обрабатывать этот сигнал и использовать <CODE>longjmp</CODE> для возврата
в функцию <CODE>main</CODE> и продолжения разбора входных строк. Ей следует также
отбросить остаток текущей строки входа.  Мы не будем далее обсуждать этот
вопрос, потому что он не характерен для программ Bison.




<H2><A NAME="SEC30">3.4 Калькулятор с отслеживаием положений: <CODE>ltcalc</CODE></A></H2>
<P>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>


<P>
Этот пример расширяет калькулятор инфиксной нотации отслеживанием положений.  
Это свойство будет использоваться для улучшения сообщений об ошибках.  Для
большей ясности этот пример -- простой целочисленный калькулятор, поскольку
большая часть изменений, необходимых для использования положений, будет
сделана в лексическом анализаторе.




<H3><A NAME="SEC31">3.4.1 Объявления <CODE>ltcalc</CODE></A></H3>

<P>
Объявления C и Bison для калькулятора с отслеживанием положение те же самые,
что и для калькулятора инфиксной нотации.



<PRE>
/* Калькулятор с отслеживанием положений.  */

%{
#define YYSTYPE int
#include &#60;math.h&#62;
%}

/* Объявления Bison.  */
%token NUM

%left '-' '+'
%left '*' '/'
%left NEG
%right '^'

%% /* Далее следует грамматика */
</PRE>

<P>
Заметьте, что специальных объявлений для работы с положениями нет.  Определять
тип данных для сохранения положений не нужно, мы будем использовать тип,
заданный по умолчанию (см. раздел <A HREF="bison_6.html#SEC55">4.6.1 Тип данных положений</A>),
являющийся структурой с четырьмя следующими целочисленными полями:
<CODE>first_line</CODE>, <CODE>first_column</CODE>, <CODE>last_line</CODE> и <CODE>last_column</CODE>.




<H3><A NAME="SEC32">3.4.2 Правила грамматики <CODE>ltcalc</CODE></A></H3>

<P>
Обрабатываются положения или нет, не влияет на синтаксис вашего языка.
Поэтому правила грамматики языка в этом примере будут очень похожи на
правила в предыдущем примере, мы только модифицируем их для работы с
новой информацией. 


<P>
В этом примере мы будем использовать положения для сообщения о делении
на ноль, и определения места неправильных выражений и подвыражений.



<PRE>
input   : /* пусто */
        | input line
;

line    : '\n'
        | exp '\n' { printf ("%d\n", $1); }
;

exp     : NUM           { $$ = $1; }
        | exp '+' exp   { $$ = $1 + $3; }
        | exp '-' exp   { $$ = $1 - $3; }
        | exp '*' exp   { $$ = $1 * $3; }
        | exp '/' exp
            {
              if ($3)
                $$ = $1 / $3;
              else
                {
                  $$ = 1;
                  fprintf (stderr, "%d.%d-%d.%d: деление на ноль",
                           @3.first_line, @3.first_column,
                           @3.last_line, @3.last_column);
                }
            }
        | '-' exp %preс NEG     { $$ = -$2; }
        | exp '^' exp           { $$ = pow ($1, $3); }
        | '(' exp ')'           { $$ = $2; }
</PRE>

<P>
Этот код показывает, как получать значения положений изнутри семантических
действий, используя псевдопеременные <CODE>@<VAR>n</VAR></CODE> для компонентов правила
и <CODE>@$</CODE> -- для групп.


<P>
Нам не нужно присваивать значение <CODE>@$</CODE>, создаваемый анализатор делает
это автоматически.  По умолчанию перед выполнением кода на C для каждого
действия <CODE>@$</CODE> правила с <VAR>n</VAR> компонентами сопоставляется интервал
от начала <CODE>@1</CODE> до конца <CODE>@<VAR>n</VAR></CODE>.  Это поведение может быть
переопределено (см. раздел <A HREF="bison_6.html#SEC57">4.6.3 Действие по умолчанию для положений</A>), а для очень специфических правил <CODE>@$</CODE> может
вычисляться вручную.




<H3><A NAME="SEC33">3.4.3 Лексический анализатор <CODE>ltcalc</CODE>.</A></H3>

<P>
До сих пор для отслеживания положений мы полагались на значения Bison по
умолчанию. Следующим шагом мы перепишем лексический анализатор и сделаем
его способным передавать в анализатор положения лексем, как он уже делает это
с их семантическими значениями.


<P>
Для этой цели мы должны принимать в расчёт каждую литеру входного текста,
чтобы избежать того, что вычисленные положения будут неверными.



<PRE>
int
yylex (void)
{
  int c;

  /* пропустить промежутки */
  while ((c = getchar ()) == ' ' || c == '\t')
    ++yylloc.last_column;

  /* шаг */
  yylloc.first_line = yylloc.last_line;
  yylloc.first_column = yylloc.last_column;

  /* обработка чисел */
  if (isdigit (c))
    {
      yylval = c - '0';
      ++yylloc.last_column;
      while (isdigit (c = getchar ()))
        {
          ++yylloc.last_column;
          yylval = yylval * 10 + c - '0';
        }
      ungetc (c, stdin);
      return NUM;
    }

  /* вернуть конец файла */
  if (c == EOF)
    return 0;

  /* вернуть однц литеру и обновить положение */
  if (c == '\n')
    {
      ++yylloc.last_line;
      yylloc.last_column = 0;
    }
  else
    ++yylloc.last_column;
  return c;
}
</PRE>

<P>
В основном, лексический анализатор делает то же, что и раньше: пропускает
пробелы и знаки табуляции и читает числа или однолитерные лексемы.
Дополнительно он обновляет <CODE>yylloc</CODE>, глобальную переменную (типа
<CODE>YYLTYPE</CODE>), содержащую положение лексемы.


<P>
Теперь, каждый раз, когда функция возвращет лексему, в распоряжении
анализатора находятся как её номер, так и семантическое значение и положение
в тексте.  Последнее необходимое изменение -- инициализация <CODE>yylloc</CODE>,
например, в управляющей функции.



<PRE>
int
main (void)
{
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = 0;
  return yyparse ();
}
</PRE>

<P>
Помните, что вычисление положений не касается синтаксиса.  Каждая литера
должна быть ассоциирована с обновлением информации о положении, независимо от
того, находится ли она в правильном входном тексте, в комментариях, в строковой
константе и т.д. 




<H2><A NAME="SEC34">3.5 Многофункциональный калькулятор: <CODE>mfcalc</CODE></A></H2>
<P>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>


<P>
Теперь, когда мы уже обсудили основы Bison, пришло время перейти к более
сложной задаче.  Приведённые выше калькуляторы поддерживали только пять
функций: <SAMP>`+'</SAMP>, <SAMP>`-'</SAMP>, <SAMP>`*'</SAMP>, <SAMP>`/'</SAMP> и <SAMP>`^'</SAMP>.  Было бы приятно
иметь калькулятор, предоставляющий другие математические функции, такие как
<CODE>sin</CODE>, <CODE>cos</CODE> и т.д.


<P>
Добавить новые операции в инфиксный калькулятор, до тех пор, пока они
обозначаются односимвольными константами, несложно.  Лексический анализатор
<CODE>yylex</CODE> возвращает все нечисловые литеры как лексемы, так что для
добавления операции достаточно введения нового правила грамматики.  Но мы
хотим иметь нечто более гибкое, встроенные функции, синтаксис которых
выглядит так:



<PRE>
<VAR>имя_функции</VAR> (<VAR>аргумент</VAR>)
</PRE>

<P>
В то же время, мы добавим в калькулятор память, допуская создание
именованных переменных, сохранение в них значений и последующее использование.
Вот пример сеанса работы многофункционального калькулятора:



<PRE>
$ <KBD>mfcalc</KBD>
<KBD>pi = 3.141592653589</KBD>
3.1415926536
<KBD>sin(pi)</KBD>
0.0000000000
<KBD>alpha = beta1 = 2.3</KBD>
2.3000000000
<KBD>alpha</KBD>
2.3000000000
<KBD>ln(alpha)</KBD>
0.8329091229
<KBD>exp(ln(beta1))</KBD>
2.3000000000
$
</PRE>

<P>
Обратите внимание, что допускаются множественное присваивание и
вложенные вызовы функций.




<H3><A NAME="SEC35">3.5.1 Объявления <CODE>mfcalc</CODE></A></H3>

<P>
Вот объявления C и Bison для многофункционального калькулятора.



<PRE>
%{
#include &#60;math.h&#62;  /* Математические функции: cos(), sin() и т.д. */
#include "calc.h"  /* Содержит определение `symrec'               */
%}
%union {
double     val;  /* Чтобы возвращать числа.                     */
symrec  *tptr;   /* Чтобы возвращать указатели таблицы символов */
}

%token &#60;val&#62;  NUM        /* Простое число двойной точности   */
%token &#60;tptr&#62; VAR FNCT   /* Переменная и функция             */
%type  &#60;val&#62;  exp

%right '='
%left '-' '+'
%left '*' '/'
%left NEG     /* Обращение -- унарный минус */
%right '^'    /* Возведение в степень       */

/* Далее следует грамматика */

%%
</PRE>

<P>
Вышеприведённая грамматика вводит только две новые возможности языка Bison.
Эти возможности позволяют семантическим значениям иметь различные типы
данных (см. раздел <A HREF="bison_6.html#SEC50">4.5.2 Несколько типов значений</A>).


<P>
Объявление <CODE>%union</CODE> задаёт весь список возможных типов, это употребляется
вместо определения <CODE>YYSTYPE</CODE>.  Допустимые типы теперь: вещественные числа
двойной точности (для <CODE>exp</CODE> и <CODE>NUM</CODE>) и указатели на элементы
таблицы символов.  См. раздел <A HREF="bison_6.html#SEC61">4.7.3 Набор типов значений</A>.


<P>
Поскольку значения теперь могут иметь различные типы, необходимо ассоциировать
тип с каждым символом грамматики, семантическое значение которого используется.
Эти символы: <CODE>NUM</CODE>, <CODE>VAR</CODE>, <CODE>FNCT</CODE> и <CODE>exp</CODE>.  Их объявления
дополнены информацией об их типах данных (помещённой в угловых скобках).


<P>
Конструкция Bison <CODE>%type</CODE> используется для объявления нетерминальных
символов, так же как <CODE>%token</CODE> используется для объявления типов лексем.
Ранее мы не использовали <CODE>%type</CODE>, потому что нетерминальные символы обычно
неявно объявляются правилами, определяющими их.  Но <CODE>exp</CODE> должно быть
объявлено явно чтобы можно было задать тип его значения.  См. раздел <A HREF="bison_6.html#SEC62">4.7.4 Нетерминальные символы</A>.




<H3><A NAME="SEC36">3.5.2 Правила грамматики <CODE>mfcalc</CODE></A></H3>

<P>
Вот правила грамматики многофункционального калькутора.  Большая их часть
напрямую скопирована из <CODE>calc</CODE>.  Введено три новых правила, использующие
<CODE>VAR</CODE> и <CODE>FNCT</CODE>.



<PRE>
input:   /* пусто */
        | input line
;

line:
          '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;

exp:      NUM                { $$ = $1;                         }
        | VAR                { $$ = $1-&#62;value.var;              }
        | VAR '=' exp        { $$ = $3; $1-&#62;value.var = $3;     }
        | FNCT '(' exp ')'   { $$ = (*($1-&#62;value.fnctptr))($3); }
        | exp '+' exp        { $$ = $1 + $3;                    }
        | exp '-' exp        { $$ = $1 - $3;                    }
        | exp '*' exp        { $$ = $1 * $3;                    }
        | exp '/' exp        { $$ = $1 / $3;                    }
        | '-' exp  %prec NEG { $$ = -$2;                        }
        | exp '^' exp        { $$ = pow ($1, $3);               }
        | '(' exp ')'        { $$ = $2;                         }
;
/* End of grammar */
%%
</PRE>



<H3><A NAME="SEC37">3.5.3 Таблица символов <CODE>mfcalc</CODE></A></H3>
<P>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>


<P>
Многофункциональному калькулятору требуется таблица символов для отслеживания
имён и значений переменных и функций.  Это не влияет на правила грамматики
(за исключением действий) или объявления Bison, но требует введения некоторых
дополнительных функций на C.


<P>
Сама таблица символов состоит из связанного списка записей.  Её определение,
находящееся в заголовке <TT>`calc.h'</TT>, приведено далее.  Оно позволяет
размещать в таблице как функции, так и переменные.



<PRE>
/* Тип функций.                                      */
typedef double (*func_t) (double);

/* Тип данных для связей в цепочке символов.         */
struct symrec
{
  char *name;  /* имя символа                        */
  int type;    /* тип символа: либо VAR, либо FNCT   */
  union
  {
    double var;                  /* значение VAR     */
    func_t fnctptr;              /* значение FNCT    */
  } value;
  struct symrec *next;    /* поле связи              */
};

typedef struct symrec symrec;

/* Таблица символов: цепочка `struct symrec'.        */
extern symrec *sym_table;

symrec *putsym (const char *, func_t);
symrec *getsym (const char *);
</PRE>

<P>
Новая версия <CODE>main</CODE> включает вызов <CODE>init_table</CODE>, функции,
инициализирующей таблицу символов.  Вот текст этих двух функций



<PRE>
#include &#60;stdio.h&#62;

int
main (void)
{
  init_table ();
  return yyparse ();
}

void
yyerror (const char *s)  /* Вызывается yyparse в случае ошибки */
{
  printf ("%s\n", s);
}

struct init
{
  char *fname;
  double (*fnct)(double);
};

struct init arith_fncts[] =
{
  "sin",  sin,
  "cos",  cos,
  "atan", atan,
  "ln",   log,
  "exp",  exp,
  "sqrt", sqrt,
  0, 0
};

/* Таблица символов: цепочка `struct symrec'.  */
symrec *sym_table = (symrec *) 0;

/* Поместить арифметические функции в таблицу. */
void
init_table (void)
{
  int i;
  symrec *ptr;
  for (i = 0; arith_fncts[i].fname != 0; i++)
    {
      ptr = putsym (arith_fncts[i].fname, FNCT);
      ptr-&#62;value.fnctptr = arith_fncts[i].fnct;
    }
}
</PRE>

<P>
Вы можете добавить к калькулятору дополнительные функции, просто редактируя
список инициализации и включая необходимые файлы заголовков.


<P>
Две важные функции позволяют просматривать символы в таблице и вводить новые.
Функции <CODE>putsym</CODE> передаётся имя и тип (<CODE>VAR</CODE> или <CODE>FNCT</CODE>)
заносимого объекта. Объект включается в начало списка, и возвращается 
указатель на объект.  Функции <CODE>getsym</CODE> передаётся имя искомого символа.
Если он найден, возвращается указатель на него, иначе же ноль.



<PRE>
symrec *
putsym (char *sym_name, int sym_type)
{
  symrec *ptr;
  ptr = (symrec *) malloc (sizeof (symrec));
  ptr-&#62;name = (char *) malloc (strlen (sym_name) + 1);
  strcpy (ptr-&#62;name,sym_name);
  ptr-&#62;type = sym_type;
  ptr-&#62;value.var = 0; /* set value to 0 even if fctn.  */
  ptr-&#62;next = (struct symrec *)sym_table;
  sym_table = ptr;
  return ptr;
}

symrec *
getsym (const char *sym_name)
{
  symrec *ptr;
  for (ptr = sym_table; ptr != (symrec *) 0;
       ptr = (symrec *)ptr-&#62;next)
    if (strcmp (ptr-&#62;name,sym_name) == 0)
      return ptr;
  return 0;
}
</PRE>

<P>
Функция <CODE>yylex</CODE> теперь должна распознавать переменные, числовые значения
и односимвольные арифметические операции.  Строки алфавитноцифровых литер,
начинающиеся не с цифры, распознаются или как переменные, или как функции, в
зависимости от того, что говорится о них в таблице символов.


<P>
Строка передаётся функции <CODE>getsym</CODE> для поиска в таблице символов. Если
имя встречается в таблице, в <CODE>yyparse</CODE> возвращаются указатель на его
положение и его тип (<CODE>VAR</CODE> или <CODE>FNCT</CODE>).  Если в таблице его ещё нет,
оно заносится как <CODE>VAR</CODE>, используя <CODE>putsym</CODE>.  Опять же, указатель и
тип (который должен быть <CODE>VAR</CODE>) возвращаются в <CODE>yyparse</CODE>.


<P>
Для обработки числовых значений и арифметических операций изменения в
<CODE>yylex</CODE> не нужны.



<PRE>
#include &#60;ctype.h&#62;

int
yylex (void)
{
  int c;

  /* Игнорировать промежутки, получить первый непробельный символ.  */
  while ((c = getchar ()) == ' ' || c == '\t');

  if (c == EOF)
    return 0;

  /* С литеры начинается число =&#62; разобрать число.                  */
  if (c == '.' || isdigit (c))
    {
      ungetc (c, stdin);
      scanf ("%lf", &#38;yylval.val);
      return NUM;
    }

  /* С литеры начинается идентификатор =&#62; читать имя.              */
  if (isalpha (c))
    {
      symrec *s;
      static char *symbuf = 0;
      static int length = 0;
      int i;

      /* Первоначально сделать буфер достаточно большим
         для имени символа из 40 литер.  */
      if (length == 0)
        length = 40, symbuf = (char *)malloc (length + 1);

      i = 0;
      do
        {
          /* Если буфер полон, расширить его.          */
          if (i == length)
            {
              length *= 2;
              symbuf = (char *)realloc (symbuf, length + 1);
            }
          /* Добавить эту литеру в буфер.              */
          symbuf[i++] = c;
          /* Получить следующую литеру.                */
          c = getchar ();
        }
      while (c != EOF &#38;&#38; isalnum (c));

      ungetc (c, stdin);
      symbuf[i] = '\0';

      s = getsym (symbuf);
      if (s == 0)
        s = putsym (symbuf, VAR);
      yylval.tptr = s;
      return s-&#62;type;
    }

  /* Любая другая литера сама по себе является лексемой.        */
  return c;
}
</PRE>

<P>
Эта программа одновременно и достаточно мощна, и гибка.  Вы можете легко
добавлять новые функции и также несложно модифицировать код для введения
предопределённых переменных, таких как <CODE>pi</CODE> и <CODE>e</CODE>.




<H2><A NAME="SEC38">3.6 Упражнения</A></H2>
<P>
<A NAME="IDX61"></A>



<OL>
<LI>

Добавьте несколько новых функций из <TT>`math.h'</TT> в список инициализации.

<LI>

Добавьте ещё один массив, содержащий константы и их значения.  Потом
модифицируйте <CODE>init_table</CODE> чтобы внести эти константы в таблицу
символов.  Проще всего будет придать константам тип <CODE>VAR</CODE>.

<LI>

Заставьте программу выводить сообщение об ошибке, если пользователь
ссылается на неинициализированную переменную каким-либо образом, кроме
присвоения ей значения.
</OL>

<P></P><HR>
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_4.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_6.html">Вперед</A>] &#160;

</BODY>
</HTML>
