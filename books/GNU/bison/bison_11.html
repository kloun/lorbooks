<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from bison.texi on June, 7  2003 -->

<TITLE>Bison 1.35 - 9. Отладка вашего анализатора</TITLE>
</HEAD>
<BODY >
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_10.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_12.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC95">9. Отладка вашего анализатора</A></H1>
<P>
<A NAME="IDX221"></A>
<A NAME="IDX222"></A>
<A NAME="IDX223"></A>
<A NAME="IDX224"></A>


<P>
Если грамматика Bison компилируется правильно, но при запуске делает не то,
чего вы хотите, помочь вам выяснить, почему это происходит, может средство
трассировки анализатора <CODE>yydebug</CODE>.


<P>
Чтобы включить компиляцию возможностей трассировки, вы должны определить
макрос <CODE>YYDEBUG</CODE> как ненулевое значение при компиляции анализатора. Вы
можете использовать параметр компилятора <SAMP>`-DYYDEBUG=1'</SAMP> или поместить
<SAMP>`#define YYDEBUG 1'</SAMP> в секцию объявлений C файла грамматики
(см. раздел <A HREF="bison_6.html#SEC41">4.1.1 Секция объявлений C</A>). Вместо этого можно использовать
параметр <SAMP>`-t'</SAMP> при запуске Bison (см. раздел <A HREF="bison_12.html#SEC96">10. Вызов Bison</A>) или
объявление <CODE>%debug</CODE> (см. раздел <A HREF="bison_6.html#SEC66">4.7.8 Обзор объявлений Bison</A>).
Мы полагаем, что вы всегда будете определять <CODE>YYDEBUG</CODE>, так что отладка
всегда будет возможна.


<P>
Средство трассировки выводит собщения, используя макровызовы вида
<CODE>YYFPRINTF (stderr, <VAR>формат</VAR>, <VAR>аргументы</VAR></CODE>, где <VAR>формат</VAR> и
<VAR>аргументы</VAR> -- обычные формат и аргументы функции <CODE>printf</CODE>.
Если вы определяете <CODE>YYDEBUG</CODE> как ненулевое значение, но не определяете
<CODE>YYFPRINTF</CODE>, автоматически включается <CODE>&#60;stdio.h&#62;</CODE> и <CODE>YYFPRINTF</CODE>
определяется как <CODE>fprintf</CODE>.


<P>
После того, как вы скомпилировали программу с использованием средств
трассировки, чтобы потребовать выполнения трассировки, нужно поместить
ненулевое значение в переменную <CODE>yydebug</CODE>.  Вы можете сделать это,
заставив это делать код на C (возможно, в функции <CODE>main</CODE>), или изменить
это значение отладчиком C.


<P>
Каждый шаг, предпринимаемый анализатором, когда <CODE>yydebug</CODE> не равно нулю,
даёт одну или две строки информации о трассировке, выдаваемой на <CODE>stderr</CODE>.
Сообщения трассировки говорят о следующем:



<UL>
<LI>

При каждом вызове <CODE>yylex</CODE>: лексема какого вида прочитана.

<LI>

При каждом сдвиге: глубина и всё содержимое стека состояний (см. раздел <A HREF="bison_8.html#SEC86">6.5 Состояния анализатора</A>).

<LI>

При каждой свёртке: по какому правилу произведена свёртка, и полное содержимое
стека после этого.
</UL>

<P>
Для осмысления этой информации полезно обратиться к файлу листинга, выдаваемому
параметром Bison <SAMP>`-v'</SAMP> (см. раздел <A HREF="bison_12.html#SEC96">10. Вызов Bison</A>).  Этот файл
показывает смысл каждого состояния в терминах позиций в различных правилах,
а также, что будет происходить в каждом состоянии при каждой возможной входной
лексеме.  Читая последовательные сообщения трассировки, вы можете видеть, что
анализатор функционирует в соответствии с его спецификацией в файле листинга.
В конце концов вы дойдёте до места, где происходит что-либо нежелательное, и
увидите, какие части грамматики несут за это ответственность.


<P>
Файл анализатора -- это программа на C, и вы можете использовать отладчики C,
но объяснить, что она делает непросто.  Функция анализатора -- это 
интерпретатор машины с конечным числом состояний, и за пределами действий
она выполняет один и тот же код снова и снова.  В каком месте грамматики она
работает, показывают только значения переменных.


<P>
<A NAME="IDX225"></A>
Отладочная информация обычно содержит тип каждой прочитанной лексемы, но не
её семантическое значение.  Вы можете также определить макрос <CODE>YYPRINT</CODE>,
чтобы предоставить способ вывода значения.  Если вы определяете <CODE>YYPRINT</CODE>,
он должен принимать три аргумента.  Анализатор будет передавать ему стандартный
поток ввода/вывода, числовой код типа лексемы и значение лексемы (из
<CODE>yylval</CODE>).


<P>
Приведём пример <CODE>YYPRINT</CODE>, подходящего для многофункционального
калькулятора (см. раздел <A HREF="bison_5.html#SEC35">3.5.1 Объявления <CODE>mfcalc</CODE></A>):



<PRE>
#define YYPRINT(file, type, value)   yyprint (file, type, value)

static void
yyprint (FILE *file, int type, YYSTYPE value)
{
  if (type == VAR)
    fprintf (file, " %s", value.tptr-&#62;name);
  else if (type == NUM)
    fprintf (file, " %d", value.val);
}
</PRE>

<P></P><HR>
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_10.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_12.html">Вперед</A>] &#160;

</BODY>
</HTML>
