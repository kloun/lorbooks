<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from bison.texi on June, 7  2003 -->

<TITLE>Bison 1.35 - 4. Файлы грамматики Bison</TITLE>
</HEAD>
<BODY >
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_5.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_7.html">Вперед</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC39">4. Файлы грамматики Bison</A></H1>

<P>
Bison принимает на вход спецификацию контекстно-свободной грамматики и
создаёт функцию на языке C, которая распознаёт правильные предложения этой
грамматики.


<P>
Имя входного файла грамматики Bison по соглашению заканчивается на <SAMP>`.y'</SAMP>.
См. раздел <A HREF="bison_12.html#SEC96">10. Вызов Bison</A>.




<H2><A NAME="SEC40">4.1 Структура грамматики Bison</A></H2>

<P>
Файл грамматики Bison содержит четыре основные секции, показанные здесь
с соответствующими разделителями.



<PRE>
%{
<VAR>Объявления C</VAR>
%}

<VAR>Объявления Bison</VAR>

%%
<VAR>Правила грамматики</VAR>
%%

<VAR>Дополнительный код на C</VAR>
</PRE>

<P>
Комментарии, заключённые в <SAMP>`/* ... */'</SAMP>, могут появляться в любой
секции.




<H3><A NAME="SEC41">4.1.1 Секция объявлений C</A></H3>
<P>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>


<P>
Секция <VAR>объявлений C</VAR> содержит макроопределения и объявления функций и
переменных, используемых в действиях правил грамматики.  Они копируются в
начало файла анализатора так, чтобы они предшествовали определению
<CODE>yyparse</CODE>.  Вы можете использовать <SAMP>`#include'</SAMP> для получения
объявлений из файлов заголовков.  Если вам не нужны какие-либо объявления C,
вы можете опустить ограничивающие эту секцию <SAMP>`%{'</SAMP> и <SAMP>`%}'</SAMP>.




<H3><A NAME="SEC42">4.1.2 Секция объявлений Bison</A></H3>
<P>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>


<P>
Секция <VAR>объявлений Bison</VAR> содержит объявления, определяющие терминальные
и нетерминальные символы, задающие приоритет и т.д.  В некоторых простых
грамматиках вам могут быть не нужны никакие объявления.  См. раздел <A HREF="bison_6.html#SEC58">4.7 Объявления Bison</A>.




<H3><A NAME="SEC43">4.1.3 Секция правил грамматики</A></H3>
<P>
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>


<P>
Секция <EM>правил грамматики</EM> содержит одно или более правил грамматики
Bison и ничего более.  См. раздел <A HREF="bison_6.html#SEC46">4.3 Синтаксис правил грамматики</A>.


<P>
Должно быть по меньшей мере одно правило грамматики, и первый ограничитель
<SAMP>`%%'</SAMP> (предшествующий правилам грамматики) не может быть опущен, даже
если это первая строка файла.




<H3><A NAME="SEC44">4.1.4 Секция дополнительного кода на C</A></H3>
<P>
<A NAME="IDX68"></A>
<A NAME="IDX69"></A>
<A NAME="IDX70"></A>


<P>
Секция <VAR>дополнительного кода на C</VAR> в точности копируется в конец
файла анализатора, точно так же, как секция <VAR>объявлений C</VAR> в начало.
Это наиболее удобное место, чтобы поместить что-либо, что вы хотите иметь
в файле анализатора, но что не нужно помещать перед определением
<CODE>yyparse</CODE>.  Например, сюда часто помещаются определения <CODE>yylex</CODE> и
<CODE>yyerror</CODE>.  См. раздел <A HREF="bison_7.html#SEC68">5. Интерфейс анализатора на C</A>.


<P>
Если последняя секция пуста, вы можете опустить <SAMP>`%%'</SAMP>, отделяющее её от
правил грамматики.


<P>
Сам анализатор Bison содержит множество статических переменных с именами,
начинающимися с <SAMP>`yy'</SAMP>, и макросов с именами, начинающимися с <SAMP>`YY'</SAMP>.
Не использовать такие имена, за исключением описанных в этом руководстве, в
секции дополнительного кода C файла грамматики -- хорошая идея.




<H2><A NAME="SEC45">4.2 Символы, терминальные и нетерминальные</A></H2>
<P>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>
<A NAME="IDX75"></A>


<P>
<EM>Символы</EM> в грамматиках Bison представялют грамматическую классификацию
языка.


<P>
<EM>Терминальный символ</EM> (также известный как <EM>тип лексемы</EM>) представляет
класс синтаксически эквивалентных лексем.  Вы используете такой символ в
правилах грамматики, чтобы обозначить, что допустима лексема этого класса.
В анализаторе Bison символ представляется числовым кодом, и функция
<CODE>yylex</CODE> возвращает код типа лексемы чтобы показать, лексема какого вида
прочитана.  Вам не нужно знать, каково значение кода, для его обозначения
можно использовать сам символ.


<P>
<EM>Нетерминальный символ</EM> обозначает класс синтаксически эквивалентных групп.
Имя символа используется при написании правил грамматики. По соглашению оно
должно быть записано в нижнем регистре.


<P>
Имена символов могут содержать буквы, цифры (но не начинаться с цифры), знаки
подчёркивания и точки.  Точки имеют значение только в нетерминалах.


<P>
Есть три способа записи терминальных символов в грамматике:



<UL>
<LI>

<EM>Именованный тип лексемы</EM> записывается идентификатором, как идентификаторы
C.  По соглашению он должен быть записан в верхнем регистре.  Каждое такое имя
должно быть определено в объявлении Bison, например, <CODE>%token</CODE>.  
См. раздел <A HREF="bison_6.html#SEC59">4.7.1 Имена типов лексем</A>.

<LI>

<A NAME="IDX76"></A>
<A NAME="IDX77"></A>
<EM>Тип однолитерной лексемы</EM> (<EM>лексема-однолитерная константа</EM>)
записывается в грамматике с использованием того же синтаксиса, что
используется в C для литерных констант: например, <CODE>'+'</CODE> -- это
тип однолитерной лексемы.  Тип однолитерной лексемы не надо объявлять,
если только вам не нужно задать тип его семантического значения (см. раздел <A HREF="bison_6.html#SEC49">4.5.1 Типы данных семантических значений</A>), ассоциативность или
приоритет (см. раздел <A HREF="bison_8.html#SEC80">6.3 Приоритет операций</A>).

По соглашению тип однолитерной лексемы используется только для представления
лексемы, состоящей из этой конкретной литеры.  Так, тип лексемы <CODE>'+'</CODE>
используется для представления литеры <SAMP>`+'</SAMP> в качестве лексемы.  Ничто
не обязывает вас придерживаться этого соглашения, но если вы не будете этого
делать, ваша программа будет путать других читателей.

В Bison также могут быть использованы все обычные escape-последовательности,
использующиеся в литерных константах C, но вы не должны использовать нулевой
символ в качестве однолитерной константы, поскольку его код ASCII -- ноль --
это код, возвращаемый <CODE>yylex</CODE> при обнаружении конца файла.
(см. раздел <A HREF="bison_7.html#SEC71">5.2.1 Соглашения о вызове <CODE>yylex</CODE></A>).

<LI>

<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<EM>Строковый литерал (строковая лексема)</EM> записывается как строковая
константа C: например, строковым литералом является <CODE>"&#60;="</CODE>.  Строковый
литерал не надо объявлять, если только вам не нужно задать тип его
семантического значения (см. раздел <A HREF="bison_6.html#SEC49">4.5.1 Типы данных семантических значений</A>), ассоциативность или приоритет
(см. раздел <A HREF="bison_8.html#SEC80">6.3 Приоритет операций</A>).

Вы можете связать строковую лексему с символическим именем (псевдонимом),
используя объявление <CODE>%token</CODE> (см. раздел <A HREF="bison_6.html#SEC59">4.7.1 Имена типов лексем</A>).  Если вы не сделали этого, лексический анализатор должен отыскать
номер строковой лексемы  в таблице <CODE>yytname</CODE> (см. раздел <A HREF="bison_7.html#SEC71">5.2.1 Соглашения о вызове <CODE>yylex</CODE></A>).

<STRONG>ВНИМАНИЕ:</STRONG> В Yacc строковые лексемы не работают.

По соглашению строковые лексемы используются только для представления
лексемы, состоящей из этой конкретной строки.   Так, тип лексемы <CODE>"&#60;="</CODE>
используется для представления строки <SAMP>`&#60;='</SAMP> в качестве лексемы.  Bison
не обязывает вас придерживаться этого соглашения, но если вы не будете этого
делать, люди, читающие вашу программу, запутаются.

В Bison также могут быть использованы все escape-последовательности,
использующиеся в строковых константах C.  Строковая лексема должна содержать
две или более литеры, для лексем из одной литеры используйте однолитерные
лексемы (см. выше).
</UL>

<P>
Выбранный вами способ записи терминального символа не влияет на его
грамматический смысл.  Оно зависит только от того, где он встречается в
правилах, и когда функция анализатора его возвращает.


<P>
Значение, возвращаемое <CODE>yylex</CODE>, -- всегда один из терминальных символов
(или 0 в случае конца входного текста).  Каким бы способом вы не записывали
тип лексемы в правилах грамматики, в определениия <CODE>yylex</CODE> он должен
быть описан тем же образом.  Числовой код типа однолитерной лексемы -- это
просто код ASCII этой литеры, и таким образом <CODE>yylex</CODE> может для
получения необходимого кода использовать ту же литерную константу.  Каждый
именованный тип лексемы в файле анализатора становится макросом C, и
<CODE>yylex</CODE> может для обозначения кода использовать то же имя (именно поэтому
точки в терминальных символах не имеют значения).  См. раздел <A HREF="bison_7.html#SEC71">5.2.1 Соглашения о вызове <CODE>yylex</CODE></A>.


<P>
Если <CODE>yylex</CODE> определяется в отдельном файле, вам необходимо сделать
доступными ей макроопределения типов лексем.  Используйте параметр <SAMP>`-d'</SAMP>
при запуске Bison, и эти макроопределения будут записаны в отдельный файл
заголовка <TT>`<VAR>имя</VAR>.tab.h'</TT>, который вы можете включать в другие
нуждающиеся в нём файлы исходного кода.  См. раздел <A HREF="bison_12.html#SEC96">10. Вызов Bison</A>.


<P>
Символ <CODE>error</CODE> -- это терминальный символ, зарезервированный для
восстановления после ошибок. Вы не должны использовать его для каких-то
других целей.  В частности, <CODE>yylex</CODE> никогда не должна возвращать это
значение.




<H2><A NAME="SEC46">4.3 Синтаксис правил грамматики</A></H2>
<P>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>


<P>
Правило грамматики Bison имеет следующий общий вид:



<PRE>
<VAR>результат</VAR>: <VAR>компоненты</VAR>...
        ;
</PRE>

<P>
где <VAR>результат</VAR> -- это описываемый правилом нетерминальный символ, а
<VAR>компоненты</VAR> -- различные терминальные и нетерминальные символы,
объединяемые этим правилом (см. раздел <A HREF="bison_6.html#SEC45">4.2 Символы, терминальные и нетерминальные</A>).


<P>
Например:



<PRE>
exp:      exp '+' exp
        ;
</PRE>

<P>
говорит о том, что две группы типа <CODE>exp</CODE> и лексема <SAMP>`+'</SAMP> между ними
могут быть объединены в более крупную группу типа <CODE>exp</CODE>.


<P>
Пробельные литеры в правилах только разделяют символы.  Вы можете по своему
усмотрению вставлять дополнительные промежутки.


<P>
Между компонентами могут быть разбросаны <VAR>действия</VAR>, определяющие
семантику правила.  Действие выглядит так:



<PRE>
{<VAR>операторы C</VAR>}
</PRE>

<P>
Обычно в правиле только одно действие, и оно следует после всех компонентов.
См. раздел <A HREF="bison_6.html#SEC51">4.5.3 Действия</A>.


<P>
<A NAME="IDX84"></A>
Для одного <VAR>результата</VAR> можно написать несколько правил, отдельно или же
соединённых литерой вертикальной черты <SAMP>`|'</SAMP> как здесь:



<PRE>
<VAR>результат</VAR>:    <VAR>компоненты первого правила</VAR>...
        | <VAR>компоненты второго правила</VAR>...
        ...
        ;
</PRE>

<P>
В любом случае правила рассматриваются как различные, даже если они таким
образом объединены.


<P>
Есть в правиле нет <VAR>компонентов</VAR>, это означает, что <VAR>результат</VAR> может
соответствовать пустой строке.  Например, вот как определяется 
последовательность нуля или более групп <CODE>exp</CODE>, разделённых запятыми:



<PRE>
expseq:   /* пусто */
        | expseq1
        ;

expseq1:  exp
        | expseq1 ',' exp
        ;
</PRE>

<P>
Традиционно в каждом правиле, не содержащем компонентов, пишется комментарий
<SAMP>`/* пусто */'</SAMP>.




<H2><A NAME="SEC47">4.4 Рекурсивные правила</A></H2>
<P>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>


<P>
Правило называется <EM>рекурсивным</EM>, если нетерминал его <VAR>результата</VAR>
появляется также в его правой части.  Почти все грамматики Bison должны
использовать рекурсию, потому что это единственный способ определить
последовательность из произвольного числа элементов.  Рассмотрим рекурсивное
определение последовательности одного или более выражений, разделённых
запятыми:



<PRE>
expseq1:  exp
        | expseq1 ',' exp
        ;
</PRE>

<P>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>


<P>
Поскольку рекурсивный символ <CODE>expseq1</CODE> -- самый левый в правой части,
мы называем это <EM>левой рекурсией</EM>.  И наоборот, вот та же конструкция,
определённая с использованием <EM>правой рекурсии</EM>:



<PRE>
expseq1:  exp
        | exp ',' expseq1
        ;
</PRE>

<P>
Последовательность любого вида может быть определена с использованием как
левой, так и правой рекурсии, но вам следует всегда использовать
леворекурсивные правила, потому что они могут разобрать последовательность
из любого числа элементов, используя ограниченое стековое пространство. Размер
используемого праворекурсивными правилами стека Bison пропорционален числу
элементов последовательности, поскольку все эти элементы должны быть помещены 
в стек перед тем, как правило будет применено в первый раз. См. раздел <A HREF="bison_8.html#SEC77">6. Алгоритм анализатора Bison</A>, по поводу дальнейшего объяснения этого факта.


<P>
<A NAME="IDX89"></A>
<EM>Косвенная</EM> или <EM>взаимная</EM> рекурсия возникает, когда результат правила
не появляется непосредственно в правой части, но встречается в правилах для
других нетерминалов, появляющихся в его правой части.


<P>
Например:



<PRE>
expr:     primary
        | primary '+' primary
        ;

primary:  constant
        | '(' expr ')'
        ;
</PRE>

<P>
определяет два взаимнорекурсивных правила, поскольку каждое из них ссылается
на другое.




<H2><A NAME="SEC48">4.5 Определение семантики языка</A></H2>
<P>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>


<P>
Правила грамматики языка определяют только его синтаксис.  Семантика
определяется семантическими значениями, сопоставленными различным лексемам и
группам, и правилами, выполняющимися при распознавании различных групп.


<P>
Например, калькулятор производит правильные вычисления, потому что с каждым
выражением сопоставлено числовое значение. Он правильно складывает, потому что
действие для группы <SAMP>`<VAR>x</VAR> + <VAR>y</VAR>'</SAMP> складывает числа,
сопоставленные с <VAR>x</VAR> и <VAR>y</VAR>.




<H3><A NAME="SEC49">4.5.1 Типы данных семантических значений</A></H3>
<P>
<A NAME="IDX93"></A>
<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>


<P>
В простой программе может быть достаточно использование одного и того же типа
данных для семантических значений всех языковых конструкций.  Это верно для
примеров постфиксного и инфиксного калькулятора (см. раздел <A HREF="bison_5.html#SEC17">3.1 Калькулятор обратной польской нотации</A>).


<P>
По умолчанию Bison использует для всех семантических значений тип <CODE>int</CODE>.
Чтобы задать другой тип, определите макрос <CODE>YYSTYPE</CODE>, как здесь:



<PRE>
#define YYSTYPE double
</PRE>

<P>
Это макроопределение должно находиться в секции объявлений C файла грамматики
(см. раздел <A HREF="bison_6.html#SEC40">4.1 Структура грамматики Bison</A>).




<H3><A NAME="SEC50">4.5.2 Несколько типов значений</A></H3>

<P>
В большинстве программ вам будут нужны разные типы данных для разных видов
лексем и групп.  Например, числовой константе может быть нужен тип <CODE>int</CODE>
или <CODE>long</CODE>, строковой -- тип <CODE>char *</CODE>, а идентификатору -- указатель
на элемент таблицы символов.


<P>
Чтобы в анализаторе можно было использовать несколько типов семантических
значений, Bison требует сделать две вещи:



<UL>
<LI>

Задать весь набор возможных типов данных в объявлении Bison <CODE>%union</CODE>
(см. раздел <A HREF="bison_6.html#SEC61">4.7.3 Набор типов значений</A>).

<LI>

Выбрать для каждого символа (терминального или нетерминального), для которого
используются семантическое значение, один из этих типов.  Для лексем это
делается в объявлении Bison <CODE>%token</CODE> (см. раздел <A HREF="bison_6.html#SEC59">4.7.1 Имена типов лексем</A>), а для групп -- в объявлении Bison <CODE>%type</CODE> 
(см. раздел <A HREF="bison_6.html#SEC62">4.7.4 Нетерминальные символы</A>).
</UL>



<H3><A NAME="SEC51">4.5.3 Действия</A></H3>
<P>
<A NAME="IDX97"></A>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>


<P>
Действие сопровождает синтаксическое правило и содержит код на C, который
должен выполняться при каждом распознавании текста, соответствующего этому
правилу.  Задачей большинства действий является вычисление семантического
значения группы, собираемой правилом, исходя из семантических значений,
сопоставленных лексемам или меньшим группам.


<P>
Действие состоит из операторов C, окружённых фигурными скобками, как составной
оператор C.  Оно может быть помещено в любой точке правила, и выполняется в
этой точке.  Большинство правил имеют только одно действие в конце правила,
после всех компонентов.  Действия внутри правила непросты, и используются
только в специальных целях (см. раздел <A HREF="bison_6.html#SEC53">4.5.5 Действия внутри правил</A>).


<P>
Код на C действия может ссылаться на семантические значения компонентов,
связываемых правилом с помощью конструкции <CODE>$<VAR>n</VAR></CODE>, обозначающей
значение <VAR>n</VAR>-го компонента.  Семантическое значение собираемой группы --
<CODE>$$</CODE>  (Bison, копируя действия в файл анализатора, превращает обе
эти конструкции в ссылки на элементы массива).


<P>
Вот типичный пример:



<PRE>
exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }
</PRE>

<P>
Это правило собирает <CODE>exp</CODE> из двух меньших групп <CODE>exp</CODE>, соединённых
лексемой `знак плюс'.  В действии <CODE>$1</CODE> и <CODE>$3</CODE> ссылаются на
семантические значения двух групп-компонентов <CODE>exp</CODE>, являющихся первым
и третьим символами в правой части правила.  Сумма сохраняется в <CODE>$$</CODE>,
становясь тем самым семантическим значением выражения сложения, только что
распознанного правилом.  Если бы с лексемой <SAMP>`+'</SAMP> было сопоставлено полезное
семантическое значение, на него можно было бы ссылаться как на <CODE>$2</CODE>.


<P>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
Если вы не задаёте действие для правила, Bison применяет действие по умолчанию:
<CODE>$$ = $1</CODE>.  То есть значение первого символа правила становится
значением всего правила.  Конечно, действие по умолчанию допустимо только если
эти два типа данных соответствуют друг другу.  Для пустого правила нет
осмысленного действия по умолчанию, каждое пустое правило должно иметь явное
действие, за исключением случая, когда его значение никогда не будет
использоваться.


<P>
<CODE>$<VAR>n</VAR></CODE> c нулевым или отрицательным <VAR>n</VAR> допустима для ссылки на
лексемы и группы, находящиеся в стеке <EM>перед</EM> соответствующими текущему
правилу лексемами и группами.  Это очень рискованный приём, и чтобы надёжно
пользоваться им, вы должны быть уверены, что знаете контекст применения
правила.  Вот случай, в котором вы можете безопасно использовать его:



<PRE>
foo:      expr bar '+' expr  { ... }
        | expr bar '-' expr  { ... }
        ;

bar:      /* пусто */
 */
        { previous_expr = $0; }
        ;
</PRE>

<P>
Пока <CODE>bar</CODE> используется только так, как здесь показано, <CODE>$0</CODE> всегда
будет ссылаться на <CODE>expr</CODE>, предшествующий <CODE>bar</CODE> в определении
<CODE>foo</CODE>.




<H3><A NAME="SEC52">4.5.4 Типы данных значений в действиях</A></H3>
<P>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>


<P>
Если вы выбрали единственный тип данных семантических значений, конструкции
<CODE>$$</CODE> и <CODE>$<VAR>n</VAR></CODE> всегда имеют этот тип.


<P>
Если вы используете <CODE>%union</CODE> для задания множества типов данных, вы
должны определить выбор из этих типов для каждого терминального или
нетерминального символа, который может иметь семантическое значение.  Тогда
каждый раз, когда вы используете <CODE>$$</CODE> или <CODE>$<VAR>n</VAR></CODE>, тип данных
определяется тем, на какой символ в правиле они ссылаются.  В этом примере,



<PRE>
exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }
</PRE>

<P>
<CODE>$1</CODE> и <CODE>$3</CODE> ссылаются на экземпляры <CODE>exp</CODE>, поэтому все они имеют
тип данных, объявленный для нетерминального символа <CODE>exp</CODE>.  Если бы
использовался <CODE>$2</CODE>, то он имел бы тип данных, объявленный для
терминального символа <CODE>'+'</CODE>, каким бы он ни был.


<P>
Вместо этого вы можете указывать тип данных, когда вы ссылаетесь на значение,
вставляя <SAMP>`&#60;<VAR>тип</VAR>&#62;'</SAMP> после <SAMP>`$'</SAMP> в начале ссылки.  Например, если
вы определите типы так:



<PRE>
%union {
  int itype;
  double dtype;
}
</PRE>

<P>
вы можете написать <CODE>$&#60;itype&#62;1</CODE> чтобы сослаться на первый компонент правила
как на целое, или <CODE>$&#60;dtype&#62;1</CODE> -- чтобы сослаться как на вещественное число
с двойной точностью.




<H3><A NAME="SEC53">4.5.5 Действия внутри правил</A></H3>
<P>
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>


<P>
Время от времени полезно помещать действия внутрь правила.  Эти действия
записываются точно так же, как обычные действия в конце правил, но выполняются
до того, как анализатор распознает следующие компоненты.


<P>
Действие внутри правила может с помощью <CODE>$<VAR>n</VAR></CODE> ссылаться на
компоненты, предшествующие ему, но не на последующие, поскольку выполняется до
их разбора.


<P>
Действие внутри правила само по себе считается одним из компонентов правила.
Это имеет значение, если позднее в том же правиле присутствует ещё одно
действие (и, обычно, ещё одно в конце правила): вы должны при вычислении
<VAR>n</VAR> в конструкции <CODE>$<VAR>n</VAR></CODE> учитывать действия вместе с правилами.


<P>
Действие внутри правила также имеет семантическое значение.  Действие может
установить его значение присваиванием <CODE>$$</CODE>, а последующие действия в
правиле могут ссылаться на него, используя <CODE>$<VAR>n</VAR></CODE>.  Поскольку для
именования действия нет символа, нет способа объявить заранее тип данных его
значения, поэтому вы должны использовать конструкцию <SAMP>`$&#60;...&#62;<VAR>n</VAR>'</SAMP>
для задания типа данных каждый раз, когда вы ссылаетесь на это значение.


<P>
Установить значение всего правила действием внутри правила невозможно,
поскольку присваивание <CODE>$$</CODE> не будет этого делать.  Единственный способ
задать значение всего правила -- использовать обычное действие в конце
правила.


<P>
Приведём пример гипотетического компилятора, обрабатывающего оператор
<CODE>let</CODE>, имеющий вид: <SAMP>`let (<VAR>переменная</VAR>) <VAR>оператор</VAR>'</SAMP> и
позволяющий создать переменную <VAR>переменная</VAR> только на время выполнения
<VAR>оператора</VAR>.  Для разбора этой конструкции мы должны поместить
<VAR>переменную</VAR> в таблицу символов на время разбора <VAR>оператора</VAR>, а после
этого удалить её.  Вот, как это делается:



<PRE>
stmt:   LET '(' var ')'
                { $&#60;context&#62;$ = push_context ();
                  declare_variable ($3); }
        stmt    { $$ = $6;
                  pop_context ($&#60;context&#62;5); }
</PRE>

<P>
Как только распознано <SAMP>`let (<VAR>переменная</VAR>)'</SAMP>, выполняется первое
действие.  Оно сохраняет копию текущего семантического контекста (список
доступных переменных) в качестве своего семантического значения, используя
вариант типа данных <CODE>context</CODE>.  Потом оно вызывает
<CODE>declare_variable</CODE>, чтобы добавить в этот список новую переменную.  Когда
работа первого действия завершена, может быть разобран вложенный оператор
<CODE>stmt</CODE>.  Имейте в виду, что действие внутри правила -- это пятый
компонент, поэтому <SAMP>`stmt'</SAMP> -- шестой.


<P>
После разбора вложенного оператора его семантическое значение становится
значением всего оператора <CODE>let</CODE>.  Потом для восстановления прошлого списка
переменных используется семантическое значение предыдущего действия.  Это
удалит из списка временную <CODE>let</CODE>-переменную, и она не будет существовать
во время разбора остальной части программы.


<P>
Применение действий до того, как правило полностью распознано, часто приводит
к конфликтам, поскольку анализатор должен принять определённый вариант разбора
чтобы обработать действие.  Например, следующие два правила без внутреннего
действия могут сушествовать совместно в работающем анализаторе, потому что
анализатор может сдвинуть лексему открывающей фигурной скобки и посмотреть, что
следует за ней, перед принятием решения, есть там объявление или нет.



<PRE>
compound: '{' declarations statements '}'
        | '{' statements '}'
        ;
</PRE>

<P>
Но если мы добавим внутреннее действие, как показано ниже, правила перестанут
работать:



<PRE>
compound: { prepare_for_local_variables (); }
          '{' declarations statements '}'
        | '{' statements '}'
        ;
</PRE>

<P>
Теперь анализатор вынужден решать, запускать или нет внутреннее действие, когда
он прочитал ещё только открывающую скобку.  Другими словами, он должен принять
решение об использовании того или иного правила, не имея информации,
достаточной для того, чтобы сделать это правильно (лексема открывающей фигурной
скобки в этот момент -- это то, что называется лексемой, <EM>увиденной
впереди</EM>, поскольку анализатор всё ещё решает, что с ней делать.
См. раздел <A HREF="bison_8.html#SEC78">6.1 Предпросмотренные лексемы</A>.).


<P>
Вы можете думать, что можно решить проблему, расположив в обоих правилах
одинаковые действия, как здесь:



<PRE>
compound: { prepare_for_local_variables (); }
          '{' declarations statements '}'
        | { prepare_for_local_variables (); }
          '{' statements '}'
        ;
</PRE>

<P>
Но это не поможет, потому что Bison не осознает, что эти два действия
идентичны (Bison никогда не пытается понимать код на C в действиях).


<P>
Если грамматика такова, что определение можно отличить от оператора по первой
лексеме (что верно для C), то одним из работающих решений будет поместить
действие после открывающей скобки, как здесь:



<PRE>
compound: '{' { prepare_for_local_variables (); }
          declarations statements '}'
        | '{' statements '}'
        ;
</PRE>

<P>
Теперь первая лексема следующего определения или оператора, которая в любом
случае должна сообщить Bison, какое правило использовать, действительно может
это сделать.


<P>
Другое решение -- вынести действие в отдельный нетерминальный символ,
служащий подпрограммой:



<PRE>
subroutine: /* пусто */
          { prepare_for_local_variables (); }
        ;

compound: subroutine
          '{' declarations statements '}'
        | subroutine
          '{' statements '}'
        ;
</PRE>

<P>
Теперь Bison может выполнить действие в правиле для <CODE>subroutine</CODE>, не
принимая решения, какое из правил для <CODE>compound</CODE> использовать в конце
концов.  Имейте в виду, что действие теперь находится в конце правила.  Любые
действия внутри правил могут быть таким образом превращены в действия в конце
правил, и именно это Bison на самом деле делает для реализации действий внутри
правил.




<H2><A NAME="SEC54">4.6 Отслеживание положений</A></H2>
<P>
<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>


<P>
Хотя правил грамматики и семантических действий и достаточно, чтобы написать
полностью функциональный анализатор, может быть полезно обрабатывать некоторую
дополнительную информацию, особенно положение символов.


<P>
Способ обработки положений определяется указанием типа данных и действия,
которые должны выполняться при разборе правил.




<H3><A NAME="SEC55">4.6.1 Тип данных положений</A></H3>
<P>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<A NAME="IDX111"></A>


<P>
Определение типа данных для положений гораздо проще, чем для семантических
значений, поскольку все лексемы и группы всегда используют один и тот же тип.


<P>
Тип положений задаётся определением макроса <CODE>YYLTYPE</CODE>. Если <CODE>YYLTYPE</CODE>
не определён, Bison по умолчанию использует структуру из четырёх членов:



<PRE>
struct
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
}
</PRE>



<H3><A NAME="SEC56">4.6.2 Действия и положения</A></H3>
<P>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>


<P>
Действия полезны не только для определения семантики языка, но и для описания
поведения анализатора, касающегося положений.


<P>
Наиболее очевидный способ получения положения синтаксической группы очень
похож на способ вычисления семантических значений.  Для получения доступа в
конкретном правиле к связываемым элементам может использоваться несколько
конструкций.  Положение <VAR>n</VAR>-го компонента правой части правила обозначается
<CODE>@<VAR>n</VAR></CODE>, а положение группы левой части -- <CODE>@$</CODE>.


<P>
Вот простой пример, использующий для положений тип данных по умолчанию:



<PRE>
exp:    ...
        | exp '/' exp
            {
              @$.first_column = @1.first_column;
              @$.first_line = @1.first_line;
              @$.last_column = @3.last_column;
              @$.last_line = @3.last_line;
              if ($3)
                $$ = $1 / $3;
              else
                {
                  $$ = 1;
                  printf("Деление на ноль, l%d,c%d-l%d,c%d",
                         @3.first_line, @3.first_column,
                         @3.last_line, @3.last_column);
                }
            }
</PRE>

<P>
Как и для семантических значений, есть действие по умолчанию для положений,
выполняемое при каждом разборе правила.  Оно устанавливает начало <CODE>@$</CODE>
на начало первого символа, а конец -- на конец последнего символа.


<P>
При использовании действия по умолчанию отслеживание положений может быть
полностью автоматическим.  Вышеприведённый пример можно переписать так:



<PRE>
exp:    ...
        | exp '/' exp
            {
              if ($3)
                $$ = $1 / $3;
              else
                {
                  $$ = 1;
                  printf("Деление на ноль, l%d,c%d-l%d,c%d",
                         @3.first_line, @3.first_column,
                         @3.last_line, @3.last_column);
                }
            }
</PRE>



<H3><A NAME="SEC57">4.6.3 Действие по умолчанию для положений</A></H3>
<P>
<A NAME="IDX116"></A>


<P>
На самом деле действия -- не лучшее место для вычисления положений.  Поскольку
положения гораздо более общи, чем семантические значения, в анализаторе есть
место, где можно переопределить действие по умолчанию для каждого правила.
Макрос <CODE>YYLLOC_DEFAULT</CODE> вызывается при каждом разборе правила, перед
запуском связанного с ним действия.


<P>
В большинстве случаев этого макроса, в общем, достаточно, чтобы избавиться от
специального кода в семантических действиях.


<P>
Макрос <CODE>YYLLOC_DEFAULT</CODE> принимает три параметра.  Первый  -- положение
группы (результат вычисления).  Второй -- массив, содержащий положения всех
элементов правой части связываемого правила.  Последний -- размер правой части
правила.


<P>
По умолчанию он определён следующим образом:



<PRE>
#define YYLLOC_DEFAULT(Current, Rhs, N)         \
  Current.last_line   = Rhs[N].last_line;       \
  Current.last_column = Rhs[N].last_column;
</PRE>

<P>
При определении <CODE>YYLLOC_DEFAULT</CODE> вы должны считать, что:



<UL>
<LI>

У аргументов нет побочных действий.  Однако, <CODE>YYLLOC_DEFAULT</CODE> может
изменять только первый из них (результат). 

<LI>

Перед выполнением <CODE>YYLLOC_DEFAULT</CODE> анализатор устанавливает <CODE>@$</CODE>
равным <CODE>@1</CODE>.

<LI>

Для обеспечения последовательности с реализацией семантических действий,
правильные индексы массива -- от 1 до <VAR>n</VAR>.
</UL>



<H2><A NAME="SEC58">4.7 Объявления Bison</A></H2>
<P>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>


<P>
Секция <EM>объявлений Bison</EM> грамматики Bison определяет символы, используемые
при формулировке грамматики и типы данных семантических значений.
См. раздел <A HREF="bison_6.html#SEC45">4.2 Символы, терминальные и нетерминальные</A>.


<P>
Все имена типов лексем (но не однолитерные лексемы, такие как <CODE>'+'</CODE> и
<CODE>'*'</CODE>) должны быть объявлены.  Нетерминальные символы должны быть
объявлены, если вам нужно задать используемый тип данных семантического
значения (см. раздел <A HREF="bison_6.html#SEC50">4.5.2 Несколько типов значений</A>).


<P>
По умолчанию первое правило файла также задаёт начальный символ.  Если вы
хотите, чтобы начальным символом был какой-то другой, вы должны объявить его
явно (см. раздел <A HREF="bison_4.html#SEC8">2.1 Языки и контекстно-свободные грамматики</A>).




<H3><A NAME="SEC59">4.7.1 Имена типов лексем</A></H3>
<P>
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>


<P>
Основной способ объявления имени типа лексемы (терминального символа)
следующий:



<PRE>
%token <VAR>имя</VAR>
</PRE>

<P>
В анализаторе Bison превратит это в директиву <CODE>#define</CODE>, так что функция
<CODE>yylex</CODE> (если она присутствует в файле) сможет использовать имя <VAR>имя</VAR>
для обозначения кода этого типа лексемы.


<P>
Если вы хотите задать ассоциативность и приоритет, вместо <CODE>%token</CODE> вы
можете использовать <CODE>%left</CODE>, <CODE>%right</CODE> или <CODE>%nonassoc</CODE>.
См. раздел <A HREF="bison_6.html#SEC60">4.7.2 Приоритет операций</A>.


<P>
Вы можете явно задать числовой код типа лексемы, добавив целочисленное значение
непосредственно после имени лексемы:



<PRE>
%token NUM 300
</PRE>

<P>
Тем не менее, в общем случае лучше позволить Bison определить числовые коды для
всех типов лексем самому.  Bison автоматически выберет коды, не конфликтующие
друг с другом и с литерами ASCII.


<P>
В случае, если тип значения -- объединение, вы дожны включить в <CODE>%token</CODE>
или другие объявления лексем тип данных, заключённый в угловые скобки
(см. раздел <A HREF="bison_6.html#SEC50">4.5.2 Несколько типов значений</A>).


<P>
Например:



<PRE>
%union {              /* определение набора типов */
  double val;
  symrec *tptr;
}
%token &#60;val&#62; NUM      /* определение лексемы NUM и её типа */
</PRE>

<P>
Вы можете связать строковую лексему с именем типа лексемы, записав строку
в конце объявления <CODE>%token</CODE>, объявляющего это имя.  Например:



<PRE>
%token arrow "=&#62;"
</PRE>

<P>
Например, грамматика языка C может задавать такие имена и соответствующие
строковые лексемы:



<PRE>
%token  &#60;operator&#62;  OR      "||"
%token  &#60;operator&#62;  LE 134  "&#60;="
%left  OR  "&#60;="
</PRE>

<P>
После того, как вы сопоставили друг с другом строку и тип лексемы, они
становятся взаимозаменяемы в дальнейших объявлениях или правилах грамматики.
Функция <CODE>yylex</CODE> может использовать имя лексемы или строку для получения
числового кода типа лексемы (см. раздел <A HREF="bison_7.html#SEC71">5.2.1 Соглашения о вызове <CODE>yylex</CODE></A>).




<H3><A NAME="SEC60">4.7.2 Приоритет операций</A></H3>
<P>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<A NAME="IDX126"></A>


<P>
Для одновременного объявления лексемы и задания её приоритета и ассоциативности
используйте объявления <CODE>%left</CODE>, <CODE>%right</CODE> или <CODE>%nonassoc</CODE>.  Они
называются <EM>объявлениями приоритета</EM>.
См. раздел <A HREF="bison_8.html#SEC80">6.3 Приоритет операций</A>, для общей информации о приоритете
операций.


<P>
Синтаксис объявления приоритета тот же, что и <CODE>%token</CODE>: или



<PRE>
%left <VAR>символы</VAR>...
</PRE>

<P>
или



<PRE>
%left &#60;<VAR>тип</VAR>&#62; <VAR>символы</VAR>...
</PRE>

<P>
В самом деле, любое из этих определений служит тем же целям, что и
<CODE>%token</CODE>. Но кроме того, они задают ассоциативность и относительный
приоритет всех <VAR>символов</VAR>:



<UL>
<LI>

Ассоциативность операции <VAR>op</VAR> определяет разбор повторяющихся операторов:
будут ли при разборе <SAMP>`<VAR>x</VAR> <VAR>op</VAR> <VAR>y</VAR> <VAR>op</VAR> <VAR>z</VAR>'</SAMP> вначале
сгруппированы <VAR>x</VAR> и <VAR>y</VAR>, или же <VAR>y</VAR> и <VAR>z</VAR>.  <CODE>%left</CODE>
задаёт левую ассоциативность (вначале группируются <VAR>x</VAR> и <VAR>y</VAR>), а
<CODE>%right</CODE> -- правую (наоборот, <VAR>y</VAR> и <VAR>z</VAR>).  <CODE>%nonassoc</CODE> задаёт
неассоциативную операцию, т.е. <SAMP>`<VAR>x</VAR> <VAR>op</VAR> <VAR>y</VAR> <VAR>op</VAR> <VAR>z</VAR>'</SAMP>
рассматривается как синтаксическая ошибка.

<LI>

Приоритет операции определяет, как она соотносится с другими операциями.
Все лексемы, объявленные в одном объявлении приоритета, имеют одинаковый
приоритет, и разбираются вместе в соответствии с их ассоциативностью.  При
объединении двух лексем, объявленных в разных объявлениях приоритета,
объявленная позднее имеет более высокий приоритет и группируется раньше.
</UL>



<H3><A NAME="SEC61">4.7.3 Набор типов значений</A></H3>
<P>
<A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>


<P>
Объявление <CODE>%union</CODE> задаёт весь набор возможных типов данных семантических
значений.  За ключевым словом <CODE>%union</CODE> следуют фигурные скобки, содержимое
которых имеет тот же вид, что и содержимое структуры <CODE>union</CODE> C.


<P>
Например:



<PRE>
%union {
  double val;
  symrec *tptr;
}
</PRE>

<P>
Это объявление говорит о том, что есть два альтернативных типа: <CODE>double</CODE> и
<CODE>symrec *</CODE>.  Им даны имена <CODE>val</CODE> и <CODE>tptr</CODE>, эти имена
используются в объявлениях <CODE>%token</CODE> и <CODE>%type</CODE> для указать одного из
этих типов для терминального или нетерминального символа (см. раздел <A HREF="bison_6.html#SEC62">4.7.4 Нетерминальные символы</A>).


<P>
Имейте в виду, что, в отличие от объявления <CODE>union</CODE> в C, вы не ставите
точку с запятой после закрывающей фигурной скобки.




<H3><A NAME="SEC62">4.7.4 Нетерминальные символы</A></H3>
<P>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
<A NAME="IDX132"></A>


<P>
Если вы используете <CODE>%union</CODE> для задания множества типов значений, вы
должны объявить тип значения каждого нетерминального символа, семантическое
значение которого используется.  Это делает объявление <CODE>%type</CODE>:



<PRE>
%type &#60;<VAR>тип</VAR>&#62; <VAR>нетерминал</VAR>...
</PRE>

<P>
Здесь <VAR>нетерминал</VAR> -- имя нетерминального символа, а <VAR>тип</VAR> -- имя,
данное в <CODE>%union</CODE> желаемой альтернативе (см. раздел <A HREF="bison_6.html#SEC61">4.7.3 Набор типов значений</A>).  Вы можете задать в одном объявлении <CODE>%type</CODE> любое
количество нетерминальных символов, если у них одинаковый тип значения.  Для
разделения между собой имён символов используйте пробелы.


<P>
Вы можете также объявить тип значения терминального символа.  Для этого
используйте ту же конструкцию <CODE>&#60;<VAR>тип</VAR>&#62;</CODE> в объявлении терминального
символа.  Все варианты объявления лексемы допускают наличие <CODE>&#60;<VAR>тип</VAR>&#62;</CODE>.




<H3><A NAME="SEC63">4.7.5 Подавление сообщений о конфликтах</A></H3>
<P>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<A NAME="IDX137"></A>


<P>
В норме Bison сообщает, если в грамматике есть какие-либо конфликты
(см. раздел <A HREF="bison_8.html#SEC79">6.2 Конфликты сдвиг/свёртка</A>), но большинство реальных
грамматик содержат безвредные конфликты сдвиг/свёртка, разрешаемые
предсказуемым образом, и которые сложно исключить.  Желательно подавить
сообщения об этих конфликтах, пока их число не изменяется.  Вы можете сделать
это объявлением <CODE>%expect</CODE>.


<P>
Это объявление выглядит так:



<PRE>
%expect <VAR>n</VAR>
</PRE>

<P>
Здесь <VAR>n</VAR> -- десятичное целое число.  Это объявление говорит, что не нужно
выдавать предупреждений, если грамматика содержит <VAR>n</VAR> конфликтов
сдвиг/свёртка и не содержит конфликтов свёртка/свёртка.  Если конфликтов меньше
или больше, или если есть конфликты свёртка/свёртка, вместо обычного
предупреждения выдаётся сообщение об ошибке.


<P>
В общем случае использование <CODE>%expect</CODE> включает следующие этапы:



<UL>
<LI>

Скомпилируйте вашу грамматику без <CODE>%expect</CODE>.  Используйте параметр
<SAMP>`-v'</SAMP> чтобы получить подробный список конфликтов и мест их возникновения.
Bison также выведет число конфликтов.

<LI>

Проверьте каждый из конфликтов, чтобы удостовериться в том, что решение Bison
по умолчанию -- это то, чего вы на самом деле хотите.  Если нет, перепишите
грамматику и вернитесь к началу.

<LI>

Добавьте объявление <CODE>%expect</CODE>, взяв число <VAR>n</VAR> равным выведенному
Bison.
</UL>

<P>
Теперь Bison перестанет раздражать вас сообщениями о проверенных вами
конфликтах, но вновь начнёт выдавать сообщения, если изменения в грамматике
повлекут появление новых конфликтов.




<H3><A NAME="SEC64">4.7.6 Начальный символ</A></H3>
<P>
<A NAME="IDX138"></A>
<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>
<A NAME="IDX142"></A>


<P>
По умолчанию Bison полагает начальным символом грамматики первый нетерминал,
заданный в секции определения грамматики.  Программист может переопределить
его объявлением <CODE>%start</CODE>, как здесь:



<PRE>
%start <VAR>символ</VAR>
</PRE>



<H3><A NAME="SEC65">4.7.7 Чистый (повторно входимый) анализатор</A></H3>
<P>
<A NAME="IDX143"></A>
<A NAME="IDX144"></A>
<A NAME="IDX145"></A>


<P>
<EM>Повторно входимая программа</EM> -- это программа, которая не меняется в
процессе выполнения.  Другими словами, она полностью состоит  из <EM>чистого</EM>
кода (кода только для чтения).  Повторная входимость важна всегда, когда
возможно асинхронное выполнение, например, не повторно входимая программа
может быть ненадёжной при вызове её из обработчика сигнала.  В системах с
несколькими потоками управления, не повторно входимая программа может быть
вызвана только внутри критического участка.


<P>
В норме Bison генерирует не повторно входимый анализатор.  Это подходит
в большинстве случаев, и даёт совместимость с YACC (стандартные интерфейсы
YACC не повторно входимы по своей природе, потому что они используют
для взаимодействия с <CODE>yylex</CODE> статически выделяемые переменные, включая
<CODE>yylval</CODE> и <CODE>yylloc</CODE>).


<P>
В качестве альтернативы вы можете создать чистый, повторно входимый анализатор.
Объявление Bison <CODE>%pure_parser</CODE> говорит, что вы хотите получить повторно
входимый анализатор.  Оно выглядит так:



<PRE>
%pure_parser
</PRE>

<P>
В результате переменные взаимодействия <CODE>yylval</CODE> и <CODE>yylloc</CODE> становятся
локальными переменными <CODE>yyparse</CODE> и используются другие соглашения о вызове
функции лексического анализатора <CODE>yylex</CODE>.  См. раздел <A HREF="bison_7.html#SEC74">5.2.4 Соглашения о вызове для чистых анализаторов</A>, для прояснения деталей.  
Переменная <CODE>yynerrs</CODE> также становится локальной переменной <CODE>yyparse</CODE>
(см. раздел <A HREF="bison_7.html#SEC75">5.3 Функция сообщения об ошибках <CODE>yyerror</CODE></A>).
Соглашения о вызове самой функции <CODE>yyparse</CODE> не изменяются.


<P>
Будет ли анализатор чистым, никак не влияет на правила грамматики.  Вы можете
создать как чистый, так и не повторно входимый анализатор из любой правильной
грамматики.




<H3><A NAME="SEC66">4.7.8 Обзор объявлений Bison</A></H3>
<P>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>


<P>
Здесь приведено краткое изложение используемых при определении грамматики
объявлений:


<DL COMPACT>

<DT><CODE>%union</CODE>
<DD>
объявляет набор типов данных, которые могут иметь семантические значения
(см. раздел <A HREF="bison_6.html#SEC61">4.7.3 Набор типов значений</A>).

<DT><CODE>%token</CODE>
<DD>
Объявляет терминальный символ (имя типа лексемы) без указание приоритета или
ассоциативности (см. раздел <A HREF="bison_6.html#SEC59">4.7.1 Имена типов лексем</A>).

<DT><CODE>%right</CODE>
<DD>
Объявляет терминальный символ (имя типа лексемы), являющийся знаком
правоассоциативной операции (см. раздел <A HREF="bison_6.html#SEC60">4.7.2 Приоритет операций</A>).

<DT><CODE>%left</CODE>
<DD>
Объявляет терминальный символ (имя типа лексемы), являющийся знаком
левоассоциативной операции (см. раздел <A HREF="bison_6.html#SEC60">4.7.2 Приоритет операций</A>).

<DT><CODE>%nonassoc</CODE>
<DD>
Объявляет терминальный символ (имя типа лексемы), являющийся знаком
неассоциативной операции (использование его там, где требуется ассоциативность,
является синтаксической ошибкой) (см. раздел <A HREF="bison_6.html#SEC60">4.7.2 Приоритет операций</A>).

<DT><CODE>%type</CODE>
<DD>
Объявляет тип семантического значения нетерминального символа
(см. раздел <A HREF="bison_6.html#SEC62">4.7.4 Нетерминальные символы</A>).

<DT><CODE>%start</CODE>
<DD>
Задаёт начальный символ грамматики (см. раздел <A HREF="bison_6.html#SEC64">4.7.6 Начальный символ</A>).

<DT><CODE>%expect</CODE>
<DD>
Объявляет ожидаемое число конфликтов сдвиг/свёртка (см. раздел <A HREF="bison_6.html#SEC63">4.7.5 Подавление сообщений о конфликтах</A>).
</DL>

<P>
Для изменения поведения <CODE>bison</CODE> используйте следующие директивы:


<DL COMPACT>

<DT><CODE>%debug</CODE>
<DD>
В файле анализатора определяет макрос <CODE>YYDEBUG</CODE> как 1, если он ещё не
определён, так что компилируются возможности отладки.  См. раздел <A HREF="bison_11.html#SEC95">9. Отладка вашего анализатора</A>.

<DT><CODE>%defines</CODE>
<DD>
Создаёт дополнительный выходной файл, содержащий макроопределения имён
типов лексем, определённых в грамматике, и типа семантического значения
<CODE>YYSTYPE</CODE>, а также несколько объявлений внешних (<CODE>extern</CODE>)
переменных.

Если выходной файл анализатора называется <TT>`<VAR>имя</VAR>.c'</TT>, то этот
файл будет называться <TT>`<VAR>имя</VAR>.h'</TT>.

Этот выходной файл необходим, если вы хотите поместить определение <CODE>yylex</CODE>
в отдельный файл исходного кода, потому что функция <CODE>yylex</CODE> должна иметь
возможность обращаться к кодам типов лексем и переменной <CODE>yylval</CODE>.
См. раздел <A HREF="bison_7.html#SEC72">5.2.2 Семантические значения лексем</A>.

<DT><CODE>%file-prefix="<VAR>префикс</VAR>"</CODE>
<DD>
Задаёт префикс имён всех выходных файлов Bison.  Имена выбираются таким
образом, как если бы входной файл назывался <TT>`<VAR>префикс</VAR>.y'</TT>.

<DT><CODE>%locations</CODE>
<DD>
Создаёт код с обработкой положений (см. раздел <A HREF="bison_7.html#SEC76">5.4 Специальные возможности, используемые в действиях</A>).  Этот режим включается всегда, когда
грамматика использует специальные лексемы <SAMP>`@<VAR>n</VAR>'</SAMP>, но если ваша
грамматика их не использует, <SAMP>`%locations'</SAMP> позволит обеспечить более
аккуратный вывод сообщений об ошибках разбора.

<DT><CODE>%name-prefix="<VAR>префикс</VAR>"</CODE>
<DD>
Переименовывает используемые анализатором внешние символы так, что они
начинаются с <VAR>префикс</VAR> вместо <SAMP>`yy'</SAMP>.  Точный список переименовываемых
символов: <CODE>yyparse</CODE>, <CODE>yylex</CODE>, <CODE>yyerror</CODE>, <CODE>yynerrs</CODE>,
<CODE>yylval</CODE>, <CODE>yychar</CODE> и <CODE>yydebug</CODE>.  Например, если вы используете
<SAMP>`%name-prefix="c_"'</SAMP>, их имена примут вид: <CODE>c_parse</CODE>, <CODE>c_lex</CODE>
и т.д.  См. раздел <A HREF="bison_6.html#SEC67">4.8 Несколько анализаторов в одной программе</A>.

<DT><CODE>%no-parser</CODE>
<DD>
Не включает никакого кода на C в файл анализатора, только создаёт таблицы.
Файл анализатора будет содержать только директивы <CODE>#define</CODE> и объявления
статических переменных.

Этот параметр также указывает Bison записать в файл <TT>`<VAR>имя_файла</VAR>.act'</TT>
код на C действий грамматики, окружённых фигурными скобками, пригодный
для оператора <CODE>switch</CODE>.

<DT><CODE>%no-lines</CODE>
<DD>
Не создаёт никаких команд препроцессора <CODE>#line</CODE> в файле анализатора.
Обычно Bison записывает эти команды в файл анализатора так, что компилятор C
и отладчики будут связывать ошибки и объектный код с вашим исходным файлом
(файлом грамматики).  Эта директива заставит их связывать ошибки с файлом
анализатора, рассматривая его как независимый исходный файл.

<DT><CODE>%output="<VAR>имя_файла</VAR>"</CODE>
<DD>
Задаёт <VAR>имя_файла</VAR> для файла анализатора.

<DT><CODE>%pure-parser</CODE>
<DD>
Запрашивает чистую (повторно входимую) программу анализатора (см. раздел <A HREF="bison_6.html#SEC65">4.7.7 Чистый (повторно входимый) анализатор</A>).

<DT><CODE>%token_table</CODE>
<DD>
Создать массив имён лексем в файле анализатора.  Имя массива -- <CODE>yytname</CODE>,
<CODE>yytname[<VAR>i</VAR>]</CODE> -- имя лексемы с внутренним кодом Bison <VAR>i</VAR>.
Первые три элемента <CODE>yytname</CODE> всегда <CODE>"$"</CODE>, <CODE>"error</CODE> и
<CODE>"$illegal"</CODE>, после них идут символы, определённые в файле грамматики.

Для однолитерных и строковых лексем имя в таблице включает одинарные или
двойные кавычки: например, <CODE>"'+'"</CODE> -- однолитерная константа, а
<CODE>"\"&#60;=\""</CODE> -- строковая лексема.  Все литеры строковой лексемы точно в
том же виде содержатся в строке, находящейся в таблице, даже двойные кавычки
не экранируются.  Например, Если лексема состоит из трёх литер <SAMP>`*"*'</SAMP>,
её строка в <CODE>yytname</CODE> содержит <SAMP>`"*"*"'</SAMP>. (На C это будет записываться
<CODE>"\"*\"*\""</CODE>).

Когда вы задаёте <CODE>%token_table</CODE>, Bison также создаёт макроопределения
<CODE>YYNTOKENS</CODE>, <CODE>YYNNTS</CODE>, <CODE>YYNRULES</CODE>, и <CODE>YYNSTATES</CODE>:

<DL COMPACT>

<DT><CODE>YYNTOKENS</CODE>
<DD>
Самый большой номер лексемы плюс один.
<DT><CODE>YYNNTS</CODE>
<DD>
Число нетерминальных символов.
<DT><CODE>YYNRULES</CODE>
<DD>
Число правил грамматики.
<DT><CODE>YYNSTATES</CODE>
<DD>
Число состояний анализатора (см. раздел <A HREF="bison_8.html#SEC86">6.5 Состояния анализатора</A>).
</DL>

<DT><CODE>%verbose</CODE>
<DD>
Создаёт дополнительный выходной файл, содержащий подробные описания состояний
анализатора, и какие действия в этом состоянии выполняются при пред-просмотре
каждого типа лексем.

Этот файл также описывает все конфликты, как разрешаемые приоритетом операций,
так и не разрешаемые.

Имя файла получается заменой <SAMP>`.tab.c'</SAMP> или <SAMP>`.c'</SAMP> в имени выходного
файла анализатора на <SAMP>`.output'</SAMP>.

Поэтому, если входной файл называется <TT>`foo.y'</TT>, файл анализатора
по умолчанию будет называться <TT>`foo.tab.c'</TT>.  Вследствие этого, подробный
выходной файл будет называться <TT>`foo.output'</TT>.

<DT><CODE>%yacc</CODE>
<DD>
<DT><CODE>%fixed-output-files</CODE>
<DD>
Как будто был задан параметр <CODE>--yacc</CODE>, т.е. имитирует Yacc,
включая его соглашения об именах.  См. раздел <A HREF="bison_12.html#SEC97">10.1 Параметры Bison</A>.
</DL>



<H2><A NAME="SEC67">4.8 Несколько анализаторов в одной программе</A></H2>

<P>
Большая часть программ, использующих Bison, разбирает только один язык, и
поэтому содержит только один анализатор Bison.  Но что делать, если вы хотите
одной программой анализировать более одного языка?  Тогда вам нужно разрешить
конфликты имён между различными определениями <CODE>yyparse</CODE>, <CODE>yylval</CODE>
и т.д.


<P>
Простой способ сделать это -- использовать параметр <SAMP>`-p <VAR>префикс</VAR>'</SAMP>
(см. раздел <A HREF="bison_12.html#SEC96">10. Вызов Bison</A>).  Тогда имена интерфейсных функций и переменных
анализатора Bison будут начинаться с <VAR>префикс</VAR>, а не с <CODE>yy</CODE>.  Это
можно использовать, чтобы дать всем анализаторам различные не конфликтующие
имена.


<P>
Точный список переименуемых символов: <CODE>yyparse</CODE>, <CODE>yylex</CODE>,
<CODE>yyerror</CODE>, <CODE>yynerrs</CODE>, <CODE>yylval</CODE>, <CODE>yychar</CODE> и <CODE>yydebug</CODE>.
Например, если вы используете <SAMP>`-p c'</SAMP>, эти имена превратятся в
<CODE>cparse</CODE>, <CODE>clex</CODE> и т.д.


<P>
<STRONG>Никакие другие переменные и макросы, связанные с Bison, не
переименуются.</STRONG>  Они не глобальны, и если одни и те же имена будут
использоваться в разных анализаторах, конфликта не возникнет.  Например,
макрос <CODE>YYSTYPE</CODE> не будет переименован, но различное его определение
в разных анализаторах не вызовет проблем (см. раздел <A HREF="bison_6.html#SEC49">4.5.1 Типы данных семантических значений</A>).


<P>
Параметр <SAMP>`-p'</SAMP> добавляет макроопределения в начало выходного файла
анализатора, определяя <CODE>yyparse</CODE> как <CODE><VAR>префикс</VAR>parse</CODE> и т.д.
Это фактически подставляет во всём файле анализатора одно имя вместо другого.


<P></P><HR>
 [<A HREF="bison_toc.html">Содержание</A>] &#160; [<A HREF="bison_5.html">Назад</A>] &#160; [<A>Пред</A>] &#160; [<A>Вверх</A>] &#160; [<A>След</A>] &#160; [<A HREF="bison_7.html">Вперед</A>] &#160;

</BODY>
</HTML>
