<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-intro-ru.texi on 11 April 2001 -->

<TITLE>Введение в CVS - Как использовать CVS -- первый набросок</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-intro-ru_1.html">first</A>, <A HREF="cvs-intro-ru_1.html">previous</A>, next, last section, <A HREF="cvs-intro-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC2" HREF="cvs-intro-ru_toc.html#TOC2">Как использовать CVS -- первый набросок</A></H1>

<P>
Перед обсуждением множества разнобразных терминов и идей, давайте
взглянем на основные команды CVS.




<H2><A NAME="SEC3" HREF="cvs-intro-ru_toc.html#TOC3">Настройка вашего репозитория</A></H2>

<P>
CVS хранит все изменения в данном проекте в дереве каталогов, называемом
<EM>репозиторием</EM> (repository). Перед тем, как начать использовать CVS,
вам необходимо настроить переменную среды <CODE>CVSROOT</CODE> так, чтобы она
указывала на каталог репозитория. Тот, кто ответственен за управление
конфигурацией вашего проекта, вероятно, знает, что именно должна
содержать в себе эта переменная; возможно даже, что переменная
<CODE>CVSROOT</CODE> уже установлена глобально.


<P>
В любом случае, на нашей системе репозиторий находится в
<TT>`/usr/src/master'</TT>. В этом случае вам следует ввести команды


<P>
<SAMP>`
setenv CVSROOT /usr/src/master
'</SAMP>


<P>
если ваш командный интерпретатор -- <CODE>csh</CODE> или порожден от него, или


<P>
<SAMP>`
CVSROOT=/usr/src/master
export CVSROOT
'</SAMP>


<P>
если это Bash или какой-либой другой вариант Bourne shell. 


<P>
Если вы забудете сделать это, CVS пожалуется, если вы попытаетесь
запустить его:



<PRE>
$ cvs checkout httpc
cvs checkout: No CVSROOT specified! Please use the `-d' option
cvs [checkout aborted]: or set the CVSROOT environment variable.
$
</PRE>



<H2><A NAME="SEC4" HREF="cvs-intro-ru_toc.html#TOC4">Извлечение рабочего каталога</A></H2>

<P>
CVS не может работать в обычном дереве каталогов; наоборот, вы должны
работать в каталоге, который CVS создаст для вас. Точно так же, как вы
выписываете книгу из библиотеки перед тем, как забрать ее с собой, вам
следует использовать команду <SAMP>`cvs checkout'</SAMP>, чтобы получить от CVS
рабочее дерево каталогов. Предположим, например, что вы работаете над
проектом, называемым <SAMP>`httpc'</SAMP>, тривиальным HTTP клиентом:



<PRE>
$ cd
$ cvs checkout httpc
U httpc/.cvsignore
U httpc/Makefile
U httpc/httpc.c
U httpc/poll-server
$
</PRE>

<P>
Команда <SAMP>`cvs checkout httpc'</SAMP> означает "Извлечь дерево исходных
текстов с именем <SAMP>`httpc'</SAMP> из репозитория, указанного в переменной
окружения <SAMP>`CVSROOT'</SAMP>". 


<P>
CVS помещает дерево в подкаталог <TT>`httpc'</TT>:



<PRE>
$ cd httpc
$ ls -l
total 8
drwxr-xr-x      2 jimb          512 Oct 31  11:04 CVS
-rw-r--r--      1 jimb           89 Oct 31  10:42 Makefile
-rw-r--r--      1 jimb         4432 Oct 31  10:45 httpc.c
-rwxr-xr-x      1 jimb          460 Oct 30  10:21 poll-server
</PRE>

<P>
Большинство этих файлов -- рабочие копии исходных текстов
<SAMP>`httpc'</SAMP>. Однако, подкаталог с именем <TT>`CVS'</TT> (самый первый)
имеет другое назначение. CVS использует его для хранения
дополнительной информации о каждом файле в этом каталоге, чтобы
определять, какие изменения вы внесли в них с тех пор, как извлекли их
из репозитория.




<H2><A NAME="SEC5" HREF="cvs-intro-ru_toc.html#TOC5">Редактирование файлов</A></H2>

<P>
После того, как CVS создал рабочее дерево каталогов, вы можете
обычным образом редактировать, компилировать и проверять находящиеся в
нем файлы -- это просто файлы. 


<P>
Например, предположим, что мы хотим скомпилировать проект, который мы
только что извлекли:



<PRE>
$ make
gcc -g -Wall -lnsl -lsocket httpc.c  -o httpc
httpc.c: In function `tcp_connection':
httpc.c:48: warning: passing arg 2 of `connect' from incompatible 
pointer type
$
</PRE>

<P>
Кажется, <TT>`httpc.c'</TT> еще не был перенесен на эту операционную
систему. Нам нужно сделать приведение типов для одного из аргументов
функции <CODE>connect</CODE>. Чтобы сделать это, надо изменить строку 48,
заменив



<PRE>
if (connect (sock, &#38;name, sizeof (name)) &#62;=  0)
</PRE>

<P>
на



<PRE>
if (connect (sock, (struct sockaddr *) &#38;name, sizeof (name)) &#62;= 0)
</PRE>

<P>
Теперь компиляция должна пройти успешно:



<PRE>
$ make
gcc -g -Wall -lnsl -lsocket httpc.c  -o httpc
$ httpc GET http://www.cyclic.com
...<VAR>здесь находится текст домашней страницы Cyclic Software</VAR>...
$
</PRE>



<H2><A NAME="SEC6" HREF="cvs-intro-ru_toc.html#TOC6">Объединение изменений</A></H2>

<P>
Так как каждый разработчик использует свой собственный рабочий каталог,
изменения, которые вы делаете в своем каталоге, не становятся
автоматически видимыми всем остальным в вашей команде. CVS не публикует
изменений, пока они не закончены. Когда вы протестируете изменения, вы
должны <EM>зафиксировать</EM> (commit) их в репозитории и сделать их
доступными остальным. Мы опишем команду <CODE>cvs commit</CODE> далее.


<P>
Однако, что если другой разработчик изменил тот же файл, что и вы, и,
может быть, даже изменил те же самые строки? Чьи изменения будет
использованы? Обычно ответить на этот вопрос автоматически невозможно, и 
CVS совершенно точно некомпетентен, чтобы принимать такие решения. 


<P>
Поэтому перед тем, как фиксировать ваши изменения, CVS требует, чтобы
исходные тексты были синхронизированы со всеми изменениями, которые
сделали остальные члены группы. Команда <CODE>cvs update</CODE> позаботится об 
этом:



<PRE>
$ cvs update
cvs update: Updating .
U Makefile
RCS file: /u/src/master/httpc/httpc.c,v
retrieving revision 1.6
retrieving revision 1.7
Merging differences between 1.6 and 1.7 into httpc.c
M httpc.c
$
</PRE>

<P>
Рассмотрим пример строка за строкой:  
<DL COMPACT>

<DT><SAMP>`U Makefile'</SAMP>
<DD>
Строка вида `U <VAR>файл</VAR>' означает, что файл просто был обновлен; кто-то еще
внес в этот файл изменения, и CVS скопировал измененный файл в ваш
рабочий каталог. 

<DT><SAMP>`RCS file:... <BR>retrieving revision 1.6<BR>retrieving revision 1.7<BR>Merging differences between 1.6 and 1.7 into httpc.c'</SAMP>
<DD>
Это сообщение означает, что кто-то еще изменил <TT>`httpc.c'</TT>; CVS
объединила их изменения с вашими и не обнаружила текстуальных
конфликтов. Цифры `<CODE>1.6</CODE>' и `<CODE>1.7</CODE>' -- это номера редакции
(revision numbers), используемые для обозначения определенных точек
истории файла.

Заметьте, что CVS объединяет изменения только в вашей рабочей копии;
репозиторий и рабочие каталоги других разработчиков остаются
нетронутыми. От вас требуется протестировать объединенный текст и
убедиться, что он верен. 

<DT><SAMP>`M httpc.c'</SAMP>
<DD>
Строка вида `M <VAR>файл</VAR>' означает, что файл был модифицирован вами и
содержит изменения, которые еще не стали видны другим разработчикам. Это 
-- изменения, которые вам следует зафиксировать. 

</DL>

<P>
Так как CVS объединил чьи-то еще изменения с вашими исходными текстами, 
следует убедиться, что они все еще работают:



<PRE>
$ make
gcc -g -Wall -lnsl -lsocket httpc.c  -o httpc
$ httpc GET http://www.cyclic.com
... <VAR>здесь находится текст домашней страницы Cyclic Software
...</VAR> 
$
</PRE>



<H2><A NAME="SEC7" HREF="cvs-intro-ru_toc.html#TOC7">Фиксирование изменений</A></H2>

<P>
Теперь, когда вы синхронизировали свои исходники с коллегами и
протестировали их, вы готовы поместить свои изменения в репозиторий
и сделать их видимыми остальным разработчикам. Единственный файл,
который вы изменили -- это <TT>`httpc.c'</TT>, но в любом случае можно
без опаски запустить <CODE>cvs update</CODE>, чтобы получить от CVS список
модифицированных файлов:



<PRE>
$ cvs update
cvs update: Updating .
M httpc.c
$
</PRE>

<P>
Как и ожидалось, единственный файл, который упоминает CVS -- это
<TT>`httpc.c'</TT>; CVS говорит, что этот файл содержит изменения, которые 
еще не были зафиксированы. Вы можете зафиксировать их так:



<PRE>
$cvs commit httpc.c
</PRE>

<P>
В этом месте CVS запустит ваш любимый текстовый редактор и попросит вас
ввести описание изменений. После того, как вы выйдете из редактора, CVS
зафиксирует ваши изменения:



<PRE>
Checking in httpc.c;
/u/src/master/httpc/httpc.c,v  &#60;-- httpc.c
new revision: 1.8; previous revision: 1.7
$
</PRE>

<P>
Заметьте, что теперь вы зафиксировали ваши изменения и они видны всем
остальным членам группы. Когда другой разработчик исполняет <CODE>cvs
update</CODE>, CVS внесет ваши изменения в файлы в его рабочем каталоге.  




<H2><A NAME="SEC8" HREF="cvs-intro-ru_toc.html#TOC8">Отслеживание изменений</A></H2>

<P>
Теперь вы, возможно, захотите узнать, какие именно изменения внес другой 
разработчик в файл <TT>`httpc.c'</TT>. Чтобы увидеть журнальные записи для 
данного файла, можно использовать команду <CODE>cvs log</CODE>:



<PRE>
$ cvs log httpc.c

RCS file: /usr/src/master/httpc/httpc.c,v
Working file: httpc.c
head: 1.8
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 8; selected revisions: 8
description:
The one and only source file for trivial HTTP client
----------------------------
revision 1.8
date: 1996/10/31 20:11:14;  author: jimb;  state: Exp;  lines: +1 -1
(tcp_connection): Cast address stucture when calling connect.
----------------------------
revision 1.7
date: 1996/10/31 19:18:45;  author: fred;  state: Exp;  lines: +6 -2
(match_header): Make this test case-insensitive.
----------------------------
revision 1.6
date: 1996/10/31 19:15:23;  author: jimb;  state: Exp;  lines: +2 -6
...
$
</PRE>

<P>
Большую часть текста здесь вы можете игнорировать; следует только
обратить внимание на серию журнальных записей после первой строки
черточек. Журнальные записи выводятся на экран в обратном
хронологическом порядке, исходя из предположения, что недавние изменения 
обычно более интересны. Каждая запись описывает одно изменение в файле,
и может быть разобрано на составные части так:


<DL COMPACT>

<DT>`<CODE>revision 1.8</CODE>'
<DD>
Каждая версия файла имеет уникальный <EM>номер редакции</EM>. Номера
редакции выглядят как `<CODE>1.1</CODE>', `<CODE>1.2</CODE>', `<CODE>1.3.2.2</CODE>' или
даже `<CODE>1.3.2.2.4.5</CODE>'. По умолчанию номер 1.1 -- это первая
редакция файла. Каждое следующее редактирование увеличивает последнюю
цифру на единицу.

<DT>`<CODE>date: 1996/10/31 20:11:14; author: jimb; ...</CODE>'
<DD>
В этой строке находится дата изменения и имя пользователя,
зафиксировавшего это изменение; остаток строки не очень интересен. 

<DT>`<CODE>(tcp_connection</CODE>: Cast...'
<DD>
Это, очевидно, описание изменения.

</DL>

<P>
Команда <CODE>cvs log</CODE> может выбирать журнальные записи по дате или по
номеру редакции; за описанием деталей обращайтесь к руководству. 


<P>
Если вы хотите взглянуть на соответствующее изменение, то можете
использовать команду <CODE>cvs diff</CODE>. Например, если вы хотите увидеть,
какие изменения Фред зафиксировал в качестве редакции 1.7, используйте
такую команду:



<PRE>
$ cvs diff -c -r 1.6 -r 1.7 httpc.c
</PRE>

<P>
Перед рассмотрением того, что нам выдала эта команда, опишем, что
означает каждая ее часть.


<DL COMPACT>

<DT><CODE>-c</CODE>
<DD>
Задает использование удобочитаемого формата выдачи
изменений. (Интересно, почему это не так по
умолчанию)<A NAME="DOCF1" HREF="cvs-intro-ru_foot.html#FOOT1">(1)</A>.

<DT><CODE>-r 1.6 -r 1.7</CODE>
<DD>
Указывает CVS, что необходимо выдать изменения, необходимые, чтобы
превратить редакцию 1.6 в редакцию 1.7. Вы можете запросить более
широкий диапазон изменений; например, <CODE>-r 1.6 -r 1.8</CODE> отобразит
изменение, сделанные Фредом, и изменения, сделанные вами чуть позже. (Вы 
также можете заказать выдачу изменений в обратном порядке -- как будто
бы они были отменены -- указав номера редакций в обратном порядке:
<CODE>-r 1.7 -r 1.6</CODE>. Это звучит странно, но иногда полезно.)

<DT><CODE>httpc.c</CODE>
<DD>
Имя файла для обработки. Если вы не укажете его, CVS выдаст отчет обо
всем каталоге.
</DL>

<P>
Вот что выдаст эта команда:

<PRE>
Index: httpc.c
=================================================================
RCS file: /u/src/master/httpc/httcp.c,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -r1.6 -r1.7
*** httpc.c     1996/10/31 19:15:23     1.6
--- httpc.c     1996/10/31 19:18:45     1.7
***************
*** 62,68 ****
  }

! /* Return non-zero iff HEADER is a prefix of TEXT.  HEADER should be
     null-terminated; LEN is the length of TEXT.  */
  static int
  match_header (char *header, char *text, size_t len)
--- 62,69 ----
  }

! /* Return non-zero iff HEADER is a prefix of TEXT, ignoring
!    differences in case.  HEADER should be lower-case, and
     null-terminated; LEN is the length of TEXT.  */
  static int
  match_header (char *header, char *text, size_t len)
***************
*** 76,81 ****
--- 77,84 ----
    for (i = 0; i &#60; header_len; i++)
      {
        char t = text[i];
+       if ('A' &#60;= t &#38;&#38; t &#60;= 'Z')
+         t += 'a' - 'A';
        if (header[i] != t)
          return 0;
      }
$
</PRE>

<P>
Требуются некоторые усилия, чтобы привыкнуть к такой подаче информации,
но это определенно стоит того<A NAME="DOCF2" HREF="cvs-intro-ru_foot.html#FOOT2">(2)</A>.


<P>
Интересная часть информации начинается с первых двух строк, начинающихся 
с <CODE>***</CODE> и <CODE>---</CODE>; они описывают старый и новый файлы,
подлежащие сравнению. Остальное состоит из двух <EM>ломтей</EM> (hunk),
каждый из которых начинается со строки из звездочек. Вот первый
"ломоть":



<PRE>
***************
*** 62,68 ****
  }

! /* Return non-zero iff HEADER is a prefix of TEXT.  HEADER should be
     null-terminated; LEN is the length of TEXT.  */
  static int
  match_header (char *header, char *text, size_t len)
--- 62,69 ----
  }

! /* Return non-zero iff HEADER is a prefix of TEXT, ignoring
!    differences in case.  HEADER should be lower-case, and
     null-terminated; LEN is the length of TEXT.  */
  static int
  match_header (char *header, char *text, size_t len)
</PRE>

<P>
Текст из более старой редакции находится после строки <CODE>*** 62,68
***</CODE>; текст новой редакции находится после строки <CODE>--- 62,69
---</CODE>. Пара цифр означает показанный промежуток строк. CVS показывает
контекст вокруг изменений и отмечает измененные строки символами
`<CODE>!</CODE>'. Таким образом, вы видите, что одна строка из верхней
половины была заменена на две строки из нижней.


<P>
Вот второй "ломоть":



<PRE>
***************
*** 76,81 ****
--- 77,84 ----
    for (i = 0; i &#60; header_len; i++)
      {
        char t = text[i];
+       if ('A' &#60;= t &#38;&#38; t &#60;= 'Z')
+         t += 'a' - 'A';
        if (header[i] != t)
          return 0;
      }
</PRE>

<P>
Здесь описывается добавление двух строк, что обозначается символами
`<CODE>+</CODE>'. CVS не выводит старый текст -- это было бы избыточно. Для
описания удаленных строк используется подобный формат. 


<P>
Как и вывод команды <CODE>diff</CODE>, вывод команды <CODE>cvs diff</CODE> обычно
называется <EM>заплатой</EM> (patch), потому что разработчики традиционно
использовали этот формат для распространения исправлений и небольших
новый возможностей. Заплата достаточно читабельна и содержит достаточно
информации, чтобы применить изменения, которые она содержит, к
текстовому файлу. В действительности, команда <CODE>patch</CODE> в среде UNIX
делает с заплатами именно это.




<H2><A NAME="SEC9" HREF="cvs-intro-ru_toc.html#TOC9">Добавление и удаление файлов</A></H2>

<P>
CVS обращается с добавлением и удалением файлов так же, как и с прочими
изменениями, записывая такие события в истории файлов. Можно смотреть на 
это так, как будто CVS сохраняет историю каталогов вместе с историей
файлов. 


<P>
CVS не считает, что созданные файлы должны оказаться под его контролем;
это не так во многих случаях. Например, не требуется записывать историю
изменений объектных и выполняемых файлов, потому что их содержимое
всегда может быть воссоздано из исходных файлов (надо надеяться). Вместо 
этого, когда вы создадите новый файл, <CODE>cvs update</CODE> маркирует этот
файл флагом `<CODE>?</CODE>', пока вы не скажете CVS, что именно вы
намереваетесь сделать с этим файлом. 


<P>
Чтобы добавить файл в проект, сначала вы должны создать его, затем
использовать команду <CODE>cvs add</CODE>, чтобы маркировать его как
добавленный. Затем при следующем выполнении команды <CODE>cvs commit</CODE>
CVS добавит этот файл в репозиторий. Например, вот так можно добавить
файл README в проект httpc:



<PRE>
$ ls
CVS     Makefile        httpc.c         poll-server
$ vi README
...<VAR>введите описание httpc</VAR>...
$ ls
CVS     Makefile        README          httpc.c         poll-server
$ cvs update
cvs update: Updating .
? README <VAR>--- CVS еще не знает об этом файле</VAR>
$ cvs add README
cvs add: scheduling file `README' for addition
cvs add: use 'cvs commit' to add this file permanently
$ cvs update <VAR>--- что же теперь думает CVS?</VAR>
cvs update: Updating .
A README <VAR>--- Файл помечен как добавленный </VAR>
$ cvs commit README
<VAR>... CVS просит вас ввести журнальную запись...</VAR>
RCS file: /u/jimb/cvs-class/rep/httpc/README,v
done
Checking in README;
/u/src/master/httpc/README,v  &#60;-- README
initial revision: 1.1
done
$
</PRE>

<P>
CVS обращается с удаленными файлами почти так же. Если вы удалите файл и 
выполните <SAMP>`cvs update'</SAMP>, CVS не считает, что вы намереваетесь
удалить файл из проекта. Вместо этого он поступает милосерднее -- он
восстанавливает последнюю сохраненную в репозитории версию файла и
маркирует его флагом <CODE>U</CODE>, точно так же, как и любой другое
обновление. (Это означает, что если вы хотите отменить изменения файла в 
рабочем каталоге, вы можете просто удалить его и позволить команде
<SAMP>`cvs update'</SAMP> создать его заново.)


<P>
Чтобы удалить файл из проекта, вы должны сначала удалить его, а затем
использовать команду <SAMP>`cvs rm'</SAMP>, чтобы пометить его для удаления. При
следующем запуске команда <SAMP>`cvs commit'</SAMP> удалит файл из
репозитория. 


<P>
Фиксирование файла, маркированного с помощью <SAMP>`cvs rm'</SAMP> не уничтожает 
историю этого файла -- к ней просто добавляется еще одна редакция ---
"не существует". В репозитории по прежнему хранятся все записи об этом
файле, и к ним можно обращаться по желанию -- например, с помощью
<SAMP>`cvs diff'</SAMP> или <SAMP>`cvs log'</SAMP>.


<P>
Для переименования файла существует несколько стратегий; самая простая
--- переименовать файл в рабочем каталоге, затем выполнить <SAMP>`cvs rm'</SAMP> 
со старым именем и <SAMP>`cvs add'</SAMP> с новым. Недостаток этого подхода в
том, что журнальные записи о содержимом старого файла не переносятся в
новый файл. Другие стратегии позволяют избежать этого, но зато
доставляют другие, более странные проблемы. 


<P>
Вы можете добавлять каталоги точно так же, как и обычные файлы.




<H2><A NAME="SEC10" HREF="cvs-intro-ru_toc.html#TOC10">Написание хороших журнальных записей</A></H2>

<P>
Если можно использовать <SAMP>`cvs diff'</SAMP>, чтобы получить точное
содержание любого изменения, то зачем тогда придумывать еще журнальную
запись о нем? Очевидно, что журнальные записи короче, чем тексты
изменений, и позволяют читателю получить общее понимание изменения без
необходимости углубляться в детали.


<P>
Однако же, хорошая запись в журнале описывает <EM>причину</EM>, по которой
было сделано изменение. Например, плохая журнальная запись для редакции
1.7 может звучать как "Преобразовать <SAMP>`t'</SAMP> к нижнему регистру". Это
правильно, но бесполезно -- <SAMP>`cvs diff'</SAMP> предоставляет точно ту же
информацию, и гораздо яснее. Гораздо лучшей журнальной записью было бы
"Сделать эту проверку независящей от регистра", потому что это гораздо
яснее описывает причину любому, кто понимает, что происходит в коде ---
клиенты HTTP должны игнорировать регистр букв при анализе заголовков
ответа от сервера.




<H2><A NAME="SEC11" HREF="cvs-intro-ru_toc.html#TOC11">Обработка конфликтов</A></H2>

<P>
Как уже упоминалось, команда <SAMP>`cvs update'</SAMP> объединяет изменения,
сделанные другими разработчиками, с исходными текстами в вашем рабочем
каталоге. Если вы отредактировали файл одновременно с кем-то другим, CVS 
объединит ваши изменения. 


<P>
Довольно легко представить себе, как работает объединение, если
изменения были совершены в разных участках файла, но что если вы оба
изменили одну и ту же строку? CVS называет эту ситуацию <EM>конфликтом</EM> и 
предоставляет вам самому разобраться с ним.


<P>
Например, предположим, что вы добавили некую проверку на ошибки в код,
определяющий адрес сервера. Перед фиксированием изменений вы должны
запустить <SAMP>`cvs update'</SAMP>, чтобы синхронизировать ваш рабочий каталог
с репозиторием:



<PRE>
$ cvs update
cvs update: Updating .
RCS file: /u/src/master/httpc/httpc.c,v
retrieving revision 1.8
retrieving revision 1.9
Merging differences between 1.8 and 1.9 into httpc.c
rcsmerge: warning: conflicts during merge
cvs update: conflicts found in httpc.c
C httpc.c
$
</PRE>

<P>
В этом случае другой разработчик изменил тот же участок файла, что и вы, 
поэтому CVS жалуется на конфликт. Вместо того, чтобы напечатать <CODE>M
httpc.c</CODE>, как это обычно происходит, CVS печатает <CODE>C httpc.c</CODE>, что
означает наличие конфликта в этом файле.


<P>
Чтобы справиться с конфликтом, откройте этот файл в редакторе. CVS
обозначает конфликтующий текст так:



<PRE>
  /* Look up the IP address of the host. */
  host_info = gethostbyname (hostname);
&#60;&#60;&#60;&#60;&#60;&#60;&#60; httpc.c
  if (! host_info)
    {
      fprintf(stderr, "%s: host not found: %s\n", progname, hostname);
      exit(1);
    }
======= 
  if (! host_info)
    {
      printf("httpc: no host");
      exit(1);
    }
&#62;&#62;&#62;&#62;&#62;&#62;&#62; 1.9

  sock = socket (PF_INET, SOCK_STREAM, 0);
</PRE>

<P>
Текст вашего рабочего файла появляется сверху, после символов
<CODE>&#60;&#60;&#60;</CODE>. Внизу находится конфликтующий код другого
разработчика. Номер редакции <CODE>1.9</CODE> указывает, что конфликтующее
изменение было внесено в версии 1.9 этого файла, упрощая проверку
журнальных записей или просто выяснение изменений с помощью <SAMP>`cvs
diff'</SAMP>. 


<P>
Когда вы решите, как именно справиться с конфликтом, уберите маркеры из
кода и отредактируйте его. В этом случае, так как ваша обработка ошибок
определенно лучше, то просто отбросьте чужой вариант, оставив такой код:



<PRE>
  /* Look up the IP address of the host. */
  host_info = gethostbyname (hostname);
  if (! host_info)
    {
      fprintf(stderr, "%s: host not found: %s\n", progname, hostname);
      exit(1);
    }

  sock = socket (PF_INET, SOCK_STREAM, 0);
</PRE>

<P>
Теперь протестируйте изменения и зафиксируйте их:



<PRE>
$ make
gcc -g -Wall -Wmissing-prototypes -lnsl -lsocket  httpc.c  -o httpc
$ httpc GET http://www.cyclic.com
HTTP/1.0 200 Document follows
Date: Thu, 31 Oct 1996 23:04:06 GMT
...
$ httpc GET http://www.frobnitz.com
httpc: host not found: www.frobnitz.com
$ cvs commit httpc.c
</PRE>

<P>
Важно понимать, что именно CVS считает конфликтом. CVS не понимает
семантики вашей программы, он обращается с исходным кодом просто как с
деревом текстовых файлов. Если один разработчик добавляет новый аргумент 
в функцию и исправляет все ее вызовы, пока другой разработчик
одновременно добавляет новый вызов этой функции, и не передает ей этот
новый аргумент, что определенно является конфликтом -- два изменения
несовместимы -- но CVS не сообщит об этом. Его понимание конфликтов
строго текстуально. 


<P>
На практике, однако, конфликты случаются редко. Обычно они происходят
потому, что два человека пытаются справиться с одной и той же проблемой, 
от недостатка взаимодействия между разработчиками, или от разногласий по 
поводу архитектуры программы. Правильное распределение задач между
разработчиками уменьшает вероятность конфликтов. 


<P>
Многие системы контроля версий позволяют разработчику <EM>блокировать</EM>
файл, предотвращая внесение в него изменений до тех пор, пока его
собственные изменения не будут зафиксированы.  Блокировки уместны в
некоторых ситуациях, но их использование не всегда лучше, чем
использование CVS -- без блокировок. Изменения обычно объединяются без
проблем, а разработчики иногда забывают убрать блокировку, в обоих
случаях явное блокирование приводит к ненужным задержкам. Более того,
блокировки предотвращают только текстуальные конфликты -- они ничего не
могут поделать с семантическими конфликтами типа вышеописанного ---
когда два разработчика редактируют разные файлы.


<P><HR><P>
Go to the <A HREF="cvs-intro-ru_1.html">first</A>, <A HREF="cvs-intro-ru_1.html">previous</A>, next, last section, <A HREF="cvs-intro-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
