<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Файлы GDB</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_12.html">previous</A>, <A HREF="gdb_14.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC103" HREF="gdb_toc.html#TOC103">Файлы GDB</A></H1>

<P>
GDB должен знать имя файла программы, которая будет
отлаживаться, чтобы прочитать его таблицу символов и чтобы запустить его.
Для отладки дампа памяти от предыдущего выполнения, вы также
должны сообщить GDB имя этого файла.




<H2><A NAME="SEC104" HREF="gdb_toc.html#TOC104">Команды для задания файлов</A></H2>

<P>
<A NAME="IDX484"></A>
<A NAME="IDX485"></A>


<P>
Вы можете указать имена исполняемого файла и файла дампа памяти.
Обычно это делается во время вызова GDB, используя
параметры с командами запуска GDB (see section <A HREF="gdb_3.html#SEC5">Вход и выход из GDB</A>).


<P>
Иногда во время сеанса GDB необходимо перейти к другому файлу.
Или вы можете запустить GDB и забыть указать файл, который
хотите использовать.  В этих ситуациях полезны команды GDB для
задания новых файлов.


<DL COMPACT>

<DT><CODE>file <VAR>имя-файла</VAR></CODE>
<DD>
<A NAME="IDX486"></A>
 <A NAME="IDX487"></A>
 
Использовать <VAR>имя-файла</VAR> в качестве программы для отладки.  Из нее
читаются символы и содержание неизменяемой памяти.
Также она является программой, которая выполняется при
использовании команды <CODE>run</CODE>.  Если вы не укажете каталог, и файл
не будет найден в рабочем катологе GDB, он использует переменную
среды <CODE>PATH</CODE> в качестве списка каталогов для поиска, точно так
же, как это делает оболочка, когда ищет программу для выполнения.
Используя команду <CODE>path</CODE>, вы можете изменить значение этой
переменной как для GDB, так и для вашей программы.

В системах с отображаемыми в память файлами, информация из таблицы
символов для <VAR>имя-файла</VAR> может храниться во вспомогательном файле
<TT>`<VAR>имя-файла</VAR>.syms'</TT>.  Если это так, GDB осуществляет
отображение таблицы символов из <TT>`<VAR>имя-файла</VAR>.syms'</TT>, запускаясь
намного быстрее.  Смотрите описания ключей файлов <SAMP>`-mapped'</SAMP> и
<SAMP>`-readnow'</SAMP> (доступных с командной строки и в командах
<CODE>file</CODE>, <CODE>symbol-file</CODE> или <CODE>add-symbol-file</CODE>, описанных
ниже), для получения большей информации.

<DT><CODE>file</CODE>
<DD>
<CODE>file</CODE> без параметров велит GDB уничтожить любую имеющуюся
информацию как об исполняемом файле, так и о таблице символов.

<A NAME="IDX488"></A>
<DT><CODE>exec-file [ <VAR>имя-файла</VAR> ]</CODE>
<DD>
Указывает, что программа, которая должна быть выполнена (но не
таблица символов), находится в <VAR>имя-файла</VAR>.  Если необходимо,
GDB ищет вашу программу с помощью переменной среды
<CODE>PATH</CODE>.  Отсутствие <VAR>имя-файла</VAR> означает, что необходимо
уничтожить информацию о выполняемом файле.

<A NAME="IDX489"></A>
<DT><CODE>symbol-file [ <VAR>имя-файла</VAR> ]</CODE>
<DD>
Читать информацию таблицы символов из файла <VAR>имя-файла</VAR>.  При
необходимости производится поиск с помощью переменной среды
<CODE>PATH</CODE>.  Для получения таблицы символов и исполняемой программы из
одного и того же файла, используйте команду <CODE>file</CODE>.

<CODE>symbol-file</CODE> без параметров сбрасывает информацию GDB о
таблице символов вашей программы.

Команда <CODE>symbol-file</CODE> велит GDB забыть содержимое своих
вспомогательных переменных, историю значений и все точки останова и выражения
автоматического отображения, так как они могут содержать указатели
на внутренние данные, хранящие символы и типы данных, которые
являются частью данных старой таблицы символов, уничтоженной внутри
GDB.

<CODE>symbol-file</CODE> не повторяется, если вы снова нажимаете <KBD>RET</KBD>
после первого выполнения.

Когда GDB сконфигурирован для определенной среды, он распознает
отладочную информацию в том формате, который обычно генерируется
для этой среды; вы можете использовать или компилятор GNU, или другие
компиляторы, которые придерживаются местных соглашений.  Наилучшие
результаты обычно достигаются с помощью компилятора GNU;
например, используя <CODE>gcc</CODE>, вы можете создавать отладочную
информацию для оптимизированного кода.

Для большинства типов объектных файлов, за исключением старых систем
SVR3, использующих COFF, команда <CODE>symbol-file</CODE> обычно не считывает
таблицу символов сразу целиком.  Вместо этого, она быстро сканирует
ее для определения, какие исходные файлы и символы в ней
присутствуют.  Детали читаются позже, по одному исходному файлу за раз,
по мере необходимости.

Такая стратегия чтения в две стадии используется для того, чтобы
GDB вызывался быстрее.  За исключением редких пауз, чтение
деталей таблицы символов для конкретного исходного файла в большинстве
случаев практически незаметно.  (Команда <CODE>set verbose</CODE>
позволяет при желании превратить эти паузы в сообщения.
See section <A HREF="gdb_16.html#SEC170">Необязательные предупреждения и сообщения</A>.)

Мы еще не реализовали двухступенчатую стратегию чтения для COFF.  Когда
таблица символов сохранена в формате COFF, <CODE>symbol-file</CODE> считывает данные
таблицы символов сразу полностью.  Заметьте, что "stabs-in-COFF" все
же реализует двухступенчатую стратегию, так как отладочная информация
реально хранится в формате stabs.

<A NAME="IDX490"></A>
<A NAME="IDX491"></A>
<A NAME="IDX492"></A>
<A NAME="IDX493"></A>
<A NAME="IDX494"></A>
<A NAME="IDX495"></A>
<DT><CODE>symbol-file <VAR>имя-файла</VAR> [ -readnow ] [ -mapped ]</CODE>
<DD>
<DT><CODE>file <VAR>имя-файла</VAR> [ -readnow ] [ -mapped ]</CODE>
<DD>
Если вы хотите быть уверены, что у GDB есть вся таблица
символов целиком, вы можете отменить двухступенчатую стратегию чтения
таблицы символов, используя параметр <SAMP>`-readnow'</SAMP> с любой
командой, загружающей информацию таблицы символов.

Если отображаемые в память файлы доступны в вашей системе через
системный вызов <CODE>mmap</CODE>, вы можете использовать другой параметр,
<SAMP>`-mapped'</SAMP>, чтобы GDB записывал символы для вашей программы
в файл многократного использования.  Последующие сеансы отладки
GDB отображают информацию о символах из этого вспомогательного
файла (если программа не изменилась), вместо того, чтобы
тратить время на чтение таблицы символов из исполняемой программы.
Использование параметра <SAMP>`-mapped'</SAMP> производит такой же эффект, как
вызов GDB с ключем командной строки <SAMP>`-mapped'</SAMP>.

Вы можете использовать оба параметра вместе, чтобы быть уверенным,
что вспомогательный файл символов содержит всю информацию о символах
вашей программы.

Вспомогательный файл символов для программы <VAR>myprog</VAR> называется
<SAMP>`<VAR>myprog</VAR>.syms'</SAMP>.  Если этот файл существует (и создан позже,
чем соответствующая исполняемая программа), GDB всегда пытается
использовать его при отладке <VAR>myprog</VAR>; не требуется никаких
специальных ключей или команд.

Файл <TT>`.syms'</TT> является специфичным для рабочей машины, на которой вы
вызываете GDB.  Он содержит точный образ внутренней таблицы
символов GDB.  Он не может быть использован одновременно на
разных рабочих платформах.

<A NAME="IDX496"></A>
<A NAME="IDX497"></A>
<DT><CODE>core-file [ <VAR>имя-файла</VAR> ]</CODE>
<DD>
Определяет местонахождение файла дампа памяти, который будет использован
как "содержимое памяти".  Обычно файлы дампов памяти содержат только
некоторые части адресного пространства процесса, создавшего их;
GDB может обращаться к исполняемому файлу за другими частями.

<CODE>core-file</CODE> без параметра указывает, что файл дампа памяти
использоваться не должен.

Обратите внимание, что файл дампа памяти игнорируется, если в данное
время ваша программа выполняется под управлением GDB.  Так что
если вы выполняли программу, и желаете вместо этого отладить файл
дампа, вы должны убить подпроцесс, в котором выполняется ваша программа.
Для этого используйте команду <CODE>kill</CODE> (see section <A HREF="gdb_5.html#SEC23">Уничтожение дочернего процесса</A>).

<A NAME="IDX498"></A>
<A NAME="IDX499"></A>
<DT><CODE>add-symbol-file <VAR>имя-файла</VAR> <VAR>адрес</VAR></CODE>
<DD>
<DT><CODE>add-symbol-file <VAR>имя-файла</VAR> <VAR>адрес</VAR> [ -readnow ] [ -mapped ]</CODE>
<DD>
<DT><CODE>add-symbol-file <VAR>имя-файла</VAR> -s<VAR>раздел</VAR> <VAR>адрес</VAR></CODE>
<DD>
Команда <CODE>add-symbol-file</CODE> считывает дополнительную информацию
таблицы символов из файла <VAR>имя-файла</VAR>.  Вы должны использовать эту
команду, если файл <VAR>имя-файла</VAR> был динамически загружен (другими
средствами) в выполняющуюся программу.  <VAR>Адрес</VAR> должен быть адресом
памяти, по которому был загружен файл; GDB сам его определить
не может.  Вы можете указать дополнительно произвольное количество пар
<SAMP>`-s <VAR>раздел</VAR> <VAR>адрес</VAR>'</SAMP>, чтобы явно указать имя раздела и
базовый адрес для него.  Вы можете указать произвольный <VAR>адрес</VAR> как
выражение.

Таблица символов из файла <VAR>имя-файла</VAR> добавляется к таблице,
изначально считанной по команде <CODE>symbol-file</CODE>.  Вы можете
использовать команду <CODE>add-symbol-file</CODE> произвольное число раз;
прочитанные таким образом символьные данные добавляются к старым.  Чтобы
уничтожить все старые данные, используйте команду <CODE>symbol-file</CODE> без
аргументов.

Команда <CODE>add-symbol-file</CODE> не повторяется, если вы нажимаете
<KBD>RET</KBD> после ее использования.

Чтобы изменить способ обработки GDB таблицы символов для
<VAR>имя-файла</VAR>, вы можете использовать параметры <SAMP>`-mapped'</SAMP> и
<SAMP>`-readnow'</SAMP> так же, как и с командой <CODE>symbol-file</CODE>.

<A NAME="IDX500"></A>
<DT><CODE>add-shared-symbol-file</CODE>
<DD>
Команда <CODE>add-shared-symbol-file</CODE> может быть использована только для
Motorola 88k в операционной системе Harris CXUX.  GDB
ищет разделяемые библиотеки автоматически, однако, если он не находит
ваших, вы можете выполнить <CODE>add-shared-symbol-file</CODE>.  Эта команда
не имеет аргументов.

<A NAME="IDX501"></A>
<DT><CODE>section</CODE>
<DD>
Команда <CODE>section</CODE> изменяет базовый адрес раздела <VAR>раздел</VAR>
выполняемого файла в <VAR>адрес</VAR>.  Это может быть использовано, если
выполняемый файл не содержит адресов разделов, (что имеет место для
формата a.out), или когда адреса, указанные в самом файле, неверны.
Каждый раздел должен изменяться отдельно.  Команда <CODE>info files</CODE>,
описанная ниже, перечисляет все разделы и их адреса.

<A NAME="IDX502"></A>
<A NAME="IDX503"></A>
<DT><CODE>info files</CODE>
<DD>
<DT><CODE>info target</CODE>
<DD>
Команды <CODE>info files</CODE> и <CODE>info target</CODE> являются синонимами; они обе
выводят текущую цель (see section <A HREF="gdb_14.html#SEC106">Определение отладочной цели</A>), включая имена выполняемого файла и файла дампа памяти, используемых
GDB, и файлов, из которых были загружены символы.  Команда
<CODE>help target</CODE> выводит все возможные цели, а не только текущую.

</DL>

<P>
Все команды для задания файлов допускают в качестве аргументов как
абсолютные, так и относительные имена файлов.  GDB всегда
преобразовывает имя файла к абсолютному и запоминает его в таком виде.


<P>
<A NAME="IDX504"></A>
GDB поддерживает разделяемые библиотеки на HP-UX, SunOS, SVr4,
Irix 5 и IBM RS/6000.


<P>
Когда вы даете команду <CODE>run</CODE>, или когда исследуете
файл дампа памяти, GDB автоматически загружает определения
символов из разделяемых библиотек.  (Однако, если вы не отлаживаете файл дампа,
GDB не понимает ссылки на функции из разделяемой библиотеки до
того, как вы выполните команду <CODE>run</CODE>.)


<P>
На HP-UX, если программа загружает разделяемую библиотеку явно,
GDB автоматически загружает символы в момент вызова
<CODE>shl_load</CODE>.


<DL COMPACT>

<DT><CODE>info share</CODE>
<DD>
<A NAME="IDX505"></A>
 <A NAME="IDX506"></A>
 
<DT><CODE>info sharedlibrary</CODE>
<DD>
Вывести имена разделяемых библиотек, загруженных в данный момент.

<A NAME="IDX507"></A>
<A NAME="IDX508"></A>
<DT><CODE>sharedlibrary <VAR>рег-выр</VAR></CODE>
<DD>
<DT><CODE>share <VAR>рег-выр</VAR></CODE>
<DD>
Загрузить символы разделяемых библиотек объектов для файлов,
удовлетворяющих регулярному выражению Unix.  Также как и для
автоматически загруженных файлов, это загружает только разделяемые
библиотеки, требуемые вашей программой для файла дампа памяти или после
ввода <CODE>run</CODE>.  Если <VAR>рег-выр</VAR> опущено, загружаются все разделяемые
библиотеки, требуемые вашей программой.
</DL>

<P>
В системах HP-UX, GDB сам определяет загрузку разделяемой
библиотеки и автоматически считывает символы из нее, до некоторого
изначально установленного порогового значения, которое вы можете при
желании изменить.


<P>
После этого порогового значения, символы из разделяемых библиотек должны
загружаться явно.  Для загрузки этих символов, используйте команду
<CODE>sharedlibrary <VAR>имя-файла</VAR></CODE>.  Базовый адрес разделяемой
библиотеки определяется GDB автоматически и вы не
должны его задавать.


<P>
Для отображения или установки порогового значения, используйте следующие
команды:


<DL COMPACT>

<DT><CODE>set auto-solib-add <VAR>порог</VAR></CODE>
<DD>
<A NAME="IDX509"></A>
 
Устанавливает размер порога автоматической загрузки в мегабайтах.  Если
<VAR>порог</VAR> ненулевой, символы из всех библиотек разделяемых объектов
будут загружаться автоматически, когда программа начинает выполнение или
когда динамический компоновщик информирует GDB о том, что
была загружена новая библиотека, до тех пор, пока таблица символов программы и
библиотек не превысит этот порог.  В противном случае, символы должны
загружаться вручную, при помощи команды <CODE>sharedlibrary</CODE>.  По
умолчанию, порог равен 100 мегабайтам.

<A NAME="IDX510"></A>
<DT><CODE>show auto-solib-add</CODE>
<DD>
Отобразить величину текущего порога автоматической загрузки в мегабайтах.
</DL>



<H2><A NAME="SEC105" HREF="gdb_toc.html#TOC105">Ошибки чтения файлов с символами</A></H2>

<P>
При чтении файла символов, GDB иногда сталкивается с такими
проблемами, как типы символов, которые он не распознает, или известные
ошибки вывода компилятора.  По умолчанию, GDB не сообщает вам о таких
проблемах, так как они сравнительно общие и прежде всего представляют
интерес для людей, занимающихся отладкой компиляторов.  Если вам интересна
информация о плохо созданных таблицах символов, вы можете запросить
GDB печатать только одно сообщение по каждому типу проблем,
независимо от того, сколько раз проблема появляется; или вы можете
попросить GDB напечатать больше сообщений, чтобы увидеть, сколько раз
проблема встречалась, командой <CODE>set complaints</CODE>
(see section <A HREF="gdb_16.html#SEC170">Необязательные предупреждения и сообщения</A>).


<P>
Печатаемые сообщения и их значения, включают:


<DL COMPACT>

<DT><CODE>inner block not inside outer block in <VAR>символ</VAR></CODE>
<DD>
Информация о символах показывает, где области символов начинаются и
заканчиваются (например, в начале функции или блока операторов).  Эта
ошибка указывает на то, что внутренний блок видимости не содержится
целиком во внешнем.

GDB обходит проблему, рассматривая внутренний блок так, как если
бы он имел такую же область видимости, что и внешний.  Если внешний блок
не является функцией, в данном сообщении <VAR>символ</VAR> может быть
показан как "<CODE>(don't known)</CODE>".

<DT><CODE>block at <VAR>адрес</VAR> out of order</CODE>
<DD>
Символьная информация для блоков символьных областей должна
появляться в порядке увеличения адресов.  Данная ошибка указывает, что это
не так.

GDB не решает этой проблемы, и у него возникают трудности при
определении местоположения символов в исходном файле, символы которого
он считывает.  (Вы часто можете определить имя поврежденного исходного
файла, указав <CODE>set verbose on</CODE>.  See section <A HREF="gdb_16.html#SEC170">Необязательные предупреждения и сообщения</A>.)

<DT><CODE>bad block start address patched</CODE>
<DD>
Символьная информация для блоков символьных областей имеет меньший
начальный адрес, чем у предшествующей строки исходного текста.
Известно, что это происходит в компиляторе Си SunOS 4.1.1 (и более
ранних версиях).

GDB обходит проблему, обрабатывая блок символьной области как
начинающийся с предыдущей исходной строки.

<DT><CODE>bad string table offset in symbol <VAR>n</VAR></CODE>
<DD>
<A NAME="IDX511"></A>
Символ с номером <VAR>n</VAR> содержит указатель на таблицу строк, который
превосходит размер таблицы.

GDB обходит проблему, считая, что символ имеет имя <CODE>foo</CODE>,
что может вызвать другие проблемы, если много символов
заканчиваются этим именем.

<DT><CODE>unknown symbol type <CODE>0x<VAR>nn</VAR></CODE></CODE>
<DD>
Символьная информация содержит новые типы данных, которые GDB еще
не знает, как считывать.  <CODE>0x<VAR>nn</VAR></CODE>---это тип символа неверно
истолкованной информации, в шестнадцатеричном виде.

GDB обходит ошибку, игнорируя эту символьную информацию.  Это
обычно позволяет вам отладживать программу, хотя некоторые
символы и недоступны.  Если вы столкнетесь с такой проблемой и
желаете ее отладить, вы можете отладить <CODE>gdb</CODE> с помощью
него же, установив точку останова на <CODE>complain</CODE>, затем дойти до
функции <CODE>read_dbx_symtab</CODE> и исследовать <CODE>*bufp</CODE>, чтобы
увидеть символ.

<DT><CODE>stub type has NULL name</CODE>
<DD>
GDB не может найти полное определение для структуры или класса.

<DT><CODE>const/volatile indicator missing (ok if using g++ v1.x), got...</CODE>
<DD>
В символьной информации для функции-члена Си++ пропущена
некоторая информация, которую последние версии компилятора должны
для нее выводить.

<DT><CODE>info mismatch between compiler and debugger</CODE>
<DD>
GDB не может разобрать спецификации типа, выведенной компилятором.

</DL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_12.html">previous</A>, <A HREF="gdb_14.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
