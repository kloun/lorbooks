<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Фиксированные последовательности команд</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_16.html">previous</A>, <A HREF="gdb_18.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC172" HREF="gdb_toc.html#TOC172">Фиксированные последовательности команд</A></H1>

<P>
Кроме команд точки останова (see section <A HREF="gdb_6.html#SEC34">Команды точки останова</A>), GDB предоставляет два способа сохранить
последовательности команд для выполнения целиком:
определяемые пользователем команды и командные файлы.




<H2><A NAME="SEC173" HREF="gdb_toc.html#TOC173">Команды, определяемые пользователем</A></H2>

<P>
<A NAME="IDX757"></A>
<EM>Команда, определяемая пользователем</EM>---это последовательность команд
GDB, которой вы назначаете имя, как новой команде.  Это
осуществляется командой <CODE>define</CODE>.  Пользовательские команды могут иметь
до 10 параметров, разделенных пробелами.  Внутри команды пользователя,
доступ к параметрам производится посредством <VAR>$arg0...$arg9</VAR>.
Вот простой пример:



<PRE>
define adder
  print $arg0 + $arg1 + $arg2
</PRE>

<P>
Для выполнения команды используйте:



<PRE>
adder 1 2 3
</PRE>

<P>
Этот пример определяет команду <CODE>adder</CODE>, которая печатает сумму трех
своих параметров.  Обратите внимание, что параметры являются текстовыми
подстановками, так что они могут ссылаться на переменные, использовать
сложные выражения или даже выполнять вызовы подчиненных функций.


<DL COMPACT>

<DT><CODE>define <VAR>имя-команды</VAR></CODE>
<DD>
<A NAME="IDX758"></A>
 
Определить команду с именем <VAR>имя-команды</VAR>.  Если команда
с таким именем уже имеется, у вас запрашивается подтверждение на ее
переопределение.

Определение команды состоит из других командных строк GDB,
которые задаются после команды <CODE>define</CODE>.  Конец этих команд
отмечается стpокой, содержащей <CODE>end</CODE>.

<A NAME="IDX759"></A>
<A NAME="IDX760"></A>
<DT><CODE>if</CODE>
<DD>
Имеет один аргумент---вычисляемое выражение.  Команда сопровождается
последовательностью команд, которые выполняются, если выражение истинно
(отлично от нуля).  Затем может следовать необязательная стpока
<CODE>else</CODE>, сопровождаемая последовательностью команд, которые
выполняются только при ложном значении данного выражения.  Конец списка
отмечается стpокой, содержащей <CODE>end</CODE>.

<A NAME="IDX761"></A>
<DT><CODE>while</CODE>
<DD>
Синтаксис подобен <CODE>if</CODE>: команда имеет один параметр, который
является вычисляемым выражением и должен сопровождаться командами,
по одной в стpоке, которые завершаются <CODE>end</CODE>.  Выполнение команд
повторяется, пока выражение истинно.

<A NAME="IDX762"></A>
<DT><CODE>document <VAR>имя-команды</VAR></CODE>
<DD>
Описывает определенную пользователем команду <VAR>имя-команды</VAR>, так,
чтобы к ней можно было обращаться посредством <CODE>help</CODE>.  Команда
<VAR>имя-команды</VAR> должна быть определена ранее.  Эта команда
считывает стpоки документации точно так же, как <CODE>define</CODE>
считывает стpоки определения команды, до строки <CODE>end</CODE>.  После
завершения команды <CODE>document</CODE>, написанная вами документация будет
отображаться командой <CODE>help</CODE> для команды <VAR>имя-команды</VAR>.

Вы можете использовать команду <CODE>document</CODE> неоднократно, чтобы
изменить документацию команды.  Переопределение команды посредством
<CODE>define</CODE> не изменяет документации.

<A NAME="IDX763"></A>
<DT><CODE>help user-defined</CODE>
<DD>
Перечислить все определенные пользователем команды, вместе с первой
строкой документации (если она есть).

<A NAME="IDX764"></A>
<DT><CODE>show user</CODE>
<DD>
<DT><CODE>show user <VAR>имя-команды</VAR></CODE>
<DD>
Вывести команды GDB, использовавшиеся для определения
<VAR>имя-команды</VAR> (но не ее документацию).  Если <VAR>имя-команды</VAR> не
задано, вывести содержимое всех определенных пользователем команд.

</DL>

<P>
При выполнении команд, определенных пользователем, команды
определения не печатаются.  Ошибка в любой из них останавливает
выполнение всей определенной пользователем команды.


<P>
При использовании в интерактивном режиме, команды, обычно запрашивающие
подтверждение, выполняются без запроса, если они используется внутри
определенной пользователем команды.  Многие команды GDB,
которые обычно печатают сообщения о своих действиях, опускают
их при использовании в команде, определенной пользователем.




<H2><A NAME="SEC174" HREF="gdb_toc.html#TOC174">Определяемые пользователем команды-ловушки</A></H2>
<P>
<A NAME="IDX765"></A>
<A NAME="IDX766"></A>


<P>
Вы можете определять <EM>ловушки</EM>, которые являются специальным
видом определяемых пользователем команд.  Всякий раз, когда вы выполняете
команду <SAMP>`foo'</SAMP>, перед ней выполняется определенная пользователем команда
<SAMP>`hook-foo'</SAMP> (без параметров), если она существует.


<P>
<A NAME="IDX767"></A>
Кроме того, существует псевдокоманда <SAMP>`stop'</SAMP>.  Определение
(<SAMP>`hook-stop'</SAMP>) велит выполняться связанным с ней командам при каждом
останове вашей программы: перед выполнением команд точек останова, перед
выводом на экран сообщений или кадров стека.


<P>
Например, чтобы игнорировать сигналы <CODE>SIGALRM</CODE> во время выполнения
в пошаговом режиме, но обрабатывать их при нормальном выполнении, вы
можете определить:



<PRE>
define hook-stop
handle SIGALRM nopass
end

define hook-run
handle SIGALRM pass
end

define hook-continue
handle SIGLARM pass
end
</PRE>

<P>
Вы можете определить ловушку для любой однословной команды
GDB, но не для синонимов команды; вам следует определить
ловушку для базового имени команды, например, <CODE>backtrace</CODE>, но не
<CODE>bt</CODE>.  Если во время выполнения вашей ловушки возникает ошибка,
выполнение команд GDB останавливается, и
он выдает приглашение (до того, как введенная вами
команда начнет выполняться).


<P>
Если вы попытаетесь определить ловушку, не соответствующую никакой
известной команде, вы получите предупреждение от команды <CODE>define</CODE>.




<H2><A NAME="SEC175" HREF="gdb_toc.html#TOC175">Командные файлы</A></H2>

<P>
<A NAME="IDX768"></A>
Командный файл для GDB---это файл, состоящий из строк с
командами GDB.  Такие файлы могут также включать комментарии
(строки, начинающиеся с <KBD>#</KBD>).  Пустая строка в командном файле
ничего не делает; она не означает повторение последней команды, как это
было бы при вводе с терминала.


<P>
<A NAME="IDX769"></A>
<A NAME="IDX770"></A>
<A NAME="IDX771"></A>
Когда вы вызываете GDB, он автоматически выполняет команды из
своих <EM>файлов инициализации</EM>.  Это файлы, называющиеся
<TT>`.gdbinit'</TT> в Unix и <TT>`gdb.ini'</TT> в DOS/Windows.  Во время старта,
GDB делает следующее:



<OL>
<LI>

считывает файл инициализации (если он существует) в вашем
домашнем каталоге<A NAME="DOCF18" HREF="gdb_foot.html#FOOT18">(18)</A>.

<LI>

Обрабатывает ключи и операнды командной строки.

<LI>

Считывает файл инициализации (если он существует) в текущем рабочем
каталоге.

<LI>

Считывает командные файлы, заданные с помощью ключа <SAMP>`-x'</SAMP>.
</OL>

<P>
Файл инициализации в вашем домашнем каталоге может
устанавливать параметры (такие как <SAMP>`set complaints'</SAMP>), которые влияют на
последующую обработку ключей и операндов командной строки.  Файлы
инициализации не выполняются, если вы используете ключ <SAMP>`-nx'</SAMP>
see section <A HREF="gdb_3.html#SEC8">Выбор режимов</A>.


<P>
<A NAME="IDX772"></A>
В некоторых конфигурациях GDB, файлу инициализации присваивается
другое имя (обычно это среды, где специализированная форма GDB должна
сосуществовать с другими формами, следовательно должно быть отличное
имя для файла инициализации специализированной версии).  Следующие
среды используют специальные имена файлов инициализации:


<P>
<A NAME="IDX773"></A>

<UL>
<LI>

VxWorks (ОС реального времени Wind River Systems): <TT>`.vxgdbinit'</TT>

<A NAME="IDX774"></A>
<LI>

OS68K (ОС реального времени Enea Data Systems): <TT>`.os68gdbinit'</TT>

<A NAME="IDX775"></A>
<LI>

ES-1800 (эмулятор Ericsson Telecom AB M68000): <TT>`.esgdbinit'</TT>
</UL>

<P>
Вы также можете запросить выполнение командного файла с помощью команды
<CODE>source</CODE>:


<DL COMPACT>

<DT><CODE>source <VAR>имя-файла</VAR></CODE>
<DD>
<A NAME="IDX776"></A>
 
Выполнить командный файл <VAR>имя-файла</VAR>.
</DL>

<P>
Строки командного файла выполняются последовательно, при этом они
не выводятся.  Ошибка в любой команде завершает выполнение всего
командного файла.


<P>
Команды, запрашивающие подтверждение в интерактивном режиме, при
выполнении в командном файле выполняются без запросов.  Многие
команды GDB, обычно выводящие сообщения о своих действиях,
опускают эти сообщения при вызове из командных файлов.




<H2><A NAME="SEC176" HREF="gdb_toc.html#TOC176">Команды для управляемого вывода</A></H2>

<P>
Во время выполнения командного файла или определенной пользователем
команды, нормальный вывод GDB подавляется; единственый появляющийся
вывод---тот, который производится явно командами из определения.  В этом
разделе описываются три команды, полезные для получения именно такого
вывода, который вы хотите.


<DL COMPACT>

<DT><CODE>echo <VAR>текст</VAR></CODE>
<DD>
<A NAME="IDX777"></A>
 
Напечатать <VAR>текст</VAR>.  Непечатные знаки могут быть включены в
<VAR>текст</VAR> при помощи экранирующих последовательностей Си, таких как
<SAMP>`\n'</SAMP> для перехода на новую строку.  <STRONG>Переход на новую строку
не печатается, если вы его не укажете.</STRONG>  В дополнение к стандартным
экранирующим последовательностям Си, обратная косая черта, за
которой следует пробел, обозначает пробел.  Это полезно для
отображения строки с пробелами в начале или конце, поскольку в противном
случае начальные и конечные пробелы удаляются из всех аргументов.  Чтобы
напечатать <SAMP>` and foo = '</SAMP>, используйте команду
<SAMP>`echo \ and foo = \ '</SAMP>.

Обратная косая черта в конце <VAR>текста</VAR> может использоваться, как и в
Си, для продолжения команды на последующие строки.  Например,


<PRE>
echo Вот пример текста,\n\
который занимает\n\
несколько строк.\n
</PRE>

производит такой же вывод как


<PRE>
echo Вот пример текста,\n
echo который занимает\n
echo несколько строк.\n
</PRE>

<A NAME="IDX778"></A>
<DT><CODE>output <VAR>выражение</VAR></CODE>
<DD>
Напечатать значение <VAR>выражения</VAR> и ничего кроме него: никаких новых
строк, никаких <SAMP>`$<VAR>nn</VAR> = '</SAMP>.  Значение также не заносится в
историю значений.  See section <A HREF="gdb_9.html#SEC51">Выражения</A>, для дополнительной
информации о выражениях.

<DT><CODE>output/<VAR>формат</VAR> <VAR>выражение</VAR></CODE>
<DD>
Вывести значение <VAR>выражения</VAR> в формате <VAR>формат</VAR>.  Вы можете
использовать те же форматы, что и для <CODE>print</CODE>.  See section <A HREF="gdb_9.html#SEC54">Форматы вывода</A>, для получения большей информации.

<A NAME="IDX779"></A>
<DT><CODE>printf <VAR>строка</VAR>, <VAR>выражения</VAR>...</CODE>
<DD>
Напечатать значения <VAR>выражений</VAR>, причем формат вывода задает <VAR>строка</VAR>.
<VAR>Выражения</VAR> разделяются запятыми и могут быть либо числами, либо
указателями.  Их значения печатаются так, как определяет <VAR>строка</VAR>,
в точности, как если бы ваша программа выполняла подпрограмму Си


<PRE>
printf (<VAR>строка</VAR>, <VAR>выражения</VAR>...);
</PRE>

Например, вы можете напечатать два шестнадцатеричных значения:


<PRE>
printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo
</PRE>

Единственые экранирующие последовательности с обратной косой чертой,
которые вы можете использовать в строке формата---простые
последовательности, состоящие из обратной косой черты, за которой
следует буква.
</DL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_16.html">previous</A>, <A HREF="gdb_18.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
