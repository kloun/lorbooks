<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Информация о конфигурации</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_14.html">previous</A>, <A HREF="gdb_16.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC119" HREF="gdb_toc.html#TOC119">Информация о конфигурации</A></H1>

<P>
В то время как почти все команды GDB доступны для всех чистых
и кросс-версий отладчика, существуют некоторые исключения.  Эта глава
описывает вещи, доступные только в определенных конфигурациях.


<P>
Существует три основные категории конфигураций: чистые конфигурации, где
рабочая и целевая машины совпадают, конфигурации для встроенных
операционных систем, которые обычно совпадают для нескольких различных
архитектур процессоров, и отдельные встроенные процессоры, которые
сильно отличаются друг от друга.




<H2><A NAME="SEC120" HREF="gdb_toc.html#TOC120">Чистая конфигурация</A></H2>

<P>
Этот раздел описывает детали, специфичные для определенных чистых
конфигураций.




<H3><A NAME="SEC121" HREF="gdb_toc.html#TOC121">HP-UX</A></H3>

<P>
В системах HP-UX, если вы ссылаетесь на функцию или переменную, имя которой
начинается со знака доллара, GDB сперва ищет имя пользователя
или системы, до поиска вспомогательной переменной.




<H3><A NAME="SEC122" HREF="gdb_toc.html#TOC122">Информация о процессах SVR4</A></H3>

<P>
<A NAME="IDX581"></A>
<A NAME="IDX582"></A>


<P>
Многие версии SVR4 предоставляют возможность, называемую
<SAMP>`/proc'</SAMP>, которая может быть использована для исследования образа
выполняемого процесса, используя подпрограммы файловой системы.  Если
GDB сконфигурирован для операционной системы, поддерживающей
эту возможность, команда <CODE>info proc</CODE> доступна для получения отчета
по некоторым видам информации о процессе, выполняющем вашу программу.
<CODE>info proc</CODE> работает только на системах SVR4, которые включают код
<CODE>procfs</CODE>.  Среди этих систем: OSF/1 (Digital Unix), Solaris,
Irix и Unixware, но не HP-UX или Linux, к примеру.


<DL COMPACT>

<DT><CODE>info proc</CODE>
<DD>
<A NAME="IDX583"></A>
 
Выдает доступную суммарную информацию о процессе.

<A NAME="IDX584"></A>
<DT><CODE>info proc mappings</CODE>
<DD>
Сообщает диапазоны адресов, доступных в программе, с информацией, может ли
ваша программа читать, записывать, или исполнять каждый из диапазонов.

<A NAME="IDX585"></A>
<DT><CODE>info proc times</CODE>
<DD>
Время запуска, время пользовательского и системного ЦП для вашей
программы и ее потомков.

<A NAME="IDX586"></A>
<DT><CODE>info proc id</CODE>
<DD>
Сообщает информацию об идентификаторах процессов, относящихся к вашей
программе: ее собственный идентификатор, идентификатор ее родителя,
группы процесса и сеанса.

<A NAME="IDX587"></A>
<DT><CODE>info proc status</CODE>
<DD>
Общая информация о состоянии процесса.  Если процесс остановлен, то этот
отчет включает причину останова и любые полученные сигналы.

<DT><CODE>info proc all</CODE>
<DD>
Показывает всю вышеперечисленную информацию о процессе.
</DL>



<H2><A NAME="SEC123" HREF="gdb_toc.html#TOC123">Встроенные операционные системы</A></H2>

<P>
Этот раздел описывает конфигурации, задействующие отладку встроенных
операционных систем, которые доступны для нескольких различных архитектур.


<P>
GDB включает возможность отлаживать программы, выполняющиеся в
различных операционных системах реального времени.




<H3><A NAME="SEC124" HREF="gdb_toc.html#TOC124">Использование GDB с VxWorks</A></H3>

<P>
<A NAME="IDX588"></A>


<DL COMPACT>

<DT><CODE>target vxworks <VAR>имя-машины</VAR></CODE>
<DD>
<A NAME="IDX589"></A>
 
Система VxWorks, присоединенная посредством TCP/IP.  Аргумент
<VAR>имя-машины</VAR> есть имя или IP-адрес машины целевой системы.

</DL>

<P>
На VxWorks, <CODE>load</CODE> компонует <VAR>имя-файла</VAR> динамически на текущей
целевой системе, и добавляет ее символьную информацию в GDB.


<P>
GDB позволяет разработчикам запускать и отлаживать с Unix-машин
задачи, выполняющиеся на сетевых целях VxWorks.  Уже выполняющиеся
задачи, запущенные из оболочки VxWorks, также могут быть отлажены.
GDB использует код, который может выполняться как на машине
Unix, так и на целевой машине VxWorks.  Программа <CODE>gdb</CODE>
устанавливается и выполняется на Unix-машине.  (Она может быть
установлена под именем <CODE>vxgdb</CODE>, чтобы отличать ее от GDB
для отладки программ на рабочей машине.)


<DL COMPACT>

<DT><CODE>VxWorks-timeout <VAR>арг</VAR></CODE>
<DD>
<A NAME="IDX590"></A>
Сейчас все цели, базирующиеся на VxWorks, поддерживают параметр
<CODE>vxworks-timeout</CODE>.  Этот параметр устанавливается пользователем, и
<VAR>арг</VAR> представляют число секунд, в течение которых GDB
ожидает ответы
на вызовы удаленных процедур.  Вы можете использовать это, если ваша
целевая машина VxWorks является медленным программным эмулятором, или
находится далеко на другом конце медленного сетевого соединения.
</DL>

<P>
Следующая информация о соединении к VxWorks была свежей, когда
это руководство было написано; более новые выпуски VxWorks могут
использовать обновленные процедуры.


<P>
<A NAME="IDX591"></A>
Для использования GDB с VxWorks, вы должны пересобрать ваше
ядро VxWorks, чтобы включить подпрограммы интерфейса удаленной отладки в
библиотеку VxWorks <TT>`rdb.a'</TT>.  Чтобы это сделать, определите
<CODE>INCLUDE_RDB</CODE> в конфигурационном файле VxWorks <TT>`configAll.h'</TT> и
пересоберите ядро VxWorks.  Получившееся ядро содержит <TT>`rdb.a'</TT>, и
порождает задачу отладки исходного кода <CODE>tRdbTask</CODE>, когда VxWorks
загружается.  Для большей информации по конфигурированию и сборке
VxWorks, смотрите руководство изготовителя.


<P>
Когда вы включили <TT>`rdb.a'</TT> в образ вашей системы VxWorks и так
установили ваши пути поиска выполняемых файлов, чтобы можно было найти
GDB, вы готовы к вызову отладчика.  Из вашей рабочей
Unix-машины, выполните <CODE>gdb</CODE> (или <CODE>vxgdb</CODE>, в
зависимости от вашей установки).


<P>
GDB появляется и показывает приглашение:



<PRE>
(vxgdb)
</PRE>



<H4><A NAME="SEC125" HREF="gdb_toc.html#TOC125">Соединение к VxWorks</A></H4>

<P>
Команда GDB <CODE>target</CODE> позволяет вам соединяться с целевой
машиной VxWorks в сети.  Для соединения с целью, имя которой есть
"<CODE>tt</CODE>", введите:



<PRE>
(vxgdb) target vxworks tt
</PRE>

<P>
GDB покажет сообщения, аналогичные этим:



<PRE>
Attaching remote machine across net... 
Connected to tt.
</PRE>

<P>
Затем GDB пытается считать таблицы символов всех объектных
модулей, загруженных на целевой машине VxWorks с того момента, как она
была включена.  GDB находит эти файлы путем поиска в
каталогах, перечисленных в путях поиска команд (see section <A HREF="gdb_5.html#SEC19">Рабочая среда вашей программы</A>); если ему не удается найти объектный файл, он
выводит подобное сообщение:



<PRE>
prog.o: No such file or directory.
</PRE>

<P>
Когда это происходит, добавьте соответствующий каталог к путям поиска с
помощью команды GDB <CODE>path</CODE>, и выполните команду
<CODE>target</CODE> снова.




<H4><A NAME="SEC126" HREF="gdb_toc.html#TOC126">Загрузка на VxWorks</A></H4>

<P>
<A NAME="IDX592"></A>
Если вы соединились с целевой машиной VxWorks и хотите отладить объект,
который еще не был загружен, вы можете использовать команду GDB
<CODE>load</CODE>, чтобы загрузить файл из Unix в VxWorks.  Объектный файл,
заданный в качестве аргумента к <CODE>load</CODE>, в действительности
открывается дважды: сначала целевой машиной VxWorks, чтобы загрузить код,
а затем GDB, чтобы считать таблицу символов.  Это может
привести к проблемам, если текущие рабочие каталоги в этих системах
различаются.  Если обе системы монтируют по NFS одинаковые
файловые системы, вы можете избежать этих проблем, используя абсолютные
пути.  В противном случае, проще всего установить рабочий каталог на
обеих системах в тот, в котором расположен объектный файл, и затем
ссылаться на него по имени, без пути.  Например, программа
<TT>`prog.o'</TT> может находиться в <TT>`<VAR>vxpath</VAR>/vw/demo/rdb'</TT> на
VxWorks и в <TT>`<VAR>hostpath</VAR>/vw/demo/rdb'</TT> на рабочей машине.  Для
загрузки этой программы, введите в VxWorks следующее:



<PRE>
-&#62; cd "<VAR>vxpath</VAR>/vw/demo/rdb"
</PRE>

<P>
Затем, в GDB, введите:



<PRE>
(vxgdb) cd <VAR>hostpath</VAR>/vw/demo/rdb
(vxgdb) load prog.o
</PRE>

<P>
GDB отобразит ответ, аналогичный этому:



<PRE>
Reading symbol data from wherever/vw/demo/rdb/prog.o... done.
</PRE>

<P>
Вы также можете использовать команду <CODE>load</CODE>, чтобы заново загрузить
объектный модуль, после редактирования и повторной компиляции соответствующего
исходного файла.  Заметьте, что при этом GDB удаляет все
определенные точки останова, автоматические отображения, вспомогательные
переменные, и очищает историю значений.  (Это необходимо для того, чтобы
сохранить целостность структур данных отладчика, которые ссылаются
на таблицу символов целевой системы.)




<H4><A NAME="SEC127" HREF="gdb_toc.html#TOC127">Запуск задач</A></H4>

<P>
<A NAME="IDX593"></A>
Вы также можете присоединиться к существующей задаче, используя команду
<CODE>attach</CODE> следующим образом:



<PRE>
(vxgdb) attach <VAR>задача</VAR>
</PRE>

<P>
где <VAR>задача</VAR> является шестнадцатеричным идентификатором задачи
VxWorks.  Когда вы присоединяетесь к задаче, она может выполняться либо
быть приостановленной.  Выполняющаяся задача приостанавливается в момент
присоединения.




<H2><A NAME="SEC128" HREF="gdb_toc.html#TOC128">Встроенные процессоры</A></H2>

<P>
Этот раздел описывает детали, специфичные для определенных встроенных
конфигураций.




<H3><A NAME="SEC129" HREF="gdb_toc.html#TOC129">Встроенный AMD A29K</A></H3>

<DL COMPACT>

<DT><CODE>target adapt <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX594"></A>
 
Монитор Adapt для A29K.

<A NAME="IDX595"></A>
<DT><CODE>target amd-eb <VAR>устр</VAR> <VAR>скорость</VAR> <VAR>прог</VAR></CODE>
<DD>
<A NAME="IDX596"></A>
Удаленная PC-резидентная плата AMD EB29K, присоединенная по
последовательным линиям.  <VAR>Устр</VAR> является последовательным
устройством, также как для <CODE>target remote</CODE>; <VAR>скорость</VAR>
позволяет вам указать скорость линии; а <VAR>прог</VAR> является именем
программы, которая будет отлаживаться, так, как оно появляется в ДОС на ПК.
See section <A HREF="gdb_15.html#SEC131">Протокол EBMON для AMD29K</A>.

</DL>



<H4><A NAME="SEC130" HREF="gdb_toc.html#TOC130">A29K UDI</A></H4>

<P>
<A NAME="IDX597"></A>
<A NAME="IDX598"></A>


<P>
Для отладки процессоров семейства a29k, GDB поддерживает
протокол AMD UDI ("Universal Debugger
Interface"<A NAME="DOCF16" HREF="gdb_foot.html#FOOT16">(16)</A>).  Для использования
этой конфигурации с целями AMD, на которых выполняется монитор MiniMON,
вам нужна программа <CODE>MONTIP</CODE>, доступная бесплатно у AMD.  Вы можете
также использовать GDB с программой <CODE>ISSTIP</CODE>,
UDI-совместимым эмулятором a29k, также доступным у AMD.


<DL COMPACT>

<DT><CODE>target udi <VAR>кл-слово</VAR></CODE>
<DD>
<A NAME="IDX599"></A>
Выбрать интерфейс UDI к удаленной плате a29k или эмулятору.  Здесь
<VAR>кл-слово</VAR> является элементом в конфигурационном файле AMD
<TT>`udi_soc'</TT>.  Этот файл содержит в качестве элементов ключевые слова,
которые определяют параметры, используемые при соединении к целям a29k.
Если файл <TT>`udi_soc'</TT> не находится в вашем рабочем каталоге, вы
должны установить путь к нему в переменной среды <SAMP>`UDICONF'</SAMP>.
</DL>



<H4><A NAME="SEC131" HREF="gdb_toc.html#TOC131">Протокол EBMON для AMD29K</A></H4>

<P>
<A NAME="IDX600"></A>
<A NAME="IDX601"></A>


<P>
AMD распространяет плату разработки 29K, предназначенную для помещения в
ПК, вместе с программой монитора <CODE>EBMON</CODE>, работающей в ДОС.  Коротко эта
система разработки называется "EB29K".  Чтобы использовать
GDB из Unix-системы для выполнения программ на плате EB29K, вы
должны сперва соединить последовательным кабелем ПК (в котором
установлена плата EB29K) и последовательный порт на Unix-системе.  Далее
мы предполагаем, что вы соединили кабелем порт ПК <TT>`COM1'</TT> и
<TT>`/dev/ttya'</TT> на Unix-системе.




<H4><A NAME="SEC132" HREF="gdb_toc.html#TOC132">Установка связи</A></H4>

<P>
Следующим шагом нужно установить параметры порта ПК, сделав в ДОС что-то
вроде этого:



<PRE>
C:\&#62; MODE com1:9600,n,8,1,none
</PRE>

<P>
Этот пример, выполненный в системе MS DOS 4.0, устанавливает порт ПК в
9600бит/сек, без проверки четности, восьмибитные данные, один
стоп-бит и отсутствие действия для "повтора"; вы должны использовать
те же параметры связи при установке соединения со стороны Unix.


<P>
Чтобы передать управление с ПК стороне Unix, введите следующее в консоли
ДОС:



<PRE>
C:\&#62; CTTY com1
</PRE>

<P>
(Позже, если вы хотите вернуть управление консоли ДОС, вы можете
использовать команду <CODE>CTTY con</CODE>---но вы должны послать ее через
устройство, имевшее управление, в нашем примере через последовательную
линию <TT>`COM1'</TT>.)


<P>
На Unix-машине, для связи с ПК используйте коммуникационную программу,
такую как <CODE>tip</CODE> или <CODE>cu</CODE>.  Например



<PRE>
cu -s 9600 -l /dev/ttya
</PRE>

<P>
Показанные ключи для <CODE>cu</CODE> определяют, соответственно, скорость
линии и последовательный порт.  Если вместо этого вы используете
<CODE>tip</CODE>, ваша командная строка может выглядеть следующим образом:



<PRE>
tip -9600 /dev/ttya
</PRE>

<P>
Ваша система может требовать другого имени в том месте, где мы
показываем <TT>`/dev/ttya'</TT> в качестве аргумента к <CODE>tip</CODE>.
Параметры связи, включая используемый порт, ассоциированы с аргументом к
<CODE>tip</CODE> в файле описаний "remote"---обычно это <TT>`/etc/remote'</TT>.


<P>
<A NAME="IDX602"></A>
Используя соединение <CODE>tip</CODE> или <CODE>cu</CODE>, измените рабочий каталог
ДОС в тот, который содержит копию вашей программы 29K, затем запустите
на ПК программу <CODE>EBMON</CODE> (управляющая программа EB29K, поставляемая
AMD с вашей платой).  Вы должны увидеть начальный вывод <CODE>EBMON</CODE>,
аналогичный следующему, заканчивающийся приглашением <CODE>EBMON</CODE>
<SAMP>`#'</SAMP>:



<PRE>
C:\&#62; G:

G:\&#62; CD \usr\joe\work29k

G:\USR\JOE\WORK29K&#62; EBMON
Am29000 PC Coprocessor Board Monitor, version 3.0-18
Copyright 1990 Advanced Micro Devices, Inc.
Written by Gibbons and Associates, Inc.

Enter '?' or 'H' for help

PC Coprocessor Type   = EB29K
I/O Base              = 0x208
Memory Base           = 0xd0000

Data Memory Size      = 2048KB
Available I-RAM Range = 0x8000 to 0x1fffff
Available D-RAM Range = 0x80002000 to 0x801fffff

PageSize              = 0x400
Register Stack Size   = 0x800
Memory Stack Size     = 0x1800

CPU PRL               = 0x3
Am29027 Available     = No
Byte Write Available  = Yes

# ~.
</PRE>

<P>
Затем выйдите из программы <CODE>cu</CODE> или <CODE>tip</CODE> (в этом примере это
сделано при помощи ввода <CODE>~.</CODE> в приглашении <CODE>EBMON</CODE>).
<CODE>EBMON</CODE> продолжает работать, готовый к тому, что GDB
перехватит управление.


<P>
Для этого примера, мы предположили, что существует соединение PC/NFS,
которое устанавливает файловую систему Unix-машины как "диск
<TT>`G:'</TT>" на ПК.  Это является, вероятно, самым удобным способом
удостовериться, что одна и та же программа 29K находится и на ПК, и в
Unix-системе.  Если у вас нет PC/NFS или чего-нибудь аналогичного,
соединяющего две системы, вы должны прибегнуть к другому
способу передачи программы 29K из Unix на ПК---возможно переписать ее на
дискету.  GDB <EM>не</EM> загружает программы по последовательной
линии.




<H4><A NAME="SEC133" HREF="gdb_toc.html#TOC133">Кросс-отладка EB29K</A></H4>

<P>
Наконец, перейдите в каталог, содержащий образ вашей программы 29K в
Unix-системе, и запустите GDB, указав имя программы в качестве
аргумента:



<PRE>
cd /usr/joe/work29k
gdb myfoo
</PRE>

<P>
Теперь вы можете использовать команду <CODE>target</CODE>:



<PRE>
target amd-eb /dev/ttya 9600 MYFOO
</PRE>

<P>
В этом примере мы предполагали, что ваша программа находится в файле
<TT>`myfoo'</TT>.  Заметьте, что имя файла, заданное в качестве последнего
аргумента к <CODE>target amd-eb</CODE>, должно быть таким, каким его видит
ДОС.  В нашем примере, это просто <CODE>MYFOO</CODE>, но вообще оно может
включать путь ДОС, и, в зависимости от механизма передачи, может быть
не похоже на имя на Unix-машине.


<P>
В этом месте вы можете установить желаемые точки останова; когда вы
будете готовы увидеть вашу программы выполняющейся на плате 29K,
используйте команду GDB <CODE>run</CODE>.


<P>
Чтобы остановить отладку удаленной программы, используйте команду
GDB <CODE>detach</CODE>.


<P>
Чтобы возвратить управление консоли ПК, используйте <CODE>tip</CODE> или
<CODE>cu</CODE> снова, после завершения вашего сеанса GDB, чтобы
присоединиться к <CODE>EBMON</CODE>.  Затем вы можете ввести команду <CODE>q</CODE>,
чтобы завершить работу <CODE>EBMON</CODE>, возвращая управление командному
интерпретатору ДОС.  Введите <KBD>CTTY con</KBD>, чтобы возвратить командный
ввод основной консоли ДОС, и введите <KBD>~.</KBD>, чтобы покинуть <CODE>tip</CODE>
или <CODE>cu</CODE>.




<H4><A NAME="SEC134" HREF="gdb_toc.html#TOC134">Удаленный журнал</A></H4>
<P>
<A NAME="IDX603"></A>
<A NAME="IDX604"></A>


<P>
Команда <CODE>target amd-eb</CODE> создает в текущем рабочем каталоге файл
<TT>`eb.log'</TT>, чтобы помочь отладить проблемы с соединением.
<TT>`eb.log'</TT> записывает весь вывод <TT>`EBMON'</TT>, включая эхо
посланных ему команд.  Выполнение <SAMP>`tail -f'</SAMP> для этого файла в другом
окне часто помогает понять проблемы с <CODE>EBMON</CODE>, или неожиданные
события на стороне ПК.




<H3><A NAME="SEC135" HREF="gdb_toc.html#TOC135">ARM</A></H3>

<DL COMPACT>

<DT><CODE>target rdi <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX605"></A>
 
Монитор ARM Angel, через интерфейс библиотеки RDI к протоколу ADP.  Вы
можете использовать эту цель для взаимодействия как с платами, на
которых выполняется монитор Angel, так и с устройством отладки
EmbeddedICE JTAG.

<A NAME="IDX606"></A>
<DT><CODE>target rdp <VAR>устр</VAR></CODE>
<DD>
Монитор ARM Demon.

</DL>



<H3><A NAME="SEC136" HREF="gdb_toc.html#TOC136">Hitachi H8/300</A></H3>

<DL COMPACT>

<DT><CODE>target hms <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX607"></A>
 
Плата Hitachi SH, H8/300 или H8/500, присоединенная через
последовательную линию к вашей машине.  Используйте специальные команды
<CODE>device</CODE> и <CODE>speed</CODE> для управления последовательной линией и
используемой скоростью связи.

<A NAME="IDX608"></A>
<DT><CODE>target e7000 <VAR>устр</VAR></CODE>
<DD>
Эмулятор E7000 для Hitachi H8 и SH.

<A NAME="IDX609"></A>
<A NAME="IDX610"></A>
<DT><CODE>target sh3 <VAR>устр</VAR></CODE>
<DD>
<DT><CODE>target sh3e <VAR>устр</VAR></CODE>
<DD>
Целевые системы Hitachi SH-3 и SH-3E.

</DL>

<P>
<A NAME="IDX611"></A>
<A NAME="IDX612"></A>
<A NAME="IDX613"></A>
<A NAME="IDX614"></A>
Когда вы выбираете удаленную отладку для платы Hitachi SH, H8/300 или
H8/500, команда <CODE>load</CODE> загружает вашу программу на плату Hitachi, и
также открывает ее как текущую выполняемую цель для GDB на
вашей машине (как команда <CODE>file</CODE>).


<P>
Для общения с вашим Hitachi SH, H8/300 или H8/500, GDB
необходимо знать следующие вещи:



<OL>
<LI>

что вы хотите использовать: <SAMP>`target hms'</SAMP>, удаленный отладочный
интерфейс для микропроцессоров Hitachi, или <SAMP>`target e7000'</SAMP>,
встроенный эмулятор для Hitachi SH и Hitachi 300H.  (<SAMP>`target hms'</SAMP>
используется по умолчанию, если GDB сконфигурирован специально
для Hitachi SH, H8/300 или H8/500.)

<LI>

какое последовательное устройство соединяет вашу машину с платой Hitachi
(по умолчанию используется первое последовательное устройство, доступное
на вашей машине).

<LI>

какую скорость использовать для этого последовательного устройства.
</OL>



<H4><A NAME="SEC137" HREF="gdb_toc.html#TOC137">Соединение с платами Hitachi</A></H4>

<P>
<A NAME="IDX615"></A>
<A NAME="IDX616"></A>
Используйте специальную команду GDB <SAMP>`device <VAR>порт</VAR>'</SAMP>,
если вам нужно явно установить последовательное устройство.  По
умолчанию используется первый <VAR>порт</VAR>, доступный на вашей машине.
Это необходимо только на Unix-машинах, где это обычно что-то типа
<TT>`/dev/ttya'</TT>.


<P>
<A NAME="IDX617"></A>
<A NAME="IDX618"></A>
GDB имеет другую специальную команду для установки скорости
связи: <SAMP>`speed <VAR>bps</VAR>'</SAMP>.  Эта команда также используется только на
Unix-машинах; в ДОС, устанавливайте скорость линии как обычно извне
GDB командой <CODE>mode</CODE> (например,
<KBD>mode com2:9600,n,8,1,p</KBD> для соединения 9600бит/сек.


<P>
Команды <SAMP>`device'</SAMP> и <SAMP>`speed'</SAMP> доступны для отладки программ
микропроцессора Hitachi, только если вы используете рабочую среду Unix.
Если вы используете ДОС, для взаимодействия с платой разработки через
последовательный порт ПК GDB полагается на вспомогательную
резидентную программу <CODE>asynctsr</CODE>.  Вы также должны использовать
команду ДОС <CODE>mode</CODE>, чтобы подготовить порт со стороны ДОС.


<P>
Следующий пример сеанса иллюстрирует шаги, необходимые для запуска
программы на H8/300 под управлением GDB.  В нем используется
программа H8/300 под названием <TT>`t.x'</TT>.  Для Hitachi SH и H8/500
процедура та же самая.


<P>
Сперва подсоедините вашу плату разработки.  В этом примере, мы
используем плату, присоединенную к порту <CODE>COM2</CODE>.  Если вы
используете другой последовательный порт, подставьте его имя в агрументе
команды <CODE>mode</CODE>.  Когда вы вызываете <CODE>asynctsr</CODE>,
вспомогательную программу связи, используемую отладчиком, вы передаете
ей только числовую часть имени последовательного порта; например, ниже
<SAMP>`asynctsr 2'</SAMP> запускает <CODE>asynctsr</CODE> для <CODE>COM2</CODE>.



<PRE>
C:\H8300\TEST&#62; asynctsr 2
C:\H8300\TEST&#62; mode com2:9600,n,8,1,p

Resident portion of MODE loaded

COM2: 9600, n, 8, 1, p

</PRE>


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Мы обнаружили ошибку в PC-NFS, которая
конфликтует с <CODE>asynctsr</CODE>.  Если вы также используете PC-NFS на
вашей ДОС-машине, вам может потребоваться отключить его, или даже
загрузить машину без него, чтобы использовать <CODE>asynctsr</CODE> для
управления отладочной платой.
</BLOCKQUOTE>

<P>
<A NAME="IDX619"></A>
Теперь, когда связь установлена и плата разработки присоединена, вы
можете запустить GDB.  Вызовите <CODE>gdb</CODE> с именем
вашей программы в качестве аргумента.  GDB выводит
обычное приглашение: <SAMP>`(gdb)'</SAMP>.  Используйте две специальные
команды для начала сеанса отладки: <SAMP>`target hms'</SAMP> для задания
кросс-отладки для платы Hitachi, и команду <CODE>load</CODE> для загрузки вашей
программы на нее.  <CODE>load</CODE> выводит имена разделов программы, и
<SAMP>`*'</SAMP> для каждых двух килобайт загруженных данных.  (Если вы хотите
обновить данные GDB для символов или для выполняемого файла без
загрузки, используйте команды GDB <CODE>file</CODE> или
<CODE>symbol-file</CODE>.  Для описания этих команд, равно как и самой команды
<CODE>load</CODE>, см. section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>.)



<PRE>
(eg-C:\H8300\TEST) gdb t.x
GDB is free software and you are welcome to distribute copies
 of it under certain conditions; type "show copying" to see
 the conditions.
There is absolutely no warranty for GDB; type "show warranty"
for details.
GDB 5.0, Copyright 1992 Free Software Foundation, Inc...
(gdb) target hms
Connected to remote H8/300 HMS system.
(gdb) load t.x
.text   : 0x8000 .. 0xabde ***********
.data   : 0xabde .. 0xad30 *
.stack  : 0xf000 .. 0xf014 *
</PRE>

<P>
Теперь вы готовы выполнять или отлаживать вашу программу.  С этого
момента, вы можете использовать все обычные команды GDB.  Команда
<CODE>break</CODE> устанавливает точки останова; <CODE>run</CODE> запускает вашу
программу; <CODE>print</CODE> или <CODE>x</CODE> отображает данные; команда
<CODE>continue</CODE> возобновляет выполнение после остановки в точке
останова.  Вы можете использовать команду <CODE>help</CODE> в любой момент,
чтобы узнать больше о командах GDB.


<P>
Помните, однако, что возможности <EM>операционной системы</EM> не доступны
на вашей плате разработки; например, если ваша программа зависает, вы
не можете послать сигнал прерывания---но можете нажать кнопку RESET!


<P>
Используйте кнопку RESET на вашей плате разработки

<UL>
<LI>

чтобы прервать вашу программу (не используйте <KBD>ctl-C</KBD> на машине с
ДОС---у нее нет способа передать сигнал прерывания на плату разработки); и

<LI>

для возврата к приглашению GDB после того, как ваша программа
нормально завершается.  Протокол связи не предусматривает другого способа
для GDB определить, что ваша программа завершилась.
</UL>

<P>
В любом случае, GDB видит результат нажатия RESET на плате
разработки как "нормальное завершение" вашей программы.




<H4><A NAME="SEC138" HREF="gdb_toc.html#TOC138">Использование встроенного эмулятора E7000</A></H4>

<P>
<A NAME="IDX620"></A>
Вы можете использовать встроенный эмулятор E7000 для разработки кода либо
для Hitachi SH, либо для H8/300H.  Используйте одну из этих форм команды
<SAMP>`target e7000'</SAMP> для соединения GDB с вашей E7000:


<DL COMPACT>

<DT><CODE>target e7000 <VAR>порт</VAR> <VAR>скорость</VAR></CODE>
<DD>
Используйте эту форму, если ваша E7000 присоединена к последовательному
порту.  Аргумент <VAR>порт</VAR> идентифицирует, какой последовательный порт
использовать (например, <SAMP>`com2'</SAMP>).  Третий аргумент является
скоростью линии в битах в секунду (например, <SAMP>`9600'</SAMP>).

<DT><CODE>target e7000 <VAR>имя-узла</VAR></CODE>
<DD>
Если ваша E7000 установлена как узел сети TCP/IP, вы можете просто
указать его имя; GDB использует для соединения <CODE>telnet</CODE>.
</DL>



<H4><A NAME="SEC139" HREF="gdb_toc.html#TOC139">Специальные команды GDB для Hitachi</A></H4>

<P>
Некоторые команды GDB доступны только для H8/300:


<DL COMPACT>

<DT><CODE>set machine h8300</CODE>
<DD>
<A NAME="IDX621"></A>
 <A NAME="IDX622"></A>
 
<DT><CODE>set machine h8300h</CODE>
<DD>
Настраивайте GDB на один из двух вариантов архитектур H8/300 с
помощью <SAMP>`set machine'</SAMP>.  Вы можете использовать <SAMP>`show machine'</SAMP>,
чтобы проверить, какой из вариантов действует в данный момент.

</DL>



<H3><A NAME="SEC140" HREF="gdb_toc.html#TOC140">H8/500</A></H3>

<DL COMPACT>

<DT><CODE>set memory <VAR>мод</VAR></CODE>
<DD>
<A NAME="IDX623"></A>
 <A NAME="IDX624"></A>
 
<DT><CODE>show memory</CODE>
<DD>
Укажите, какую модель памяти H8/500 (<VAR>мод</VAR>) вы используете с помощью
<SAMP>`set memory'</SAMP>; проверяйте, какая модель используется при помощи
<SAMP>`show memory'</SAMP>.  Допустимыми значениями для <VAR>мод</VAR> являются
<CODE>small</CODE>, <CODE>big</CODE>, <CODE>medium</CODE> и <CODE>compact</CODE>.

</DL>



<H3><A NAME="SEC141" HREF="gdb_toc.html#TOC141">Intel i960</A></H3>

<DL COMPACT>

<DT><CODE>target mon960 <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX625"></A>
 
Монитор MON960 для Intel i960.

<A NAME="IDX626"></A>
<DT><CODE>target nindy <VAR>имя-устр</VAR></CODE>
<DD>
Плата Intel 960, управляемая Nindy Monitor.  <VAR>Имя-устр</VAR> является
именем последовательного устройства, которое должно использоваться для
соединения, например <TT>`/dev/ttya'</TT>.

</DL>

<P>
<A NAME="IDX627"></A>
<A NAME="IDX628"></A>
<EM>Nindy</EM>---это программа ROM Monitor для целевых систем Intel 960.
Когда GDB сконфигурирован для управления удаленным Intel 960 с
использованием Nindy, вы можете указать ему, как присоединиться к 960
несколькими способами:



<UL>
<LI>

Указав последовательный порт, версию протокола Nindy и скорость связи
через ключи командной строки;

<LI>

Ответив на запрос при старте;

<LI>

Используя команду <CODE>target</CODE> в любом месте вашего сеанса
GDB.  See section <A HREF="gdb_14.html#SEC108">Команды для управления целями</A>.

</UL>

<P>
<A NAME="IDX629"></A>
С интерфейсом Nindy к плате Intel 960, команда <CODE>load</CODE> загружает
<VAR>имя-файла</VAR> на 960, а также добавляет его символьные данные в
GDB.




<H4><A NAME="SEC142" HREF="gdb_toc.html#TOC142">Вызов Nindy</A></H4>

<P>
Если вы просто запустите <CODE>gdb</CODE> без использования ключей
командной строки, у вас запросят, какой последовательный порт
использовать, <EM>до</EM> того, как вы получите обычное приглашение
GDB:



<PRE>
Attach /dev/ttyNN -- specify NN, or "quit" to quit:
</PRE>

<P>
Ответьте на запрос с любым суффиксом (после <SAMP>`/dev/tty'</SAMP>),
определяющим последовательный порт, который вы хотите использовать.  Вы
можете, по своему выбору, просто начать работу без соединения с
Nindy, ответив на приглашение пустой строкой.  Если вы сделаете это и позже
захотите присоединиться к Nindy, используйте <CODE>target</CODE>
(see section <A HREF="gdb_14.html#SEC108">Команды для управления целями</A>).




<H4><A NAME="SEC143" HREF="gdb_toc.html#TOC143">Параметры для Nindy</A></H4>

<P>
Вот параметры вызова для начала вашего сеанса GDB с подключенной
платой Nindy-960:


<DL COMPACT>

<DT><CODE>-r <VAR>порт</VAR></CODE>
<DD>
Задайте имя порта последовательного интерфейса, который должен
использоваться для соединения с целевой системой.  Этот ключ доступен
только когда GDB сконфигурирован для целевой архитектуры Intel
960.  Вы можете определить <VAR>порт</VAR> любым из следующих способов:
полный путь (например, <SAMP>`-r /dev/ttya'</SAMP>), имя устройства в
<TT>`/dev'</TT> (например, <SAMP>`-r ttya'</SAMP>) или просто уникальный суффикс для
определенного <CODE>tty</CODE> (например, <SAMP>`-r a'</SAMP>).

<DT><CODE>-O</CODE>
<DD>
(Заглавная буква "O", не ноль.)  Определяет, что GDB
должен использовать "старый" протокол монитора Nindy для
соединения с целевой системой.  Этот ключ доступен только когда
GDB сконфигурирован для целевой архитектуры Intel 960.


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> если вы определите <SAMP>`-O'</SAMP>, но в
действительности попытаетесь связаться с системой, которая
ожидает более нового протокола, соединение не будет установлено, как
будто не соответствуют скорости.  GDB неоднократно пытается
соединиться снова на нескольких различных скоростях линии.  Вы можете
остановить этот процесс посредством прерывания.
</BLOCKQUOTE>

<DT><CODE>-brk</CODE>
<DD>
Определяет, что GDB должен сперва послать целевой системе
сигнал <CODE>BREAK</CODE>, пытаясь сбросить ее, перед соединением с целью
Nindy.


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Многие целевые системы не имеют требуемых
для этого аппаратных средств; это работает только на немногих платах.
</BLOCKQUOTE>

</DL>

<P>
Стандартный ключ <SAMP>`-b'</SAMP> управляет скоростью линии, используемой на
последовательном порту.




<H4><A NAME="SEC144" HREF="gdb_toc.html#TOC144">Команда сброса Nindy</A></H4>

<DL COMPACT>

<DT><CODE>reset</CODE>
<DD>
<A NAME="IDX630"></A>
Для целей Nindy, эта команда посылает "break" удаленной целевой
системе; она полезна, только если целевая система была оборудована
схемой для выполнения аппаратного сброса (или других действий,
представляющих интерес) при обнаружении прерывания.
</DL>



<H3><A NAME="SEC145" HREF="gdb_toc.html#TOC145">Mitsubishi M32R/D</A></H3>

<DL COMPACT>

<DT><CODE>target m32r <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX631"></A>
 
Монитор ROM Mitsubishi M32R/D.

</DL>



<H3><A NAME="SEC146" HREF="gdb_toc.html#TOC146">M68k</A></H3>

<P>
Конфигурация Motorola m68k включает поддержку ColdFire, и команду
<CODE>target</CODE> для следующих мониторов ROM.


<DL COMPACT>

<DT><CODE>target abug <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX632"></A>
 
Монитор ABug ROM для M68K.

<A NAME="IDX633"></A>
<DT><CODE>target cpu32bug <VAR>устр</VAR></CODE>
<DD>
Монитор CPU32BUG, выполняющийся на плате CPU32 (M68K).

<A NAME="IDX634"></A>
<DT><CODE>target dbug <VAR>устр</VAR></CODE>
<DD>
Монитор dBUG ROM для Motorola ColdFire.

<A NAME="IDX635"></A>
<DT><CODE>target est <VAR>устр</VAR></CODE>
<DD>
Монитор EST-300 ICE, выполняющийся на плате CPU32 (M68K).

<A NAME="IDX636"></A>
<DT><CODE>target rom68k <VAR>устр</VAR></CODE>
<DD>
Монитор ROM 68K, выполняющийся на плате M68K IDP.

</DL>

<P>
Если GDB сконфигурирован с <CODE>m68*-ericsson-*</CODE>, то вместо
этого у него будет только одна специальная команда <CODE>target</CODE>:


<DL COMPACT>

<DT><CODE>target es1800 <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX637"></A>
 
Эмулятор ES-1800 для M68K.

</DL>

<DL COMPACT>

<DT><CODE>target rombug <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX638"></A>
 
Монитор ROMBUG ROM для OS/9000.

</DL>



<H3><A NAME="SEC147" HREF="gdb_toc.html#TOC147">M88K</A></H3>

<DL COMPACT>

<DT><CODE>target bug <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX639"></A>
 
Монитор BUG, выполняющийся на плате MVME187 (m88k).

</DL>



<H3><A NAME="SEC148" HREF="gdb_toc.html#TOC148">Встроенный MIPS</A></H3>

<P>
<A NAME="IDX640"></A>
GDB может использовать удаленный отладочный протокол MIPS для
взаимодействия с платой MIPS, присоединенной к последовательной линии.
Эта возможность доступна, если вы сконфигурировали GDB с
<SAMP>`--target=mips-idt-ecoff'</SAMP>.


<P>
Используйте эти команды GDB для определения соединения с вашей
целевой платой:


<DL COMPACT>

<DT><CODE>target mips <VAR>порт</VAR></CODE>
<DD>
<A NAME="IDX641"></A>
Для выполнения программы на плате, выполните <CODE>gdb</CODE>, задав
имя программы в качестве аргумента.  Для соединения с платой,
используйте команду <SAMP>`target mips <VAR>порт</VAR>'</SAMP>, где <VAR>порт</VAR>---имя
последовательного порта, присоединенного к плате.  Если программа еще не
была загружена на плату, вы можете использовать команду <CODE>load</CODE>,
чтобы это сделать.  Затем вы можете использовать все обычные команды
GDB.

Например, эта последовательность команд устанавливает соединение к
целевой плате через последовательный порт, загружает и начинает
выполнение из отладчика программы с именем <VAR>prog</VAR>:


<PRE>
host$ gdb <VAR>prog</VAR>
GDB is free software and ...
(gdb) target mips /dev/ttyb
(gdb) load <VAR>prog</VAR>
(gdb) run
</PRE>

<DT><CODE>target mips <VAR>имя-машины</VAR>:<VAR>номер-порта</VAR></CODE>
<DD>
В некоторых рабочих конфигурациях GDB, вы можете задать
TCP-соединение (например, к последовательной линии, управляемой
терминальным концентратором) вместо последовательного порта, используя
синтаксис <SAMP>`<VAR>имя-машины</VAR>:<VAR>номер-порта</VAR>'</SAMP>.

<DT><CODE>target pmon <VAR>порт</VAR></CODE>
<DD>
<A NAME="IDX642"></A>
Монитор ROM PMON.

<DT><CODE>target ddb <VAR>порт</VAR></CODE>
<DD>
<A NAME="IDX643"></A>
NEC DDB-разновидность PMON для Vr4300.

<DT><CODE>target lsi <VAR>порт</VAR></CODE>
<DD>
<A NAME="IDX644"></A>
LSI-разновидность PMON.

<A NAME="IDX645"></A>
<DT><CODE>target r3900 <VAR>устр</VAR></CODE>
<DD>
Densan DVE-R3900 монитор ROM для Toshiba R3900 Mips.

<A NAME="IDX646"></A>
<DT><CODE>target array <VAR>устр</VAR></CODE>
<DD>
Плата контроллера RAID Array Tech LSI33K.

</DL>

<P>
GDB также поддерживает следующие специальные команды для целей
MIPS:


<DL COMPACT>

<DT><CODE>set processor <VAR>арг</VAR></CODE>
<DD>
<DT><CODE>show processor</CODE>
<DD>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>
Используйте команду <CODE>set processor</CODE> для установки типа процессора
MIPS, когда вы хотите обратиться к регистрам, уникальным для данного
типа процессора.  Например, <CODE>set processor <VAR>r3041</VAR></CODE> велит
GDB использовать регистры CPO, соответствующие микросхеме
3041.  Используйте команду <CODE>show processor</CODE>, чтобы узнать, какой
процессор MIPS используется GDB.  Используйте команду
<CODE>info reg</CODE> чтобы узнать, какие регистры использует GDB.

<DT><CODE>set mipsfpu double</CODE>
<DD>
<DT><CODE>set mipsfpu single</CODE>
<DD>
<DT><CODE>set mipsfpu none</CODE>
<DD>
<DT><CODE>show mipsfpu</CODE>
<DD>
<A NAME="IDX649"></A>
<A NAME="IDX650"></A>
<A NAME="IDX651"></A>
Если ваша целевая плата не поддерживает сопроцессор MIPS для вычислений
с плавающей точкой, вы должны использовать команду <SAMP>`set mipsfpu
none'</SAMP> (если вам это нужно, вы можете поместить эту команду в ваш
файл инициализации GDB).
Это говорит GDB, как найти значения
функций, которые возвращают величины с плавающей точкой.  Это также
позволяет GDB избежать сохранения регистров с плавающей точкой
при вызове функций на плате.  Если вы используете сопроцессор поддержки
вычислений с плавающей точкой с поддержкой только одинарной точности,
как на процессоре R4650, используйте команду <SAMP>`set mipsfpu
single'</SAMP>.  По умолчанию используется сопроцессор поддержки вычислений с
плавающей точкой двойной точности; этот режим может быть выбран с
помощью <SAMP>`set mipsfpu double'</SAMP>.

В предыдущих версиях, единственным выбором была двойная точность или
отсутствие поддержки вычислений с плавающей точкой, так что <SAMP>`set
mipsfpu on'</SAMP> выберет режим двойной точности, а <SAMP>`set mipsfpu off'</SAMP>
отключит эту поддержку.

Как обычно, вы можете запросить значение переменной <CODE>mipsfpu</CODE> при
помощи <SAMP>`show mipsfpu'</SAMP>.

<DT><CODE>set remotedebug <VAR>n</VAR></CODE>
<DD>
<DT><CODE>show remotedebug</CODE>
<DD>
<A NAME="IDX652"></A>
<A NAME="IDX653"></A>
<A NAME="IDX654"></A>
<A NAME="IDX655"></A>
Вы можете увидеть некоторую отладочную информацию о связи с
платой, установив переменную <CODE>remotedebug</CODE>.  Если вы установите ее
в <CODE>1</CODE> при помощи <SAMP>`set remotedebug 1'</SAMP>, будет отображаться
каждый пакет.  Если вы установите ее в <CODE>2</CODE>, то будет отображаться
каждый символ.  В любой момент вы можете проверить текущее значение
переменной командой <SAMP>`show remotedebug'</SAMP>.

<DT><CODE>set timeout <VAR>секунды</VAR></CODE>
<DD>
<DT><CODE>set retransmit-timeout <VAR>секунды</VAR></CODE>
<DD>
<DT><CODE>show timeout</CODE>
<DD>
<DT><CODE>show retransmit-timeout</CODE>
<DD>
<A NAME="IDX656"></A>
<A NAME="IDX657"></A>
<A NAME="IDX658"></A>
<A NAME="IDX659"></A>
<A NAME="IDX660"></A>
<A NAME="IDX661"></A>
Вы можете управлять временем ожидания пакета, используемом в удаленном
протоколе MIPS, при помощи команды <CODE>set timeout <VAR>секунды</VAR></CODE>.
Значение по умолчанию---5 секунд.  Аналогично, вы можете управлять
временем ожидания, используемом при ожидании подтверждения пакета с
помощью команды <CODE>set retransmit-timeout <VAR>секунды</VAR></CODE>.  По
умолчанию 3 секунды.  Вы можете узнать обе эти величины с помощью
<CODE>show timeout</CODE> и <CODE>show retransmit-timeout</CODE>.  (Эти команды
доступны <EM>только</EM> если GDB сконфигурирован для цели
<SAMP>`--target=mips-idt-ecoff'</SAMP>.)

Время ожидания, установленное при помощи <CODE>set timeout</CODE>, не имеет
значения, когда GDB ожидает остановки вашей программы.  В этом
случае, GDB ждет бесконечно, потому что у него нет способа
узнать, сколько программа будет выполняться, пока не остановится.
</DL>



<H3><A NAME="SEC149" HREF="gdb_toc.html#TOC149">PowerPC</A></H3>

<DL COMPACT>

<DT><CODE>target dink32 <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX662"></A>
 
Монитор ROM DINK32.

<A NAME="IDX663"></A>
<DT><CODE>target ppcbug <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX664"></A>
<DT><CODE>target ppcbug1 <VAR>устр</VAR></CODE>
<DD>
Монитор ROM PPCBUG для PowerPC.

<A NAME="IDX665"></A>
<DT><CODE>target sds <VAR>устр</VAR></CODE>
<DD>
Монитор SDS, выполняющийся на плате PowerPC (такой как Motorola ADS).

</DL>



<H3><A NAME="SEC150" HREF="gdb_toc.html#TOC150">Встроенный HP PA</A></H3>

<DL COMPACT>

<DT><CODE>target op50n <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX666"></A>
 
Монитор OP50N, выполняющийся на плате OKI HPPA.

<A NAME="IDX667"></A>
<DT><CODE>target w89k <VAR>устр</VAR></CODE>
<DD>
Монитор W89K, выполняющийся на плате Winbond HPPA.

</DL>



<H3><A NAME="SEC151" HREF="gdb_toc.html#TOC151">Hitachi SH</A></H3>

<DL COMPACT>

<DT><CODE>target hms <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX668"></A>
 
Плата Hitachi SH, присоединенная через последовательную линию к вашей
рабочей машине.  Используйте специальные команды <CODE>device</CODE> и
<CODE>speed</CODE> для управления последовательной линией и используемой
скоростью связи.

<A NAME="IDX669"></A>
<DT><CODE>target e7000 <VAR>устр</VAR></CODE>
<DD>
Эмулятор E7000 для Hitachi SH.

<A NAME="IDX670"></A>
<A NAME="IDX671"></A>
<DT><CODE>target sh3 <VAR>устр</VAR></CODE>
<DD>
<DT><CODE>target sh3e <VAR>устр</VAR></CODE>
<DD>
Целевые системы Hitachi SH-3 и SH-3E.

</DL>



<H3><A NAME="SEC152" HREF="gdb_toc.html#TOC152">Tsqware Sparclet</A></H3>

<P>
<A NAME="IDX672"></A>


<P>
GDB позволяет разработчикам отлаживать с Unix-машины задачи,
выполняющиеся на целевых системах Sparclet.  GDB использует код,
который выполняется как Unix-машине, так и на цели Sparclet.  Программа
<CODE>gdb</CODE> устанавливается и работает на Unix-машине.


<DL COMPACT>

<DT><CODE>remotetimeout <VAR>арг</VAR></CODE>
<DD>
<A NAME="IDX673"></A>
GDB поддерживает параметр <CODE>remotetimeout</CODE>.  Он
устанавливатся пользователем, а <VAR>арг</VAR> представляет число секунд, в
течение которых GDB ожидает ответы.
</DL>

<P>
<A NAME="IDX674"></A>
При компиляции для отладки, используйте ключи <SAMP>`-g'</SAMP> для получения
отладочной информации, и <SAMP>`-Ttext'</SAMP> для того, чтобы разместить
программу в том месте, в каком вы хотите загрузить ее на целевую
машину.  Вы также можете добавить ключ <SAMP>`-n'</SAMP> или <SAMP>`-N'</SAMP>,
чтобы уменьшить размеры разделов.  Например:



<PRE>
sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N
</PRE>

<P>
Для проверки, что адреса в действительности являются теми, которые вы
подразумевали, можно использовать <CODE>objdump</CODE>:



<PRE>
sparclet-aout-objdump --headers --syms prog
</PRE>

<P>
<A NAME="IDX675"></A>
После того, как вы установили путь поиска выполняемых файлов, в котором
присутствует GDB, вы готовы запустить отладчик.  С вашей
рабочей машины Unix, выполните <CODE>gdb</CODE> (или
<CODE>sparclet-aout-gdb</CODE>, в зависимости от вашей установки).


<P>
GDB запустится и покажет приглашение:



<PRE>
(gdbslet)
</PRE>



<H4><A NAME="SEC153" HREF="gdb_toc.html#TOC153">Установка файла для отладки</A></H4>

<P>
Команда GDB <CODE>file</CODE> позволяет вам выбрать программу для
отладки.



<PRE>
(gdbslet) file prog
</PRE>

<P>
Затем GDB пытается прочитать таблицу символов программы
<TT>`prog'</TT>.  Он находит файл путем поиска в каталогах, перечисленных в
пути поиска команд.  Если файл был скомпилирован с отладочной
информацией (ключ <SAMP>`-g'</SAMP>), то также будет произведен поиск исходных
файлов.  GDB находит исходные файлы, производя поиск в
каталогах, перечисленных в пути поиска каталогов (see section <A HREF="gdb_5.html#SEC19">Рабочая среда вашей программы</A>).  Если ему не удается найти файл, он выводит
сообщение, подобное этому:



<PRE>
prog: No such file or directory.
</PRE>

<P>
Когда это случается, добавьте соответствующие каталоги в пути поиска с
помощью команд GDB <CODE>path</CODE> и <CODE>dir</CODE>, и выполните
команду <CODE>target</CODE> снова.




<H4><A NAME="SEC154" HREF="gdb_toc.html#TOC154">Соединение к Sparclet</A></H4>

<P>
Команда GDB <CODE>target</CODE> позволяет вам установить
соединение с целевой машиной Sparclet.  Для соединения с
последовательным портом "<CODE>ttya</CODE>", введите:



<PRE>
(gdbslet) target sparclet /dev/ttya
Remote target sparclet connected to /dev/ttya
main () at ../prog.c:3
</PRE>

<P>
GDB выведет сообщение, подобное этому:



<PRE>
Connected to ttya.
</PRE>



<H4><A NAME="SEC155" HREF="gdb_toc.html#TOC155">Загрузка на Sparclet</A></H4>

<P>
<A NAME="IDX676"></A>
Когда вы установили соединение к цели Sparclet, вы можете использовать
команду GDB <CODE>load</CODE> для загрузки файла с рабочей машины на
целевую.  Имя файла и смещение загрузки должно быть задано команде
<CODE>load</CODE> в качестве аргумента.  Так как формат файла aout, программа
должна быть загружена по начальному адресу.  Чтобы определить, чему
равна эта величина, вы можете использовать <CODE>objdump</CODE>.  Смещение
загрузки---это смещение, которое добавляется к VMA (Virtual Memory
Address<A NAME="DOCF17" HREF="gdb_foot.html#FOOT17">(17)</A>)
каждого раздела файла.
Например, если программа <TT>`prog'</TT> была скомпонована с адресом текста
0x1201000, сегментом данных по адресу 0x12010160 и сегментом стека по
адресу 0x12010170, введите в GDB:



<PRE>
(gdbslet) load prog 0x12010000
Loading section .text, size 0xdb0 vma 0x12010000
</PRE>

<P>
Если код загружается по адресу, отличному от того, по которому программа
была скомпонована, вам может потребоваться использовать команды
<CODE>section</CODE> и <CODE>add-symbol-file</CODE>, чтобы сообщить GDB,
куда отобразить таблицу символов.




<H4><A NAME="SEC156" HREF="gdb_toc.html#TOC156">Выполнение и отладка</A></H4>

<P>
<A NAME="IDX677"></A>
Теперь вы можете начать отлаживать задачу, используя команды
GDB для управления выполнением, <CODE>b</CODE>, <CODE>step</CODE>,
<CODE>run</CODE>, и так далее.  Все такие команды перечислены в этом
руководстве.



<PRE>
(gdbslet) b main
Breakpoint 1 at 0x12010000: file prog.c, line 3.
(gdbslet) run
Starting program: prog
Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
3        char *symarg = 0;
(gdbslet) step
4        char *execarg = "hello!";
(gdbslet)
</PRE>



<H3><A NAME="SEC157" HREF="gdb_toc.html#TOC157">Fujitsu Sparclite</A></H3>

<DL COMPACT>

<DT><CODE>target sparclite <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX678"></A>
 
Платы Fujitsu sparclite, используемые только с целью загрузки.  Чтобы
отлаживать программу, вы должны использовать дополнительную команду.
Например, target remote <VAR>устр</VAR>, используя стандартный удаленный
протокол GDB.

</DL>



<H3><A NAME="SEC158" HREF="gdb_toc.html#TOC158">Tandem ST2000</A></H3>

<P>
GDB может быть использован с телефонным коммутатором Tandem
ST2000, поддерживающим протокол Tandem STDBUG.


<P>
Для соединения вашего ST2000 с рабочей машиной, смотрите руководство
производителя.  После того, как ST2000 физически подключен, вы можете
выполнить:



<PRE>
target st2000 <VAR>устр</VAR> <VAR>скорость</VAR>
</PRE>

<P>
чтобы установить его как вашу отладочную среду.  <VAR>Устр</VAR>---это обычно
имя последовательного устройства, такое как <TT>`/dev/ttya'</TT>,
соединенного с ST2000 через последовательную линию.  Вместо этого, вы
можете указать <VAR>устр</VAR> как TCP-соединение (например, к
последовательной линии, присоединенной через терминальный концентратор),
используя синтаксис <CODE><VAR>имя-машины</VAR>:<VAR>номер-порта</VAR></CODE>.


<P>
Команды <CODE>load</CODE> и <CODE>attach</CODE> <EM>не</EM> определены для этой цели;
вы должны загрузить вашу программу на ST2000 также, как вы это обычно
делаете для автономных действий.  GDB читает отладочную
информацию (например, символы) из отдельной, отладочной версии
программы, которая доступна на вашем рабочем компьютере.


<P>
<A NAME="IDX679"></A>
Следующие вспомогательные команды GDB доступны для облегчения
работы в среде ST2000:


<DL COMPACT>

<DT><CODE>st2000 <VAR>команда</VAR></CODE>
<DD>
<A NAME="IDX680"></A>
<A NAME="IDX681"></A>
<A NAME="IDX682"></A>
Послать <VAR>команду</VAR> монитору STDBUG.  Доступные команды описаны в
руководстве производителя.

<DT><CODE>connect</CODE>
<DD>
<A NAME="IDX683"></A>
Соединяет управляющий терминал с командным монитором STDBUG.  Когда вы
закончили взаимодействие с STDBUG, ввод одной из двух
последовательностей символов возвратит вас назад к приглашению
GDB: <KBD><KBD>RET</KBD>~.</KBD> (Return, за которым следует тильда и
точка) или <KBD><KBD>RET</KBD>~<KBD>C-d</KBD></KBD> (Return, за которым следует тильда
и control-D).
</DL>



<H3><A NAME="SEC159" HREF="gdb_toc.html#TOC159">Zilog Z8000</A></H3>

<P>
<A NAME="IDX684"></A>
<A NAME="IDX685"></A>
<A NAME="IDX686"></A>


<P>
Будучи сконфигурированным для отладки целей Zilog Z8000, GDB
включает имитатор Z8000.


<P>
Для семейства Z8000, <SAMP>`target sim'</SAMP> имитирует либо Z8002 (не
сегментированный вариант архитектуры Z8000), либо Z8001
(сегментированный вариант).  Имитатор распознает подходящую архитектуру
изучая объектный код.


<DL COMPACT>

<DT><CODE>target sim <VAR>арг</VAR></CODE>
<DD>
<A NAME="IDX687"></A>
<A NAME="IDX688"></A>
Отладка программ на имитируемом ЦП.  Если имитатор поддерживает
параметры установки, укажите их в <VAR>арг</VAR>.
</DL>

<P>
После определения этой цели, вы можете отлаживать программы для
имитированного ЦП таким же образом, как программы для вашего рабочего
компьютера; используйте команду <CODE>file</CODE> для загрузки образа новой
программы, команду <CODE>run</CODE> для запуска вашей программы, и так далее.


<P>
Помимо того, что доступны все обычные машинные регистры
(see section <A HREF="gdb_9.html#SEC60">Регистры</A>), имитатор Z8000 предоставляет три
специально названных регистра с дополнительной информацией:


<DL COMPACT>

<DT><CODE>cycles</CODE>
<DD>
Считает тактовые импульсы с имитаторе.

<DT><CODE>insts</CODE>
<DD>
Считает инструкции, выполненные в имитаторе.

<DT><CODE>time</CODE>
<DD>
Время выполнения в шестидесятых долях секунды.

</DL>

<P>
Вы можете ссылаться на эти значения в выражениях GDB с помощью
обычных соглашений; например, <SAMP>`b fputc if $cycles&#62;5000'</SAMP>
устанавливает условную точку останова, которая срабатывает только после
как минимум 5000 имитированных тактовых импульсов.




<H2><A NAME="SEC160" HREF="gdb_toc.html#TOC160">Архитектуры</A></H2>

<P>
Этот раздел описывает свойства архитектур, которые воздействуют на все
применения GDB с данной архитектурой, как при чистой отладке,
так и при кросс-отладке.




<H3><A NAME="SEC161" HREF="gdb_toc.html#TOC161">A29K</A></H3>

<DL COMPACT>

<DT><CODE>set rstack_high_address <VAR>адрес</VAR></CODE>
<DD>
<A NAME="IDX689"></A>
 <A NAME="IDX690"></A>
 <A NAME="IDX691"></A>
 
В процессорах семейства AMD 29000, регистры сохраняются в отдельном
<EM>стеке регистров</EM>.  Для отладчика не существует способа
определить размер этого стека.  Обычно, GDB просто
подразумевает, что стек "достаточно большой".  Это может привести к
тому, что GDB попытается обратиться несуществующей области
памяти.  В случае необходимости, вы можете решить эту проблему, указав
конечный адрес стека регистров с помощью команды <CODE>set
rstack_high_address</CODE>.  Аргумент должен быть адресом, который вы,
вероятно, захотите начать с <SAMP>`0x'</SAMP>, чтобы задать его в
шестнадцатеричном виде.

<A NAME="IDX692"></A>
<DT><CODE>show rstack_high_address</CODE>
<DD>
Отобразить текущее ограничение на стек регистров для процессоров
семейства AMD 29000.

</DL>



<H3><A NAME="SEC162" HREF="gdb_toc.html#TOC162">Alpha</A></H3>

<P>
Смотрите следующий раздел.




<H3><A NAME="SEC163" HREF="gdb_toc.html#TOC163">MIPS</A></H3>

<P>
<A NAME="IDX693"></A>
<A NAME="IDX694"></A>
<A NAME="IDX695"></A>
<A NAME="IDX696"></A>
Компьютеры, базирующиеся на архитектурах Alpha и MIPS, используют
необычный кадр стека, который иногда требует от GDB поиска в
объектном коде в обратном направлении, чтобы найти начало функции.


<P>
<A NAME="IDX697"></A>
Чтобы сократить время ответа (особенно для встроенных приложений, где
GDB может быть ограничен медленной последовательной линией для
этого поиска), вы можете захотеть ограничить область поиска, используя
одну из этих команд:


<DL COMPACT>

<DT><CODE>set heuristic-fence-post <VAR>предел</VAR></CODE>
<DD>
<A NAME="IDX698"></A>
 
Ограничить GDB для исследования не более <VAR>предела</VAR> байт при
поиске начала функции.  Значение <VAR>0</VAR> (по умолчанию) означает
неограниченный поиск.  Однако, исключая <VAR>0</VAR>, чем больше предел, тем
больше байт <CODE>heuristic-fence-post</CODE> должен просмотреть, и,
следовательно, тем дольше он будет выполняться.

<DT><CODE>show heuristic-fence-post</CODE>
<DD>
Отобразить текущее значение данного предела.
</DL>

<P>
Эти команды доступны <EM>только</EM> когда GDB сконфигурирован
для отладки программ на процессорах Alpha или MIPS.


<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_14.html">previous</A>, <A HREF="gdb_16.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
