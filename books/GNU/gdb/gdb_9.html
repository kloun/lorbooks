<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Исследование данных</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_8.html">previous</A>, <A HREF="gdb_10.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC50" HREF="gdb_toc.html#TOC50">Исследование данных</A></H1>

<P>
<A NAME="IDX302"></A>
<A NAME="IDX303"></A>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>
Для исследования данных в вашей программе обычно используется
команда <CODE>print</CODE> (сокращенно <CODE>p</CODE>) или ее синоним
<CODE>inspect</CODE>.  Она вычисляет и выводит значение выражения, записанного
на том же языке, что и ваша программа (see section <A HREF="gdb_10.html#SEC62">Использование GDB с различными языками программирования</A>).


<DL COMPACT>

<DT><CODE>print <VAR>выраж</VAR></CODE>
<DD>
<DT><CODE>print /<VAR>f</VAR> <VAR>выраж</VAR></CODE>
<DD>
<VAR>выраж</VAR> является выражением (на исходном языке).  По умолчанию, значение
<VAR>выраж</VAR> выводится в формате, соответствующем его типу данных; вы можете
выбрать другой формат, указав <SAMP>`/<VAR>f</VAR>'</SAMP>, где <VAR>f</VAR>---буква,
определяющая формат; смотрите section <A HREF="gdb_9.html#SEC54">Форматы вывода</A>.

<DT><CODE>print</CODE>
<DD>
<DT><CODE>print /<VAR>f</VAR></CODE>
<DD>
Если вы опустите <VAR>выраж</VAR>, GDB отображает последнее
значение снова (из <EM>истории значений</EM>; see section <A HREF="gdb_9.html#SEC58">История значений</A>).  Это предоставляет вам удобный способ изучить то же
самое значение в другом формате.
</DL>

<P>
Команда <CODE>x</CODE> позволяет исследовать данные на более низком уровне.  Она
исследует данные в памяти по указанному адресу и выводит их в
указанном формате.  See section <A HREF="gdb_9.html#SEC55">Исследование памяти</A>.


<P>
Если вас интересует информация о типах или о том, как объявлены
поля структуры или класса, используйте команду <CODE>ptype <VAR>выраж</VAR></CODE>
вместо <CODE>print</CODE>.  See section <A HREF="gdb_11.html#SEC95">Исследование таблицы символов</A>.




<H2><A NAME="SEC51" HREF="gdb_toc.html#TOC51">Выражения</A></H2>

<P>
<A NAME="IDX306"></A>
<CODE>print</CODE> и многие другие команды GDB допускают в качестве
параметра выражение и вычисляют его значение.  В выражении GDB
допустимо использование любого типа констант, переменных или операторов,
определенных в используемом вами языке программирования, включая
условные выражения, вызовы функций, приведение типов и строковые
постоянные.  К сожалению, исключением являются символы, определенные
командами препроцессора <CODE>#define</CODE>.


<P>
GDB поддерживает константы-массивы в выражениях, введенных
пользователем.  Синтаксис следующий: {<VAR>элемент</VAR>,
<VAR>элемент</VAR>...}.  Например, вы можете использовать команду
<CODE>print {1, 2, 3}</CODE>, чтобы создать в памяти массив,
который будет доступен в программе так же, как выделенный функцией
<CODE>malloc</CODE>.


<P>
По причине широкого распространения Си, большинство выражений в
примерах этого руководства написаны на Си.  See section <A HREF="gdb_10.html#SEC62">Использование GDB с различными языками программирования</A>, для информации об использовании
выражений в других языках.


<P>
В этом разделе мы обсуждаем операторы, которые вы можете использовать
в выражениях GDB независимо от используемого вами языка
программирования.


<P>
Приведения типов поддерживается во всех языках, а не только в Си,
так как бывает очень полезно преобразовать число в указатель, чтобы
исследовать структуру, расположенную по этому адресу в памяти.


<P>
GDB поддерживает эти операторы, в дополнении к следующим,
являющимися общими для языков программирования:


<DL COMPACT>

<DT><CODE>@</CODE>
<DD>
<SAMP>`@'</SAMP> является бинарным оператором, позволяющим рассматривать
области памяти как массивы.
See section <A HREF="gdb_9.html#SEC53">Искусственные массивы</A>, для дополнительной информации.

<DT><CODE>::</CODE>
<DD>
<SAMP>`::'</SAMP> позволяет вам указывать переменную в терминах файла или функции,
где она определена.  See section <A HREF="gdb_9.html#SEC52">Переменные программы</A>.

<A NAME="IDX307"></A>
<A NAME="IDX308"></A>
<A NAME="IDX309"></A>
<A NAME="IDX310"></A>
<DT><CODE>{<VAR>тип</VAR>} <VAR>адрес</VAR></CODE>
<DD>
Ссылается на объект типа <VAR>тип</VAR>, хранящийся в памяти по адресу
<VAR>адрес</VAR>.  <VAR>Адрес</VAR> может быть любым выражением, значением которого
является целое число или указатель (но вокруг бинарных операторов, также
как и вокруг оператора приведения типа, требуются скобки).  Эта
конструкция допустима, независимо от того, какого типа данные
предположительно расположены по <VAR>адресу</VAR>.
</DL>



<H2><A NAME="SEC52" HREF="gdb_toc.html#TOC52">Переменные программы</A></H2>

<P>
Чаще всего в качестве выражения используется имя переменной вашей
программы.


<P>
Переменные в выражениях трактуются в контексте выбранного кадра стека
(see section <A HREF="gdb_7.html#SEC43">Выбор кадра</A>); они могут быть либо



<UL>
<LI>

глобальными (или статическими)
</UL>

<P>
либо



<UL>
<LI>

видимыми из точки выполнения в данном кадре, в соответствии с правилами
определения области видимости языка программирования.
</UL>

<P>
Это означает, что в функции



<PRE>
foo (a)
     int a;
{
  bar (a);
  {
    int b = test ();
    bar (b);
  }
}
</PRE>

<P>
вы можете исследовать и использовать переменную <CODE>a</CODE> всякий раз,
когда ваша программа выполняется в пределах функции <CODE>foo</CODE>, но вы
можете использовать или исследовать переменную <CODE>b</CODE> только тогда,
когда ваша программа выполняется внутри блока, в котором она объявлена.


<P>
<A NAME="IDX311"></A>
Есть исключение: вы можете ссылаться на переменную или функцию, областью
видимости которой является единственный исходный файл, даже если точка
текущего выполнения в нем не находится.  Допускается существование
нескольких переменных или функций с одинаковым именем (в различных
исходных файлах).  Если это так, обращение к этому имени приводит к
непредсказуемым результатам.  Если хотите, вы можете указать
статическую переменную в конкретной функции или в файле, используя
двойное двоеточие:


<P>
<A NAME="IDX312"></A>
<A NAME="IDX313"></A>

<PRE>
<VAR>файл</VAR>::<VAR>переменная</VAR>
<VAR>функция</VAR>::<VAR>переменная</VAR>
</PRE>

<P>
Здесь <VAR>файл</VAR> или <VAR>функция</VAR>---название контекста для статической
<VAR>переменной</VAR>.  В первом случае вы можете использовать кавычки, чтобы
GDB рассматривал имя файла как одно слово; например, чтобы вывести
глобальное значение переменной <CODE>x</CODE>, определенной в <TT>`f2.c'</TT>:



<PRE>
(gdb) p 'f2.c'::x
</PRE>

<P>
<A NAME="IDX314"></A>
Такое использование <SAMP>`::'</SAMP> крайне редко конфликтует с похожим
использованием той же записи в Си++.  GDB также поддерживает
использование оператора определения области видимости Си++ в выражениях.


<P>
<A NAME="IDX315"></A>
<A NAME="IDX316"></A>

<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> В некоторых случаях, в определенной точке функции
(сразу после входа в новую область видимости, и непосредственно перед
выходом из нее)
может показаться, что локальная переменная имеет неверное значение.
</BLOCKQUOTE>

<P>
Вы можете столкнуться с этой проблемой при пошаговом выполнении по
одной машинной инструкции.  Она возникает из-за того, что на большинстве
машин процедура установки кадра стека (включая определения локальных
переменных) занимает более одной инструкции; если вы
производите пошаговое выполнение по одной машинной инструкции, может
показаться, что переменная имеет неверное значение, пока кадр стека не
будет полностью построен.  При выходе, для уничтожения кадра стека
обычно также требуется более одной инструкции; после начала
пошагового выполнения этой группы инструкций, определения локальных переменных
могут пропасть.


<P>
Это также может случиться, когда компилятор делает значительную
оптимизацию.  Чтобы быть уверенным, что вы всегда видите точные
значения, отключите всю оптимизацию при компиляции.


<P>
<A NAME="IDX317"></A>
Другой возможный эффект оптимизации компилятора заключается в уничтожении
неиспользуемых переменных, или в присвоении переменных регистрам (а не
адресам памяти).  В зависимости от поддержки таких ситуаций,
предоставляемой форматом отладочной информации, который использует
компилятор, GDB может не вывести значения таких локальных
переменных.  Если это происходит, GDB выведет сообщение,
подобное этому:



<PRE>
No symbol "foo" in current context.
</PRE>

<P>
Для решения таких проблем, либо перекомпилируйте программу без
оптимизации, или используйте другой формат отладочной информации, если
компилятор поддерживает несколько таких форматов.  Например
GCC, компилятор GNU Си/Си++, обычно поддерживает ключ
<SAMP>`-gstabs'</SAMP>.  <SAMP>`-gstabs'</SAMP> создает отладочную информацию в формате,
являющимся развитием таких форматов, как COFF.  У вас может быть
возможность использовать DWARF-2 (<SAMP>`-gdwarf-2'</SAMP>), который тоже
является эффективной формой представления отладочной информации.
Смотрите section `Опции для отладки вашей программы или GNU CC' in <CITE>Использование GNU CC</CITE>, для дополнительной
информации.




<H2><A NAME="SEC53" HREF="gdb_toc.html#TOC53">Искусственные массивы</A></H2>

<P>
<A NAME="IDX318"></A>
<A NAME="IDX319"></A>
Часто бывает полезным вывести несколько объектов одного типа,
расположенных в памяти последовательно; часть массива или динамический
массив, для которого в программе существует только указатель.


<P>
Вы можете это сделать, обращаясь к непрерывному участку памяти как к
<EM>искусственному массиву</EM>, используя бинарный оператор <SAMP>`@'</SAMP>.
Левым операндом для <SAMP>`@'</SAMP> должен быть первый элемент желаемого
массива, и он должен быть индивидуальным объектом.  Правым операндом
должна быть длина массива.  Результатом операции будет массив, все элементы
которого имеют тот же тип, что и левый аргумент.  Первым элементом
массива является левый аргумент; второй элемент формируется из байтов
памяти, непосредственно следующих за байтами, содержащими первый элемент, и
так далее.  Например, если в программе есть строка



<PRE>
int *array = (int *) malloc (len * sizeof (int));
</PRE>

<P>
то вы можете вывести содержимое <CODE>array</CODE> с помощью



<PRE>
p *array@len
</PRE>

<P>
Левый операнд операции <SAMP>`@'</SAMP> должен находиться в памяти.
Значения массивов, полученных операцией <SAMP>`@'</SAMP>, при индескации ведут
себя точно так же, как и другие массивы, и приводятся к указателям при
использовании в выражениях.  Искусственные массивы чаще всего появляются
в выражениях через историю значений (see section <A HREF="gdb_9.html#SEC58">История значений</A>), после вывода одного из них.


<P>
Другой способ создания искусственного массива---использование приведения
типов.  Оно заново интерпретирует значение так, как если бы оно было
массивом.  Значение не обязано находиться в памяти.

<PRE>
(gdb) p/x (short[2])0x12345678
$1 = {0x1234, 0x5678}
</PRE>

<P>
Если вы опускаете длину массива (как в
<SAMP>`(<VAR>тип</VAR>[])<VAR>значение</VAR>'</SAMP>), GDB для удобства вычисляет
его размер для заполнения значениями (как
<SAMP>`sizeof(<VAR>значение</VAR>)/sizeof(<VAR>тип</VAR>)'</SAMP>:

<PRE>
(gdb) p/x (short[])0x12345678
$2 = {0x1234, 0x5678}
</PRE>

<P>
Иногда механизма искусственных массивов бывает недостаточно;
в сравнительно сложных структурах данных, интересующие нас элементы могут
не быть смежными---например, если вас интересуют значения указателей в
массиве.  Одно из полезных решений этой проблемы---использование
вспомогательной переменной (see section <A HREF="gdb_9.html#SEC59">Вспомогательные переменные</A>) в качестве счетчика в выражении, выводящем
первое интересующее нас значение, а затем повторять это выражение
нажатием <KBD>RET</KBD>.  Предположим, например, у вас есть массив
<CODE>dtab</CODE> указателей на структуры, и вас интересуют значения полей
<CODE>fv</CODE> в каждой структуре.  Ниже приведен пример ваших возможных действий:



<PRE>
set $i = 0
p dtab[$i++]-&#62;fv
<KBD>RET</KBD>
<KBD>RET</KBD>
...
</PRE>



<H2><A NAME="SEC54" HREF="gdb_toc.html#TOC54">Форматы вывода</A></H2>

<P>
<A NAME="IDX320"></A>
<A NAME="IDX321"></A>
По умолчанию, GDB печатает значение в соответствии с его типом.
Это не всегда отвечает вашему желанию.  Например, вы можете захотеть вывести
число в шестнадцатеричной записи, или указатель в десятичной.  Или вы
можете захотеть просмотреть данные по некоторому адресу в памяти в
виде строки символов или в виде инструкций.  Для этого, при выводе значения
укажите <EM>формат вывода</EM>.


<P>
Простейшим применением форматов вывода является форматирование вывода
уже вычисленного выражения.  Это осуществляется путем начала параметров
команды <CODE>print</CODE> с косой черты и символа формата.  Поддерживаются
следующие символы формата:


<DL COMPACT>

<DT><CODE>x</CODE>
<DD>
Рассматривать биты значения как целое, и вывести целое в
шестнадцатеричном виде.

<DT><CODE>d</CODE>
<DD>
Вывести как десятичное целое со знаком.

<DT><CODE>u</CODE>
<DD>
Вывести как десятичное целое без знака.

<DT><CODE>o</CODE>
<DD>
Вывести как восьмеричное целое.

<DT><CODE>t</CODE>
<DD>
Вывести как целое в двоичном виде.  Буква <SAMP>`t'</SAMP> означает "two".
<A NAME="DOCF11" HREF="gdb_foot.html#FOOT11">(11)</A>

<DT><CODE>a</CODE>
<DD>
<A NAME="IDX322"></A>
Вывести в виде адреса, как абсолютного в шестнадцатеричной записи, так и
в виде смещения от ближайшего предшествующего символа.  Вы можете
использовать этот формат для того, чтобы определить, где (в какой
функции) расположен какой-либо неизвестный адрес:


<PRE>
(gdb) p/a 0x54320
$3 = 0x54320 &#60;_initialize_vx+396&#62;
</PRE>

<DT><CODE>c</CODE>
<DD>
Рассматривать как целое и вывести в виде строковой постоянной.

<DT><CODE>f</CODE>
<DD>
Рассматривать биты значения как число с плавающей точкой и вывести с
использованием обычного синтаксиса для чисел с плавающей точкой.
</DL>

<P>
Например, чтобы вывести счетчик программы в шестнадцатеричном виде
(see section <A HREF="gdb_9.html#SEC60">Регистры</A>), введите



<PRE>
p/x $pc
</PRE>

<P>
Обратите внимание, что перед косой чертой не требуется пробела, потому
что имена команд в GDB не могут содержать косую черту.


<P>
Чтобы вывести последнее значение из истории значений в другом
формате, вы можете воспользоваться командой <CODE>print</CODE> лишь с указанием
формата и без выражения.  Например, <SAMP>`p/x'</SAMP> выведет последнее
значение в шестнадцатеричной форме.




<H2><A NAME="SEC55" HREF="gdb_toc.html#TOC55">Исследование памяти</A></H2>

<P>
Вы можете использовать команду <CODE>x</CODE> (от слова "examine") для
исследования памяти в одном из нескольких форматов, независимо от типов
данных вашей программы.


<P>
<A NAME="IDX323"></A>
<DL COMPACT>

<DT><CODE>x/<VAR>nfu</VAR> <VAR>адрес</VAR></CODE>
<DD>
<A NAME="IDX324"></A>
 
<DT><CODE>x <VAR>адрес</VAR></CODE>
<DD>
<DT><CODE>x</CODE>
<DD>
Для исследования памяти используйте команду <CODE>x</CODE>.
</DL>

<P>
<VAR>n</VAR>, <VAR>f</VAR> и <VAR>u</VAR>---необязательные параметры, определяющие,
сколько памяти отобразить и в каком формате; <VAR>адрес</VAR>---это выражение,
задающее адрес, с которого вы хотите начать отображение памяти.  Если вы
используете значения по умолчанию для <VAR>nfu</VAR>, то вам не нужно вводить
косую черту <SAMP>`/'</SAMP>.  Некоторые команды устанавливают удобные значения
по умолчанию для <VAR>адреса</VAR>.


<DL COMPACT>

<DT><VAR>n</VAR>, счетчик повторений
<DD>
Счетчик повторений является десятичным целым числом; по умолчанию 1.
Он определяет, сколько памяти отобразить (считая в единицах <VAR>u</VAR>).

<DT><VAR>f</VAR>, формат отображения
<DD>
Формат отображения---это один из форматов, используемых командой
<CODE>print</CODE>, <SAMP>`s'</SAMP> (строка, оканчивающаяся нулем), или <SAMP>`i'</SAMP>
(машинная инструкция).  Первоначально, значением по умолчанию
установлено <SAMP>`x'</SAMP> (шестнадцатеричная форма).  Значение по умолчанию
изменяется каждый раз, когда вы используете либо <CODE>x</CODE>, либо
<CODE>print</CODE>.

<DT><VAR>u</VAR>, размер единицы измерений
<DD>
Размер единицы измерений может быть одним из

<DL COMPACT>

<DT><CODE>b</CODE>
<DD>
Байты.
<DT><CODE>h</CODE>
<DD>
Полуслова (два байта).
<DT><CODE>w</CODE>
<DD>
Слова (четыре байта).  Это первоначальное значение по умолчанию.
<DT><CODE>g</CODE>
<DD>
Длинные слова (восемь байт).
</DL>

Каждый раз, когда вы определяете размер единицы измерений командой <CODE>x</CODE>,
этот размер становится размером по умолчанию при последующем использовании
<CODE>x</CODE>.  (Для форматов <SAMP>`s'</SAMP> и <SAMP>`i'</SAMP>, размер единицы измерений
игнорируется и обычно не пишется.)

<DT><VAR>адрес</VAR>, начальный адрес отображения
<DD>
<VAR>адрес</VAR>---это адрес, с которого вы хотите, чтобы GDB
начинал отображение памяти.  Значение выражения не обязано должно быть
указателем (хотя может им быть); оно всегда интерпретируется как целый
адрес байта в памяти.  See section <A HREF="gdb_9.html#SEC51">Выражения</A>, для дополнительной
информации о выражениях.  Значением по умолчанию для <VAR>адреса</VAR>
обычно является адрес, следующий за последним изученным адресом, но некоторые
другие команды также устанавливают это значение: <CODE>info breakpoints</CODE>
(в адрес последней выведенной точки останова), <CODE>info line</CODE> (в
начальный адрес строки) и <CODE>print</CODE> (если вы используете эту
команду для отображения значения из памяти).
</DL>

<P>
Например, <SAMP>`x/3uh 0x54320'</SAMP>---запрос на вывод трех полуслов
(<CODE>h</CODE>) памяти в формате беззнаковых десятичных целых (<SAMP>`u'</SAMP>),
начиная с адреса <CODE>0x54320</CODE>.  <SAMP>`x/4xw $sp'</SAMP> выводит четыре слова
(<SAMP>`w'</SAMP>) памяти, расположенные над указателем стека (здесь <SAMP>`$sp'</SAMP>;
see section <A HREF="gdb_9.html#SEC60">Регистры</A>), в шестнадцатеричном виде (<SAMP>`x'</SAMP>).


<P>
Так как все буквы, обозначающие размер единиц измерения, отличаются от букв,
определяющих форматы вывода, вы не должны запоминать, формат или размер
единиц измерений указывается раньше; это можно делать в любом
порядке.  Спецификации вывода <SAMP>`4xw'</SAMP> и <SAMP>`4wx'</SAMP> означают в
точности одно и то же.  (Однако, число <VAR>n</VAR> должно быть первым;
<SAMP>`wx4'</SAMP> не сработает.)


<P>
Хотя размер единицы измерения <VAR>u</VAR> игнорируется для форматов <SAMP>`s'</SAMP>
и <SAMP>`i'</SAMP>, тем не менее вы можете воспользоваться счетчиком повторений
<VAR>n</VAR>; например, <SAMP>`3i'</SAMP> указывает, что вы хотите вывести три
машинные инструкции, включая любые операнды.  Команда <CODE>disassemble</CODE>
предоставляет альтернативный способ исследования машинных инструкций;
смотрите section <A HREF="gdb_8.html#SEC49">Исходный текст и машинный код</A>.


<P>
Все значения по умолчанию для аргументов команды <CODE>x</CODE> разработаны
таким образом, чтобы облегчить продолжение сканирования памяти с
минимальными конкретизациями при очередном использовании <CODE>x</CODE>.  Например,
после того, как вы просмотрели три машинные инструкции с помощью
<SAMP>`x/3i <VAR>адрес</VAR>'</SAMP>, вы можете просмотреть следующие семь, используя
просто <SAMP>`x/7'</SAMP>.  Если вы повторяете команду <CODE>x</CODE> нажатием
<KBD>RET</KBD>, число повторений <VAR>n</VAR> остается прежним; другие параметры
берутся по умолчанию, как для последовательных использований <CODE>x</CODE>.


<P>
<A NAME="IDX325"></A>
Адреса и их содержимое, выводимые командой <CODE>x</CODE>, не сохраняются в
истории значений, так как они мешали бы.
Вместо этого,
GDB делает их доступными для последующего использования в
выражениях как значения вспомогательных переменных <CODE>$_</CODE> и
<CODE>$__</CODE>.  После команды <CODE>x</CODE>, последний исследованный адрес
доступен для использования в выражениях во вспомогательной переменной
<CODE>$_</CODE>.  Содержимое этого адреса, исследованное только что, доступно во
вспомогательной переменной <CODE>$__</CODE>.


<P>
Если команде <CODE>x</CODE> задан счетчик повторений, адрес и его содержимое
сохраняются из последнего выведенного элемента памяти; это не то же
самое, что последний выведенный адрес, если в последней строке вывода
были отображены несколько элементов.




<H2><A NAME="SEC56" HREF="gdb_toc.html#TOC56">Автоматическое отображение</A></H2>
<P>
<A NAME="IDX326"></A>
<A NAME="IDX327"></A>


<P>
Если вам необходимо часто выводить значение какого-либо выражения
(чтобы увидеть, как оно меняется), вы можете добавить его в
<EM>список автоматического отображения</EM>, чтобы GDB выводил его
значение каждый раз при остановке вашей программы.  Каждому выражению,
добавленному в список, присваивается идентификационный номер; чтобы
удалить выражение из списка, вы указываете этот номер.  Автоматическое
отображение выглядит следующим образом:



<PRE>
2: foo = 38
3: bar[5] = (struct hack *) 0x3804
</PRE>

<P>
Это отображение показывает номера элементов, выражения и их текущие
значения.  Как и при отображении, запрашиваемом вручную с помощью <CODE>x</CODE>
или <CODE>print</CODE>, вы можете указать предпочитаемый формат вывода;
фактически, <CODE>display</CODE> определяет, следует использовать <CODE>print</CODE>
или <CODE>x</CODE>, в зависимости от того, на сколько жесткая ваша
спецификация формата: используется <CODE>x</CODE>, если вы указываете размер
элемента или один из двух форматов (<SAMP>`i'</SAMP> и <CODE>s</CODE>), которые
поддерживаются только <CODE>x</CODE>; в остальных случаях используется <CODE>print</CODE>.


<DL COMPACT>

<DT><CODE>display <CODE>выраж</CODE></CODE>
<DD>
<A NAME="IDX328"></A>
 
Добавляет выражение <VAR>выраж</VAR> к списку выражений, отображаемых каждый
раз, когда ваша программа останавливается.  See section <A HREF="gdb_9.html#SEC51">Выражения</A>.

<CODE>display</CODE> не повторяется, если вы повторно нажимаете
<KBD>RET</KBD> после ее использования.

<DT><CODE>display/<VAR>формат</VAR> <VAR>выраж</VAR></CODE>
<DD>
Если <VAR>формат</VAR> определяет только формат вывода, а не размер или
счетчик повторений, выражение <VAR>выраж</VAR> добавляется в список
автоматического отображения, но его отображение осуществляется в
указанном формате <VAR>формат</VAR>.  See section <A HREF="gdb_9.html#SEC54">Форматы вывода</A>.

<DT><CODE>display/<VAR>формат</VAR> <VAR>адрес</VAR></CODE>
<DD>
Если <VAR>форматом</VAR> является <SAMP>`i'</SAMP> или <SAMP>`s'</SAMP>, или он включает в себя размер
элементов или их число, выражение <VAR>адрес</VAR> добавляется как адрес
памяти для исследования при каждой остановке вашей программы.  Под
исследованием в данном случае подразумевается выполнение
<SAMP>`x/<VAR>формат</VAR> <VAR>адрес</VAR>'</SAMP>.  See section <A HREF="gdb_9.html#SEC55">Исследование памяти</A>.
</DL>

<P>
Например, команда <SAMP>`display/i $pc'</SAMP> может быть полезна, чтобы при каждой
остановке видеть машинную инструкцию, которая будет
выполняться следующей (<SAMP>`$pc'</SAMP>---это общее обозначение счетчика
программы; see section <A HREF="gdb_9.html#SEC60">Регистры</A>).


<DL COMPACT>

<DT><CODE>undisplay <VAR>номера</VAR>...</CODE>
<DD>
<A NAME="IDX329"></A>
 <A NAME="IDX330"></A>
 
<DT><CODE>delete display <VAR>номера</VAR>...</CODE>
<DD>
Удалить элементы с номерами <VAR>номера</VAR> из списка выражений, подлежащих
отображению.

<CODE>undisplay</CODE> не повторяется при последующем нажатии <KBD>RET</KBD>.
(Иначе вы сразу получили бы сообщение об ошибке <SAMP>`No display number
...'</SAMP>.)

<A NAME="IDX331"></A>
<DT><CODE>disable display <VAR>номера</VAR>...</CODE>
<DD>
Отключить отображение элементов с номерами <VAR>номера</VAR>.  Отключенные
элементы не выводятся автоматически, но и не забываются.
Впоследствии их можно снова включить.

<A NAME="IDX332"></A>
<DT><CODE>enable display <VAR>номера</VAR>...</CODE>
<DD>
Включить отображение элементов с номерами <VAR>номера</VAR>.  Выражения,
соответствующие этим номерам, снова будут выводиться автоматически, пока
вы укажете обратное.

<DT><CODE>display</CODE>
<DD>
Отобразить текущие значения выражений из списка, точно так же,
как это происходит при остановке вашей программы.

<A NAME="IDX333"></A>
<DT><CODE>info display</CODE>
<DD>
Вывести список выражений, ранее установленных для автоматического
отображения, каждое с его номером элемента, но не показывая значений.  Список
включает отключенные выражения, с соответствующей пометкой.  Он также
включает в себя выражения, которые не могут быть показаны прямо сейчас,
потому что обращаются к автоматическим переменным, недоступным
в данный момент.
</DL>

<P>
Если отображаемое выражение обращается к локальным переменным, оно
не имеет смысла вне того лексического контекста, для которого оно
устанавливалось.  Такое выражения отключается, как только выполнение
входит в контекст, где одна из его переменных становится неопределенной.
Например, если вы дадите команду <CODE>display last_char</CODE>, находясь
внутри функции с аргументом <CODE>last_char</CODE>, GDB будет
отображать этот аргумент, пока программа останавливается внутри этой
функции.  Как только она остановится где-то еще---где нет переменной
<CODE>last_char</CODE>---отображение будет отключено автоматически.  Вы
можете снова включить его при следующей остановке программы там, где
<CODE>last_char</CODE> будет вновь иметь смысл.




<H2><A NAME="SEC57" HREF="gdb_toc.html#TOC57">Параметры вывода</A></H2>

<P>
<A NAME="IDX334"></A>
<A NAME="IDX335"></A>
GDB предоставляет следующие способы управления выводом массивов,
структур и символов.


<P>
Данные параметры полезны при отладке программ на любом языке:


<DL COMPACT>

<DT><CODE>set print address</CODE>
<DD>
<A NAME="IDX336"></A>
 
<DT><CODE>set print address on</CODE>
<DD>
GDB выводит адреса памяти, показывающие положение стека,
структур, указателей, точек останова, и так далее, даже
когда он отображает также содержимое этих адресов.  Значение по умолчанию
установлено в <CODE>on</CODE>.  Например, вот как выглядит отображение кадра
стека с установленным <CODE>set print address on</CODE>:


<PRE>
(gdb) f
#0  set_quotes (lq=0x34c78 "&#60;&#60;", rq=0x34c88 "&#62;&#62;")
    at input.c:530
530         if (lquote != def_lquote)
</PRE>

<DT><CODE>set print address off</CODE>
<DD>
Не выводить адреса при отображении их содержимого.  Вот, например,
тот же кадр стека, отображенный с установкой <CODE>set print address
off</CODE>:


<PRE>
(gdb) set print addr off
(gdb) f
#0  set_quotes (lq="&#60;&#60;", rq="&#62;&#62;") at input.c:530
530         if (lquote != def_lquote)
</PRE>

Вы можете использовать <SAMP>`set print address off'</SAMP>, чтобы удалить
все машинно-зависимые отображения из интерфейса GDB.  Например, с
<CODE>print address off</CODE>, вы должны получить одинаковый текст для
цепочек вызовов на всех машинах, независимо от того, включают они
указатели в качестве аргументов или нет.

<A NAME="IDX337"></A>
<DT><CODE>show print address</CODE>
<DD>
Показать, должны выводиться адреса или нет.
</DL>

<P>
При выводе адреса в символьной форме, GDB обычно выводит ближайший
предшествующий символ плюс смещение.  Если этот символ не определяет
адрес однозначно (например, это имя, областью действия которого является
один исходный файл), вам может потребоваться дать пояснения.  Один из
способов это сделать---с помощью <CODE>info line</CODE>; например,
<SAMP>`info line *0x4537'</SAMP>.  Альтернативный способ заключается в том, чтобы
GDB выводил имя исходного файла и номер строки при выводе
символьного адреса:


<DL COMPACT>

<DT><CODE>set print symbol-filename on</CODE>
<DD>
<A NAME="IDX338"></A>
 
Велит GDB выводить имя исходного файла и номер строки
символа в символьной форме адреса.

<DT><CODE>set print symbol-filename off</CODE>
<DD>
Не выводить имя исходного файла и номер строки символа.  Принимается по
умолчанию.

<A NAME="IDX339"></A>
<DT><CODE>show print symbol-filename</CODE>
<DD>
Показать, будет GDB выводить имя исходного файла и номер строки
в символьной форме адреса или нет.
</DL>

<P>
Другая ситуация, в которой полезно показывать имена файлов
и номера строк, возникает при дисассемблировании кода; GDB
показывает вам номер строки и исходный файл, которые соответствуют
каждой инструкции.


<P>
Вы также можете захотеть видеть символьную форму только в том
случае, если выводимый адрес достаточно близок к ближайшему
предшествующему символу:


<DL COMPACT>

<DT><CODE>set print max-symbolic-offset <VAR>макс-смещение</VAR></CODE>
<DD>
<A NAME="IDX340"></A>
 
Велит GDB выводить символьные формы только тех
адресов, для которых смещение между ближайшим предшествующим символом и
адресом меньше, чем <VAR>макс-смещение</VAR>.  По умолчанию значение
<VAR>макс-смещение</VAR> равно 0; в этом случае GDB всегда выводит
адрес в символьной форме, если ему предшествует хоть какой-нибудь символ.

<A NAME="IDX341"></A>
<DT><CODE>show print max-symbolic-offset</CODE>
<DD>
Запрашивает информацию о максимальном смещении, для которого GDB
выводит символьную форму адреса.
</DL>

<P>
<A NAME="IDX342"></A>
<A NAME="IDX343"></A>
Если у вас есть указатель, и вы не знаете, на что он указывает,
попробуйте <SAMP>`set print symbol-filename on'</SAMP>.  Затем вы можете определить
название и исходный файл переменной, на которую он указывает, используя
<SAMP>`p/a <VAR>указатель</VAR>'</SAMP>.  Это интерпретирует адрес в символьной
форме.  Например, здесь GDB показывает, что переменная
<CODE>ptt</CODE> указывает на другую переменную <CODE>t</CODE>, определенную в файле
<TT>`hi2.c'</TT>:



<PRE>
(gdb) set print symbol-filename on
(gdb) p/a ptt
$4 = 0xe008 &#60;t in hi2.c&#62;
</PRE>


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Для указателей, указывающих на локальные
переменные, <SAMP>`p/a'</SAMP> не показывает символьное имя и имя файла,
которому принадлежит объект ссылки, даже если установлен соответствующий
параметр <CODE>set print</CODE>.
</BLOCKQUOTE>

<P>
Другие установки управляют выводом объектов различных типов:


<DL COMPACT>

<DT><CODE>set print array</CODE>
<DD>
<A NAME="IDX344"></A>
 
<DT><CODE>set print array on</CODE>
<DD>
Структурный вывод массивов.  Этот формат удобенее для чтения, но
занимает больше места.  По умолчанию отключено.

<DT><CODE>set print array off</CODE>
<DD>
Вернуться к сжатому формату вывода массивов.

<A NAME="IDX345"></A>
<DT><CODE>show print array</CODE>
<DD>
Показать, какой формат (сжатый или структурный) выбран для отображения
массивов.

<A NAME="IDX346"></A>
<DT><CODE>set print elements <VAR>число-элементов</VAR></CODE>
<DD>
Установить ограничение на количество выводимых GDB элементов
массива.  Если GDB выводит большой массив, вывод прерывается
после того, как будет выведено установленное командой <CODE>set print
elements</CODE> число элементов.  Это ограничение также действует при
отображении строк.  Когда GDB стартует, этот предел принимается
равным 200.  Установка <VAR>число-элементов</VAR> в ноль означает, что вывод
не ограничен.

<A NAME="IDX347"></A>
<DT><CODE>show print elements</CODE>
<DD>
Показать количество элементов большого массива, которые будут выведены
GDB.  Если это число равно 0, вывод не ограничивается.

<A NAME="IDX348"></A>
<DT><CODE>set print null-stop</CODE>
<DD>
Указывает GDB прекращать вывод символов массива, как только
встретится первый NULL.  Это полезно, когда большие массивы
фактически содержат только короткие строки.
По умолчанию отключено.

<A NAME="IDX349"></A>
<DT><CODE>set print pretty on</CODE>
<DD>
Велит GDB выводить структуры в формате с отступами, по одному
элементу в строке, например:


<PRE>
$1 = {
  next = 0x0,
  flags = {
    sweet = 1,
    sour = 1
  },
  meat = 0x54 "Pork"
}
</PRE>

<DT><CODE>set print pretty off</CODE>
<DD>
Указывает GDB выводить структуры в компактном формате, как здесь:


<PRE>
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
meat = 0x54 "Pork"}
</PRE>

Этот формат устанавливается по умолчанию.

<A NAME="IDX350"></A>
<DT><CODE>show print pretty</CODE>
<DD>
Показать, какой формат GDB использует для вывода структур.

<A NAME="IDX351"></A>
<DT><CODE>set print sevenbit-strings on</CODE>
<DD>
Осуществлять вывод, используя только семибитные символы; если этот
параметр установлен, GDB отображает любые восьмибитные символы (в
строках или символьных значениях), используя запись <CODE>\</CODE><VAR>nnn</VAR>.
Эта установка очень удобна, если вы работаете на английском (ASCII)
и используете старший бит символов как маркер или "мета"-бит.

<DT><CODE>set print sevenbit-strings off</CODE>
<DD>
Выводить восьмибитные символы полностью.  Это позволяет
использовать большее количество международных наборов символов, и
устанавливается по умолчанию.

<A NAME="IDX352"></A>
<DT><CODE>show print sevenbit-strings</CODE>
<DD>
Показать, выводит GDB только семибитные литеры или нет.

<A NAME="IDX353"></A>
<DT><CODE>set print union on</CODE>
<DD>
Велит GDB выводить объединения, содержащиеся в структурах.
Устанавливается по умолчанию.

<DT><CODE>set print union off</CODE>
<DD>
Указывает GDB не выводить объединения, содержащиеся в структурах.

<A NAME="IDX354"></A>
<DT><CODE>show print union</CODE>
<DD>
Запросить GDB, будет ли он выводить объединения, содержащиеся
в структурах.

Например, пусть даны описания


<PRE>
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
              Bug_forms;

struct thing {
  Species it;
  union {
    Tree_forms tree;
    Bug_forms bug;
  } form;
};

struct thing foo = {Tree, {Acorn}};
</PRE>

с установленным <CODE>set print union on</CODE>, команда <SAMP>`p foo'</SAMP> выведет


<PRE>
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
</PRE>

а с установленным <CODE>set print union off</CODE>, эта же команда выведет


<PRE>
$1 = {it = Tree, form = {...}}
</PRE>

</DL>

<P>
Следующие установки представляют интерес при отладке программ на Си++:


<DL COMPACT>

<DT><CODE>set print demangle</CODE>
<DD>
<A NAME="IDX355"></A>
 <A NAME="IDX356"></A>
 
<DT><CODE>set print demangle on</CODE>
<DD>
Печатать идентификаторы Си++ в их изначальной, а не в закодированной
("искаженной") форме, передаваемой ассемблеру и компоновщику для
сборки с контролем типа.  Установлено по умолчанию.

<A NAME="IDX357"></A>
<DT><CODE>show print demangle</CODE>
<DD>
Показать, в искаженной или восстановленной форме выводятся
идентификаторы Си++.

<A NAME="IDX358"></A>
<DT><CODE>set print asm-demangle</CODE>
<DD>
<DT><CODE>set print asm-demangle on</CODE>
<DD>
Выводить идентификаторы Си++ в их исходной форме, а не в
искаженной, даже при выводе ассемблерного кода, например при
дисассемблировании инструкций.  По умолчанию отключено.

<A NAME="IDX359"></A>
<DT><CODE>show print asm-demangle</CODE>
<DD>
Показать, в закодированной или восстановленной форме выводятся
имена Си++ при выводе кода ассемблера.

<A NAME="IDX360"></A>
<A NAME="IDX361"></A>
<DT><CODE>set demangle-style <VAR>стиль</VAR></CODE>
<DD>
Выбрать одну из нескольких схем кодирования, используемых
различными компиляторами для представления имен Си++.  Параметр
<VAR>стиль</VAR> может быть следующим:

<DL COMPACT>

<DT><CODE>auto</CODE>
<DD>
Позволить GDB выбрать стиль декодирования посредством
изучения вашей программы.

<DT><CODE>gnu</CODE>
<DD>
Декодирование основывается на алгоритме кодирования компилятора
GNU Си++ (<CODE>g++</CODE>).  Устанавливается по умолчанию.

<DT><CODE>hp</CODE>
<DD>
Декодирование основывается на алгоритме кодирования HP ANSI Си++ (<CODE>aCC</CODE>).

<DT><CODE>lucid</CODE>
<DD>
Декодирование основывается на алгоритме кодирования компилятора
Lucid Си++ (<CODE>lcc</CODE>).

<DT><CODE>arm</CODE>
<DD>
Декодировать, используя алгоритм из <CITE>C++ Annotated Reference
Manual</CITE>.
<STRONG>Предупреждение:</STRONG> одной этой установки недостаточно, чтобы производить
отладку исполняемых программ, сгенерированных <CODE>cfront</CODE>.
Чтобы реализовать это, GDB требует дальнейших усовершенствований.

</DL>
Если вы опустите <VAR>стиль</VAR>, то увидите список возможных форматов.

<A NAME="IDX362"></A>
<DT><CODE>show demangle-style</CODE>
<DD>
Отобразить текущий стиль кодирования, используемый для
декодирования символов Си++.

<A NAME="IDX363"></A>
<DT><CODE>set print object</CODE>
<DD>
<DT><CODE>set print object on</CODE>
<DD>
При отображении указателя на объект, идентифицировать <EM>фактический</EM>
(производный), а не <EM>объявленный</EM> тип объекта, используя
таблицу виртуальных функций.

<DT><CODE>set print object off</CODE>
<DD>
Отображать только объявленный тип объекта, не ссылаясь на таблицу
виртуальных функций.  Устанавливается по умолчанию.

<A NAME="IDX364"></A>
<DT><CODE>show print object</CODE>
<DD>
Показать, какой из типов объекта выводится.

<A NAME="IDX365"></A>
<DT><CODE>set print static-members</CODE>
<DD>
<DT><CODE>set print static-members on</CODE>
<DD>
Выводить статические члены при отображении объекта Си++.  Установлено по
умолчанию.

<DT><CODE>set print static-members off</CODE>
<DD>
Не выводить статические члены при отображении объекта Си++.

<A NAME="IDX366"></A>
<DT><CODE>show print static-members</CODE>
<DD>
Показать, выводятся статические члены Си++ или нет.

<A NAME="IDX367"></A>
<DT><CODE>set print vtbl</CODE>
<DD>
<DT><CODE>set print vtbl on</CODE>
<DD>
Осуществлять структурный вывод таблиц виртуальных функций Си++.  По умолчанию
отключено.  (Команды <CODE>vtbl</CODE> не работают для программ,
скомпилированных компилятором HP ANSI Си++ (<CODE>aCC</CODE>).)

<DT><CODE>set print vtbl off</CODE>
<DD>
Не производить структурного вывода таблиц виртуальных функций Си++.

<A NAME="IDX368"></A>
<DT><CODE>show print vtbl</CODE>
<DD>
Показать, производится структурный вывод таблиц виртуальных
функций Си++ или нет.
</DL>



<H2><A NAME="SEC58" HREF="gdb_toc.html#TOC58">История значений</A></H2>

<P>
<A NAME="IDX369"></A>
Значения, выведенные командой <CODE>print</CODE>, сохраняются в <EM>истории
значений</EM> GDB.  Это позволяет вам обращаться к ним в других
выражениях.  Значения сохраняются, пока таблица символов не будет заново
считана или уничтожена (например, командами <CODE>file</CODE> или
<CODE>symbol-file</CODE>).  При изменении таблицы символов, история значений
уничтожается, так как значения могут содержать указатели на типы,
определенные в таблице символов.


<P>
<A NAME="IDX370"></A>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
Выведенным значениям присваиваются <EM>номера в истории</EM>, по которым вы
можете на них ссылаться.  Эти номера являются последовательными целыми
числами, начинающимися с единицы.  Команда <CODE>print</CODE>
показывает номер в истории, присвоенный значению, выводя перед ним
<SAMP>`$<VAR>номер</VAR> = '</SAMP>, где <VAR>номер</VAR>---это номер в истории.


<P>
Для обращения к какому-либо предшествующему значению, используйте
<SAMP>`$'</SAMP>, за которым следует номер в истории.  Способ, которым
<CODE>print</CODE> маркирует вывод продуман так, чтобы напоминать вам об
этом.  Просто <CODE>$</CODE> ссылается на самое последнее значение в истории,
а <CODE>$$</CODE>---на предпоследнее.  <CODE>$$<VAR>n</VAR></CODE> ссылается на <VAR>n</VAR>-е
с конца значение; <CODE>$$2</CODE>---значение, находящееся перед <CODE>$$</CODE>,
<CODE>$$1</CODE> эквивалентно <CODE>$$</CODE>, а <CODE>$$0</CODE> эквивалентно <CODE>$</CODE>.


<P>
Предположим, например, вы только что вывели указатель на структуру и
хотите посмотреть ее содержимое.  Для этого достаточно ввести



<PRE>
p *$
</PRE>

<P>
Если у вас есть цепочка структур, где компонента <CODE>next</CODE> указывает на
следующую, вы можете вывести содержимое следующей структуры так:



<PRE>
p *$.next
</PRE>

<P>
Вы можете выводить последовательные звенья в цепочке повторяя эту
команду.  Это можно сделать простым нажатием <KBD>RET</KBD>.


<P>
Обратите внимание, что в историю записываются значения, а не
выражения.  Если значение <CODE>x</CODE> равно 4, и вы наберете:



<PRE>
print x
set x=5
</PRE>

<P>
то значение, записанное в историю значений командой <CODE>print</CODE>, будет
по-прежнему равно 4, хотя значение <CODE>x</CODE> изменилось.


<DL COMPACT>

<DT><CODE>show values</CODE>
<DD>
<A NAME="IDX373"></A>
 
Вывести из истории последние десять значений, с их номерами.  Это похоже
на команду <SAMP>`p $$9'</SAMP>, повторенную десять раз, за исключением того,
что <CODE>show values</CODE> не изменяет историю.

<DT><CODE>show values <VAR>n</VAR></CODE>
<DD>
Вывести десять значений из истории, расположенных вокруг элемента
с номером <VAR>n</VAR>.

<DT><CODE>show values +</CODE>
<DD>
Вывести десять значений из истории, следующих сразу после
последнего выведенного значения.  Если доступных значений больше
нет, <CODE>show values +</CODE> не выводит ничего.
</DL>

<P>
Нажатие <KBD>RET</KBD> для повтора <CODE>show values <VAR>n</VAR></CODE> действует точно
так же, как <SAMP>`show values +'</SAMP>.




<H2><A NAME="SEC59" HREF="gdb_toc.html#TOC59">Вспомогательные переменные</A></H2>

<P>
<A NAME="IDX374"></A>
GDB предоставляет <EM>вспомогательные переменные</EM>, которые вы
можете в нем использовать, чтобы сохранить значение и обратиться к
нему позже.  Эти переменные существуют только в GDB; они не
являются частью вашей программы и установка вспомогательной переменной
не оказывает непосредственного влияния на ее дальшейшее выполнение.
Поэтому вы можете пользоваться ими совершенно свободно.


<P>
Имена вспомогательных переменных начинаются с <SAMP>`$'</SAMP>.  Любое имя с приставкой
<SAMP>`$'</SAMP> может использоваться для вспомогательной переменной, если
только оно не является предопределенным машинно-зависимым именем регистра,
(see section <A HREF="gdb_9.html#SEC60">Регистры</A>).  (Ссылки на историю значений,
напротив, есть <EM>числа</EM>, которым предшествует <SAMP>`$'</SAMP>.
See section <A HREF="gdb_9.html#SEC58">История значений</A>.)


<P>
Вы можете сохранить значение во вспомогательной переменной с помощью
выражения присваивания, как если бы вы устанавливали переменную в
вашей программе.  Например:



<PRE>
set $foo = *object_ptr
</PRE>

<P>
сохранит в <CODE>$foo</CODE> значение объекта, на который указывает
<CODE>object_ptr</CODE>.


<P>
Первое использование вспомогательной переменной создает ее, но
значением переменной будет <CODE>void</CODE>, пока вы не присвоите ей новое.
С помощью другого присваивания вы можете в любое время
изменить значение.


<P>
Вспомогательные переменные не имеют фиксированного типа.  Вы можете
присваивать вспомогательной переменной значение любого типа, включая
структуры и массивы, даже если у этой переменной уже было значение
другого типа.  Будучи использованной в выражении, вспомогательная
переменная имеет тип своего текущего значения.


<DL COMPACT>

<DT><CODE>show convenience</CODE>
<DD>
<A NAME="IDX375"></A>
 
Вывести список используемых вспомогательных переменных с их значениями.
Сокращается как <CODE>show conv</CODE>.
</DL>

<P>
Один из способов использования вспомогательных переменных---в качестве
увеличивающегося счетчика или продвигающегося указателя.  Например,
чтобы напечатать поле из последовательных элементов массива структур:



<PRE>
set $i = 0
print bar[$i++]-&#62;contents
</PRE>

<P>
Повторяйте эту команду нажатием <KBD>RET</KBD>.


<P>
Некоторые вспомогательные переменные создаются GDB автоматически,
и им присваиваются значения, которые вероятно могут оказаться полезными.


<DL COMPACT>

<DT><CODE>$_</CODE>
<DD>
<A NAME="IDX376"></A>
 
Переменная <CODE>$_</CODE> устанавливается автоматически командой <CODE>x</CODE> в
последний исследованный адрес (see section <A HREF="gdb_9.html#SEC55">Исследование памяти</A>).
Другие команды, которые устанавливают адрес по умолчанию для
исследования командой <CODE>x</CODE>, также присваивают <CODE>$_</CODE> упомянутый
адрес; эти команды включают <CODE>info line</CODE> и <CODE>info breakpoint</CODE>.
Переменная <CODE>$_</CODE> имеет тип <CODE>void *</CODE>, если только она не
установлена командой <CODE>x</CODE>; в этом случае она является указателем на
тип переменной <CODE>$__</CODE>.

<A NAME="IDX377"></A>
<DT><CODE>$__</CODE>
<DD>
Переменная <CODE>$__</CODE> устанавливается автоматически командой <CODE>x</CODE> в
значение, находящееся по последнему исследованному адресу.  Ее тип
выбирается соответствующим формату, в котором это значение было
выведено.

<DT><CODE>$_exitcode</CODE>
<DD>
<A NAME="IDX378"></A>
Переменной <CODE>$_exitcode</CODE> автоматически присваивается код завершения,
когда отлаживаемая программа завершается.
</DL>

<P>
В системах HP-UX, если вы ссылаетесь на функцию или переменную, чье имя
начинается со знака доллара, GDB сначала производит поиск
пользовательского или системного имени, перед поиском вспомогательной
переменной.




<H2><A NAME="SEC60" HREF="gdb_toc.html#TOC60">Регистры</A></H2>

<P>
<A NAME="IDX379"></A>
В выражениях, вы можете обращаться к содержимому машинных регистров,
обозначая их как переменные с именами, начинающимся с <SAMP>`$'</SAMP>.  Имена
регистров различаются от машины к машине; для вывода имен регистров,
используемых на вашей машине, воспользуйтесь командой <CODE>info registers</CODE>.


<DL COMPACT>

<DT><CODE>info registers</CODE>
<DD>
<A NAME="IDX380"></A>
 
Вывести имена и содержимое всех регистров, кроме
регистров с плавающей точкой (в выбранном кадре стека).

<A NAME="IDX381"></A>
<A NAME="IDX382"></A>
<DT><CODE>info all-registers</CODE>
<DD>
Вывести имена и содержимое всех регистров, включая регистры с плавающей
точкой.

<DT><CODE>info registers <VAR>имя-рег</VAR> ...</CODE>
<DD>
Выводит <EM>относительное</EM> значение каждого из указанных в <VAR>имя-рег</VAR>
регистров.  Как подробно обсуждается ниже, значения
регистров обычно относятся к выбранному кадру стека.  <VAR>Имя-рег</VAR>
может быть любым допустимым на вашей машине именем регистра, с <SAMP>`$'</SAMP>
в начале имени или без.
</DL>

<P>
GDB распознает четыре "стандартных" имени регистров, которые
доступны (в выражениях) на большинстве машин---если только они не
конфликтуют с каноническим для архитектуры обозначением регистров.
Названия регистров <CODE>$pc</CODE> и <CODE>$sp</CODE> используются для регистра
счетчика программы и указателя вершины стека.  <CODE>$fp</CODE> используется
как имя регистра, содержащего указатель на текущий кадр стека, а
<CODE>$ps</CODE>---как имя регистра, содержащего состояние процессора.
Например, вы можете вывести счетчик программы в шестнадцатеричной записи
с помощью



<PRE>
p/x $pc
</PRE>

<P>
или вывести следующую исполняемую инструкцию, используя



<PRE>
x/i $pc
</PRE>

<P>
или увеличить указатель вершины стека на четыре<A NAME="DOCF12" HREF="gdb_foot.html#FOOT12">(12)</A> с помощью



<PRE>
set $sp += 4
</PRE>

<P>
Когда возможно, эти четыре стандартных имени регистров доступны на вашей
машине, даже если она имеет другую каноническую мнемонику,
если не возникает конфликта.  Команда <CODE>info registers</CODE>
показывает канонические имена.  В SPARC, например, <CODE>info registers</CODE>
отображает регистр состояния процессора как <CODE>$psr</CODE>, но вы также можете
называть его <CODE>$ps</CODE>; а на машинах, базирующихся на платформе x86,
<CODE>$ps</CODE> является синонимом для регистра EFLAGS.


<P>
Когда регистр изучается таким образом, GDB всегда рассматривает
содержимое обычного регистра как целое.  Некоторые машины имеют
специальные регистры, которые могут содержать только значение с
плавающей точкой; их значения трактуются как величины с плавающей
точкой.  Не существует способа сослаться на содержимое обычного
регистра как на величину с плавающей точкой (хотя вы можете распечатать
его значение командой <EM>print</EM> как величину с плавающей точкой,
используя <SAMP>`print/f $<VAR>имя-рег</VAR>'</SAMP>).


<P>
Некоторые регистры имеют различные "необработанные" и "виртуальные"
форматы данных.  Это означает, что формат данных, в котором
операционная система сохраняет содержимое регистра, не совпадает с
тем, который обычно воспринимается вашей программой.  Например, регистры
сопроцессора с плавающей точкой 68881 всегда сохраняются в
"расширенном" (необработанном) формате, но все программы на Си работают с
"двойным" (виртуальным) форматом.  В подобных случаях, GDB обычно
работает только с виртуальным форматом (форматом, имеющим смысл в вашей
программе), но команда <CODE>info registers</CODE> выводит данные в обоих
форматах.


<P>
Обычно значения регистров относятся к выбранному кадру стека
(see section <A HREF="gdb_7.html#SEC43">Выбор кадра</A>).  Это значит, что вы получаете
значение, которое содержалось бы в регистре, если бы произошел выход
из всех внутренних кадров стека и их сохраненные регистры были бы
восстановлены.  Для того чтобы увидеть истинное содержимое аппаратных
регистров, вы должны выбрать самый внутренний кадр (с помощью
<SAMP>`frame 0'</SAMP>).


<P>
Однако, GDB, исходя из машинного кода, сгенерированного вашим
компилятором, должен установить, где сохранены регистры.  Если
некоторые регистры не сохранены, или если GDB не в состоянии найти
сохраненные регистры, выбранный кадр стека не имеет значения.




<H2><A NAME="SEC61" HREF="gdb_toc.html#TOC61">Аппаратные средства поддержки вычислений с плавающей точкой</A></H2>
<P>
<A NAME="IDX383"></A>


<P>
В зависимости от конфигурации, GDB может выдать вам больше информации
о состоянии аппаратных средств поддержки вычислений с плавающей
точкой.


<DL COMPACT>

<DT><CODE>info float</CODE>
<DD>
<A NAME="IDX384"></A>
 
Отобразить аппаратно-зависимую информацию о модуле поддержки
вычислений с плавающей точкой.  Ее точное содержание и размещение
зависит от микросхемы поддержки вычислений с плавающей точкой.  В
настоящее время, <SAMP>`info float'</SAMP> поддерживается на машинах ARM и x86.
</DL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_8.html">previous</A>, <A HREF="gdb_10.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
