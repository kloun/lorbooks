<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Выполнение программ под управлением GDB</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_4.html">previous</A>, <A HREF="gdb_6.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC15" HREF="gdb_toc.html#TOC15">Выполнение программ под управлением GDB</A></H1>

<P>
Прежде чем выполнять программу под управлением GDB, при
компиляции вы должны сгенерировать отладочную информацию.


<P>
Вы можете запустить GDB с параметрами или без, в любой среде
по вашему выбору.  Если вы отлаживаете программу на той же машине, на
которой выполняется GDB, вы можете перенаправить ввод и вывод
вашей программы, отлаживать уже выполняющийся процесс, или убить
дочерний процесс.




<H2><A NAME="SEC16" HREF="gdb_toc.html#TOC16">Компиляция для отладки</A></H2>

<P>
Для эффективной отладки программы, при компиляции вы должны
сгенерировать отладочную информацию.  Эта отладочная информация
сохраняется в объектном файле; она описывает тип данных
каждой переменной или функции, и соответствие между номерами строк
исходного текста и адресами в выполняемом коде.


<P>
Чтобы запросить генерацию отладочной информации, укажите ключ <SAMP>`-g'</SAMP>
при вызове компилятора.


<P>
Многие компиляторы Си не могут обрабатывать ключи <SAMP>`-g'</SAMP> и <SAMP>`-O'</SAMP>
вместе.  Используя такие компиляторы, вы не можете создавать
оптимизированные выполняемые файлы, содержащие отладочную информацию.


<P>
GCC, GNU компилятор Си, поддерживает <SAMP>`-g'</SAMP> с или без
<SAMP>`-O'</SAMP>, делая возможным отладку оптимизированного кода.  Мы
рекомендуем, чтобы вы <EM>всегда</EM> использовали <SAMP>`-g'</SAMP> при
компиляции программ.  Вы можете думать, что ваша программа правильная,
но нет никакого смысла испытывать удачу.


<P>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
Когда вы отлаживаете программу, откомпилированную с <SAMP>`-g -O'</SAMP>,
помните, что оптимизатор перестраивает ваш код; отладчик же показывает то, что
там находится в действительности.  Не удивляйтесь, если
порядок выполнения не будет в точности соответствовать вашему исходному
файлу!  Крайний пример: если вы определяете переменную, но нигде ее не
используете, GDB никогда не увидит этой переменной, потому
что при оптимизации компилятор ее исключит.


<P>
Некоторые вещи не работают с <SAMP>`-g -O'</SAMP> также, как просто с <SAMP>`-g'</SAMP>,
в частности, на машинах с планированием инструкций.
Если сомневаетесь, перекомпилируйте с одним ключем <SAMP>`-g'</SAMP>, и если это
устранит проблему, пожалуйста, сообщите нам об этом как об ошибке
(включите тестовый пример!).


<P>
Ранние версии компилятора GNU Си допускали вариант ключа для отладочной
информации <SAMP>`-gg'</SAMP>.  GDB больше не поддерживает этот
формат; если этот ключ есть у вашего компилятора GNU Си, не
используйте его.




<H2><A NAME="SEC17" HREF="gdb_toc.html#TOC17">Начало выполнения вашей программы</A></H2>
<P>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>


<DL COMPACT>

<DT><CODE>run</CODE>
<DD>
<A NAME="IDX82"></A>
 <A NAME="IDX83"></A>
 
<DT><CODE>r</CODE>
<DD>
Используйте команду <CODE>run</CODE> для запуска вашей программы под
управлением GDB.  Сначала вы должны задать имя программы (кроме
как на VxWorks) с параметрами GDB (see section <A HREF="gdb_3.html#SEC5">Вход и выход из GDB</A>), или используя команды <CODE>file</CODE> или <CODE>exec-file</CODE>
(see section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>).

</DL>

<P>
Если вы запускаете вашу программу в среде выполнения, поддерживающей
процессы, <CODE>run</CODE> создает подчиненный процесс, и этот процесс
выполняет вашу программу.  (В средах, не поддерживающих процессы,
<CODE>run</CODE> выполняет переход на начало вашей программы.)


<P>
Выполнение программы зависит от определенной информации, которую она
получает от породившего ее процесса.  GDB предоставляет способы
задать эту информацию, что вы должны сделать <EM>до</EM> запуска
программы.  (Вы можете изменить ее после старта, но такие
изменения воздействуют на вашу программу только при следующем запуске.)
Эта информация может быть разделена на четыре категории:


<DL COMPACT>

<DT><EM>Параметры.</EM>
<DD>
Задайте параметры, которые нужно передать вашей программе, как параметры
команды <CODE>run</CODE>.  Если на вашей системе доступна оболочка, она
используется для передачи параметров, так что при их описании вы можете
использовать обычные соглашения (такие как раскрывание шаблонов или
подстановка переменных).
В системах Unix, вы можете контролировать, какая оболочка используется, с
помощью переменной среды <CODE>SHELL</CODE>.
See section <A HREF="gdb_5.html#SEC18">Аргументы вашей программы</A>.

<DT><EM>Среда.</EM>
<DD>
Обычно ваша программа наследует свою среду от GDB, но вы
можете использовать команды GDB <CODE>set environment</CODE> и
<CODE>unset environment</CODE>, чтобы изменить часть настроек среды, влияющих
на нее.  See section <A HREF="gdb_5.html#SEC19">Рабочая среда вашей программы</A>.

<DT><EM>Рабочий каталог.</EM>
<DD>
Ваша программа наследует свой рабочий каталог от GDB.  Вы
можете установить рабочий каталог GDB командой <CODE>cd</CODE>.
See section <A HREF="gdb_5.html#SEC20">Рабочий каталог вашей программы</A>.

<DT><EM>Стандартный ввод и вывод.</EM>
<DD>
Обычно ваша программа использует те же устройства для стандартного
ввода и вывода, что и GDB.  Вы можете перенаправить ввод и
вывод в строке команды <CODE>run</CODE>, или использовать команду <CODE>tty</CODE>,
чтобы установить другое устройство для вашей программы.
See section <A HREF="gdb_5.html#SEC21">Ввод и вывод вашей программы</A>.

<A NAME="IDX84"></A>
<EM>Предупреждение:</EM> Хотя перенаправление ввода и вывода работает, вы
не можете использовать каналы для передачи выходных данных отлаживаемой
программы другой программе; если вы попытаетесь это сделать, скорее
всего GDB перейдет к отладке неправильной программы.
</DL>

<P>
Когда вы подаете команду <CODE>run</CODE>, ваша программа начинает выполняться
немедленно.  See section <A HREF="gdb_6.html#SEC26">Остановка и продолжение исполнения</A>, для обсуждения
того, как остановить вашу программу.  Как только ваша программа
остановилась, вы можете вызывать функции вашей программы, используя
команды <CODE>print</CODE> или <CODE>call</CODE>.  See section <A HREF="gdb_9.html#SEC50">Исследование данных</A>.


<P>
Если время модификации вашего символьного файла изменилось с того
момента, когда GDB последний раз считывал символы, он
уничтожает свою символьную таблицу и считывает ее заново.  При этом
GDB старается сохранить ваши текущие точки останова.




<H2><A NAME="SEC18" HREF="gdb_toc.html#TOC18">Аргументы вашей программы</A></H2>

<P>
<A NAME="IDX85"></A>
Аргументы к вашей программе могут быть заданы как аргументы к команде
<CODE>run</CODE>.
Они передаются оболочке, которая раскрывает символы шаблонов и выполняет
перенаправление ввода-вывода, и с того момента попадают в вашу
программу.  Ваша переменная среды <CODE>SHELL</CODE> (если она существует)
определяет, какую оболочку использует GDB.  Если вы не
определите <CODE>SHELL</CODE>, он использует оболочку по умолчанию
(<TT>`/bin/sh'</TT> в Unix).


<P>
В не-Unix системах, программу обычно запускает непосредственно
GDB, который эмулирует перенаправление ввода-вывода через
соответствующие системные вызовы, и символы шаблонов раскрываются кодом
запуска, а не оболочкой.


<P>
<CODE>run</CODE> без аргументов использует те же аргументы, которые
использовались предыдущей командой <CODE>run</CODE>, или которые установлены
командой <CODE>set args</CODE>.


<DL COMPACT>

<DT><CODE>set args</CODE>
<DD>
<A NAME="IDX86"></A>
 
Задает аргументы, которые будут использоваться при следующем запуске
вашей программы.  Если у <CODE>set args</CODE> нет аргументов, <CODE>run</CODE>
выполняет вашу программу без аргументов.  Если вы запустили вашу
программу с аргументами, то единственный способ запустить ее
снова без аргументов---это использовать <CODE>set args</CODE> до следующего
запуска командой <CODE>run</CODE>.

<A NAME="IDX87"></A>
<DT><CODE>show args</CODE>
<DD>
Показать аргументы, которые будут переданы вашей программе при ее вызове.
</DL>



<H2><A NAME="SEC19" HREF="gdb_toc.html#TOC19">Рабочая среда вашей программы</A></H2>

<P>
<A NAME="IDX88"></A>
<EM>Среда</EM> состоит из набора переменных среды и их значений.
Переменные среды обычно хранят такие данные, как ваше имя пользователя,
домашний каталог, тип терминала и путь поиска для
запуска программ.  Как правило, вы устанавливаете переменные среды с
помощью оболочки и они наследуются всеми другими программами, которые вы
вызываете.  При отладке может оказаться полезным попробовать
запустить программу в измененной среде, не перезапуская
GDB.


<DL COMPACT>

<DT><CODE>path <VAR>каталог</VAR></CODE>
<DD>
<A NAME="IDX89"></A>
 
Добавить <VAR>каталог</VAR> в начало переменной среды <CODE>PATH</CODE> (пути
поиска выполняемых файлов), как для GDB, так и для вашей
программы.  Вы можете указать названия нескольких каталогов, разделив их
пробелом или системно-зависимым разделителем (<SAMP>`:'</SAMP> в Unix, <SAMP>`;'</SAMP>
в MS-DOS и MS-Windows).  Если <VAR>каталог</VAR> уже находится в списке путей,
он переносится в начало, так что поиск в нем будет производиться
раньше.

Вы можете использовать строку <SAMP>`cwd'</SAMP>, чтобы сослаться на
рабочий каталог, который является текущим в тот момент, когда
GDB производит поиск.  Если вместо этого вы используете
<SAMP>`.'</SAMP>, то она будет указывать на тот каталог, в котором вы
выполнили команду <CODE>path</CODE>.  GDB заменяет <SAMP>`.'</SAMP> в
аргументе <VAR>каталог</VAR> (на текущий путь) до добавления <VAR>каталога</VAR> к
списку путей поиска.

<A NAME="IDX90"></A>
<DT><CODE>show paths</CODE>
<DD>
Отобразить список путей для поиска выполняемых файлов (переменную среды
<CODE>PATH</CODE>).

<A NAME="IDX91"></A>
<DT><CODE>show environment [<VAR>имя-перем</VAR>]</CODE>
<DD>
Вывести значение переменной среды <VAR>имя-перем</VAR>, которое будет
передано вашей программе при ее старте.  Если вы не указываете
<VAR>имя-перем</VAR>, вывести названия и значения всех переменных среды,
передаваемых вашей программе.  Вы можете сократить
<CODE>environment</CODE> как <CODE>env</CODE>.

<A NAME="IDX92"></A>
<DT><CODE>set environment <VAR>имя-перем</VAR> [=<VAR>значение</VAR>]</CODE>
<DD>
Присваивает <VAR>значение</VAR> переменной среды <VAR>имя-перем</VAR>.  Значение
меняется только для вашей программы, но не для самого GDB.
<VAR>значение</VAR> может быть любой строкой; значениями переменных среды
являются просто строки, а их интерпретацию обеспечивает ваша
программа.  Параметр <VAR>значение</VAR> является необязательным; если он
опущен, переменная устанавливается в пустое значение.

Например, эта команда:


<PRE>
set env USER = foo
</PRE>

говорит отлаживаемой программе, что при последующих запусках именем
пользователя является <SAMP>`foo'</SAMP>.  (Пробелы, окружающие <SAMP>`='</SAMP>,
использованы здесь для ясности; в действительности, они не обязательны.)

<A NAME="IDX93"></A>
<DT><CODE>unset environment <VAR>имя-перем</VAR></CODE>
<DD>
Удалить переменную <VAR>имя-перем</VAR> из среды, передаваемой вашей
программе.  Это отличается от <SAMP>`set env <VAR>имя-перем</VAR> ='</SAMP>;
<CODE>unset environment</CODE> удаляет переменную из среды, а не присваивает
ей пустое значение.
</DL>

<P>
<EM>Предупреждение:</EM> В системах Unix, GDB вызывает вашу
программу, используя оболочку, указанную вашей переменной среды
<CODE>SHELL</CODE>, если она определена (или <CODE>/bin/sh</CODE>, если не
определена).  Если ваша переменная <CODE>SHELL</CODE> указывает на оболочку,
которая выполняет файл инициализации---такой как <TT>`.cshrc'</TT> для
оболочки C-shell, или <TT>`.bashrc'</TT> для BASH---любая переменная, которую вы
установите в этом файле, воздействует на вашу программу.  В этой
связи, вы можете захотеть перенести установку переменных среды в
файлы, которые выполняются только при вашем входе в систему, такие как
<TT>`.login'</TT> или <TT>`.profile'</TT>.




<H2><A NAME="SEC20" HREF="gdb_toc.html#TOC20">Рабочий каталог вашей программы</A></H2>

<P>
<A NAME="IDX94"></A>
Каждый раз, когда вы запускаете свою программу командой <CODE>run</CODE>, она
наследует рабочий каталог от текущего рабочего каталога
GDB.  В начальный момент, рабочий каталог GDB
наследуется от его родительского процесса (обычно оболочки), но вы
можете задать новый рабочий каталог командой <CODE>cd</CODE> из GDB.


<P>
Рабочий каталог GDB также служит каталогом по умолчанию для
команд отладчика, определяющих действия с файлами.  See section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>.


<DL COMPACT>

<DT><CODE>cd <VAR>каталог</VAR></CODE>
<DD>
<A NAME="IDX95"></A>
 
Установить рабочий каталог GDB в <VAR>каталог</VAR>.

<A NAME="IDX96"></A>
<DT><CODE>pwd</CODE>
<DD>
Вывести рабочий каталог GDB.
</DL>



<H2><A NAME="SEC21" HREF="gdb_toc.html#TOC21">Ввод и вывод вашей программы</A></H2>

<P>
<A NAME="IDX97"></A>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
По умолчанию, программа, которую вы запускаете под управлением
GDB, осуществляет ввод и вывод на тот же терминал, что и
GDB.  Для взаимодействия с вами, GDB переключает
терминал в свой собственный терминальный режим, но он записывает
терминальные режимы, которые использовала ваша программа, и
переключается назад к ним, когда вы продолжаете выполнение программы.


<DL COMPACT>

<DT><CODE>info terminal</CODE>
<DD>
<A NAME="IDX100"></A>
 
Отображает информацию, записанную GDB о терминальных режимах,
которые использует ваша программа.
</DL>

<P>
Вы можете перенаправить ввод и/или вывод вашей программы, используя
перенаправление оболочки с помощью команды <CODE>run</CODE>.  Например,



<PRE>
run &#62; выходной-файл
</PRE>

<P>
запускает вашу программу, перенаправляя ее вывод в <TT>`выходной-файл'</TT>.


<P>
<A NAME="IDX101"></A>
<A NAME="IDX102"></A>
Другой способ задать, как ваша программа должна осуществлять ввод и
вывод---использовать команду <CODE>tty</CODE>.  Эта команда принимает в
качестве агрумента имя файла, который будет использоваться по умолчанию
для будущих команд <CODE>run</CODE>.  Эта команда также сбрасывает управляющий
терминал для дочернего процесса для будущих команд <CODE>run</CODE>.
Например,



<PRE>
tty /dev/ttyb
</PRE>

<P>
указывает, что процессы, запущенные последующими командами <CODE>run</CODE>,
для ввода и вывода используют по умолчанию терминал <TT>`/dev/ttyb'</TT>, и
что он будет их управляющим терминалом.


<P>
Явное перенаправление в <CODE>run</CODE> замещает эффект команды <CODE>tty</CODE>
для устройств ввода-вывода, но не ее воздействие на управляющий терминал.


<P>
Когда вы используете команду <CODE>tty</CODE> или перенаправляете ввод в
команде <CODE>run</CODE>, изменяется только ввод <EM>для вашей программы</EM>.
Ввод для GDB по прежнему происходит через ваш терминал.




<H2><A NAME="SEC22" HREF="gdb_toc.html#TOC22">Отладка запущенного ранее процесса</A></H2>
<P>
<A NAME="IDX103"></A>
<A NAME="IDX104"></A>


<DL COMPACT>

<DT><CODE>attach <VAR>идент-процесса</VAR></CODE>
<DD>
Эта команда присоединяется к выполняющемуся процессу---процессу, который
был запущен вне GDB.  (Команда <CODE>info files</CODE> показывает ваши
активные цели.)  В качестве аргумента команда получает идентификатор
процесса.  Обычный способ узнать идентификатор
Unix-процесса---воспользоваться утилитой <CODE>ps</CODE> или командой оболочки
<SAMP>`jobs -l'</SAMP>.

<CODE>attach</CODE> не повторяется, если вы нажмете <KBD>RET</KBD> второй раз
после выполнения команды.
</DL>

<P>
Чтобы использовать <CODE>attach</CODE>, ваша программа должна выполняться в
среде, поддерживающей процессы; например, <CODE>attach</CODE> не работает на
специальных машинах, не имеющих операционной системы.  Вы также должны
обладать полномочиями для посылки сигнала процессу.


<P>
Когда вы используете <CODE>attach</CODE>, отладчик находит программу
выполняющегося процесса, производя поиск сперва в текущем рабочем
каталоге, а затем (если программа не найдена), используя пути поиска
исходных файлов (see section <A HREF="gdb_8.html#SEC48">Определение каталогов с исходными файлами</A>).  Также, для загрузки программы вы можете
использовать команду <CODE>file</CODE>.  See section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>.


<P>
Первое, что GDB делает после подготовки указанного процесса к
отладке---останавливает его.  Вы можете исследовать и изменять
присоединенный процесс всеми командами GDB, которые обычно
доступны, когда вы запускаете процессы с помощью <CODE>run</CODE>.  Вы можете
устанавливать точки останова; вы можете пошагово выполнять программу и
продолжить ее обычное выполнение, вы можете изменять области данных.
Если вы решите продолжить выполнение процесса после присоединения к нему
GDB, вы можете использовать команду <CODE>continue</CODE>.


<DL COMPACT>

<DT><CODE>detach</CODE>
<DD>
<A NAME="IDX105"></A>
 
Когда вы закончили отлаживать присоединенный процесс, для его
освобождения из под управления GDB вы можете использовать
команду <CODE>detach</CODE>.  Отсоединение процесса продолжает его
выполнение.  После команды <CODE>detach</CODE>, этот процесс и
GDB снова становятся совершенно независимыми, и вы готовы
присоединить или запустить с помощью <CODE>run</CODE> другой процесс.
<CODE>detach</CODE> не повторяется, если вы нажмете <KBD>RET</KBD> еще раз
после выполнения команды.
</DL>

<P>
Если вы выйдете из GDB или используете команду <CODE>run</CODE>, пока
у вас есть присоединенный процесс, вы убьете этот процесс.  По
умолчанию, GDB запрашивает подтверждение, если вы пытаетесь
сделать одну из этих вещей; вы можете контролировать, нужно вам это
подтверждение или нет, используя команду <CODE>set confirm</CODE>
(see section <A HREF="gdb_16.html#SEC170">Необязательные предупреждения и сообщения</A>).




<H2><A NAME="SEC23" HREF="gdb_toc.html#TOC23">Уничтожение дочернего процесса</A></H2>

<DL COMPACT>

<DT><CODE>kill</CODE>
<DD>
<A NAME="IDX106"></A>
 
Уничтожить дочерний процесс, в котором ваша программа выполняется под
управлением GDB.
</DL>

<P>
Эта команда полезна, если вы хотите отладить дамп памяти, а не
выполняющийся процесс.  GDB игнорирует любые дампы памяти, пока
ваша программа выполняется.


<P>
В некоторых операционных системах, программа не может быть выполнена вне
GDB, пока у вас есть в ней точки останова, установленные
отладчиком.  В этой ситуации вы можете использовать команду
<CODE>kill</CODE>, чтобы разрешить выполнение вашей программы вне отладчика.


<P>
Команда <CODE>kill</CODE> также полезна, если вы хотите перекомпилировать и
перекомпоновать вашу программу, так как во многих системах невозможно
модифицировать исполняемый файл во время выполнения процесса.  В этом
случае, когда вы в следующий раз введете <CODE>run</CODE>, GDB
заметит, что файл изменился, и заново прочитает символьную таблицу
(стараясь при этом сохранить ваши точки останова).




<H2><A NAME="SEC24" HREF="gdb_toc.html#TOC24">Отладка программ с несколькими нитями</A></H2>

<P>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
В некоторых операционных системах, таких как HP-UX и Solaris, одна
программа может иметь несколько <EM>нитей</EM> выполнения.  Точная семантика
нитей меняется от одной операционной системы к другой, но в общем, нити
одной программы сродни нескольким процессам---за исключением того, что
они разделяют одно адресное пространство (то есть, все они могут исследовать и
модифицировать одни и те же переменные).  С другой стороны, каждая нить
имеет свои собственные регистры и стек выполнения, и, возможно, свои
собственные участки памяти.


<P>
GDB предоставляет следующие возможности для отладки
многонитевых программ:



<UL>
<LI>автоматическое уведомление о новых нитях

<LI><SAMP>`thread <VAR>номер-нити</VAR>'</SAMP>, команда для переключения между

нитями
<LI><SAMP>`info threads'</SAMP>, команда для запроса информации о

существующих нитях
<LI><SAMP>`thread apply [<VAR>номер-нити</VAR>] [<VAR>all</VAR>] <VAR>арг</VAR>'</SAMP>,

команда для применения некоторой команды к списку нитей
<LI>точки останова, определяемые отдельно для каждой нити

</UL>


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Эти возможности доступны еще не в любой
конфигурации GDB, где операционная система поддерживает нити.
Если ваш GDB не поддерживает нити, эти команды не имеют
эффекта.  Например, в системах без поддержки нитей, GDB ничего
не выводит на команду <SAMP>`info threads'</SAMP>, и всегда отвергает команду
<CODE>thread</CODE>, как в этом примере:



<PRE>
(gdb) info threads
(gdb) thread 1
Thread ID 1 not known.  Use the "info threads" command to
see the IDs of currently known threads.<A NAME="DOCF5" HREF="gdb_foot.html#FOOT5">(5)</A>
</PRE>

</BLOCKQUOTE>

<P>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
Возможности отладки нитей GDB позволяют вам наблюдать все нити
во время выполнения вашей программы, но когда управление переходит к
GDB, одна конкретная нить выделяется для отладки.  Она
называется <EM>текущей нитью</EM>.  Отладочные команды показывают
информацию о программе с точки зрения текущей нити.


<P>
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
Когда GDB обнаруживает новую нить в вашей программе, он выводит
для нее идентификатор на целевой системе с сообщением в форме <SAMP>`[New
<VAR>сист-тег</VAR>]'</SAMP>.  <VAR>Сист-тег</VAR> является идентификатором нити, чья форма
различается в зависимости от конкретной системы.  Например, в LynxOS вы
можете увидеть



<PRE>
[New process 35 thread 27]
</PRE>

<P>
когда GDB замечает новую нить.  Напротив, в системе SGI,
<VAR>сист-тег</VAR> выглядит просто как <SAMP>`process 368'</SAMP>, без дополнительных
спецификаций.


<P>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
Для отладочных целей, GDB присваивает свои собственные номера
нитей---всегда в виде одного целого числа---каждой нити в вашей
программе.


<DL COMPACT>

<DT><CODE>info threads</CODE>
<DD>
<A NAME="IDX115"></A>
 
Вывести краткую информацию обо всех имеющихся в данный момент в вашей
программе нитях.  Для каждой нити, GDB отображает (в этом
порядке):


<OL>
<LI>номер нити, назначенный GDB

<LI>идентификатор нити на целевой системе (<VAR>сист-тег</VAR>)

<LI>краткие сведения о текущем кадре стека для этой нити

</OL>

Звездочка <SAMP>`*'</SAMP> слева от номера нити GDB обозначает текущую
нить.

Например,
</DL>


<PRE>
(gdb) info threads
  3 process 35 thread 27  0x34e5 in sigpause ()
  2 process 35 thread 23  0x34e5 in sigpause ()
* 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
    at threadtest.c:68
</PRE>

<P>
В системах HP-UX:


<P>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
Для отладочных целей, GDB присваивает свои собственные номера
нитей---небольшие целые, присваиваемые в порядке создания нитей---
каждой нити в вашей программе.


<P>
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
Когда GDB обнаруживает новую нить в вашей программе, он выводит
как номер нити, присвоенный GDB, так и идентификатор на целевой
системе для нити с сообщением в форме <SAMP>`[New <VAR>сист-тег</VAR>]'</SAMP>.
<VAR>сист-тег</VAR> является идентификатором нити, чья форма
различается в зависимости от конкретной системы.  Например, в HP-UX,
когда GDB замечает новую нить, вы увидите



<PRE>
[New thread 2 (system thread 26594)]
</PRE>

<DL COMPACT>

<DT><CODE>info threads</CODE>
<DD>
<A NAME="IDX120"></A>
 
Вывести краткую информацию обо всех имеющихся в данный момент в вашей
программе нитях.  Для каждой нити, GDB отображает (в этом
порядке):


<OL>
<LI>номер нити, назначенный GDB

<LI>идентификатор нити на целевой системе (<VAR>сист-тег</VAR>)

<LI>краткие сведения о текущем кадре стека для этой нити

</OL>

Звездочка <SAMP>`*'</SAMP> слева от номера нити GDB означает текущую
нить.

Например,
</DL>


<PRE>
(gdb) info threads
    * 3 system thread 26607  worker (wptr=0x7b09c318 "@") \<BR>
                               at quicksort.c:137
      2 system thread 26606  0x7b0030d8 in __ksleep () \<BR>
                               from /usr/lib/libc.2
      1 system thread 27905  0x7b003498 in _brk () \<BR>
                               from /usr/lib/libc.2
</PRE>

<DL COMPACT>

<DT><CODE>thread <VAR>номер-нити</VAR></CODE>
<DD>
<A NAME="IDX121"></A>
 
Сделать нить с номером <VAR>номер-нити</VAR> текущей.  Аргумент команды,
<VAR>номер-нити</VAR>, является внутренним номером нити GDB, который
показан в первом поле <SAMP>`info threads'</SAMP>.  GDB отвечает,
выводя системный идентификатор выбранной вами нити, и обзор ее кадра
стека:


<PRE>
(gdb) thread 2
[Switching to process 35 thread 23]
0x34e5 in sigpause ()
</PRE>

Также как и с сообщением <SAMP>`[New ...]'</SAMP>, форма текста после
<SAMP>`Switching to'</SAMP> зависит от соглашений для идентификации нитей в
вашей системе.

<A NAME="IDX122"></A>
<DT><CODE>threads apply [<VAR>номер-нити</VAR>] [<VAR>all</VAR>] <VAR>арг</VAR></CODE>
<DD>
Команда <CODE>thread apply</CODE> позволяет вам применить команду к одной или
нескольким нитям.  Задайте номера нитей, на которые вы хотите
воздействовать, в аргументе <VAR>номер-нити</VAR>.  <VAR>Номер-нити</VAR>---это
внутренний номер нити GDB, который показан в первом поле
<SAMP>`info threads'</SAMP>.  Чтобы применить команду ко всем нитям, используйте
<CODE>thread apply all</CODE> <VAR>арг</VAR>.
</DL>

<P>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
Когда GDB останавливает вашу программу, вследствие точки
останова или по сигналу, он автоматически выбирает нить, в которой
появилась точка останова или сигнал.  GDB предупреждает вас о
переключении контекста сообщением в форме <SAMP>`[Switching to
<VAR>сист-тег</VAR>]'</SAMP> для идентификации нити.


<P>
See section <A HREF="gdb_6.html#SEC39">Остановка и запуск многонитевых программ</A>, для
дополнительной информации о поведении GDB, когда вы
останавливаете и запускаете многонитевую программу.


<P>
See section <A HREF="gdb_6.html#SEC29">Установка точек наблюдения</A>, для
информации о точках наблюдения в многонитевых программах.




<H2><A NAME="SEC25" HREF="gdb_toc.html#TOC25">Отладка многонитевых программ</A></H2>

<P>
<A NAME="IDX126"></A>
<A NAME="IDX127"></A>
В большинстве систем, GDB не имеет специальной поддержки для
отладки программ, создающих дополнительные процессы с помощью функции
<CODE>fork</CODE>.  Когда программа вызывает <CODE>fork</CODE>, GDB будет
продолжать отладку родительского процесса, а дочерний процесс будет
выполняться беспрепятственно.  Если выполнение дочернего процесса дойдет
до места, где вы установили точку останова, дочерний процесс получит
сигнал <CODE>SIGTRAP</CODE>, который приведет к остановке процесса (если он не
перехватывает этот сигнал).


<P>
Однако, если вы хотите отладить дочерний процесс, существует достаточно
простое решение.  Поместите вызов <CODE>sleep</CODE> в код программы, который
дочерний процесс выполнит после <CODE>fork</CODE>.  Может быть удобным
вызывать <CODE>sleep</CODE> только если установлена определенная переменная
среды или если существует определенный файл, так что задержка не будет
происходить, если вы не захотите отлаживать дочерний процесс.
Пока дочерний процесс спит, используйте программу <CODE>ps</CODE> для
получения ее идентификатора процесса.  Затем укажите GDB
(новому экземпляру GDB, если вы отлаживаете также и родительский
процесс) присоединиться к дочернему процессу (see section <A HREF="gdb_5.html#SEC22">Отладка запущенного ранее процесса</A>).
Начиная с этого момента, вы можете отлаживать дочерний процесс точно
также, как любой другой процесс, к которому вы присоединились.


<P>
В системе HP-UX (только в версиях 11.x и более поздних?) GDB
предоставляет средства для отладки программ, которые создают
дополнительные процессы, используя функции <CODE>fork</CODE> или <CODE>vfork</CODE>.


<P>
По умолчанию, когда программа ветвится, GDB будет продолжать
отладку родительского процесса, а дочерний процесс будет выполняться
беспрепятственно.


<P>
Если вы хотите отлаживать дочерний процесс вместо родительского,
используйте команду <CODE>set follow-fork-mode</CODE>.


<DL COMPACT>

<DT><CODE>set follow-fork-mode <VAR>режим</VAR></CODE>
<DD>
<A NAME="IDX128"></A>
 
Устанавливает реакцию отладчика на вызов <CODE>fork</CODE> или <CODE>vfork</CODE> в
программе.  Вызов <CODE>fork</CODE> или <CODE>vfork</CODE> создает новый процесс.
<VAR>режим</VAR> может быть:

<DL COMPACT>

<DT><CODE>parent</CODE>
<DD>
После ветвления отлаживается исходный процесс.  Дочерний процесс
выполняется беспрепятственно.  Это поведение по умолчанию.

<DT><CODE>child</CODE>
<DD>
После ветвления отлаживается новый процесс.  Родительский процесс
выполняется беспрепятственно.

<DT><CODE>ask</CODE>
<DD>
Отладчик будет запрашивать один из этих вариантов.
</DL>

<DT><CODE>show follow-fork-mode</CODE>
<DD>
Отображает текущую реакцию отладчика на вызов <CODE>fork</CODE> или
<CODE>vfork</CODE>.
</DL>

<P>
Если вы запрашиваете отладку дочернего процесса и за
<CODE>vfork</CODE> следует <CODE>exec</CODE>, GDB выполняет новую программу
до первой точки останова, установленной в ней.  Если у вас была
установлена точка останова на функции <CODE>main</CODE> в вашей исходной
программе, она будет также установлена на <CODE>main</CODE> в
дочернем процессе.


<P>
Когда дочерний процесс порождается вызовом <CODE>vfork</CODE>, вы не можете
отлаживать дочерний или родительский процесс до тех пор, пока не
завершится вызов <CODE>exec</CODE>.


<P>
Если вы даете GDB команду <CODE>run</CODE> после выполнения
<CODE>exec</CODE>, новая программа стартует заново.  Чтобы перезапустить
родительский процесс, используйте команду <CODE>file</CODE> с именем
выполняемого файла родительской программы в качестве аргумента.


<P>
Вы можете использовать команду <CODE>catch</CODE>, чтобы остановить
GDB, когда сделан вызов <CODE>fork</CODE>, <CODE>vfork</CODE> или
<CODE>exec</CODE>.  See section <A HREF="gdb_6.html#SEC30">Установка точек перехвата</A>.


<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_4.html">previous</A>, <A HREF="gdb_6.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
