<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Редактирование командной строки</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_21.html">previous</A>, <A HREF="gdb_23.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC218" HREF="gdb_toc.html#TOC218">Редактирование командной строки</A></H1>

<P>
Эта глава описывает основные возможности интерфейса редактирования
командной строки GNU.




<H2><A NAME="SEC219" HREF="gdb_toc.html#TOC219">Введение в редактирование строк</A></H2>

<P>
Следующие параграфы описывают нотацию, используемую для обозначения
нажатия клавиш.


<P>
Текст <KBD>C-k</KBD> читается как `Control-K' и описывает знак, полученный
нажатием клавиши <KBD>k</KBD> при нажатой клавише Control.


<P>
Текст <KBD>M-k</KBD> читается как `Meta-K' и описывает знак, введенный
нажатием клавиши <KBD>k</KBD> при нажатой клавише Meta (если у вас она
имеется).  На многих клавиатурах клавиша Meta отмечается с помощью
<KBD>ALT</KBD>.  На клавиатурах с двумя клавишами, отмеченными <KBD>ALT</KBD>
(обычно по разные стороны от пробела), <KBD>ALT</KBD> на левой стороне обычно
устанавливается для работы клавишей Meta.  Правый <KBD>ALT</KBD>
также может быть сконфигурирован для работы Meta, или он может быть
сконфигурирован как другой модификатор, например как клавиша Compose для
ввода символов с акцентами.


<P>
Если у вас нет клавиши Meta или <KBD>ALT</KBD>, или другой клавиши,
работающей как Meta, идентичное нажатие клавиш можно получить
нажав <I>сначала</I> <KBD>ESC</KBD>, а затем <KBD>k</KBD>.  Эти процессы
называются <EM>метафикацией</EM> клавиши <KBD>k</KBD>.


<P>
Текст <KBD>M-C-k</KBD> читается как `Meta-Control-k' и описывает знак,
полученный посредством <EM>метафикации</EM> <KBD>C-k</KBD>.


<P>
Кроме того, некоторые клавиши имеют собственные имена.  Именно,
<KBD>DEL</KBD>, <KBD>ESC</KBD>, <KBD>LFD</KBD>, <KBD>SPC</KBD>, <KBD>RET</KBD> и <KBD>TAB</KBD> в этом
тексте или в файле инициализации обозначают сами себя (see section <A HREF="gdb_22.html#SEC226">Файл инициализации Readline</A>).
Если на вашей клавиатуре нет клавиши <KBD>LFD</KBD>, нажатие <KBD>C-j</KBD>
приведет к вводу желаемого символа.
Клавиша <KBD>RET</KBD> на некоторых клавиатурах может быть отмечена как
<KBD>Return</KBD> или <KBD>Enter</KBD>.




<H2><A NAME="SEC220" HREF="gdb_toc.html#TOC220">Взаимодействие с Readline</A></H2>
<P>
<A NAME="IDX997"></A>


<P>
Часто во время интерактивного сеанса вы вводите длинную строку
текста только для того, чтобы заметить, что первое слово набрано
неправильно.  Библиотека Readline дает вам набор команд для
управления текстом во время ввода, позволяя вам лишь исправить опечатку,
а не набирать заново большую часть строки.  С помощью
этих команд редактирования, вы перемещаете курсор в место,
требующее исправления, и удаляете или вставляете текст для коррекции.
Затем, когда строка полностью исправлена, вы просто нажимаете <KBD>RET</KBD>.
Чтобы нажать <KBD>RET</KBD> вам не обязательно находиться в конце строки; вся
строка вводится независимо от расположения в ней курсора.




<H3><A NAME="SEC221" HREF="gdb_toc.html#TOC221">Сведения первой необходимости</A></H3>
<P>
<A NAME="IDX998"></A>
<A NAME="IDX999"></A>
<A NAME="IDX1000"></A>


<P>
Для того, чтобы ввести знак в строку, просто нажмите его.  Введенный знак
появляется там, где был курсор, и затем курсор перемещается на одну
позицию вправо.  Если вы неверно набрали знак, вы можете использовать
ваш знак уничтожения, чтобы вернуться и удалить неверный знак.


<P>
Иногда вы можете набрать символ ошибочно, и не
заметить ошибки, пока не напечатаете несколько других знаков.  В этом
случае, вы можете набрать <KBD>C-b</KBD>, чтобы переместить курсор влево, и
затем исправить вашу ошибку.  После этого, вы можете переместить
курсор вправо нажатием <KBD>C-f</KBD>.


<P>
Когда вы добавляете текст в середину строки, символы справа от
курсора `сдвигаются вперед', чтобы освободить место для вставляемого
текста.  Аналогично, когда вы удаляете текст за курсором, символы
справа от него `сдвигаются назад', занимая пустое пространство,
созданное в результате удаления текста.  Ниже следует список
команд первой необходимости для редактирования вводимого текста.


<DL COMPACT>

<DT><KBD>C-b</KBD>
<DD>
Переместиться назад на одну позицию.
<DT><KBD>C-f</KBD>
<DD>
Переместиться вперед на одну позицию.
<DT><KBD>DEL</KBD> или <KBD>Backspace</KBD>
<DD>
Удалить символ слева от курсора.
<DT><KBD>C-d</KBD>
<DD>
Удалить символ под курсором.
<DT>Ввод символов
<DD>
Вставить символ в строку в позицию курсора.
<DT><KBD>C-_</KBD> или <KBD>C-x C-u</KBD>
<DD>
Отменить последнюю команду редактирования.  Вы можете отменить все,
вернувшись назад к пустой строке.
</DL>

<P>
(В зависимости от вашей конфигурации, клавиша <KBD>Backspace</KBD> может быть
настроена удалять знак слева от курсора, а <KBD>DEL</KBD> удалять знак под
курсором, как <KBD>C-d</KBD>, вместо символа, расположенного от курсора
слева.)




<H3><A NAME="SEC222" HREF="gdb_toc.html#TOC222">Команды перемещения Readline</A></H3>

<P>
Приведенная выше таблица описывает только самые базовые
последовательности клавиш, которые
могут вам понадобиться для редактирования строки ввода.  Для удобства, в
дополнение к <KBD>C-b</KBD>, <KBD>C-f</KBD>, <KBD>C-d</KBD> и <KBD>DEL</KBD> были добавлены
многие другие команды.  Вот некоторые из них, предназначенные для более
быстрого перемещения по строке.


<DL COMPACT>

<DT><KBD>C-a</KBD>
<DD>
Переместиться в начало строки.
<DT><KBD>C-e</KBD>
<DD>
Переместиться в конец строки.
<DT><KBD>M-f</KBD>
<DD>
Переместиться вперед на слово.  Слово состоит из букв и цифр.
<DT><KBD>M-b</KBD>
<DD>
Переместиться назад на слово.
<DT><KBD>C-l</KBD>
<DD>
Очистить экран, напечатав текущую строку заново вверху экрана.
</DL>

<P>
Заметьте, что <KBD>C-f</KBD> перемещает курсор вперед на символ, в то время
как <KBD>M-f</KBD> перемещает вперед на слово.  Это своего рода соглашение,
что при нажатии клавиши Сontrol производятся действия над символами, при
нажатии клавиши Meta---над словами.




<H3><A NAME="SEC223" HREF="gdb_toc.html#TOC223">Команды уничтожения Readline</A></H3>

<P>
<A NAME="IDX1001"></A>
<A NAME="IDX1002"></A>


<P>
<EM>Уничтожение</EM> текста означает уничтожение текста из строки, но
сохранение его для дальнейшего использования, обычно для
<EM>восстановления</EM> (повторной вставки) обратно в строку.
(`Вырезать' и `вставить' являются более свежими жаргонными синонимами
для `уничтожить' и `восстановить'.)


<P>
Если в описании команды сказано, что она `уничтожает' текст,
то вы можете быть уверены, что позже его можно будет получить обратно в
другом (или том же самом) месте.


<P>
Когда вы используете команду уничтожения, текст сохраняется в
<EM>кольцевом списке уничтожений</EM>.  Любое число последовательных уничтожений
сохраняет весь уничтоженный текст вместе, так что когда вы
восстанавливаете его назад, вы получите все.  Список уничтожений не
имеет привязки к строкам; текст, уничтоженный вами в предыдущей строке
ввода, доступен для восстановления позже, когда вы вводите другую
строку.
<A NAME="IDX1003"></A>


<P>
Вот список команд для уничтожения текста.


<DL COMPACT>

<DT><KBD>C-k</KBD>
<DD>
Уничтожить текст от текущей позиции курсора до конца строки.

<DT><KBD>M-d</KBD>
<DD>
Уничтожить от курсора до конца текущего слова, или, если курсор
находится между словами, до конца следующего слова.
Границы слов такие же, как и используемые <KBD>M-f</KBD>.

<DT><KBD>M-<KBD>DEL</KBD></KBD>
<DD>
Уничтожить от курсора до начала текущего слова, или, если курсор
находится между словами, до начала предыдущего слова.
Границы слов такие же, как и используемые <KBD>M-b</KBD>.

<DT><KBD>C-w</KBD>
<DD>
Уничтожить от курсора до предыдущего пробельного символа.  Это отличается от
M-<KBD>DEL</KBD>, так как границы слова различаются.

</DL>

<P>
Вот как можно <EM>восстановить</EM> текст обратно в строку.  Восстановление
означает копирование последнего уничтоженного текста из буфера
уничтожений.


<DL COMPACT>

<DT><KBD>C-y</KBD>
<DD>
Восстановить последний уничтоженный текст в буфер перед курсором.

<DT><KBD>M-y</KBD>
<DD>
Циклический сдвиг по кольцевому списку уничтожений, и восстановление
новой вершины.  Вы можете использовать это, только если предыдущая команда
была <KBD>C-y</KBD> или <KBD>M-y</KBD>.
</DL>



<H3><A NAME="SEC224" HREF="gdb_toc.html#TOC224">Параметры команд Readline</A></H3>

<P>
Вы можете передавать числовые параметры командам Readline.  Иногда
параметр действует как счетчик повторений, иногда он является
<EM>знаком</EM>, если аргумент имеет знак.  Если вы передаете
отрицательный параметр команде, которая обычно действует в прямом
направлении, то она будет действовать в обратном направлении.  Например,
чтобы уничтожить текст до начала строки, вы можете набрать
<SAMP>`<KBD>M--</KBD> <KBD>C-k</KBD>'</SAMP>.


<P>
Общий способ передачи числовых параметров команде состоит в
наборе Meta-цифр перед командой.  Если первая набранная `цифра' есть знак
минус (<SAMP>`-'</SAMP>), тогда знак аргумента будет отрицательным.  Если вы набрали
одну мета-цифру для начала параметра, вы можете набрать оставшиеся
цифры, и потом команду.  Например, чтобы передать команде <KBD>C-d</KBD>
параметр 10, вы можете набрать <SAMP>`<KBD>M-1 0 C-d</KBD>'</SAMP>.




<H3><A NAME="SEC225" HREF="gdb_toc.html#TOC225">Поиск команд в истории</A></H3>

<P>
Readline предоставляет команды для поиска в истории команд
строк, содержащих указанную подстроку.  Существует два режима поиска:
<EM>наращиваемый</EM> и <EM>ненаращиваемый</EM>.


<P>
Наращиваемый поиск начинается до того, как пользователь закончит ввод
строки поиска.  По мере ввода очередных символов строки поиска, Readline
отображает следующий элемент из истории, соответствующий строке,
введенной на данный момент.  Наращиваемый поиск требует ровно столько
символов, сколько требуется для нахождения желаемого элемента истории.
Для поиска определенной строки в истории в обратном направлении, введите
<KBD>C-r</KBD>.  Ввод <KBD>C-s</KBD> производит поиск в прямом направлении.
Символы, присутствующие в значении переменной <CODE>isearch-terminators</CODE>,
используются для завершения наращиваемого поиска.  Если этой переменной
не было присвоено значение, знаки <KBD>ESC</KBD> и <KBD>C-J</KBD> будут завершать
наращиваемый поиск.  <KBD>C-g</KBD> прерывает наращиваемый поиск и
восстанавливает исходную строку.  Когда поиск завершается, элемент
истории, содержащий искомую строку, становится текущей строкой.


<P>
Для нахождения других подходящих элементов списка истории, введите
соответственно <KBD>C-r</KBD> или <KBD>C-s</KBD>.  Это произведет поиск вперед или
назад в истории до следующего элемента, соответствующего введенной
строке поиска.  Любая другая последовательность клавиш, привязанная к
команде Readline, завершит поиск и выполнит эту команду.  Например,
<KBD>RET</KBD> завершит поиск и примет эту строку, таким образом выполняя
команду из списка истории.


<P>
Ненаращиваемый поиск считывает строку поиска целиком, до начала поиска
соответствующих строк истории.  Строка поиска может быть введена
пользователем или являться частью содержимого текущей строки.




<H2><A NAME="SEC226" HREF="gdb_toc.html#TOC226">Файл инициализации Readline</A></H2>
<P>
<A NAME="IDX1004"></A>


<P>
Хотя библиотека Readline поставляется с установленным по умолчанию набором
привязок клавиш, аналогичному Emacs, возможно использование
другого набора привязок.  Любой пользователь может настраивать
программы, которые используют Readline, помещая команды в файл
<EM>inputrc</EM>, обычно в своем домашнем каталоге.  Имя этого
файла берется из переменной среды <CODE>INPUTRC</CODE>.  Если
эта переменная не установлена, по умолчанию берется файл <TT>`~/.inputrc'</TT>.


<P>
Когда запускается программа, использующая библиотеку Readline,
файл инициализации считывается и устанавливаются привязки клавиш.


<P>
Кроме того, команда <KBD>C-x C-r</KBD> считывает файл инициализации заново,
так что изменения, которые вы могли cделать к этому времени, вступают в
силу.




<H3><A NAME="SEC227" HREF="gdb_toc.html#TOC227">Синтаксис файла инициализации Readline</A></H3>

<P>
Существуют всего несколько конструкций, которые допускаются в файле
инициализации Readline.  Пустые строки игнорируются.  Строки,
начинающиеся с <SAMP>`#'</SAMP>, являются комментариями.  Строки, начинающиеся с
<SAMP>`$'</SAMP>, обозначают условные конструкции (see section <A HREF="gdb_22.html#SEC228">Условные конструкции инициализации</A>).  Другие строки обозначают установку переменных и
привязки клавиш.


<DL COMPACT>

<DT>Установка переменных
<DD>
Вы можете изменять поведение Readline во время выполнения посредством
изменения значений переменных, используя команду <CODE>set</CODE> в
файле инициализации.  Вот как можно изменить привязку клавиш Emacs,
используемую по умолчанию, для использования команд редактирования
строки <CODE>vi</CODE>:


<PRE>
set editing-mode vi
</PRE>

Основная часть поведения при выполнении изменяется с помощью следующих
переменных.

<DL COMPACT>

<DT><CODE>bell-style</CODE>
<DD>
<A NAME="IDX1005"></A>
Контролирует, что происходит, когда Readline хочет издать звук на
терминале.  Если установлено в <SAMP>`none'</SAMP>, Readline никогда не издает
звук.  Если установлено в <SAMP>`visible'</SAMP>, Readline использует визуальный
звонок, если есть возможность.  Если установлено в <SAMP>`audible'</SAMP> (по
умолчанию), Readline пытается издать звук на терминале.

<DT><CODE>comment-begin</CODE>
<DD>
<A NAME="IDX1006"></A>
Строка для вставки в начало строки, когда выполняется команда
<SAMP>`insert-comment'</SAMP>.  По умолчанию <CODE>"#"</CODE>.

<DT><CODE>completion-ignore-case</CODE>
<DD>
Если установлено в <SAMP>`on'</SAMP>, Readline производит проверку совпадений
и завершение имени файла без учета регистра.
По умолчанию <SAMP>`off'</SAMP>.

<DT><CODE>completion-query-items</CODE>
<DD>
<A NAME="IDX1007"></A>
Количество возможных завершений, определяющее, когда у пользователя
запрашивается, хочет ли он увидеть список возможных вариантов.  Если
число возможных завершений больше этого значения, Readline спросит у
пользователя, хочет он их просмотреть или нет; в противном случае, они
просто отображаются.  По умолчанию устанавливается предел <CODE>100</CODE>.

<DT><CODE>convert-meta</CODE>
<DD>
<A NAME="IDX1008"></A>
Если установлено в <SAMP>`on'</SAMP>, Readline будет преобразовывать символы с
установленным восьмым битом в последовательность клавиш ASCII,
удаляя восьмой бит и подставляя в качестве префикса знак <KBD>ESC</KBD>, тем
самым преобразовывая их в последовательность клавиш с Meta-префиксом.
По умолчанию <SAMP>`on'</SAMP>.

<DT><CODE>disable-completion</CODE>
<DD>
<A NAME="IDX1009"></A>
Если установлено в <SAMP>`on'</SAMP>, Readline будет препятствовать завершению
слов.  Знаки завершения будут вставляться в строку так, как если бы они
отображались в <CODE>self-insert</CODE>.  По умолчанию <SAMP>`off'</SAMP>.

<DT><CODE>editing-mode</CODE>
<DD>
<A NAME="IDX1010"></A>
Переменная <CODE>editing-mode</CODE> контролирует, какой набор привязок клавиш
используется.  По умолчанию, Readline запускается в режиме
редактирования Emacs, где нажатия клавиш очень похожи на Emacs.  Эта
переменная может быть установлена или в <SAMP>`emacs'</SAMP>, или в <SAMP>`vi'</SAMP>.

<DT><CODE>enable-keypad</CODE>
<DD>
<A NAME="IDX1011"></A>
Когда установлено в <SAMP>`on'</SAMP>, Readline будет пытаться активизировать
малую клавиатуру приложения, когда она вызывается.  Это требуется
некоторым системам для активации клавиш со стрелками.  По умолчанию
<SAMP>`off'</SAMP>.

<DT><CODE>expand-tilde</CODE>
<DD>
<A NAME="IDX1012"></A>
Если установлено в <SAMP>`on'</SAMP>, производится раскрывание тильды, когда
Readline осуществляет завершение слова.  По умолчанию <SAMP>`off'</SAMP>.

<DT><CODE>horizontal-scroll-mode</CODE>
<DD>
<A NAME="IDX1013"></A>
Эта переменная может быть установлена в <SAMP>`on'</SAMP> или <SAMP>`off'</SAMP>.
Установка в <SAMP>`on'</SAMP> означает, что текст в редактируемых строках будет
прокручиваться горизонтально в одной строке экрана, когда ширина строки
становится больше ширины экрана, вместо переноса на новую строку.  По
умолчанию, эта переменная установлена в <SAMP>`off'</SAMP>.

<DT><CODE>input-meta</CODE>
<DD>
<A NAME="IDX1014"></A>
<A NAME="IDX1015"></A>
Если установлено в <SAMP>`on'</SAMP>, Readline включит восьмибитовый ввод
(восьмой бит не будет удаляться из считываемых символов) независимо от
того, поддерживает ли это терминал.  Значение по умолчанию <SAMP>`off'</SAMP>.  Имя
<CODE>meta-flag</CODE> является синонимом для этой переменной.

<DT><CODE>isearch-terminators</CODE>
<DD>
<A NAME="IDX1016"></A>
Строка из знаков, которые должны прекращать наращиваемый поиск без
последующего выполнения знака как команды (see section <A HREF="gdb_22.html#SEC225">Поиск команд в истории</A>).
Если этой переменной не присвоено значение, наращиваемый поиск
прекращают знаки <KBD>ESC</KBD> и <KBD>C-J</KBD>.

<DT><CODE>keymap</CODE>
<DD>
<A NAME="IDX1017"></A>
Устанавливает текущую раскладку клавиатуры Readline для привязок команд
к клавишам.  Возможные имена для <CODE>keymap</CODE>: <CODE>emacs</CODE>,
<CODE>emacs-standard</CODE>, <CODE>emacs-meta</CODE>, <CODE>emacs-ctlx</CODE>, <CODE>vi</CODE>,
<CODE>vi-command</CODE> и <CODE>vi-insert</CODE>.  <CODE>vi</CODE> эквивалентно
<CODE>vi-command</CODE>; <CODE>emacs</CODE> эквивалентно <CODE>emacs-standard</CODE>.
Значение по умолчанию <CODE>emacs</CODE>.  Значение переменной
<CODE>editing-mode</CODE> также влияет на раскладку по умолчанию.

<DT><CODE>mark-directories</CODE>
<DD>
Если установлено в <SAMP>`on'</SAMP>, к именам каталогов после завершения
добавляется косая черта.  По умолчанию <SAMP>`on'</SAMP>.

<DT><CODE>mark-modified-lines</CODE>
<DD>
<A NAME="IDX1018"></A>
Эта переменная, будучи установлена в <SAMP>`on'</SAMP>, велит Readline
отображать звездочку (<SAMP>`*'</SAMP>) в начале тех строк истории, которые были
модифицированы.  По умолчанию, эта переменная установлена в <SAMP>`off'</SAMP>.

<DT><CODE>output-meta</CODE>
<DD>
<A NAME="IDX1019"></A>
Если установлено в <SAMP>`on'</SAMP>, Readline будет отображать знаки с
установленным восьмым битом непосредственно, а не в виде экранирующих
последовательностей с Meta-префиксом.  По умолчанию <SAMP>`off'</SAMP>.

<DT><CODE>print-completions-horizontally</CODE>
<DD>
Если установлено в <SAMP>`on'</SAMP>, Readline будет отображать завершения,
отсортированные горизонтально в алфавитном порядке, а не вниз по
экрану.  По умолчанию <SAMP>`off'</SAMP>.

<DT><CODE>show-all-if-ambiguous</CODE>
<DD>
<A NAME="IDX1020"></A>
Это изменяет поведение по умолчанию функций завершения.  При
установке в <SAMP>`on'</SAMP>, если слово имеет более одного возможного
завершения, они будут выводиться немедленно, вместо подачи сигнала.  По
умолчанию <SAMP>`off'</SAMP>.

<DT><CODE>visible-stats</CODE>
<DD>
<A NAME="IDX1021"></A>
Если установлено в <SAMP>`on'</SAMP>,
при выводе возможных завершений, к имени файла добавляется знак,
обозначающий тип файла.  По умолчанию <SAMP>`off'</SAMP>.

</DL>

<DT>Привязки клавиш
<DD>
Синтаксис для управления привязками клавиш в файле инициализации прост.
Во-первых, вы должны найти имя команды, которую вы хотите изменить.
Следующий раздел содержит таблицы с именем команды, привязкой клавиш по
умолчанию, если таковые есть, и коротким описанием, что делает команда.

Если вы знаете имя команды, просто поместите в строке файла
инициализации название клавиши, к которой вы хотите привязать команду,
двоеточие, и затем имя команды.  Название клавиши может быть выражено
различными способами, в зависимости от того, как вам удобнее.

<DL COMPACT>

<DT><VAR>назв-клавиши</VAR>: <VAR>имя-функции</VAR> или <VAR>макрос</VAR>
<DD>
<VAR>назв-клавиши</VAR>---это название клавиши, записанное по-английски.
Например:

<PRE>
Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "&#62; output"
</PRE>

В этом примере, <KBD>C-u</KBD> привязана к функции <CODE>universal-argument</CODE>,
а <KBD>C-o</KBD> привязана к выполнению макрокоманды, записанной с правой
стороны (то есть, вставить текст <SAMP>`&#62; output'</SAMP> в строку).

<DT>"<VAR>послед-клавиш</VAR>": <VAR>имя-функции</VAR> или <VAR>макро</VAR>
<DD>
<VAR>послед-клавиш</VAR> отличается от вышеупомянутого <VAR>назв-клавиши</VAR>
тем, что позволяет определять строки, обозначающие целую последовательность
клавиш, посредством ее заключения в двойные кавычки.
Могут быть использованы некоторые экранирующие последовательности в стиле
GNU Emacs, как в следующем примере, но имена специальных знаков не
распознаются.


<PRE>
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
</PRE>

В этом примере, <KBD>C-u</KBD> привязывается к функции
<CODE>universal-argument</CODE> (как это было в первом примере),
<SAMP>`<KBD>C-x</KBD> <KBD>C-r</KBD>'</SAMP> привязывается к функции
<CODE>re-read-init-file</CODE> и <SAMP>`<KBD>ESC</KBD> <KBD>[ 1 1 ~</KBD>'</SAMP> привязывается к
вставке текста <SAMP>`Function Key 1'</SAMP>.

</DL>

Следующие экранирующие последовательности в стиле GNU Emacs доступны
при определении последовательности клавиш:

<DL COMPACT>

<DT><CODE><KBD>\C-</KBD></CODE>
<DD>
префикс Control
<DT><CODE><KBD>\M-</KBD></CODE>
<DD>
префикс Meta
<DT><CODE><KBD>\e</KBD></CODE>
<DD>
префикс экранирующего знака
<DT><CODE><KBD>\\</KBD></CODE>
<DD>
обратная косая черта
<DT><CODE><KBD>\"</KBD></CODE>
<DD>
<KBD>"</KBD>, знак двойных кавычек
<DT><CODE><KBD>\'</KBD></CODE>
<DD>
<KBD>'</KBD>, одинарная кавычка или апостроф
</DL>

В дополнение к экранирующим последовательностям стиля GNU Emacs,
доступен второй набор последовательностей с обратной косой чертой:

<DL COMPACT>

<DT><CODE>\a</CODE>
<DD>
тревога (звуковой сигнал)
<DT><CODE>\b</CODE>
<DD>
переместиться назад на одну позицию
<DT><CODE>\d</CODE>
<DD>
удаление
<DT><CODE>\f</CODE>
<DD>
перевод страницы
<DT><CODE>\n</CODE>
<DD>
новая строка
<DT><CODE>\r</CODE>
<DD>
возврат каретки
<DT><CODE>\t</CODE>
<DD>
горизонтальная табуляция
<DT><CODE>\v</CODE>
<DD>
вертикальная табуляция
<DT><CODE>\<VAR>nnn</VAR></CODE>
<DD>
знак, восьмеричное значение кода <CODE>ASCII</CODE> которого есть <VAR>nnn</VAR>
(от одной до трех цифр)
<DT><CODE>\x<VAR>nnn</VAR></CODE>
<DD>
знак, шестнадцатеричное значение кода <CODE>ASCII</CODE> которого есть <VAR>nnn</VAR>
(от одной до трех цифр)
</DL>

При вводе текста макрокоманды, для обозначения ее определения должны
использоваться одиночные или двойные кавычки.  Предполагается, что текст
без кавычек является именем функции.  В теле макрокоманды, экранирующие
последовательности с обратной косой чертой раскрываются.  Обратная косая
черта будет экранировать любой другой знак в тексте макрокоманды,
включая <SAMP>`"'</SAMP> и <SAMP>`''</SAMP>.  Например, следующая привязка велит
<SAMP>`<KBD>C-x</KBD> \'</SAMP> вставлять одиночную <SAMP>`\'</SAMP> в строку:

<PRE>
"\C-x\\": "\\"
</PRE>

</DL>



<H3><A NAME="SEC228" HREF="gdb_toc.html#TOC228">Условные конструкции инициализации</A></H3>

<P>
Readline реализует возможности, аналогичные по смыслу возможностям
условной компиляции препроцессора Си, позволяющие производить привязки
клавиш и установку переменных в результате тестов.  Вот четыре
директивы, используемые анализатором.


<DL COMPACT>

<DT><CODE>$if</CODE>
<DD>
Конструкция <CODE>$if</CODE> позволяет производить привязки в зависимости от
режима редактирования, используемого терминала, или приложения,
использующего Readline.  Содержимое теста продолжается до конца строки;
для его ограничения не требуются никакие знаки.

<DL COMPACT>

<DT><CODE>mode</CODE>
<DD>
Форма <CODE>mode=</CODE> директивы <CODE>$if</CODE> используется для проверки в
каком из режимов находится Readline: <CODE>emacs</CODE> или <CODE>vi</CODE>.  Это
может быть использовано, например, вместе с командой <SAMP>`set keymap'</SAMP>
для установки привязок в наборы <CODE>emacs-standard</CODE> и
<CODE>emacs-ctlx</CODE>, только если Readline запускается в режиме
<CODE>emacs</CODE>.

<DT><CODE>term</CODE>
<DD>
Форма <CODE>term=</CODE> может использоваться для включения привязок клавиш,
уникальных для какого-либо терминала, возможно для привязки вывода
последовательности клавиш к функциональным клавишам терминала.  Слово,
стоящее справа от <SAMP>`='</SAMP>, сравнивается как с полным названием
терминала, так и с частью названия, идущей до первого <SAMP>`-'</SAMP>.  Это
позволяет, например, опознавать как <CODE>sun</CODE>, так и <CODE>sun-cmd</CODE>.

<DT><CODE>application</CODE>
<DD>
Конструкция <VAR>application</VAR> используется для включения установок,
уникальных для какого-либо приложения.  Каждая программа, использующая
библиотеку Readline, устанавливает <VAR>application name</VAR>, и вы можете
проверить его.  Это может быть использовано для привязки
последовательностей клавиш к функциям, полезным в конкретной программе.
Например, следующая команда добавляет последовательность, которая
заключает в кавычки текущее или предыдущее слово в Bash:

<PRE>
$if Bash
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
$endif
</PRE>

</DL>

<DT><CODE>$endif</CODE>
<DD>
Эта команда, как показано в предыдущем примере, заканчивает команду
<CODE>$if</CODE>.

<DT><CODE>$else</CODE>
<DD>
Команды этой ветви директивы <CODE>$if</CODE> выполняются, если проверка
заканчивается неудачей.

<DT><CODE>$include</CODE>
<DD>
Эта директива принимает в качестве аргумента одно имя файла и считывает
из него команды и привязки клавиш.

<PRE>
$include /etc/inputrc
</PRE>

</DL>



<H3><A NAME="SEC229" HREF="gdb_toc.html#TOC229">Пример файла инициализации</A></H3>

<P>
Вот пример файла <VAR>inputrc</VAR>.  Он иллюстрирует привязки клавиш, присвоение
значений переменным и синтаксис условий.



<PRE>
# Этот файл управляет поведением редактирования строки ввода в
# программах, использующих библиотеку Gnu Readline.  Среди таких программ
# FTP, Bash, и Gdb.
#
# Вы можете заново считать файл inputrc с помощью C-x C-r.
# Строки, начинающиеся с '#', являются комментариями.
#
# Сначала, включим все общесистемные привязки и переменные из
# /etc/Inputrc
$include /etc/Inputrc

#
# Установка различных привязок для режима emacs.

set editing-mode emacs 

$if mode=emacs

Meta-Control-h:	backward-kill-word	Текст после имени функции игнорируется

#
# Стрелки в режиме малой клавиатуры
#
#"\M-OD":        backward-char
#"\M-OC":        forward-char
#"\M-OA":        previous-history
#"\M-OB":        next-history
#
# Стрекли в режиме ANSI
#
"\M-[D":        backward-char
"\M-[C":        forward-char
"\M-[A":        previous-history
"\M-[B":        next-history
#
# Стрелки в восьмибитном режиме малой клавиатуры
#
#"\M-\C-OD":       backward-char
#"\M-\C-OC":       forward-char
#"\M-\C-OA":       previous-history
#"\M-\C-OB":       next-history
#
# Стрелки в восьмибитовом режиме ANSI
#
#"\M-\C-[D":       backward-char
#"\M-\C-[C":       forward-char
#"\M-\C-[A":       previous-history
#"\M-\C-[B":       next-history

C-q: quoted-insert

$endif

# Привязки старого стиля.  Устанавливается по умолчанию.
TAB: complete

# Макрокоманды, удобные при взаимодействии с оболочкой
$if Bash
# редактирование пути
"\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
# Подготовка к вводу слова в кавычках -- вставляет открывающуюся и
# закрывающуюся двойные кавычки и помещает курсор сразу за открывающей
"\C-x\"": "\"\"\C-b"
# вставляет обратную косую черту (testing backslash escapes in sequences
# and macros)  
"\C-x\\": "\\"
# Заключает в кавычки текущее или предыдущее слово
"\C-xq": "\eb\"\ef\""
# Добавляет привязку для обновления строки, которая непривязана
"\C-xr": redraw-current-line
# Редактирование переменной в текущей строке
"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
$endif

# использовать визуальный звонок, если он доступен
set bell-style visible

# не урезать символы при чтении до 7 бит
set input-meta on

# позволяет ввод символов iso-latin1, вместо из преобразования к
# последовательностям с Meta-префиксом
# prefix-meta sequences
set convert-meta off

# отображает символы непосредственно с установленным восьмым битом, а не
# в виде знаков с Meta-префиксом
set output-meta on

# если существует более 150 возможных завершений слова, запросить
# пользователя, хочет ли он видеть их все
set completion-query-items 150

# Для FTP
$if Ftp
"\C-xg": "get \M-?"
"\C-xt": "put \M-?"
"\M-.": yank-last-arg
$endif
</PRE>



<H2><A NAME="SEC230" HREF="gdb_toc.html#TOC230">Привязываемые команды Readline</A></H2>

<P>
Этот раздел описывает команды Readline, которые могут быть привязаны к
последовательностям клавиш.




<H3><A NAME="SEC231" HREF="gdb_toc.html#TOC231">Команды для перемещения</A></H3>
<DL COMPACT>

<DT><CODE>beginning-of-line (C-a)</CODE>
<DD>
<A NAME="IDX1022"></A>
Переместиться в начало текущей строки.

<DT><CODE>end-of-line (C-e)</CODE>
<DD>
<A NAME="IDX1023"></A>
Переместиться в конец строки.

<DT><CODE>forward-char (C-f)</CODE>
<DD>
<A NAME="IDX1024"></A>
Переместиться на один знак вперед.

<DT><CODE>backward-char (C-b)</CODE>
<DD>
<A NAME="IDX1025"></A>
Переместиться назад на один знак.

<DT><CODE>forward-word (M-f)</CODE>
<DD>
<A NAME="IDX1026"></A>
Переместиться вперед до конца следующего слова.  Слова составляются из
букв и цифр.

<DT><CODE>backward-word (M-b)</CODE>
<DD>
<A NAME="IDX1027"></A>
Переместиться назад к началу текущего или предыдущего слова.  Слова
составляются из букв и цифр.

<DT><CODE>clear-screen (C-l)</CODE>
<DD>
<A NAME="IDX1028"></A>
Очистить экран и перерисовать текущую строку, оставляя ее наверху
экрана.

<DT><CODE>redraw-current-line ()</CODE>
<DD>
<A NAME="IDX1029"></A>
Обновить текущую строку.  По умолчанию не привязана.

</DL>



<H3><A NAME="SEC232" HREF="gdb_toc.html#TOC232">Команды для манипуляции историей</A></H3>

<DL COMPACT>

<DT><CODE>accept-line (Newline, Return)</CODE>
<DD>
<A NAME="IDX1030"></A>
Ввод строки независимо от положения курсора.  Если строка
непуста, добавить ее к списку истории.  Если эта строка была
строкой истории, то восстановить строку истории до ее первоначального
состояния.

<DT><CODE>previous-history (C-p)</CODE>
<DD>
<A NAME="IDX1031"></A>
Переместиться `вверх' по списку истории.

<DT><CODE>next-history (C-n)</CODE>
<DD>
<A NAME="IDX1032"></A>
Переместиться `вниз' по списку истории.

<DT><CODE>beginning-of-history (M-&#60;)</CODE>
<DD>
<A NAME="IDX1033"></A>
Переместиться к первой строке истории.

<DT><CODE>end-of-history (M-&#62;)</CODE>
<DD>
<A NAME="IDX1034"></A>
Переместиться в конец истории ввода, то есть к строке, которая сейчас
редактируется.

<DT><CODE>reverse-search-history (C-r)</CODE>
<DD>
<A NAME="IDX1035"></A>
Обратный поиск начиная с текущей строки и перемещаясь по мере
необходимости `вверх' по истории.  Это наращиваемый поиск.

<DT><CODE>forward-search-history (C-s)</CODE>
<DD>
<A NAME="IDX1036"></A>
Прямой поиск начиная с текущей строки и перемещаясь по мере
необходимости `вниз' по истории.  Это наращиваемый поиск.

<DT><CODE>non-incremental-reverse-search-history (M-p)</CODE>
<DD>
<A NAME="IDX1037"></A>
Обратный поиск начиная с текущей строки и перемещаясь по мере
необходимости `вверх' по истории, используя ненаращиваемый поиск строки,
заданной пользователем.

<DT><CODE>non-incremental-forward-search-history (M-n)</CODE>
<DD>
<A NAME="IDX1038"></A>
Прямой поиск начиная с текущей строки и перемещаясь по мере
необходимости `вниз' по истории, используя ненаращиваемый поиск строки,
заданной пользователем.

<DT><CODE>history-search-forward ()</CODE>
<DD>
<A NAME="IDX1039"></A>
Прямой поиск в истории строки символов между началом текущей строки и
точкой.  Это ненаращиваемый поиск.  По умолчанию эта команда не
привязана.

<DT><CODE>history-search-backward ()</CODE>
<DD>
<A NAME="IDX1040"></A>
Обратный поиск в истории строки символов между началом текущей строки и
точкой.  Это ненаращиваемый поиск.  По умолчанию эта команда не привязана.

<DT><CODE>yank-nth-arg (M-C-y)</CODE>
<DD>
<A NAME="IDX1041"></A>
Вставить первый аргумент предыдущей команды (обычно второе слово
предыдущей строки).  С аргументом <VAR>n</VAR>, вставляет <VAR>n</VAR>-ное слово
из предыдущей команды (слова в предыдущей команде начинаются со слова
0).  Отрицательный аргумент вставляет <VAR>n</VAR>-ное с конца слово
предыдущей команды.

<DT><CODE>yank-last-arg (M-., M-_)</CODE>
<DD>
<A NAME="IDX1042"></A>
Вставить последний аргумент предыдущей команды (последнее слово
предыдущего элемента истории).  С аргументом, ведет себя точно так же,
как <CODE>yank-nth-arg</CODE>.  Последовательные вызовы <CODE>yank-last-arg</CODE>
перемещают назад по списку истории, вставляя последний аргумент каждой
строки по очереди.

</DL>



<H3><A NAME="SEC233" HREF="gdb_toc.html#TOC233">Команды для изменения текста</A></H3>

<DL COMPACT>

<DT><CODE>delete-char (C-d)</CODE>
<DD>
<A NAME="IDX1043"></A>
Удалить символ в позиции курсора.  Если курсор находится в
начале строки, в строке нет символов и последний набранный знак не был
привязан к <CODE>delete-char</CODE>, возвращает EOF.

<DT><CODE>backward-delete-char (Rubout)</CODE>
<DD>
<A NAME="IDX1044"></A>
Удалить символ за курсором.  Числовой параметр предписывает
уничтожать символы, а не удалять их.

<DT><CODE>forward-backward-delete-char ()</CODE>
<DD>
<A NAME="IDX1045"></A>
Удалить символ под курсором, если не находится в конце строки, в этом
случае удаляется символ за курсором.  По умолчанию, эта функция не
привязана к какой-либо клавише.

<DT><CODE>quoted-insert (C-q, C-v)</CODE>
<DD>
<A NAME="IDX1046"></A>
Добавить в строку следующий введенный знак, каким бы он ни был.  Таким
образом можно вставить последовательность клавиш, например <KBD>C-q</KBD>.

<DT><CODE>tab-insert (M-TAB)</CODE>
<DD>
<A NAME="IDX1047"></A>
Вставить знак табуляции.

<DT><CODE>self-insert (a, b, A, 1, !, ...)</CODE>
<DD>
<A NAME="IDX1048"></A>
Эти символы вставляют сами себя.

<DT><CODE>transpose-chars (C-t)</CODE>
<DD>
<A NAME="IDX1049"></A>
Переместить знак перед курсором вперед за знак под курсором, также перемещая
курсор вперед.  Если точка вставки находится в конце строки, то
переставить последние два знака в строке.  Отрицательные аргументы не
оказывают действия.

<DT><CODE>transpose-words (M-t)</CODE>
<DD>
<A NAME="IDX1050"></A>
Переместить слово перед точкой за слово после точки.  Также перемещает
точку за это слово.

<DT><CODE>upcase-word (M-u)</CODE>
<DD>
<A NAME="IDX1051"></A>
Перевести в верхний регистр текущее (или следующее) слово.  С
отрицательным аргументом, переводит в верхний регистр предыдущее
слово, но не перемещает курсор.

<DT><CODE>downcase-word (M-l)</CODE>
<DD>
<A NAME="IDX1052"></A>
Перевести в нижний регистр текущее (или следующее) слово.  С
отрицательным аргументом переводит в нижний регистр предыдущее слово, но
не перемещает курсор.

<DT><CODE>capitalize-word (M-c)</CODE>
<DD>
<A NAME="IDX1053"></A>
Перевести текущее (или предыдущее) слово в нижний регистр с первой
заглавной буквой.  С отрицательным аргументом, действует на предыдущее
слово, но не перемещает курсор.

</DL>



<H3><A NAME="SEC234" HREF="gdb_toc.html#TOC234">Уничтожение и восстановление</A></H3>

<DL COMPACT>

<DT><CODE>kill-line (C-k)</CODE>
<DD>
<A NAME="IDX1054"></A>
Уничтожить текст от точки до конца строки.

<DT><CODE>backward-kill-line (C-x Rubout)</CODE>
<DD>
<A NAME="IDX1055"></A>
Уничтожить назад до начала строки.

<DT><CODE>unix-line-discard (C-u)</CODE>
<DD>
<A NAME="IDX1056"></A>
Уничтожить назад от курсора до начала текущей строки.

<DT><CODE>kill-whole-line ()</CODE>
<DD>
<A NAME="IDX1057"></A>
Уничтожить все символы в текущей строке, независимо от позиции точки.
По умолчанию эта функция не привязана.

<DT><CODE>kill-word (M-d)</CODE>
<DD>
<A NAME="IDX1058"></A>
Уничтожить от точки до конца текущего слова,
или, если курсор находится между словами, до конца следующего слова.
Границы слова такие же, как для <CODE>forward-word</CODE>.

<DT><CODE>backward-kill-word (M-DEL)</CODE>
<DD>
<A NAME="IDX1059"></A>
Уничтожить слово за точкой.  Границы слова такие же, как для
<CODE>backward-word</CODE>.

<DT><CODE>unix-word-rubout (C-w)</CODE>
<DD>
<A NAME="IDX1060"></A>
Уничтожает слово за точкой, используя в качестве границы
слова пробелы.  Уничтоженный текст сохраняется в кольцевом списке
уничтожений.

<DT><CODE>delete-horizontal-space ()</CODE>
<DD>
<A NAME="IDX1061"></A>
Удалить все пробелы и знаки табуляции вокруг точки.  По умолчанию эта
функция не привязана.

<DT><CODE>kill-region ()</CODE>
<DD>
<A NAME="IDX1062"></A>
Уничтожить текст в текущей области.  Эта функция по
умолчанию не привязана.

<DT><CODE>copy-region-as-kill ()</CODE>
<DD>
<A NAME="IDX1063"></A>
Копировать текст области в буфер уничтожения, так что он может быть сразу
восстановлен.  Эта команда по умолчанию не привязана.

<DT><CODE>copy-backward-word ()</CODE>
<DD>
<A NAME="IDX1064"></A>
Копировать слово перед точкой в буфер уничтожений.  Границы слова
такие же, как для <CODE>backward-word</CODE>.  Эта команда по умолчанию не
привязана.

<DT><CODE>copy-forward-word ()</CODE>
<DD>
<A NAME="IDX1065"></A>
Копировать слово, следующее за точкой, в буфер уничтожений.  Границы слова
такие же, как для <CODE>forward-word</CODE>.  Эта команда по умолчанию не
привязана.

<DT><CODE>yank (C-y)</CODE>
<DD>
<A NAME="IDX1066"></A>
Восстановить вершину кольцевого списка уничтожений в буфер в текущую
позицию курсора.

<DT><CODE>yank-pop (M-y)</CODE>
<DD>
<A NAME="IDX1067"></A>
Циклический сдвиг кольцевого списка уничтожений и восстановление новой
вершины.  Вы можете использовать эту команду только если предыдущей
командой была <CODE>yank</CODE> или <CODE>yank-pop</CODE>.
</DL>



<H3><A NAME="SEC235" HREF="gdb_toc.html#TOC235">Определение числовых параметров</A></H3>
<DL COMPACT>

<DT><CODE>digit-argument (<KBD>M-0</KBD>, <KBD>M-1</KBD>, ... <KBD>M--</KBD>)</CODE>
<DD>
<A NAME="IDX1068"></A>
Добавить эту цифру к вводимому аргументу, или начать новый
аргумент.  <KBD>M--</KBD> начинает отрицательный аргумент.

<DT><CODE>universal-argument ()</CODE>
<DD>
<A NAME="IDX1069"></A>
Это другой способ задать аргумент.  Если за этой командой следуют одна
или несколько цифр, возможно со знаком минус в начале, то они
определяют аргумент.  Если за командой следуют цифры, повторное
выполнение <CODE>universal-argument</CODE> заканчивает числовой аргумент, а в
противном случае он игнорируется.
В особом случае, если непосредственно за этой командой следует или
цифра, или знак минус, аргумент для следующей команды умножается на
четыре.  Изначально аргумент равен единице, так что выполнение этой
функции первый раз делает его равным четырем, второй раз---шестнадцати,
и так далее.  По умолчанию эта функция не привязана к клавише.
</DL>



<H3><A NAME="SEC236" HREF="gdb_toc.html#TOC236">Readline вводит за вас</A></H3>

<DL COMPACT>

<DT><CODE>complete (<KBD>TAB</KBD>)</CODE>
<DD>
<A NAME="IDX1070"></A>
Пытается завершить текст перед курсором.  Действие функции зависит от
приложения.  Обычно, если вы вводите имя файла, вы можете выполнить
завершение имени файла; если вы вводите команду, вы можете завершить
команду; если вводите символ для GDB, можете выполнить завершение имени
символа; если вы вводите переменную для Bash, можете завершить имя
переменной, и так далее.

<DT><CODE>possible-completions (M-?)</CODE>
<DD>
<A NAME="IDX1071"></A>
Перечислить возможные завершения текста перед курсором.

<DT><CODE>insert-completions (M-*)</CODE>
<DD>
<A NAME="IDX1072"></A>
Вставить все завершения текста перед точкой, которые были бы созданы
<CODE>possible-completions</CODE>.

<DT><CODE>menu-complete ()</CODE>
<DD>
<A NAME="IDX1073"></A>
Аналогично <CODE>complete</CODE>, но замещает завершаемое слово одним
совпадением из списка возможных завершений.  Повторяемое выполнение
<CODE>menu-complete</CODE> обходит список возможных завершений, вставляя
каждое совпадение по очереди.  В конце списка завершений издается
звуковой сигнал и восстанавливается исходный текст.  Аргумент <VAR>n</VAR>
перемещает на <VAR>n</VAR> позиций вперед в списке совпадений; отрицательный
аргумент может использоваться для перемещения по списку назад.  Эта
команда предназначается для привязки к <KBD>TAB</KBD>, но по умолчанию не
привязана.

<DT><CODE>delete-char-or-list ()</CODE>
<DD>
<A NAME="IDX1074"></A>
Удаляет знак в позиции курсора, если он не находится в начале или конце
строки (как <CODE>delete-char</CODE>).  Если курсор находится в конце строки,
поведение аналогично <CODE>possible-completions</CODE>.  Эта команда по
умолчанию не привязана.

</DL>



<H3><A NAME="SEC237" HREF="gdb_toc.html#TOC237">Клавиатурные макросы</A></H3>
<DL COMPACT>

<DT><CODE>start-kbd-macro (C-x ()</CODE>
<DD>
<A NAME="IDX1075"></A>
Начать сохранение вводимых символов в текущий клавиатурный макрос.

<DT><CODE>end-kbd-macro (C-x ))</CODE>
<DD>
<A NAME="IDX1076"></A>
Прекратить сохранение вводимых символов в текущий клавиатурный макрос и
запомнить его определение.

<DT><CODE>call-last-kbd-macro (C-x e)</CODE>
<DD>
<A NAME="IDX1077"></A>
Выполнить последний определенный клавиатурный макрос, выводя символы
макроса так, как если бы он набирался на клавиатуре.

</DL>



<H3><A NAME="SEC238" HREF="gdb_toc.html#TOC238">Некоторые другие команды</A></H3>
<DL COMPACT>

<DT><CODE>re-read-init-file (C-x C-r)</CODE>
<DD>
<A NAME="IDX1078"></A>
Считать содержание файла <VAR>inputrc</VAR>, и подключить любые найденные там
привязки клавиш и присвоения переменных.

<DT><CODE>abort (C-g)</CODE>
<DD>
<A NAME="IDX1079"></A>
Прервать текущую команду редактирования и издать звук на терминале
(зависит от установки <CODE>bell-style</CODE>).

<DT><CODE>do-uppercase-version (M-a, M-b, M-<VAR>x</VAR>, ...)</CODE>
<DD>
<A NAME="IDX1080"></A>
Если метафицированный знак <VAR>x</VAR> находится в нижнем регистре,
выполнить команду, привязанную к соответствующему символу в верхнем
регистре.

<DT><CODE>prefix-meta (<KBD>ESC</KBD>)</CODE>
<DD>
<A NAME="IDX1081"></A>
Метафицировать следующий введенный вами символ.  Это для клавиатур, не
имеющих клавиши Meta.  Ввод <SAMP>`<KBD>ESC</KBD> f'</SAMP> эквивалентен вводу
<KBD>M-f</KBD>.

<DT><CODE>undo (C-_, C-x C-u)</CODE>
<DD>
<A NAME="IDX1082"></A>
Наращиваемая отмена, запоминаемая отдельно для каждой строки.

<DT><CODE>revert-line (M-r)</CODE>
<DD>
<A NAME="IDX1083"></A>
Отменить все изменения, сделанные в этой строке.  Это аналогично
выполнению достаточного числа раз команды <CODE>undo</CODE>, чтобы вернуться в
начало.

<DT><CODE>tilde-expand (M-~)</CODE>
<DD>
<A NAME="IDX1084"></A>
Выполнить раскрывание знака тильды для текущего слова.

<DT><CODE>set-mark (C-@)</CODE>
<DD>
<A NAME="IDX1085"></A>
Установить отметку в текущей точке.  Если задан числовой аргумент,
отметка устанавливается в указанной позиции.

<DT><CODE>exchange-point-and-mark (C-x C-x)</CODE>
<DD>
<A NAME="IDX1086"></A>
Поменять местами точку и отметку.  Текущая позиция курсора устанавливается
в сохраненную позицию, а старое положение курсора запоминается как отметка.

<DT><CODE>character-search (C-])</CODE>
<DD>
<A NAME="IDX1087"></A>
Считывается символ, и точка перемещается к следующему появлению этого
символа.  Отрицательный аргумент производит поиск вхождения символа в
обратном направлении.

<DT><CODE>character-search-backward (M-C-])</CODE>
<DD>
<A NAME="IDX1088"></A>
Считывается символ, и точка перемещается к предыдущему появлению этого
символа.  Отрицательный аргумент производит поиск последующих вхождений
символа.

<DT><CODE>insert-comment (M-#)</CODE>
<DD>
<A NAME="IDX1089"></A>
Значение переменной <CODE>comment-begin</CODE> вставляется в начало текущей
строки, и строка вводится, так как если бы был введен знак ввода строки.

<DT><CODE>dump-functions ()</CODE>
<DD>
<A NAME="IDX1090"></A>
Напечатать все функции и их привязки к клавишам в выходной поток
Readline.  Если задан числовой аргумент, вывод форматируется так, что он
может быть сделан частью файла <VAR>inputrc</VAR>.  По умолчанию, эта команда
не привязана.

<DT><CODE>dump-variables ()</CODE>
<DD>
<A NAME="IDX1091"></A>
Напечатать все устанавливаемые переменные и их значения в выходной поток
Readline.  Если задан числовой аргумент, вывод форматируется так, что он
может быть сделать частью файла <VAR>inputrc</VAR>.  Эта команда по умолчанию
не привязана.

<DT><CODE>dump-macros ()</CODE>
<DD>
<A NAME="IDX1092"></A>
Напечатать все последовательности клавиш Readline, привязанные к
макросам, и выводимые ими строки.  Если задан числовой аргумент, вывод
форматируется так, что он может быть сделан частью файла <VAR>inputrc</VAR>.
Эта команда по умолчанию не привязана.

</DL>



<H2><A NAME="SEC239" HREF="gdb_toc.html#TOC239">Режим vi Readline</A></H2>

<P>
Хотя библиотека Readline не имеет полного набора функций редактирования
<CODE>vi</CODE>, она все же содержит достаточно для простого редактирования
строки.  Режим <CODE>vi</CODE> Readline функционирует так, как определено в
стандарте POSIX 1003.2.


<P>
Для интерактивного переключения между режимами редактирования
<CODE>emacs</CODE> и <CODE>vi</CODE>, используйте команду <KBD>M-C-j</KBD>
(<CODE>toggle-editing-mode</CODE>).
По умолчанию, Readline использует режим <CODE>emacs</CODE>.


<P>
Когда вы вводите строку в режиме <CODE>vi</CODE>, вы уже находитесь в режиме
`вставки', как если бы вы набрали <SAMP>`i'</SAMP>.  Нажатие <KBD>ESC</KBD>
переключает вас в `командный' режим, в котором вы можете редактировать
текст строки стандартными клавишами перемещения <CODE>vi</CODE>, перемещаться
к предыдущим строкам истории посредством <SAMP>`k'</SAMP> и к последующим
строкам посредством <SAMP>`j'</SAMP>, и так далее.


<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_21.html">previous</A>, <A HREF="gdb_23.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
