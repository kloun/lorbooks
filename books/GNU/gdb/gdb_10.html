<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Использование GDB с различными языками программирования</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_9.html">previous</A>, <A HREF="gdb_11.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC62" HREF="gdb_toc.html#TOC62">Использование GDB с различными языками программирования</A></H1>
<P>
<A NAME="IDX385"></A>


<P>
Хотя языки программирования обычно имеют общие аспекты, их выражения редко
выглядят одинаково.  Например, в ANSI Си, разыменование указателя
<CODE>p</CODE> осуществляется операцией <CODE>*p</CODE>, а в Модуле-2 это
выполняется как <CODE>p^</CODE>.  Представление (и отображение) значений также
может быть различным.  Шестнадцатеричные числа в Си отображаются как
<SAMP>`0x1ae'</SAMP>, в то время как в Модуле-2 они отображаются как <SAMP>`1AEH'</SAMP>.


<P>
<A NAME="IDX386"></A>
В GDB встроена специальная информация о некоторых языках, которая
позволяет описывать действия, подобные упомянутым, на языке
вашей программы, и позволяет GDB выводить значения в виде,
принятом в языке, на котором написана ваша программа.  Язык, которым вы
пользуетесь для построения выражений, называется <EM>рабочим языком</EM>.




<H2><A NAME="SEC63" HREF="gdb_toc.html#TOC63">Переход от одного языка к другому</A></H2>

<P>
Существует два способа управления рабочим языком: либо GDB
устанавливает его автоматически, либо вы можете сделать это
самостоятельно.  Для этих целей вы можете воспользоваться командой <CODE>set
language</CODE>.  По умолчанию, при старте GDB устанавливает язык
автоматически.  Рабочий язык используется чтобы определить, как
интерпретируются вводимые вами выражения, как выводятся значения, и так
далее.


<P>
В дополнение к рабочему языку, каждый исходный файл, с
которым работает GDB, имеет свой собственный рабочий язык.  Для
некоторых форматов объектных файлов компилятор может указывать, на
каком языке написан конкретный исходный файл.  Однако, чаще всего
GDB распознает язык по имени файла.  Язык исходного файла
определяет, будут ли восстанавливаться имена Си++; таким образом,
<CODE>backtrace</CODE> может показывать каждый кадр в соответствии с
исходным языком.  Не существует способа установить язык исходного файла
из GDB, но вы можете установить язык, ассоциированный с
расширением файла.  See section <A HREF="gdb_10.html#SEC67">Отображение языка программирования</A>.


<P>
Наиболее часто эта проблема возникает, когда вы используете программу,
такую как <CODE>cfront</CODE> или <CODE>f2c</CODE>, которая создает текст на Си, но
написана на другом языке.  В этом случае нужно сделать, чтобы программа
использовала директивы <CODE>#line</CODE> в выводе текста Си; тогда
GDB будет знать правильный язык исходного текста первоначальной
программы, и выведет этот исходный код, а не сгенерированный код Си.




<H3><A NAME="SEC64" HREF="gdb_toc.html#TOC64">Соответствие расширений файлов и языков</A></H3>

<P>
Если имя исходного файла заканчивается одним из следующих расширений, то
GDB воспринимает это как указание на обозначенный язык.


<DL COMPACT>

<DT><TT>`.c'</TT>
<DD>
Исходный файл Си

<DT><TT>`.C'</TT>
<DD>
<DT><TT>`.cc'</TT>
<DD>
<DT><TT>`.cp'</TT>
<DD>
<DT><TT>`.cpp'</TT>
<DD>
<DT><TT>`.cxx'</TT>
<DD>
<DT><TT>`.c++'</TT>
<DD>
Исходный файл Си++

<DT><TT>`.f'</TT>
<DD>
<DT><TT>`.F'</TT>
<DD>
Исходный файл Фортрана

<DT><TT>`.ch'</TT>
<DD>
<DT><TT>`.c186'</TT>
<DD>
<DT><TT>`.c286'</TT>
<DD>
Исходный файл CHILL

<DT><TT>`.mod'</TT>
<DD>
Исходный файл Модулы-2

<DT><TT>`.s'</TT>
<DD>
<DT><TT>`.S'</TT>
<DD>
Исходный файл Ассемблера.  В действительности, восприниматся почти
также, как Си, но GDB не пропускает вводные части функций при
пошаговом выполнении.
</DL>

<P>
В дополнение к этому, вы можете установить язык, ассоциированный с
расширением имени файла.  See section <A HREF="gdb_10.html#SEC67">Отображение языка программирования</A>.




<H3><A NAME="SEC65" HREF="gdb_toc.html#TOC65">Установка рабочего языка</A></H3>

<P>
Если вы позволяете GDB устанавливать язык автоматически,
выражения в сеансе отладки и в вашей программе интерпретируются одинаково.


<P>
<A NAME="IDX387"></A>
По желанию, вы можете установить язык сами.  Для этого
воспользуйтесь командой <SAMP>`set language <VAR>язык</VAR>'</SAMP>, где
<VAR>язык</VAR>---название языка, например, <CODE>c</CODE> или <CODE>modula-2</CODE>.
Чтобы получить перечень поддерживаемых языков, наберите <SAMP>`set language'</SAMP>.


<P>
Установка языка вручную запрещает GDB автоматически переключать
рабочий язык.  Это может привести к неприятным последствиям, если вы
попытаетесь отладить программу, когда рабочий язык не
совпадает с исходным языком, когда выражение допустимо в обоих
языках, но означает разные вещи.  Например, если текущий исходный
файл написан на Си, а в GDB выбрана Модула-2, команда



<PRE>
print a = b + c
</PRE>

<P>
может не привести к ожидаемому результату.  В Си это означает
сложить <CODE>b</CODE> и <CODE>c</CODE> и поместить результат в <CODE>a</CODE>.
Выведенным результатом будет значение <CODE>a</CODE>.  В Модуле-2 это
означает сравнение <CODE>a</CODE> с результатом <CODE>b+c</CODE>, выдающее значение
типа <CODE>BOOLEAN</CODE>.




<H3><A NAME="SEC66" HREF="gdb_toc.html#TOC66">Распознавание GDB исходного языка</A></H3>

<P>
Для автоматической установки GDB рабочего языка, используйте
<SAMP>`set language local'</SAMP> или <SAMP>`set language auto'</SAMP>.  Тогда
GDB будет определять рабочий язык автоматически.  То есть при
остановке вашей программы в кадре стека (обычно, в точке останова),
GDB устанавливает рабочий язык в тот, который записан для
функции в этом кадре.  Если язык для кадра неизвестен (то есть, если
функция или блок, соответствующие кадру, были определены в исходном
файле, не имевшем распознаваемого расширения), текущий рабочий язык не
изменяется, а GDB выдает предупреждающее сообщение.


<P>
Для большинства программ, которые написаны целиком на одном языке,
автоматическая установка языка может показаться ненужной.
Однако, в основной программе, написанной на одном исходном языке,
могут использоваться программные модули и библиотеки, написанные на
другом исходном языке.  Использование в этом случае <SAMP>`set language
auto'</SAMP> освобождает вас от установки рабочего языка вручную.




<H2><A NAME="SEC67" HREF="gdb_toc.html#TOC67">Отображение языка программирования</A></H2>

<P>
Следующие команды помогают вам определить, какой язык
является рабочим, а также на каком языке были написаны исходные файлы.


<P>
<A NAME="IDX388"></A>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<DL COMPACT>

<DT><CODE>show language</CODE>
<DD>
Отобразить текущий рабочий язык.  Это тот язык, который вы можете
использовать в командах типа <CODE>print</CODE> для построения и вычисления
выражений, в которые могут входить переменные вашей программы.

<DT><CODE>info frame</CODE>
<DD>
Отобразить исходный язык для данного кадра стека.  Этот язык
становится рабочим, если используется идентификатор из этого кадра.
See section <A HREF="gdb_7.html#SEC44">Информация о кадре стека</A>, для дополнительной
информации.

<DT><CODE>info source</CODE>
<DD>
Отобразить исходный язык данного исходного файла.
See section <A HREF="gdb_11.html#SEC95">Исследование таблицы символов</A>, для получения
дополнительной информации.
</DL>

<P>
При необычных обстоятельствах, у вас могут быть исходные файлы с
расширениями, не входящими в стандартный список.  Вы можете явно
установить расширение, ассоциированное с языком:


<P>
<A NAME="IDX391"></A>
<A NAME="IDX392"></A>
<DL COMPACT>

<DT><CODE>set extension-language <VAR>.расш</VAR> <VAR>язык</VAR></CODE>
<DD>
Установить соответствие исходных файлов с расширением <VAR>.расш</VAR> с
исходным языком <VAR>язык</VAR>.

<DT><CODE>info extensions</CODE>
<DD>
Перечислить все расширения имен файлов и соответствующие им языки.
</DL>



<H2><A NAME="SEC68" HREF="gdb_toc.html#TOC68">Проверка диапазона и принадлежности типу</A></H2>


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> В этот выпуск включены команды GDB для
проверки диапазона и соответствия типов, но они пока не оказывают
никакого действия.  Этот раздел описывает их предполагаемые возможности.
</BLOCKQUOTE>

<P>
Некоторые языки обеспечивают защиту от достаточно общих ошибок
с помощью набора проверок времени компиляции и времени выполнения.  Это
включает проверку типов аргументов функций и операторов и обеспечивает
проверку математического переполнения во время выполнения.  Проверки
такого рода помогают убедиться в корректности программы после ее
компиляции путем устранения несоответствия типов, и предоставляя
активную проверку ошибок выхода за пределы диапазона во время
выполнения.


<P>
По вашему желанию, GDB может проводить подобные проверки.  Хотя
GDB не проверяет операторы вашей программы, он может, например, проверять
выражения, введенные непосредственно в GDB для вычисления
командой <CODE>print</CODE>.  Как и в случае рабочего языка,
GDB может также автоматически решить, выполнять проверку или нет,
основываясь на исходном языке вашей программы.  See section <A HREF="gdb_10.html#SEC71">Поддерживаемые языки</A>, для информации об установках по умолчанию для
поддерживаемых языков.


<P>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>


<H3><A NAME="SEC69" HREF="gdb_toc.html#TOC69">Краткий обзор проверки соответствия типов</A></H3>

<P>
Некоторые языки, такие как Модула-2, должны иметь жесткое соответствие
типов, то есть аргументы операторов и функций должны иметь правильный тип, в
противном случае возникает ошибка.  Описанные здесь проверки
предотвращают ошибки несоответствия типов, которые могут вызвать
ошибки времени выполнения.  Например,



<PRE>
1 + 2 => 3
но
error--> 1 + 2.3
</PRE>

<P>
Во втором примере ошибка, потому что <CODE>CARDINAL</CODE> 1 не совместим по
типу с <CODE>REAL</CODE> 2.3.


<P>
Для выражений, используемых вами в командах GDB, вы можете
указать GDB не производить проверку; или же рассматривать любое
несоответствие как ошибку и прекращать обработку выражения; или только
выводить предупреждение в случае возникновения несоответствия, но
вычислять выражение в любом случае.  В последнем случае, GDB
вычисляет выражения, подобные второму примеру, но также выводит
предупреждающее сообщение.


<P>
Даже если вы отключили проверку типов, GDB может прекратить
обработку выражения по другим причинам, связанным с типами.  Например,
GDB не знает, как сложить <CODE>int</CODE> и <CODE>struct foo</CODE>.  Такие
типы ошибок не имеют ничего общего с используемым языком и
обычно возникают из выражений, подобных описанному выше, которые нет смысла
вычислять.


<P>
Каждый язык определяет степень строгости контроля типов.  Например, как
Модула-2, так и Си требуют, чтобы аргументы арифметических операций были
числами.  В Си, перечисляемые типы и указатели могут быть представлены в
виде чисел, так что они допустимы в качестве аргументов математических
операторов.  See section <A HREF="gdb_10.html#SEC71">Поддерживаемые языки</A>, для более
подробного обсуждения конкретных языков.


<P>
GDB предоставляет некоторые дополнительные команды для контроля
проверки типов:


<P>
<A NAME="IDX395"></A>
<A NAME="IDX396"></A>
<A NAME="IDX397"></A>
<DL COMPACT>

<DT><CODE>set check type auto</CODE>
<DD>
Включить или отключить контроль типов, в зависимости от
текущего рабочего языка.  See section <A HREF="gdb_10.html#SEC71">Поддерживаемые языки</A>, для
установок по умолчанию для каждого языка.

<DT><CODE>set check type on</CODE>
<DD>
<DT><CODE>set check type off</CODE>
<DD>
Включить или отключить контроль типов, пренебрегая установкой
по умолчанию для текущего рабочего языка.  Вывести предупреждающее
сообщение, если установка не соответствует используемой по умолчанию.
Если возникает несоответствие типов во время вычисления
выражения при включенном контроле типов, GDB выводит
сообщение и прерывает вычисление выражения.

<DT><CODE>set check type warn</CODE>
<DD>
При возникновении несоответствия типов вывести предупреждающее
сообщение, но попытаться вычислить выражение.  Вычисление выражения все
же может быть невозможным по другим причинам.  Например, GDB не
может складывать числа со структурами.

<DT><CODE>show type</CODE>
<DD>
Показать текущую установку проверки типов, а также была ли она установлена
GDB автоматически.
</DL>

<P>
<A NAME="IDX398"></A>
<A NAME="IDX399"></A>


<H3><A NAME="SEC70" HREF="gdb_toc.html#TOC70">Краткий обзор проверки диапазона</A></H3>

<P>
В некоторых языках (например, в Модуле-2), выход за границы диапазона типа
считается ошибкой; эти ошибки отслеживаются с помощью контроля времени
выполнения.  Эти проверки диапазона служат для того, чтобы избежать
переполнения при вычислениях и не допустить превышения индексами
элементов массива границ индексации.


<P>
В выражениях, используемых вами в командах GDB, вы можете указать
GDB обрабатывать ошибки диапазона одним из трех способов:
игнорировать их, всегда рассматривать как ошибки и прерывать
обработку выражения, или выводить предупреждение и продолжать вычисление
выражения.


<P>
Ошибки диапазона могут возникать при числовом переполнении, при
превышении границы индексации массива или при использовании константы, не
принадлежащей ни к одному типу.  Однако, некоторые языки не
считают переполнение ошибкой.  Во многих реализациях Си,
математическое переполнение вызывает "циклический переход" к меньшему
значению.  Например, если <VAR>m</VAR>---наибольшее целое значение, а
<VAR>s</VAR>---наименьшее, то



<PRE>
<VAR>m</VAR> + 1 => <VAR>s</VAR>
</PRE>

<P>
Это также является специфичным для конкретных языков, а в некоторых
случаях---для отдельного компилятора или машины.
Для дальнейших сведений по отдельным языкам, See section <A HREF="gdb_10.html#SEC71">Поддерживаемые языки</A>.


<P>
GDB обеспечивает некоторые дополнительные команды для контроля
проверки диапазона:


<P>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>
<A NAME="IDX402"></A>
<DL COMPACT>

<DT><CODE>set check range auto</CODE>
<DD>
Включить или отключить контроль диапазона, в зависимости от
текущего рабочего языка.  See section <A HREF="gdb_10.html#SEC71">Поддерживаемые языки</A>,
для получения информации об установках по умолчанию для каждого языка.

<DT><CODE>set check range on</CODE>
<DD>
<DT><CODE>set check range off</CODE>
<DD>
Включить или отключить контроль типов, пренебрегая установкой
по умолчанию для текущего рабочего языка.
Если установка не соответствует используемой по умолчанию, выводится
предупреждающее сообщение.  Если происходит ошибка диапазона и контроль
включен, выводится сообщение и вычисление выражения прерывается.

<DT><CODE>set check range warn</CODE>
<DD>
При выявлении ошибки диапазона, GDB выведет предупреждающее
сообщение, но попытается вычислить выражение.  Тем не менее,
вычисление выражения может быть невозможным по другим причинам,
таким как обращение к памяти, которой процесс не владеет (типичный
пример для многих систем Unix).

<DT><CODE>show range</CODE>
<DD>
Показать текущую установку проверки диапазона и была ли она установлена
GDB автоматически.
</DL>



<H2><A NAME="SEC71" HREF="gdb_toc.html#TOC71">Поддерживаемые языки</A></H2>

<P>
GDB поддерживает Си, Си++, Фортран, Java, Chill, ассемблер и
Модула-2.  Некоторые возможности GDB могут быть задействованы в
выражениях независимо от используемого языка: операторы GDB
<CODE>@</CODE> и <CODE>::</CODE> и конструкция <SAMP>`{тип}адрес'</SAMP>
(see section <A HREF="gdb_9.html#SEC51">Выражения</A>) могут быть использованы в конструкциях
любого поддерживаемого языка.


<P>
Следующие разделы подробно описывают, до какой степени каждый из
исходных языков поддерживается GDB.  Эти разделы не задумывались как
учебники или руководства по языкам; они лишь служат справочным
руководством по тому, что допускает анализатор выражений
GDB, и как должны выглядеть входные и выходные форматы в
различных языках.  Существует много хороших книг по каждому из этих
языков; пожалуйста, загляните в них, если вам нужен учебник или
справочник по языку.




<H3><A NAME="SEC72" HREF="gdb_toc.html#TOC72">Си и Си++</A></H3>

<P>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>


<P>
Поскольку Си и Си++ тесно связаны, многие возможности GDB
применимы к ним обоим.  Когда это имеет место, мы обсуждаем эти языки
вместе.


<P>
<A NAME="IDX405"></A>
<A NAME="IDX406"></A>
<A NAME="IDX407"></A>
Средства отладки Си++ обеспечиваются совместно компилятором Си++
и GDB.  Следовательно, для эффективной отладки программы на
Си++, вам следует пользоваться одним из поддерживаемых компиляторов,
например GNU <CODE>g++</CODE>, или компилятором HP ANSI Си++
(<CODE>aCC</CODE>).


<P>
При использовании GNU Си++, для получения наилучших результатов
используйте формат отладочной информации stabs.  Вы можете выбрать его
явно с помощью ключа командной строки <SAMP>`-gstabs'</SAMP> или <SAMP>`-gstabs+'</SAMP>.  Смотрите
section `Ключи для отладки вашей программы или GNU CC' in <CITE>Использование GNU CC</CITE>, для дополнительной информации.




<H4><A NAME="SEC73" HREF="gdb_toc.html#TOC73">Операторы Си и Си++</A></H4>

<P>
<A NAME="IDX408"></A>


<P>
Операторы должны быть определены на значениях определенных типов.
Например, <CODE>+</CODE> определен на числах, но не на структурах.
Операторы часто определяются на группах типов.


<P>
Для целей Си и Си++, имеют место следующие определения:



<UL>

<LI>

<EM>Целые типы</EM> включают <CODE>int</CODE> с любыми спецификаторами
класса памяти; <CODE>char</CODE>; <CODE>enum</CODE>; и, для Си++, <CODE>bool</CODE>.

<LI>

<EM>Типы с плавающей точкой</EM> включают <CODE>float</CODE>, <CODE>double</CODE> и
<CODE>long double</CODE> (если поддерживается целевой платформой).

<LI>

<EM>Типы указателей</EM> включают все типы, определенные как
<CODE>(<VAR>тип</VAR> *)</CODE>.

<LI>

<EM>Скалярные типы</EM> включают все вышеперечисленные типы.

</UL>

<P>
Поддерживаются следующие операторы, перечисленные здесь в порядке
возрастания приоритета:


<DL COMPACT>

<DT><CODE>,</CODE>
<DD>
Запятая, или оператор последовательного выполнения.  Выражения,
разделенные в списке запятыми, вычисляются слева направо;
результатом всего выражения является результат, полученный последним.

<DT><CODE>=</CODE>
<DD>
Присваивание.  Значение выражения приваивания---присвоенное значение.
Определено на скалярных типах.

<DT><CODE><VAR>опер</VAR>=</CODE>
<DD>
Используется в выражениях в форме <CODE><VAR>a</VAR> <VAR>опер</VAR>= <VAR>b</VAR></CODE>
и преобразовывается в <CODE><VAR>a</VAR> = <VAR>a опер b</VAR></CODE>.
<CODE><VAR>опер</VAR>=</CODE> и <CODE>=</CODE> имеют одинаковый приоритет.
<VAR>опер</VAR> может быть одним из операторов <CODE>|</CODE>, <CODE>^</CODE>, <CODE>&#38;</CODE>,
<CODE>&#60;&#60;</CODE>, <CODE>&#62;&#62;</CODE>, <CODE>+</CODE>, <CODE>-</CODE>, <CODE>*</CODE>,
<CODE>/</CODE>, <CODE>%</CODE>.

<DT><CODE>?:</CODE>
<DD>
Тернарный оператор.  <CODE><VAR>a</VAR> ? <VAR>b</VAR> : <VAR>c</VAR></CODE> истолковывается
так: если <VAR>a</VAR>, то <VAR>b</VAR>, иначе <VAR>c</VAR>.  <VAR>a</VAR>
должно быть целого типа.

<DT><CODE>||</CODE>
<DD>
Логическое или.  Определено на целых типах.

<DT><CODE>&#38;&#38;</CODE>
<DD>
Логическое и.  Определено на целых типах.

<DT><CODE>|</CODE>
<DD>
Побитовое или.  Определено на целых типах.

<DT><CODE>^</CODE>
<DD>
Побитовое исключающее или.  Определено на целых типах.

<DT><CODE>&#38;</CODE>
<DD>
Побитовое и.  Определено на целых типах.

<DT><CODE>==, !=</CODE>
<DD>
Равенство и неравенство.  Определено на скалярных типах.  Значение
этих выражений отлично от нуля для истины и 0 для лжи.

<DT><CODE>&#60;, &#62;, &#60;=, &#62;=</CODE>
<DD>
Меньше чем, больше чем, меньше или равно, больше или равно.  Определено
на скалярных типах.  Значение этих выражений равно 0 для лжи и отлично от нуля
для истины.

<DT><CODE>&#60;&#60;, &#62;&#62;</CODE>
<DD>
Левый сдвиг и правый сдвиг.  Определено на целых типах.

<DT><CODE>@</CODE>
<DD>
Оператор GDB создания "искусственного массива"
(see section <A HREF="gdb_9.html#SEC51">Выражения</A>).

<DT><CODE>+, -</CODE>
<DD>
Сложение и вычитание.  Определено на целочисленных типах, типах с
плавающей точкой и указателях.

<DT><CODE>*, /, %</CODE>
<DD>
Умножение, деление и остаток.  Умножение и деление определены на
целочисленных типах и типах с плавающей точкой.  Остаток определен
на целочисленных типах.

<DT><CODE>++, --</CODE>
<DD>
Инкремент и декремент.  При появлении перед переменной,
операция выполняется прежде, чем переменная используется в
выражении; при появлении после переменной,
значение переменной используется до выполнения операции.

<DT><CODE>*</CODE>
<DD>
Разыменование указателя.  Определено для указателей.  Имеет тот
же приоритет, что и <CODE>++</CODE>.

<DT><CODE>&#38;</CODE>
<DD>
Оператор получения адреса.  Определен на переменных.  Имеет тот же
приоритет, что и <CODE>++</CODE>.

Для отладки Си++, GDB реализует использование <SAMP>`&#38;'</SAMP>
независимо от того, что позволяет сам язык Си++: вы можете использовать
<SAMP>`&#38;(&#38;<VAR>ссылка</VAR>)'</SAMP> (или просто  <SAMP>`&#38;&#38;<VAR>ссылка</VAR>'</SAMP>),
чтобы исследовать адрес, по которому хранится
переменная-ссылка Си++ (объявленная с помощью <SAMP>`&#38;<VAR>ссылка</VAR>'</SAMP>).

<DT><CODE>-</CODE>
<DD>
Унарный минус.  Определен на целочисленных типах и типах с
плавающей точкой.  Имеет тот же приоритет, что и <CODE>++</CODE>.

<DT><CODE>!</CODE>
<DD>
Логическое отрицание.  Определено на целочисленных типах.  Имеет тот
же приоритет, что и <CODE>++</CODE>.

<DT><CODE>~</CODE>
<DD>
Оператор побитового дополнения.  Определен на целочисленных
типах. Имеет тот же приоритет, что и <CODE>++</CODE>.

<DT><CODE>., -&#62;</CODE>
<DD>
Элемент структуры и указатель на элемент структуры.  Для удобства,
GDB считает их эквивалентными, определяя, следует ли
разыменовывать указатель, основываясь на сохраненной информации о типах.
Определен на данных структуры (<CODE>struct</CODE>) и объединения (<CODE>union</CODE>).

<DT><CODE>.*, -&#62;*</CODE>
<DD>
Разыменовывание указателя на элемент.

<DT><CODE>[]</CODE>
<DD>
Индексация массива.  <CODE><VAR>a</VAR>[<VAR>i</VAR>]</CODE> определяется как
<CODE>*(<VAR>a</VAR>+<VAR>i</VAR>)</CODE>.  Имеет тот же приоритет, что и <CODE>-&#62;</CODE>.

<DT><CODE>()</CODE>
<DD>
Список параметров функции.  Имеет тот же приоритет, что и <CODE>-&#62;</CODE>.

<DT><CODE>::</CODE>
<DD>
Оператор Си++ определения области видимости.  Определен на типах
<CODE>struct</CODE>, <CODE>union</CODE> и <CODE>class</CODE>.

<DT><CODE>::</CODE>
<DD>
Двойное двоеточие также представляет оператор GDB области
видимости (see section <A HREF="gdb_9.html#SEC51">Выражения</A>).  Имеет тот же приоритет, что
и <CODE>::</CODE>, описанный выше.
</DL>

<P>
Если оператор переопределен в пользовательском коде, GDB обычно
пытается выполнить переопределенную версию, а не использовать
предопределенное значение оператора.




<H4><A NAME="SEC74" HREF="gdb_toc.html#TOC74">Константы Си и Си++</A></H4>

<P>
<A NAME="IDX409"></A>


<P>
GDB позволяет вам выражать константы Си и Си++ следующими способами:



<UL>
<LI>

Целочисленные константы---это последовательности цифр.  Восьмеричные
константы начинаются с <SAMP>`0'</SAMP> (с нуля), а шестнадцатеричные константы---с
<SAMP>`0x'</SAMP> или <SAMP>`0X'</SAMP>.  Константы также могут заканчиваться буквой
<SAMP>`l'</SAMP>, указывая, что значение константы должно рассматриваться как
длинное (<CODE>long</CODE>).

<LI>

Константы с плавающей точкой---это последовательность цифр, за которой
следует десятичная точка, другая последовательность цифр, и, возможно,
порядок.  Порядок указывается в форме
<SAMP>`e[[+]|-]<VAR>nnn</VAR>'</SAMP>, где <VAR>nnn</VAR>---другая
последовательность цифр.  Для положительных порядков <SAMP>`+'</SAMP> является
необязательным.  Константа с плавающей точкой может также
заканчиваться буквой <SAMP>`f'</SAMP> или <SAMP>`F'</SAMP>, это указывает на то, что
константа должна рассматриваться как <CODE>float</CODE> (в отличие от
<CODE>double</CODE> по умолчанию), или буквой <SAMP>`l'</SAMP> или <SAMP>`L'</SAMP>, что
указывает на константу типа <CODE>long double</CODE>.

<LI>

Перечисляемые константы состоят из перечисляемых идентификаторов, или
их целочисленных эквивалентов.

<LI>

Символьные константы---это одиночный символ, заключенный в одиночные
кавычки (<CODE>'</CODE>), или число---порядковое значение соответствующего
символа (обычно его значение ASCII).  Внутри кавычек, одиночный
символ может быть представлен либо буквой, либо <EM>экранирующей
последовательностью</EM>, которая имеет форму <SAMP>`\<VAR>nnn</VAR>'</SAMP>, где
<VAR>nnn</VAR> является восьмеричным представлением порядкового значения
символа; или форму <SAMP>`\<VAR>x</VAR>'</SAMP>, где <SAMP>`<VAR>x</VAR>'</SAMP>---специальный
предопределенный знак, например, <SAMP>`\n'</SAMP> для знака новой строки.

<LI>

Строковые константы---последовательность символьных констант (без
одиночных кавычек), заключенная в двойные кавычки (<CODE>"</CODE>).  Туда
могут входить любые допустимые символьные константы (как описано выше).
Двойным кавычкам внутри строки должна предшествовать обратная косая
черта, так что <SAMP>`"a\"b'c"'</SAMP>, например, является строкой из пяти
символов.

<LI>

Константы-указатели представляют собой целочисленные значения.  Вы можете также
записывать указатели на константы, используя оператор Cи <SAMP>`&#38;'</SAMP>.

<LI>

Константы-массивы---заключенные в фигурные скобки (<SAMP>`{'</SAMP> и
<SAMP>`}'</SAMP>) списки элементов, разделенные запятыми; например,
<SAMP>`{1,2,3}'</SAMP> является массивом с тремя целочисленными элементами,
<SAMP>`{{1,2}, {3,4}, {5,6}}'</SAMP> является массивом размерности три
на два, и <SAMP>`{&#38;"hi", &#38;"there", &#38;"fred"}'</SAMP> является трехэлементным
массивом указателей.
</UL>



<H4><A NAME="SEC75" HREF="gdb_toc.html#TOC75">Выражения Си++</A></H4>

<P>
<A NAME="IDX410"></A>
Обработчик выражений GDB может интерпретировать большинство
выражений Си++.


<P>
<A NAME="IDX411"></A>
<A NAME="IDX412"></A>
<A NAME="IDX413"></A>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>
<A NAME="IDX416"></A>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>
<A NAME="IDX419"></A>

<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> GDB может отлаживать программы на Си++
только если вы используете подходящий компилятор.  Обычно,
отладка Си++ зависит от использования дополнительной отладочной информации в
таблице символов, и, таким образом, требует специальной поддержки.
В частности, если ваш компилятор генерирует a.out, MIPS ECOFF,
RS/6000 XCOFF, или ELF с расширениями stabs к таблице
символов, все эти средства доступны.  (С GNU CC вы можете
использовать ключ <SAMP>`-gstabs'</SAMP>, чтобы явно запросить расширения
отладки stabs).  С другой стороны, если формат объектного
кода---стандартный COFF или DWARF в ELF, значительная часть
поддержки Си++ в GDB <EM>не</EM> работает.
</BLOCKQUOTE>


<OL>

<LI>

<A NAME="IDX420"></A>
 
Допускаются вызовы функций-членов; вы можете использовать выражения типа


<PRE>
count = aml-&#62;GetOriginal(x, y)
</PRE>

<A NAME="IDX421"></A>
<A NAME="IDX422"></A>
<LI>

Пока функция-член активна (в выбранном кадре стека), вашим выражениям
доступно то же пространство имен, что и функции-члену; то есть
GDB допускает неявные ссылки на указатель
экземпляра класса <CODE>this</CODE> по тем же правилам, что и Си++.

<A NAME="IDX423"></A>
<A NAME="IDX424"></A>
<A NAME="IDX425"></A>
<LI>

Вы можете вызывать перегруженные функции; GDB производит вызов
функции с правильным определением, но с некоторыми ограничениями.
GDB не совершает преобразования, для выполнения которых требуются
преобразования типов, определенные пользователем, вызовы конструкторов
или конкретизации не существующих в программе шаблонов.  Он также не
может обрабатывать списки с неопределенным числом аргументов
или аргументы со значениями по умолчанию.

Он производит преобразования и расширения целочисленных типов,
расширения типов с плавающей точкой, арифметические преобразования,
преобразования указателей, преобразования класса объекта в базовые
классы и стандартные преобразования, например функции или массива к
указателю; это требует точного совпадения числа аргументов функции.

Разрешение перегруженных имен производится всегда, если не
указано <CODE>set overload-resolution off</CODE>.  See section <A HREF="gdb_10.html#SEC79">Возможности GDB для Си++</A>.

Вы должны указать <CODE>set overload-resolution off</CODE>, чтобы задать
функцию явно при вызове перегруженной функции, как в примере

<PRE>
p 'foo(char,int)'('x', 13)
</PRE>

Возможности GDB для завершения команд могут упростить это;
смотрите section <A HREF="gdb_4.html#SEC13">Завершение команд</A>.

<A NAME="IDX426"></A>
<LI>

GDB понимает переменные, объявленные как ссылки Си++; вы можете
использовать их в выражениях, точно как вы делаете в исходном тексте
Си++---они автоматически разыменовываются.

В списке параметров, показываемом GDB при отображении кадра
стека, значения переменных-ссылок не отображаются (в отличие от
других переменных); это позволяет избежать неудобств из-за того, что ссылки
часто используются для больших структур.  <EM>Адрес</EM>
переменной-ссылки всегда выводится, если только вы не установили
<SAMP>`set print address off'</SAMP>.

<LI>

GDB поддерживает оператор Си++ определения области видимости имени
<CODE>::</CODE>---ваши выражения могут использовать его так же, как в вашей
программе.  Так как одна область видимости может быть определена
внутри другой, вы можете при необходимости неоднократно использовать
<CODE>::</CODE>, например, в выражении типа
<SAMP>`<VAR>обл1</VAR>::<VAR>обл2</VAR>::<VAR>имя</VAR>'</SAMP>.  GDB также
позволяет определить область видимости имени путем ссылки на исходный
файл, при отладке как Си, так и Си++ (see section <A HREF="gdb_9.html#SEC52">Переменные программы</A>).
</OL>

<P>
Кроме того, при использовании с компилятором HP Си++, GDB
правильно поддерживает вызов виртуальных функций, вывод виртуальный баз
объектов, вызов функций в базовом подобъекте, приведение объектов и
выполнение операторов, определенных пользвателем.




<H4><A NAME="SEC76" HREF="gdb_toc.html#TOC76">Значения Си и Си++ по умолчанию</A></H4>

<P>
<A NAME="IDX427"></A>


<P>
Если вы разрешаете GDB устанавливать проверки диапазона
и принадлежности типу автоматически, обе они по умолчанию
<EM>отключены</EM>, если рабочий язык изменяется на Си или Си++.  Это
происходит независимо от того, выбираете рабочий язык вы или
GDB.


<P>
Если вы разрешаете GDB устанавливать язык автоматически, он распознает
исходные файлы, чьи имена заканчиваются расширением <TT>`.c'</TT>,
<TT>`.C'</TT> или <TT>`.cc'</TT>, и так далее, и когда GDB начинает
обработку кода, скомпилированного из одного из этих файлов, он
устанавливает рабочий язык в Си или Си++.
See section <A HREF="gdb_10.html#SEC66">Распознавание GDB исходного языка</A>, для более подробного обсуждения.




<H4><A NAME="SEC77" HREF="gdb_toc.html#TOC77">Проверки диапазона и принадлежности типу в Си и Си++</A></H4>

<P>
<A NAME="IDX428"></A>


<P>
Когда GDB производит разбор выражений Си или Си++, по умолчанию
проверки соответствия типов не проводятся.  Однако, если вы их включите,
GDB считает типы двух переменных эквивалентными, если:



<UL>
<LI>

Обе переменные структурированы и имеют один и тот же тег структуры,
объединения или перечисления.

<LI>

Имена типов обеих переменных совпадают или были объявлены
эквивалентными через <CODE>typedef</CODE>.
</UL>

<P>
Проверка диапазона, если она включена, выполняется для
математических операций.  Индексы массивов не проверяются, так как они
часто применяются для индексирования указателей, которые
сами по себе массивами не являются.




<H4><A NAME="SEC78" HREF="gdb_toc.html#TOC78">GDB и Си</A></H4>

<P>
Команды <CODE>set print union</CODE> и <CODE>show print union</CODE> применимы к типу
<CODE>union</CODE>.  При установке в <SAMP>`on'</SAMP>, любые объединения, находящиеся внутри
структуры или класса, также выводятся.  В противном случае, они
отображаются как <SAMP>`{...}'</SAMP>.


<P>
Оператор <CODE>@</CODE> помогает при отладке динамических массивов,
сформированных с помощью указателей и функции выделения памяти.
See section <A HREF="gdb_9.html#SEC51">Выражения</A>.




<H4><A NAME="SEC79" HREF="gdb_toc.html#TOC79">Возможности GDB для Си++</A></H4>

<P>
<A NAME="IDX429"></A>


<P>
Некоторые команды GDB особенно полезны при использовании с
Си++, а некоторые разработаны специально для него.  Ниже приведено их
краткое описание:


<DL COMPACT>

<DT><CODE>меню точки останова</CODE>
<DD>
<A NAME="IDX430"></A>
 
Когда вы хотите установить точку останова в перегруженной
функции, меню точки останова GDB помогает вам указать, какое
определение функции вам нужно.  See section <A HREF="gdb_6.html#SEC35">Меню точки останова</A>.

<A NAME="IDX431"></A>
<DT><CODE>rbreak <VAR>рег-выр</VAR></CODE>
<DD>
Установка точек останова при помощи регулярных выражений
полезна при использовании перегруженных функций,
не являющихся членами специальных классов.  See section <A HREF="gdb_6.html#SEC28">Установка точек останова</A>.

<A NAME="IDX432"></A>
<DT><CODE>catch throw</CODE>
<DD>
<DT><CODE>catch catch</CODE>
<DD>
Отлаживайте обработку исключений Си++ с помощью этих команд.
See section <A HREF="gdb_6.html#SEC30">Установка точек перехвата</A>.

<A NAME="IDX433"></A>
<DT><CODE>ptype <VAR>имя-типа</VAR></CODE>
<DD>
Вывести отношения наследования вместе с другой информацией для типа
<VAR>имя-типа</VAR>.  See section <A HREF="gdb_11.html#SEC95">Исследование таблицы символов</A>.

<A NAME="IDX434"></A>
<DT><CODE>set print demangle</CODE>
<DD>
<DT><CODE>show print demangle</CODE>
<DD>
<DT><CODE>set print asm-demangle</CODE>
<DD>
<DT><CODE>show print asm-demangle</CODE>
<DD>
Управляет отображением символов Си++ в их исходной форме, как при выводе
кода в виде исходного текста Си++, так и при выводе результата
дисассемблирования.
See section <A HREF="gdb_9.html#SEC57">Параметры вывода</A>.

<DT><CODE>set print object</CODE>
<DD>
<DT><CODE>show print object</CODE>
<DD>
Выбрать, выводить производные (реальные) или описанные типы объектов.
See section <A HREF="gdb_9.html#SEC57">Параметры вывода</A>.

<DT><CODE>set print vtbl</CODE>
<DD>
<DT><CODE>show print vtbl</CODE>
<DD>
Управляет форматом вывода таблиц виртуальных функций.
See section <A HREF="gdb_9.html#SEC57">Параметры вывода</A>.
(Команды <CODE>vtbl</CODE> не работают для программ, скомпилированных
компилятором HP ANSI Си++ (<CODE>aCC</CODE>).)

<A NAME="IDX435"></A>
<A NAME="IDX436"></A>
<DT><CODE>set overload-resolution on</CODE>
<DD>
Включить разрешение перегруженных символов при вычислении выражений
Си++.  Значение по умолчанию <CODE>on</CODE>.  Для перегруженных функций,
GDB вычисляет аргументы и ищет функции, чьи сигнатуры
удовлетворяют типам аргументов, используя стандартные правила
преобразования Си++ (смотрите section <A HREF="gdb_10.html#SEC75">Выражения Си++</A>, для
дополнительной информации).  Если GDB не может найти такие
функции, он выводит сообщение.

<DT><CODE>set overload-resolution off</CODE>
<DD>
Отключить разрешение перегруженных символов при вычислении выражений
Си++.  Для перегруженных функций, не являющихся функциями-членами
класса, GDB выбирает функцию с указанным именем, которую
он первой находит в таблице символов, в не зависимости от того, правильного
типа ее аргументы или нет.  Для перегруженных функций, являющихся
функциями-членами класса, GDB ищет функцию, чья сигнатура
<EM>точно</EM> совпадает с типами аргументов.

<DT><CODE>Перегруженные имена смиволов</CODE>
<DD>
Вы можете указать конкретное определение перегруженного символа,
используя ту же запись, что и для объявления таких символов в
Си++: введите <CODE><VAR>символ</VAR>(<VAR>типы</VAR>)</CODE> вместо просто
<VAR>символ</VAR>.  Вы также можете воспользоваться средствами завершения
слова командной строки GDB, чтобы вывести список возможных
вариантов, или чтобы завершить набор за вас.
See section <A HREF="gdb_4.html#SEC13">Завершение команд</A>, для подробного обсуждения, как это
сделать.
</DL>



<H3><A NAME="SEC80" HREF="gdb_toc.html#TOC80">Модула-2</A></H3>

<P>
<A NAME="IDX437"></A>


<P>
Расширения, сделанные в GDB для поддержки Модулы-2,
поддерживаются только для программ, скомпилированных
GNU компилятором Модулы-2 (который сейчас разрабатывается).
Другие компиляторы Модулы-2 в настоящее время не
поддерживаются, и попытка отладки исполняемых программ, полученных
ими, скорее всего приведет к ошибке при считывании GDB таблицы
символов этой программы.


<P>
<A NAME="IDX438"></A>




<H4><A NAME="SEC81" HREF="gdb_toc.html#TOC81">Операторы Модулы-2</A></H4>
<P>
<A NAME="IDX439"></A>


<P>
Операторы должны быть определены на значениях определенных типов.
Например, <CODE>+</CODE> определен на числах, но не на структурах.
Операторы часто определяются на группах типов.  Для целей Модулы-2,
имеют место следующие определения:



<UL>

<LI>

<EM>Целые типы</EM> состоят из <CODE>INTEGER</CODE>, <CODE>CARDINAL</CODE>
и их поддиапазонов.

<LI>

<EM>Символьные типы</EM> состоят из <CODE>CHAR</CODE> и его поддиапазонов.

<LI>

<EM>Типы с плавающей точкой</EM> состоят из <CODE>REAL</CODE>.

<LI>

<EM>Типы-указатели</EM> состоят из всего, объявленного как <CODE>POINTER TO
<VAR>тип</VAR></CODE>.

<LI>

<EM>Скалярные типы</EM> включают все вышеперечисленное.

<LI>

<EM>Типы-множества</EM> состоят из типов <CODE>SET</CODE> и <CODE>BITSET</CODE>.

<LI>

<EM>Булевый тип</EM> состоит из <CODE>BOOLEAN</CODE>.
</UL>

<P>
Поддерживаются следующие операторы; они представлены в порядке
возрастания приоритета:


<DL COMPACT>

<DT><CODE>,</CODE>
<DD>
Разделитель аргументов функции или индексов массива.

<DT><CODE>:=</CODE>
<DD>
Присваивание.  Значением <VAR>перем</VAR> <CODE>:=</CODE> <VAR>знач</VAR> является <VAR>знач</VAR>.

<DT><CODE>&#60;, &#62;</CODE>
<DD>
Меньше чем, больше чем для целочисленных типов, типов с
плавающей точкой и перечислимых типов.

<DT><CODE>&#60;=, &#62;=</CODE>
<DD>
Меньше или равно, больше или равно.  Определено на
целочисленных типах, типах с плавающей точкой и перечислимых типах.
Включение для множеств.  Такой же приоритет, как у <CODE>&#60;</CODE>.

<DT><CODE>=, &#60;&#62;, #</CODE>
<DD>
Равенство и два способа выражения неравенства; допустимо на
скалярных типах.  Такой же приоритет, как у <CODE>&#60;</CODE>.  В сценариях
GDB, для неравенства допустимо только <CODE>&#60;&#62;</CODE>, так как
<CODE>#</CODE> конфликтует со знаком комментария.

<DT><CODE>IN</CODE>
<DD>
Установка принадлежности.  Определено на множествах и
типах их элементов.  Такой же приоритет, как у <CODE>&#60;</CODE>.

<DT><CODE>OR</CODE>
<DD>
Дизъюнкция (логическое ИЛИ).  Определена на булевых типах.

<DT><CODE>AND, &#38;</CODE>
<DD>
Конъюнкция (логическое И).  Определена на булевых типах.

<DT><CODE>@</CODE>
<DD>
Оператор "искусственного массива" GDB (see section <A HREF="gdb_9.html#SEC51">Выражения</A>).

<DT><CODE>+, -</CODE>
<DD>
Сложение и вычитание на целочисленных типах и типах с плавающей
точкой, или объединение и разность на множественных типах.

<DT><CODE>*</CODE>
<DD>
Умножение на целочисленных типах и типах с плавающей точкой, или
пересечение на типах-множествах.

<DT><CODE>/</CODE>
<DD>
Деление на типах с плавающей точкой.  Симметрическая разность
множеств на типах-множествах.  Такой же приоритет, как у <CODE>*</CODE>.

<DT><CODE>DIV, MOD</CODE>
<DD>
Целочисленное деление и остаток.  Определены на целочисленных
типах.  Такой же приоритет, как у <CODE>*</CODE>.

<DT><CODE>-</CODE>
<DD>
Отрицание.  Определено на данных типов <CODE>INTEGER</CODE> и <CODE>REAL</CODE>.

<DT><CODE>^</CODE>
<DD>
Разыменовывание указателя.  Определено на типах-указателях.

<DT><CODE>NOT</CODE>
<DD>
Булево отрицание.  Определено на булевых типах.  Такой же приоритет, как
у <CODE>^</CODE>.

<DT><CODE>.</CODE>
<DD>
Селектор полей <CODE>RECORD</CODE>.  Определен для данных типа <CODE>RECORD</CODE>.
Такое же приоритет, как у <CODE>^</CODE>.

<DT><CODE>[]</CODE>
<DD>
Индексация массива.  Определена для данных типа <CODE>ARRAY</CODE>.  Такой же
приоритет, как у <CODE>^</CODE>.

<DT><CODE>()</CODE>
<DD>
Список параметров процедуры.  Определен на объектах <CODE>PROCEDURE</CODE>.
Такой же приоритет, как у <CODE>^</CODE>.

<DT><CODE>::, .</CODE>
<DD>
Операторы GDB и Модулы-2 определения области видимости.
</DL>


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Множества и операции над ними еще не
поддерживаются, так что GDB трактует использование оператора
<CODE>IN</CODE> или операторов <CODE>+</CODE>, <CODE>-</CODE>, <CODE>*</CODE>, <CODE>/</CODE>,
<CODE>=</CODE>, , <CODE>&#60;&#62;</CODE>, <CODE>#</CODE>, <CODE>&#60;=</CODE>, и <CODE>&#62;=</CODE> на
множествах как ошибку.
</BLOCKQUOTE>

<P>
<A NAME="IDX440"></A>


<H4><A NAME="SEC82" HREF="gdb_toc.html#TOC82">Встроенные функции и процедуры</A></H4>

<P>
Модула-2 также делает доступными несколько встроенных процедур и
функций.  При их описании, используются следующие метапеременные:


<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
представляет переменную типа <CODE>ARRAY</CODE>.

<DT><VAR>c</VAR>
<DD>
представляет константу или переменную типа <CODE>CHAR</CODE>.

<DT><VAR>i</VAR>
<DD>
представляет переменную или константу целого типа.

<DT><VAR>m</VAR>
<DD>
представляет идентификатор, принадлежащий множеству.  Обычно
используется в одной функции с метапеременной <VAR>s</VAR>.  Тип <VAR>s</VAR>
должен быть <CODE>SET OF <VAR>метатип</VAR></CODE> (где <VAR>метатип</VAR>---тип <VAR>m</VAR>).

<DT><VAR>n</VAR>
<DD>
представляет переменную или константу целого типа или
типа с плавающей точкой.

<DT><VAR>r</VAR>
<DD>
представляет переменную или константу типа с плавающей точкой.

<DT><VAR>t</VAR>
<DD>
представляет тип.

<DT><VAR>v</VAR>
<DD>
представляет переменную.

<DT><VAR>x</VAR>
<DD>
представляет переменную или константу одного из нескольких типов.
Смотрите пояснение к функции для дополнительной информации.
</DL>

<P>
Ниже описаны все встроенные процедуры Модулы-2, возвращающие результат.


<DL COMPACT>

<DT><CODE>ABS(<VAR>n</VAR>)</CODE>
<DD>
Возвращает абсолютное значение <VAR>n</VAR>.

<DT><CODE>CAP(<VAR>c</VAR>)</CODE>
<DD>
Если <VAR>c</VAR>---символ нижнего регистра, процедура возвращает его эквивалент
в верхнем регистре, иначе возвращает сам аргумент.

<DT><CODE>CHR(<VAR>i</VAR>)</CODE>
<DD>
Возвращает символ, порядковое значение которого есть <VAR>i</VAR>.

<DT><CODE>DEC(<VAR>v</VAR>)</CODE>
<DD>
Уменьшает значение переменной <VAR>v</VAR> на единицу.  Возвращает новое значение.

<DT><CODE>DEC(<VAR>v</VAR>,<VAR>i</VAR>)</CODE>
<DD>
Уменьшает значение переменной <VAR>v</VAR> на <VAR>i</VAR>.  Возвращает новое значение.

<DT><CODE>EXCL(<VAR>m</VAR>,<VAR>s</VAR>)</CODE>
<DD>
Удаляет элемент <VAR>m</VAR> из множества <VAR>s</VAR>.  Возвращает новое множество.

<DT><CODE>FLOAT(<VAR>i</VAR>)</CODE>
<DD>
Возвращает эквивалент целого числа <VAR>i</VAR> в формате с плавающей точкой.

<DT><CODE>HIGH(<VAR>a</VAR>)</CODE>
<DD>
Возвращает индекс последнего элемента <VAR>a</VAR>.

<DT><CODE>INC(<VAR>v</VAR>)</CODE>
<DD>
Увеличивает значение переменной <VAR>v</VAR> на единицу.  Возвращает новое
значение.

<DT><CODE>INC(<VAR>v</VAR>,<VAR>i</VAR>)</CODE>
<DD>
Увеличивает значение переменной <VAR>v</VAR> на <VAR>i</VAR>.  Возвращает новое
значение.

<DT><CODE>INCL(<VAR>m</VAR>,<VAR>s</VAR>)</CODE>
<DD>
Добавляет элемент <VAR>m</VAR> в множество <VAR>s</VAR>, если его там еще нет.
Возвращает новое множество.

<DT><CODE>MAX(<VAR>t</VAR>)</CODE>
<DD>
Возвращает максимальное значение типа <VAR>t</VAR>.

<DT><CODE>MIN(<VAR>t</VAR>)</CODE>
<DD>
Возвращает минимальное значение типа <VAR>t</VAR>.

<DT><CODE>ODD(<VAR>i</VAR>)</CODE>
<DD>
Возвращает булево значение TRUE, если число <VAR>i</VAR> нечетно.

<DT><CODE>ORD(<VAR>x</VAR>)</CODE>
<DD>
Возвращает порядковое значение своего аргумента.  Например, порядковое
значение символа---его ASCII-значение (на машинах, поддерживающих
набор символов ASCII).  <VAR>x</VAR> должна принадлежать упорядоченному
типу, что включает целочисленные, символьный и перечислимый типы.

<DT><CODE>SIZE(<VAR>x</VAR>)</CODE>
<DD>
Возвращает размер аргумента.  <VAR>x</VAR> может быть переменной или типом.

<DT><CODE>TRUNC(<VAR>r</VAR>)</CODE>
<DD>
Возвращает целую часть <VAR>r</VAR>.

<DT><CODE>VAL(<VAR>t</VAR>,<VAR>i</VAR>)</CODE>
<DD>
Возвращает элемент типа <VAR>t</VAR>, порядковое значение которого есть <VAR>i</VAR>.
</DL>


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Множества и операции над ними еще не
поддерживаются, так что GDB рассматривает использование
процедур <CODE>INCL</CODE> и <CODE>EXCL</CODE> как ошибку.
</BLOCKQUOTE>

<P>
<A NAME="IDX441"></A>


<H4><A NAME="SEC83" HREF="gdb_toc.html#TOC83">Константы</A></H4>

<P>
GDB позволяет вам выражать константы Модулы-2 следующими способами:



<UL>

<LI>

Целые константы являются просто последовательностью цифр.
При использовании в выражении, константа интерпретируется так, чтобы быть
совместимой по типу с остальной частью выражения.  Шестнадцатеричные
целые числа определяются окончанием <SAMP>`H'</SAMP>, а восьмеричные---
окончанием <SAMP>`B'</SAMP>.

<LI>

Константы с плавающей точкой задаются как последовательность цифр,
за которой следует десятичная точка и другая последовательность цифр.
Необязательный порядок может быть задан в форме
<SAMP>`E[+|-]<VAR>nnn</VAR>'</SAMP>, где
<SAMP>`[+|-]<VAR>nnn</VAR>'</SAMP> и есть желаемый порядок.  Все цифры
константы с плавающей точкой должны быть десятичными (по основанию 10).

<LI>

Символьные константы состоят из одиночных символов, заключенных в пару
одинаковых кавычек: либо одиночных (<CODE>'</CODE>), либо двойных (<CODE>"</CODE>).
Они также могут быть заданы своим порядковым значением (обычно
ASCII-значением), за которым следует <SAMP>`C'</SAMP>.

<LI>

Строковые константы состоят из последовательности символов, окруженных
парой одинаковых кавычек: либо одиночных (<CODE>'</CODE>), либо двойных
(<CODE>"</CODE>).  Также допускаются экранирующие последовательности в
стиле Си.  See section <A HREF="gdb_10.html#SEC74">Константы Си и Си++</A>, для краткого
объяснения экранирующих последовательностей.

<LI>

Перечислимые константы состоят из перечислимого идентификатора.

<LI>

Булевы константы состоят из идентификаторов <CODE>TRUE</CODE> и <CODE>FALSE</CODE>.

<LI>

Константы-указатели состоят только из целочисленных значений.

<LI>

Константы-множества пока не поддерживаются.
</UL>



<H4><A NAME="SEC84" HREF="gdb_toc.html#TOC84">Установки по умолчанию Модулы-2</A></H4>
<P>
<A NAME="IDX442"></A>


<P>
Если проверка диапазона или принадлежности типу устанавливается
GDB автоматически, то по умолчанию обе они устанавливаются в
<CODE>on</CODE>, если рабочим языком становится Модула-2.  Это происходит
независимо от того, кто выбрал рабочий язык---вы или GDB.


<P>
Если вы разрешаете GDB выбирать язык автоматически, то при анализе
кода, скомпилированного из файла, чье имя оканчивается на <TT>`.mod'</TT>,
GDB установит рабочим языком Модулу-2.  See section <A HREF="gdb_10.html#SEC66">Распознавание GDB исходного языка</A>, для
дополнительной информации.




<H4><A NAME="SEC85" HREF="gdb_toc.html#TOC85">Отклонения от стандарта Модулы-2</A></H4>
<P>
<A NAME="IDX443"></A>


<P>
Для упрощения отладки программ на Модуле-2 было сделано несколько
изменений.  В основном, это сделано путем ослабления строгости контроля типов:



<UL>
<LI>

В отличие от стандарта Модулы-2, константы-указатели могут быть
сформированы целыми числами.  Это позволяет вам изменять
переменные-указатели в процессе отладки.  (В стандарте Модулы-2,
реальный адрес, содержащийся в переменной-указателе, скрыт от
вас; его можно изменить лишь прямым присваиванием значения другой
переменной-указателя или выражения, возвращающего указатель.)

<LI>

Экранирующие последовательности Си могут использоваться в строках и
символах, чтобы представить непечатаемые символы.  GDB выводит
строки со встроенными экранирующими последовательностями.  Одиночные
непечатаемые символы выводятся с помощью формата <SAMP>`CHR(<VAR>nnn</VAR>)'</SAMP>.

<LI>

Оператор присваивания (<CODE>:=</CODE>) возвращает значение своего правого аргумента.

<LI>

Все встроенные процедуры как изменяют, так <EM>и</EM> возвращают свой аргумент.
</UL>



<H4><A NAME="SEC86" HREF="gdb_toc.html#TOC86">Проверки диапазона и принадлежности типу Модулы-2</A></H4>
<P>
<A NAME="IDX444"></A>



<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> в этом выпуске, GDB еще не выполняет проверки
диапазона и принадлежности типу.
</BLOCKQUOTE>

<P>
GDB считает две переменные Модулы-2 эквивалентными по типу,
если:



<UL>
<LI>

Их типы были объявлены эквивалентными посредством оператора <CODE>TYPE
<VAR>t1</VAR> = <VAR>t2</VAR></CODE>

<LI>

Они были объявлены на одной и той же строке.  (Примечание:  Это верно
для компилятора GNU Модула-2, но это может не выполнятся для других
компиляторов.)
</UL>

<P>
Пока проверка соответствия типов включена, любая попытка
скомбинировать переменные не эквивалентных типов является ошибкой.


<P>
Проверка диапазона выполняется во всех математических операциях,
присваиваниях, при индексации массивов и во всех встроенных функциях
и процедурах.




<H4><A NAME="SEC87" HREF="gdb_toc.html#TOC87">Операторы определения области видимости <CODE>::</CODE> и <CODE>.</CODE></A></H4>
<P>
<A NAME="IDX445"></A>
<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
<A NAME="IDX448"></A>


<P>
Существует несколько тонких различий между операторами области видимости
Модулы-2 (<CODE>.</CODE>) и GDB (<CODE>::</CODE>).  Оба имеют похожий синтаксис:



<PRE>

<VAR>модуль</VAR> . <VAR>идент</VAR>
<VAR>область</VAR> :: <VAR>идент</VAR>
</PRE>

<P>
где <VAR>область</VAR>---имя модуля или процедуры, <VAR>модуль</VAR>---имя модуля,
а <VAR>идент</VAR>---любой идентификатор, описанный в пределах вашей программы,
за исключением другого модуля.


<P>
Использование оператора <CODE>::</CODE> заставляет GDB искать
идентификатор <VAR>идент</VAR> в <VAR>области</VAR>.  Если он в ней
не найден, GDB ищет его во всех областях,
содержащих <VAR>область</VAR>.


<P>
Использование оператора <CODE>.</CODE> заставляет GDB искать
идентификатор <VAR>идент</VAR>, который был импортирован из модуля определения
<VAR>модуль</VAR>, в текущей области видимости.  В этом операторе cчитается
ошибкой, если идентификатор <VAR>идент</VAR> не был
импортирован из модуля определения <VAR>модуль</VAR>, или если <VAR>идент</VAR> не
является в нем идентификатором.




<H4><A NAME="SEC88" HREF="gdb_toc.html#TOC88">GDB и Модула-2</A></H4>

<P>
Некоторые команды GDB имеют мало смысла при отладке программ на
Модуле-2.  Пять подкоманд из команд <CODE>set print</CODE> и <CODE>show
print</CODE> применимы исключительно к Си и Си++: <SAMP>`vtbl'</SAMP>, <SAMP>`demangle'</SAMP>,
<SAMP>`asm-demangle'</SAMP>, <SAMP>`object'</SAMP> и <SAMP>`union'</SAMP>.  Первые четыре
применимы к Си++, а последняя к типу Си <CODE>union</CODE>, который не имеет
прямого аналога в Модуле-2.


<P>
Оператор <CODE>@</CODE> (see section <A HREF="gdb_9.html#SEC51">Выражения</A>) хоть и доступен при
использовании любого языка, бесполезен при работе с Модулой-2.  Его цель
состоит в том, чтобы помочь при отладке <EM>динамических массивов</EM>, которые
не могут быть созданы в Модуле-2 в отличие от Си или Си++.  Однако,
конструкция <SAMP>`{<VAR>тип</VAR>}<VAR>адр-выр</VAR>'</SAMP> все же полезна, так как
адрес может быть определен целочисленной константой.


<P>
<A NAME="IDX449"></A>
В сценариях GDB, оператор неравенства Модулы-2 <CODE>#</CODE>
интерпретируется как начало комментария.  Используйте вместо него <CODE>&#60;&#62;</CODE>.




<H3><A NAME="SEC89" HREF="gdb_toc.html#TOC89">Chill</A></H3>

<P>
Расширения, сделанные в GDB для поддержки Chill, работают
только с программами, созданными компилятором GNU Chill.
Другие компиляторы Chill в настоящее время не поддерживаются, и попытка
отладить программы, полученные с их помощью, скорее всего приведет к
ошибке в тот момент, когда GDB будет считывать таблицу символов
выполняемого файла.


<P>
Этот раздел охватывает темы, связанные с Chill, и возможности
GDB для их поддержки.




<H4><A NAME="SEC90" HREF="gdb_toc.html#TOC90">Как отображаются режимы</A></H4>

<P>
Поддержка GDB типов данных (режимов) Chill непосредственно
связана с возможностями компилятора GNU Chill, и, следовательно,
слегка отличается от стандартной спецификации языка.  Вот
предоставляемые режимы:


<DL COMPACT>

<DT><CODE><EM>Дискретные режимы:</EM></CODE>
<DD>

<UL>
<LI>

<EM>Целочисленные режимы</EM>, которые предопределены как <CODE>BYTE,
UBYTE, INT, UINT, LONG, ULONG</CODE>,
<LI>

<EM>Булевский режим</EM>, который предопределен как <CODE>BOOL</CODE>,
<LI>

<EM>Символьный режим</EM>, который предопределен как <CODE>CHAR</CODE>,
<LI>

<EM>Режим-множество</EM>, который отображается ключевым словом
<CODE>SET</CODE>.

<PRE>
(gdb) ptype x
type = SET (karli = 10, susi = 20, fritzi = 100)
</PRE>

Если тип является ненумерованным множеством, значения элементов
множества опускаются.
<LI>

<EM>Режим-диапазон</EM>, который отображается как

<PRE>
<CODE>тип = &#60;базовый-режим&#62;(&#60;нижняя граница&#62; : &#60;верхняя граница&#62;)</CODE>
</PRE>

где <CODE>&#60;нижняя граница&#62;, &#60;верхняя граница&#62;</CODE> может быть любым
дискретным буквенным выражением (например, имена элементов множества).
</UL>

<DT><CODE><EM>Режим powerset:</EM></CODE>
<DD>
Режим Powerset отображается ключевым словом <CODE>POWERSET</CODE>, за
которым следует режим элемента.

<PRE>
(gdb) ptype x
type = POWERSET SET (egon, hugo, otto)
</PRE>

<DT><CODE><EM>Режимы-ссылки:</EM></CODE>
<DD>

<UL>
<LI>

<EM>Режим привязанной ссылки</EM>, который отображается ключевым словом
<CODE>REF</CODE>, за которым следует название режима, к которому ссылка
привязана.
<LI>

<EM>Режим свободной ссылки</EM>, который отображается ключевым словом
<CODE>PTR</CODE>.
</UL>

<DT><CODE><EM>Процедурный режим</EM></CODE>
<DD>
Процедурный режим отображается в виде <CODE>тип = PROC(&#60;список параметров&#62;)
&#60;возвращаемый режим&#62; EXCEPTIONS (&#60;список исключений&#62;)</CODE>.  <CODE>&#60;список
параметров&#62;</CODE> представляет собой список режимов параметров.
<CODE>&#60;возвращаемый режим&#62;</CODE> указывает режим результата процедуры, если
она возвращает результат.  <CODE>&#60;список исключений&#62;</CODE> перечисляет все
возможные исключения, которые могут быть возбуждены процедурой.

<DT><CODE><EM>Синхронизационные режимы:</EM></CODE>
<DD>

<UL>
<LI>

<EM>Режим события</EM>, который отображается как

<PRE>
<CODE>EVENT (&#60;длина события&#62;)</CODE>
</PRE>

где <CODE>&#60;длина события&#62;</CODE> является необязательной.
<LI>

<EM>Буферный режим</EM>, который отображается как

<PRE>
<CODE>BUFFER (&#60;длина буфера&#62;)&#60;режим елементов буфера&#62;</CODE>
</PRE>

где <CODE>(&#60;длина буфера&#62;)</CODE> является необязательной.
</UL>

<DT><CODE><EM>Режимы времени:</EM></CODE>
<DD>

<UL>
<LI>

<EM>Режим длительности</EM>, который предопределен как <CODE>DURATION</CODE>
<LI>

<EM>Режим абсолютного времени</EM>, который предопределен как <CODE>TIME</CODE>
</UL>

<DT><CODE><EM>Вещественные режимы:</EM></CODE>
<DD>
Вещественные режимы предопределены как <CODE>REAL</CODE> и <CODE>LONG_REAL</CODE>.

<DT><CODE><EM>Строковые режимы:</EM></CODE>
<DD>

<UL>
<LI>

<EM>Режим строки символов</EM>, который отображается как

<PRE>
<CODE>CHARS(&#60;длина строки&#62;)</CODE>
</PRE>

за которым следует ключевое слово <CODE>VARYING</CODE>, если строковый режим
является изменяющимся режимом
<LI>

<EM>Режим строки битов</EM>, который отображается как

<PRE>
<CODE>BOOLS(&#60;длина строки&#62;)</CODE>
</PRE>

</UL>

<DT><CODE><EM>Режим массива:</EM></CODE>
<DD>
Режим массива отображается ключевым словом <CODE>ARRAY(&#60;диапазон&#62;)</CODE>,
за которым следует режим элементов (который, в свою очередь, может быть
режимом массива).

<PRE>
(gdb) ptype x
type = ARRAY (1:42)
          ARRAY (1:20)
             SET (karli = 10, susi = 20, fritzi = 100)
</PRE>

<DT><CODE><EM>Структурный режим</EM></CODE>
<DD>
Структурный режим отображается ключевым словом <CODE>STRUCT(&#60;список
полей&#62;)</CODE>.  <CODE>&#60;список полей&#62;</CODE> состоит из имен и режимов полей
структуры.  Структуры с вариантами имеют ключевое слово <CODE>CASE
&#60;поле&#62; OF &#60;варианты поля&#62; ESAC</CODE> в их списке полей.  Так как текущая
версия компилятора GNU Chill не реализует обработку тегов (нет
проверок времени выполнения вариантных полей, и, следовательно, нет
отладочной информации), вывод всегда содержит все вариантные поля.

<PRE>
(gdb) ptype str
type = STRUCT (
    as x,
    bs x,
    CASE bs OF
    (karli):
        cs a
    (ott):
        ds x
    ESAC
)
</PRE>

</DL>



<H4><A NAME="SEC91" HREF="gdb_toc.html#TOC91">Местоположения и доступ к ним</A></H4>

<P>
Местоположением в Chill является объект, который может содержать
значения.


<P>
Доступ к значению местоположения обычно производится посредством
(описанного) имени местоположения.  Вывод удовлетворяет спецификации
значений в программах на Chill.  То, как значения задаются, является темой
следующего раздела, смотрите section <A HREF="gdb_10.html#SEC92">Значения и операции с ними</A>.


<P>
Псевдо-местоположение <CODE>RESULT</CODE> (или <CODE>result</CODE>) может
использоваться для отображения или изменения результата процедуры,
активной в настоящий момент:



<PRE>
set result := EXPR
</PRE>

<P>
Это делает то же самое, что и действие Chill <CODE>RESULT EXPR</CODE> (которое
в GDB недоступно).


<P>
Значения местоположений режима ссылок выводятся, в случае режима
свободной ссылки, посредством
<CODE>PTR(&#60;шестнадцатеричное значение&#62;)</CODE>, и с помощью <CODE>(REF &#60;режим ссылки&#62;) (&#60;шестнадцатеричное
значение&#62;)</CODE> в случае привязанной ссылки.  <CODE>&#60;шестнадцатеричное
значение&#62;</CODE> представляет адрес, на который указывает ссылка.  Для доступа
к значению местоположения, указываемого ссылкой, используйте оператор
разыменовывания <SAMP>`-&#62;'</SAMP>.


<P>
Значения местоположений процедурного режима отображаются как

<PRE>
<CODE>{ PROC
(&#60;режимы аргументов&#62; ) &#60;возвращаемый режим&#62; } &#60;адрес&#62; &#60;имя
местоположения процедуры&#62;</CODE>
</PRE>

<P>
<CODE>&#60;режимы аргументов&#62;</CODE>---это список
режимов, в соответствии со спецификацией параметров процедуры, а
<CODE>&#60;адрес&#62;</CODE> указывает адрес точки входа.


<P>
Подструктуры значений строковых режимов, режимов массивов или структур
(например, срезы массивов, поля  структурных местоположений) доступны при
использовании определенных операторов, которые описаны в следующем
разделе, смотрите section <A HREF="gdb_10.html#SEC92">Значения и операции с ними</A>.


<P>
Значение местоположения может быть интерпретировано как имеющее другой
режим посредством преобразования местоположений.  Это преобразование
режимов записывается как <CODE>&#60;имя режима&#62;(&#60;местоположение&#62;)</CODE>.
Пользователь должен учесть, что размеры режимов должны быть равными, в
противном случае возникает ошибка.  Более того, не производится никаких
проверок диапазона местоположения по сравнению с режимом назначения, и,
следовательно, результат может быть достаточно обескураживающим.



<PRE>
(gdb) print int (s(3 up 4)) XXX TO be filled in !! XXX
</PRE>



<H4><A NAME="SEC92" HREF="gdb_toc.html#TOC92">Значения и операции с ними</A></H4>

<P>
Значения используются для изменения местоположений, для более подробного
изучения сложных структур и для отфильтровывания значимой информации из
большого объема данных.  Определено несколько операций
(зависящих от режима), которые позволяют проводить подобные изучения.
Эти операции применимы не только к значениям-константам, но также и к
местоположениям, что может оказаться достаточно полезным при отладке
сложных структур.  Во время разбора командной строки (например, вычисляя
выражение), GDB рассматривает имена местоположений как значения
этих местоположений.


<P>
Этот раздел описывает, как должны задаваться значения и какие операции
допустимо использовать с этими значениями.


<DL COMPACT>

<DT><CODE>Буквенные значения</CODE>
<DD>
Буквенные значения определяются также, как в программах
GNU Chill.  Для подробной спецификации, смотрите главу 1.5
Руководства по реализации GNU Chill.

<DT><CODE>Значения-наборы</CODE>
<DD>
Набор может быть задан как <CODE>&#60;имя режима&#62;[&#60;набор&#62;]</CODE>, где <CODE>&#60;имя
режима&#62;</CODE> может быть опущено, если режим набора определяется однозначно.
Эта однозначность определяется из контекста вычисляемого выражения.
<CODE>&#60;набор&#62;</CODE> может быть одним из:


<UL>
<LI><EM>Набор powerset</EM>

<LI><EM>Набор массивов</EM>

<LI><EM>Набор структур</EM>

</UL>

Наборы-powerset, наборы массивов и наборы структур определяются также,
как в программах на Chill.

<DT><CODE>Значение элемента строки</CODE>
<DD>
Значение элемента строки задается как

<PRE>
<CODE>&#60;строковое значение&#62;(&#60;индекс&#62;)</CODE>
</PRE>

где <CODE>&#60;индекс&#62;</CODE> является целочисленным
выражением.  Это дает символьное значение, которое экивалентно символу,
указываемому в строке индексом <CODE>&#60;индекс&#62;</CODE>.

<DT><CODE>Значение среза строки</CODE>
<DD>
Значение среза строки задается как <CODE>&#60;значение строки&#62;(&#60;спецификация
среза&#62;)</CODE>, где <CODE>&#60;спецификация среза&#62;</CODE> может быть либо диапазоном
целых выражений, либо задаваться в виде <CODE>&#60;начальное выражение&#62; up
&#60;размер&#62;</CODE>.  <CODE>&#60;размер&#62;</CODE> обозначает число элементов, которое содержит
срез.  Полученная величина является строкой, которая является частью
указанной строки.

<DT><CODE>Значения элементов массива</CODE>
<DD>
Значение элемента массива указывается как <CODE>&#60;величина
массива&#62;(&#60;выр&#62;)</CODE> и дает величину элемента массива с режимом как у
указанного массива.

<DT><CODE>Значение среза массива</CODE>
<DD>
Срез массива задается как <CODE>&#60;значение массива&#62;(&#60;спецификация
среза&#62;)</CODE>, где <CODE>&#60;спецификация среза&#62;</CODE> может быть диапазоном,
определенным либо выражениями, либо как <CODE>&#60;начальное выр&#62; up
&#60;размер&#62;</CODE>.  <CODE>&#60;размер&#62;</CODE> обозначает число элементов массива, которое
содержит срез.  Получаемое значение есть массив, который является
частью указанного.

<DT><CODE>Значение поля структуры</CODE>
<DD>
Значение поля структуры получается как <CODE>&#60;значение структуры&#62;.&#60;имя
поля&#62;</CODE>, где <CODE>&#60;имя поля&#62;</CODE> указывает имя поля, заданное в определении
режима структуры.  Режим полученного значения соответствует этому
определению режима в определении структуры.

<DT><CODE>Значения вызова процедуры</CODE>
<DD>
Значение вызова процедуры получается из значения, возвращенного
процедурой<A NAME="DOCF13" HREF="gdb_foot.html#FOOT13">(13)</A>.

Значения местоположений режима длительности представляются буквами
<CODE>ULONG</CODE>.

Значения местоположений режима-времени выводятся как

<PRE>
<CODE>TIME(&#60;сек&#62;:&#60;нсек&#62;)</CODE>.
</PRE>

<DT><CODE>Значение безаргументного оператора</CODE>
<DD>
Значение безаргументного оператора получается из значения экземпляра для
текущего активного процесса.

<DT><CODE>Значения выражений</CODE>
<DD>
Значение, доставляемое выражением, является результатом вычисления
указанного выражения.  В случае ошибки (несовместимость режимов, и так
далее), вычисление выражения прерывается с соответствующим сообщением об
ошибке.  Выражение может быть заключено в скобки, что приводит к
вычислению этого выражения до любого другого, использующего результат
выражения в скобках.  GDB поддерживаются следующие операторы:

<DL COMPACT>

<DT><CODE><CODE>OR, ORIF, XOR</CODE></CODE>
<DD>
<DT><CODE><CODE>AND, ANDIF</CODE></CODE>
<DD>
<DT><CODE><CODE>NOT</CODE></CODE>
<DD>
Логические операторы, определенные на операндах булевого режима.

<DT><CODE><CODE>=, /=</CODE></CODE>
<DD>
Операторы равенства и неравенства, определенные на всех режимах.

<DT><CODE><CODE>&#62;, &#62;=</CODE></CODE>
<DD>
<DT><CODE><CODE>&#60;, &#60;=</CODE></CODE>
<DD>
Операторы отношения, заданные на предопределенных режимах.

<DT><CODE><CODE>+, -</CODE></CODE>
<DD>
<DT><CODE><CODE>*, /, MOD, REM</CODE></CODE>
<DD>
Арифметические операторы, заданные на предопределенных режимах.

<DT><CODE><CODE>-</CODE></CODE>
<DD>
Оператор изменения знака.

<DT><CODE><CODE>//</CODE></CODE>
<DD>
Оператор соединения строк.

<DT><CODE><CODE>()</CODE></CODE>
<DD>
Оператор повторения строки.

<DT><CODE><CODE>-&#62;</CODE></CODE>
<DD>
Оператор ссылки местоположения, который может быть использован
либо для получения адреса местоположения (<CODE>-&#62;loc</CODE>), или для
разыменовывания ссылки местоположения (<CODE>loc-&#62;</CODE>).

<DT><CODE><CODE>OR, XOR</CODE></CODE>
<DD>
<DT><CODE><CODE>AND</CODE></CODE>
<DD>
<DT><CODE><CODE>NOT</CODE></CODE>
<DD>
Операторы режимов powerset и строки битов.

<DT><CODE><CODE>&#62;, &#62;=</CODE></CODE>
<DD>
<DT><CODE><CODE>&#60;, &#60;=</CODE></CODE>
<DD>
Операторы включения режима powerset.

<DT><CODE><CODE>IN</CODE></CODE>
<DD>
Оператор принадлежности.
</DL>
</DL>



<H4><A NAME="SEC93" HREF="gdb_toc.html#TOC93">Проверка диапазона и типов в Chill</A></H4>

<P>
GDB считает два режима переменных Chill эквивалентными, если их
размеры равны.  Это правило применяется рекурсивно для
более сложных типов данных.  Это означает, что сложные режимы
считаются эквивалентными, если режимы всех элементов (которые тоже могут
быть сложными, например, массивами, структурами, и так далее) имеют
одинаковый размер.


<P>
Проверка диапазона производится для всех математических операций,
присваиваний, границ индексов массива и всех встроенных процедур.


<P>
Строгие проверки типов включаются с помощью команды GDB
<CODE>set check strong</CODE>.  Это навязывает строгую проверку диапазона и
принадлежности типу для всех действий, где используются конструкции
Chill (выражения, встроенные функции, и так далее), в соответствии с
семантикой, определенной в спецификации языка z.200.


<P>
Все проверки могут быть отключены командой GDB <CODE>set check
off</CODE>.




<H4><A NAME="SEC94" HREF="gdb_toc.html#TOC94">Установки по умолчанию Chill</A></H4>

<P>
Если проверки типа и диапазона установлены GDB автоматически,
обе они по умолчанию включены, когда рабочий язык переключается на
Chill.  Это происходит независимо от того, вы выбрали рабочий язык или
GDB.


<P>
Если вы разрешите GDB устанавливать рабочий язык автоматически,
то при попадании в код, скомпилированный из файла, чье имя заканчивается
на <TT>`.ch'</TT>, он переключает рабочий язык на Chill.  See section <A HREF="gdb_10.html#SEC66">Распознавание GDB исходного языка</A>, для
дополнительной информации.


<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_9.html">previous</A>, <A HREF="gdb_11.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
