<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Остановка и продолжение исполнения</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_5.html">previous</A>, <A HREF="gdb_7.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC26" HREF="gdb_toc.html#TOC26">Остановка и продолжение исполнения</A></H1>

<P>
Основные цели применения отладчика---остановка вашей программы до ее
завершения, или чтобы в случае нарушений в работе вашей программы вы могли
выяснить их причину.


<P>
Внутри GDB ваша программа может остановиться по нескольким
причинам, таким как сигнал, точка останова, или достижение новой строки
после команды GDB, такой как <CODE>step</CODE>.  Затем вы можете
исследовать и изменять значения переменных, устанавливать новые точки
останова и удалять старые, и затем продолжить выполнение.  Обычно,
выводимые GDB сообщения предоставляют достаточную информацию о
состоянии вашей программы, но вы также можете запросить эту информацию
явно в любое время.


<DL COMPACT>

<DT><CODE>info program</CODE>
<DD>
<A NAME="IDX129"></A>
 
Отобразить информацию о состоянии вашей программы: выполняется она или
нет, каким процессом она является и почему остановлена.
</DL>



<H2><A NAME="SEC27" HREF="gdb_toc.html#TOC27">Точки останова, точки наблюдения и точки перехвата</A></H2>

<P>
<A NAME="IDX130"></A>
<EM>Точка останова</EM> останавливает вашу программу всякий раз, когда ее
выполнение достигает определенной точки.  Для каждой точки останова вы
можете добавлять условия для лучшего управления условиями остановки.
Вы можете устанавливать точки останова командой
<CODE>break</CODE> и ее вариантами (see section <A HREF="gdb_6.html#SEC28">Установка точек останова</A>), чтобы задать место, где должна остановиться
ваша программа, по номеру строки, имени функции или точному адресу.


<P>
В конфигурациях HP-UX, SunOS 4.x, SVR4 и Alpha OSF/1, вы можете устанавливать
точки останова в разделяемых библиотеках до запуска выполняемого файла.
В системах HP-UX существует небольшое ограничение: вы должны подождать,
пока программа не перестанет выполняться, для установки точек
останова в подпрограммах из разделяемой библиотеки, которые не
вызываются напрямую из программы (например, подпрограммах, являющихся
аргументами вызова <CODE>pthread_create</CODE>).


<P>
<A NAME="IDX131"></A>
<A NAME="IDX132"></A>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<EM>Точка наблюдения</EM>---это специальная точка останова, которая
останавливает вашу программу при изменении значения выражения.  Вы
должны использовать другую команду для установки точки наблюдения
(see section <A HREF="gdb_6.html#SEC29">Установка точек наблюдения</A>), но
помимо этого, вы можете обращаться с ней так же, как с любой
другой точкой останова: вы включаете, отключаете и удаляете точки
останова и точки наблюдения при помощи одних и тех же команд.


<P>
Вы можете установить, что значения из вашей программы должны
отображаться автоматически, когда GDB останавливается в точке
останова.  See section <A HREF="gdb_9.html#SEC56">Автоматическое отображение</A>.


<P>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<EM>Точка перехвата</EM>---это другая специализированная точка останова,
которая останавливает вашу программу при возникновении события
определенного типа, такого как выбрасывание исключения в Си++ или
загрузка библиотеки.  Также как с точками наблюдения, вы используете
другую команду для установки точки перехвата, (see section <A HREF="gdb_6.html#SEC30">Установка точек перехвата</A>), но помимо этого, вы можете
обращаться с ней так же, как с любой другой точкой останова.  (Для
остановки, когда ваша программа получает сигнал, используйте команду
<CODE>handle</CODE>; смотрите section <A HREF="gdb_6.html#SEC38">Сигналы</A>.)


<P>
<A NAME="IDX137"></A>
<A NAME="IDX138"></A>
Когда вы создаете точку останова, наблюдения или перехвата, GDB
присваивает ей номер; эти номера являются последовательными
целыми числами, начинающимися с единицы.  Во многих командах для
управления различными возможностями точек останова, вы используете эти
номера для указания, какую точку останова вы хотите изменить.  Каждая
точка останова может быть <EM>включена</EM> или <EM>отключена</EM>; если точка
останова отключена, она не оказывает никакого влияния на вашу программу,
пока вы снова не включите ее.


<P>
<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
Некоторые команды GDB допускают в качестве указания точек
останова, на которые они действуют, их диапазоны.  Диапазон точек
останова---это или номер одной точки, например <SAMP>`5'</SAMP>, или два таких
номера, в порядке увеличения, разделенные дефисом, например <SAMP>`5-7'</SAMP>.
Когда команде задается диапазон точек останова, она действует на все
точки останова в этом диапазоне.




<H3><A NAME="SEC28" HREF="gdb_toc.html#TOC28">Установка точек останова</A></H3>

<P>
<A NAME="IDX141"></A>
<A NAME="IDX142"></A>
<A NAME="IDX143"></A>
<A NAME="IDX144"></A>
Точки останова устанавливаются командой <CODE>break</CODE> (сокращенно
<CODE>b</CODE>).  Вспомогательная переменная отладчика <SAMP>`$bpnum'</SAMP> хранит
номер последней установленной вами точки останова; смотрите
section <A HREF="gdb_9.html#SEC59">Вспомогательные переменные</A>, для
обсуждения того, что вы можете делать со вспомогательными переменными.


<P>
Вы можете задавать место для установки новой точки останова несколькими
способами.


<DL COMPACT>

<DT><CODE>break <VAR>функция</VAR></CODE>
<DD>
Установить точку останова на входе в функцию <VAR>функция</VAR>.
При использовании языков, допускающих перегрузку символов, таких как
Си++, <VAR>функция</VAR> может ссылаться более чем на одно возможное место
останова.  See section <A HREF="gdb_6.html#SEC35">Меню точки останова</A>, для
обсуждения такой ситуации.

<DT><CODE>break +<VAR>смещение</VAR></CODE>
<DD>
<DT><CODE>break -<VAR>смещение</VAR></CODE>
<DD>
Установить точку останова через несколько строк впереди или сзади от
позиции, на которой выполнение остановилось в текущем выбранном
<EM>кадре стека</EM>.  (See section <A HREF="gdb_7.html#SEC41">Кадры стека</A>, для описания кадров стека.)

<DT><CODE>break <VAR>номер-строки</VAR></CODE>
<DD>
Установить точку останова на строке <VAR>номер-строки</VAR> в текущем
исходном файле.  Текущий исходный файл---это файл, исходный текст
которого отображался последним.  Точка останова остановит вашу программу
сразу перед выполнением какого-либо кода на этой строке.

<DT><CODE>break <VAR>имя-файла</VAR>:<VAR>номер-строки</VAR></CODE>
<DD>
Установить точку останова на строке <VAR>номер-строки</VAR> в исходном
файле <VAR>имя-файла</VAR>.

<DT><CODE>break <VAR>имя-файла</VAR>:<VAR>функция</VAR></CODE>
<DD>
Установить точку останова на входе в <VAR>функцию</VAR>,
находящуюся в файле <VAR>имя-файла</VAR>.  Указание имени файла вместе с
именем функции является излишним, за исключением ситуаций, когда
несколько файлов содержат одинаково названные функции.

<DT><CODE>break *<VAR>адрес</VAR></CODE>
<DD>
Установить точку останова по адресу <VAR>адрес</VAR>.  Вы можете
использовать это для установки точек останова в тех частях вашей
программы, которые не имеют отладочной информации или исходных файлов.

<DT><CODE>break</CODE>
<DD>
При вызове без аргументов, <CODE>break</CODE> устанавливает точку останова на
инструкции, которая должна быть выполнена следующей в выбранном кадре
стека (see section <A HREF="gdb_7.html#SEC40">Исследование стека</A>).  В любом выбранном кадре,
кроме самого внутреннего, это останавливает вашу программу, как только
управление возвращается в этот кадр.  Это похоже на результат команды
<CODE>finish</CODE> в кадре внутри выбранного кадра---за исключением того, что
<CODE>finish</CODE> не оставляет активной точки останова.  Если вы используете
<CODE>break</CODE> без аргументов в самом внутреннем кадре, GDB
останавливается, когда в следующий раз достигает текущего места; это
может быть полезно внутри циклов.

Обычно GDB игнорирует точки останова, когда он возобновляет
выполнение, пока не будет выполнена хотя бы одна
инструкция.  Если бы он этого не делал, вы не могли бы продолжать
выполнение после точки останова, не отключив сперва эту точку останова.
Это правило применяется вне зависимости от того, существовала или нет
точка останова, когда ваша программа остановилась.

<DT><CODE>break ... if <VAR>усл</VAR></CODE>
<DD>
Установить точку останова с условием <VAR>усл</VAR>; каждый раз, когда
достигается точка останова, происходит вычисление выражения <VAR>усл</VAR>, и
остановка происходит только если эта величина не равна нулю---то есть, если
<VAR>усл</VAR> истинно.  <SAMP>`...'</SAMP> означает один из возможных
аргументов, перечисленных выше (или отсутствие аргументов), описывающих
место остановки.  See section <A HREF="gdb_6.html#SEC33">Условия останова</A>, для большей
информации об условных точках останова.

<A NAME="IDX145"></A>
<DT><CODE>tbreak <VAR>арг</VAR></CODE>
<DD>
Установить точку останова только до первой активизации.  Аргументы
<VAR>арг</VAR> такие же, как для команды <CODE>break</CODE>, и точка останова
устанавливается аналогичным образом, но она автоматически уничтожается
после того, как ваша программа первый раз на ней остановится.
See section <A HREF="gdb_6.html#SEC32">Отключение точек останова</A>.

<A NAME="IDX146"></A>
<DT><CODE>hbreak <VAR>арг</VAR></CODE>
<DD>
Установить аппаратно-поддерживаемую точку останова.
Аргументы <VAR>арг</VAR> такие же, как и для команды <CODE>break</CODE>, и точка
останова устанавливается аналогичным образом, но она требует аппаратной
поддержки и некоторые целевые платформы могут ее не иметь.  Основной
целью этого является отладка кода EPROM/ROM, так что вы можете установить точку
останова на инструкции без изменения инструкции.  Это может быть
использовано с новой генерацией ловушек, предоставляемой SPARClite DSU и
некоторыми машинами на базе x86.  Эти платформы будут генерировать
ловушки, когда программа обращается к некоторым данным или адресу
инструкции, которые назначены регистрам отладки.  Однако, регистры
аппаратных точек останова могут хранить ограниченное число точек
останова.  Например, на DSU, только две точки останова могут быть
установлены одновременно, и GDB будет отвергать эту команду,
если используется больше.  Удалите или отключите неиспользуемые
аппаратные точки останова перед установкой новых (see section <A HREF="gdb_6.html#SEC32">Отключение точек останова</A>).  See section <A HREF="gdb_6.html#SEC33">Условия останова</A>.

<A NAME="IDX147"></A>
<DT><CODE>thbreak <VAR>арг</VAR></CODE>
<DD>
Установить аппаратно-поддерживаемую точку останова,
включенную только до первой активизации.  Аргументы <VAR>арг</VAR> такие же,
как и для команды <CODE>hbreak</CODE>, и точка останова устанавливается
аналогичным образом.  Однако, как в случае команды <CODE>tbreak</CODE>, точка
останова автоматически уничтожается после того, как программа первый раз
на ней остановится.  Также, как и в случае команды <CODE>hbreak</CODE>,
точка останова требует аппаратной поддержки и некоторые аппаратные
платформы могут ее не иметь.  See section <A HREF="gdb_6.html#SEC32">Отключение точек останова</A>.  Смотрите также section <A HREF="gdb_6.html#SEC33">Условия останова</A>.

<A NAME="IDX148"></A>
<A NAME="IDX149"></A>
<DT><CODE>rbreak <VAR>рег-выр</VAR></CODE>
<DD>
Установить точки останова на всех функциях, удовлетворяющих
регулярному выражению <VAR>рег-выр</VAR>.  Эта команда устанавливает
безусловные точки останова при всех совпадениях, выводя список всех
установленных точек останова.  После установки,
они рассматриваются точно так же, как точки останова,
установленные командой <CODE>break</CODE>.  Вы можете удалять их, отключать,
или делать их условными таким же способом, как любые другие точки
останова.

Регулярные выражения имеют стандартный синтаксис, используемый такими
средствами, как <TT>`grep'</TT>.  Заметьте, что это отличается от
синтаксиса, используемого оболочками; так, например, <CODE>foo*</CODE>
подходит для всех функций, которые включают <CODE>fo</CODE>, за которым
следует любое число букв <CODE>o</CODE>.  Существует неявное <CODE>.*</CODE> в
начале и в конце введенного вами регулярного выражения, так что для
нахождения только тех функций, которые начинаются на <CODE>foo</CODE>,
используйте <CODE>^foo</CODE>.

При отладке программ, написанных на Си++, <CODE>rbreak</CODE> полезна для
установки точек останова на перегруженных функциях, не являющихся
членами никакого специального класса.

<A NAME="IDX150"></A>
<A NAME="IDX151"></A>
<DT><CODE>info breakpoints [<VAR>n</VAR>]</CODE>
<DD>
<DT><CODE>info break [<VAR>n</VAR>]</CODE>
<DD>
<DT><CODE>info watchpoints [<VAR>n</VAR>]</CODE>
<DD>
Вывести таблицу всех установленных и не удаленных точек останова,
наблюдения и перехвата, со следующими колонками для каждой точки:

<DL COMPACT>

<DT><EM>Номер точки останова</EM>
<DD>
<DT><EM>Тип</EM>
<DD>
Точка останова, наблюдения или перехвата.
<DT><EM>План</EM>
<DD>
Помечена ли точка останова для отключения или удаления после активации.
<DT><EM>Включена или отключена</EM>
<DD>
Включенные точки останова помечаются как <SAMP>`y'</SAMP>.  <SAMP>`n'</SAMP> отмечает
отключенные точки.
<DT><EM>Адрес</EM>
<DD>
Адрес памяти, где расположена точка останова в вашей программе.
<DT><EM>Где</EM>
<DD>
Файл и номер строки, где расположена точка останова в исходном файле.
</DL>

Если точка останова условная, <CODE>info break</CODE> показывает условие на
строке, следующей за этой точкой; команды точки останова, если они есть,
перечисляются после этого.

<CODE>info break</CODE> с номером точки останова <VAR>n</VAR> в качестве аргумента
отображает только эту точку.  Вспомогательная переменная <CODE>$_</CODE> и
адрес по умолчанию для исследования для команды <CODE>x</CODE> устанавливаются
равными адресу последней из перечисленных точек останова (see section <A HREF="gdb_9.html#SEC55">Исследование памяти</A>).

<CODE>info break</CODE> отображает то число раз, которое точка останова была
активирована.  Это особенно полезно при использовании вместе с командой
<CODE>ignore</CODE>.  Вы можете игнорировать большое число активаций точки
останова, посмотреть информацию о точке останова чтобы узнать, сколько
раз она активировалась, и затем запустить заново, игнорируя на единицу
меньше, чем это число.  Это быстро приведет вас к последней активации
этой точки останова.
</DL>

<P>
GDB позволяет вам установить любое число точек останова в
одном и том же месте вашей программы.  В этом нет ничего глупого или
бессмысленного.  Когда точки останова являются условными, это даже
полезно (see section <A HREF="gdb_6.html#SEC33">Условия останова</A>).


<P>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
GDB сам иногда устанавливает точки останова в вашей программе
для специальных целей, таких как правильная обработка <CODE>longjmp</CODE> (в
программах на Си).  Этим внутренним точкам останова присваиваются
отрицательные номера, начиная с <CODE>-1</CODE>; <SAMP>`info breakpoints'</SAMP> не
отображает их.


<P>
Вы можете увидеть эти точки останова с помощью служебной команды
GDB <SAMP>`maint info breakpoints'</SAMP>.


<DL COMPACT>

<DT><CODE>maint info breakpoints</CODE>
<DD>
<A NAME="IDX154"></A>
 
Используя тот же формат, что и <SAMP>`info breakpoints'</SAMP>, отобразить как
точки останова, установленные вами явно, так и те, которые
GDB использует для внутренних целей.  Внутренние точки останова
показываются с отрицательными номерами.  Колонка типа определяет, какого
типа точка останова показана:

<DL COMPACT>

<DT><CODE>breakpoint</CODE>
<DD>
Обычная, явно установленная точка останова.

<DT><CODE>watchpoint</CODE>
<DD>
Обычная, явно установленная точка наблюдения.

<DT><CODE>longjmp</CODE>
<DD>
Внутренняя точка останова, используемая для корректной обработки
пошагового выполнения вызовов <CODE>longjmp</CODE>.

<DT><CODE>longjmp resume</CODE>
<DD>
Внутренняя точка останова на цели <CODE>longjmp</CODE>.

<DT><CODE>until</CODE>
<DD>
Временная внутренняя точка останова, используемая командой GDB
<CODE>until</CODE>.

<DT><CODE>finish</CODE>
<DD>
Временная внутренняя точка останова, используемая командой GDB
<CODE>finish</CODE>.

<DT><CODE>shlib events</CODE>
<DD>
События в разделяемых библиотеках.

</DL>

</DL>



<H3><A NAME="SEC29" HREF="gdb_toc.html#TOC29">Установка точек наблюдения</A></H3>

<P>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
Вы можете использовать точку наблюдения для остановки
выполнения, как только изменится значение какого-либо выражения, не
предсказывая конкретное место, где это может произойти.


<P>
В зависимости от вашей системы, точки наблюдения могут быть реализованы
программно или аппаратно.  GDB осуществляет программную реализацию
точек наблюдения путем пошагового выполнения вашей программы и проверки
значения переменной на каждом шаге, что в сотни раз медленнее
нормального выполнения.  (Но тем не менее это может стоить того, найти
ошибку в программе, когда вы не представляете, в какой ее части она
находится, может быть очень нелегко.)


<P>
В некоторых системах, таких как HP-UX, Linux и некоторых других
платформах, базирующихся на x86, GDB включает поддержку для
аппаратных точек наблюдения, которые не замедляют выполнение вашей
программы.


<DL COMPACT>

<DT><CODE>watch <VAR>выраж</VAR></CODE>
<DD>
<A NAME="IDX158"></A>
 
Устанавливает точку наблюдения за выражением.  GDB остановит
программу, когда <VAR>выраж</VAR> сохраняется программой и его величина
изменяется.

<A NAME="IDX159"></A>
<DT><CODE>rwatch <VAR>выраж</VAR></CODE>
<DD>
Устанавливает точку наблюдения, которая остановит программу, когда
наблюдаемое <VAR>выраж</VAR> считывается программой.

<A NAME="IDX160"></A>
<DT><CODE>awatch <VAR>выраж</VAR></CODE>
<DD>
Устанавливает точку наблюдения, которая остановит программу, когда
<VAR>выраж</VAR> либо считывается, либо сохраняется программой.

<A NAME="IDX161"></A>
<DT><CODE>info watchpoints</CODE>
<DD>
Эта команда печатает список точек наблюдения, останова и перехвата; это
то же самое, что и <CODE>info break</CODE>.
</DL>

<P>
Когда это возможно, GDB устанавливает <EM>аппаратную точку
наблюдения</EM>.  Аппаратные точки наблюдения выполняются очень быстро, и
отладчик сообщает об изменении величины точно в месте инструкции, где это
изменение произошло.  Если GDB не может установить аппаратную
точку наблюдения, он устанавливает программную точку наблюдения, которая
выполняется намного медленнее и сообщает об изменении величины на следующем
операторе, а не инструкции, после появления изменения.


<P>
Когда вы даете команду <CODE>watch</CODE>, GDB сообщает



<PRE>
Hardware watchpoint <VAR>номер</VAR>: <VAR>выраж</VAR>
</PRE>

<P>
если ему удалось установить аппаратную точку наблюдения.


<P>
В настоящее время, команды <CODE>awatch</CODE> и <CODE>rwatch</CODE> могут
устанавливать только аппаратные точки наблюдения, так как доступы к данным,
которые не изменяют величины наблюдаемого выражения, не могут быть
замечены без исследования каждой инструкции во время ее выполнения, а
GDB пока этого не делает.  Если GDB обнаруживает, что
не может установить аппаратную точку останова командами <CODE>awatch</CODE>
или <CODE>rwatch</CODE>, он напечатает сообщение, аналогичное этому:



<PRE>
Expression cannot be implemented with read/access
watchpoint.<A NAME="DOCF6" HREF="gdb_foot.html#FOOT6">(6)</A>
</PRE>

<P>
Иногда GDB не может установить аппаратную точку наблюдения из-за
того, что тип данных наблюдаемого выражения занимает больше места, чем
допускает аппаратная точка наблюдения на целевой платформе.  Например,
некоторые системы позволяют наблюдать за областями, занимающими до 4
байт; на таких системах вы не можете устанавливать аппаратные точки
наблюдения за выражениями, которые в результате дают число
с плавающей точкой двойной точности (которое обычно занимает 8 байт).  В
качестве одного из решений, можно разбить большую область на несколько
меньших областей, и затем наблюдать за каждой из них с помощью отдельной
точки наблюдения.


<P>
Если вы установите слишком много аппаратных точек наблюдения,
GDB может быть не в состоянии задействовать их все, когда вы
возобновите выполнение вашей программы.  Так как точное количество
активных точек наблюдения неизвестно до того момента, когда ваша
программа должна возобновить выполнение, GDB может быть не в
состоянии предупредить вас об этом, когда вы устанавливаете точку
наблюдения, и предупреждение будет напечатано только когда программа
возобновит выполнение:



<PRE>
Hardware watchpoint <VAR>номер</VAR>: Could not insert watchpoint<A NAME="DOCF7" HREF="gdb_foot.html#FOOT7">(7)</A>
</PRE>

<P>
Если это происходит, удалите или отключите некоторые точки наблюдения.


<P>
SPARClite DSU будет генерировать ловушки, когда программа обращается к
некоторым данным или адресу инструкции, которые отведены для отладочных
регистров.  Для адресов данных, DSU упрощает команду <CODE>watch</CODE>.
Однако, аппаратные регистры точек останова могут принять только две
точки наблюдения за данными, и обе точки наблюдения должны быть одного
типа.  Например, вы можете установить две точки наблюдения с помощью
команды <CODE>watch</CODE>, две с помощью команды <CODE>rwatch</CODE>, <STRONG>или</STRONG>
две с помощью команды <CODE>awatch</CODE>, но вы не можете установить одну
точку наблюдения с помощью одной команды, а другую с помощью другой.
GDB не примет команду, если вы попытаетесь смешать различные
точки наблюдения.  Удалите или отключите неиспользуемые точки наблюдения
перед установкой новых.


<P>
Если вы вызываете функцию интерактивно, используя <CODE>print</CODE> или
<CODE>call</CODE>, все установленные вами точки наблюдения будут неактивными,
до тех пор пока GDB не достигнет точки останова другого типа,
или пока вызов не завершится.


<P>
GDB автоматически удаляет точки наблюдения, которые наблюдают
за локальными переменными, или за выражениями, которые используют такие
переменные, когда они выходят из области видимости, то есть когда
выполнение покидает блок, в котором эти переменные были определены.  В
частности, когда отлаживаемая программа завершается, <EM>все</EM>
локальные переменные выходят из области видимости, и таким образом
остаются установленными только те точки наблюдения, которые наблюдают за
глобальными переменными.  Если вы снова запустите программу, вы должны
будете заново установить все такие точки наблюдения.  Одним из способов
сделать это будет установить точку останова на входе в функцию
<CODE>main</CODE>, и, когда программа остановится, установить все точки
наблюдения.



<BLOCKQUOTE>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
<P>
<EM>Предупреждение:</EM> В многонитевых программах точки наблюдения
являются лишь частично полезными.  С текущей реализацией точек
наблюдения,  GDB может наблюдать только за величиной выражения
<EM>в одной нити</EM>.  Если вы уверены, что выражение может измениться
только вследствие действий внутри текущей нити (и если вы также уверены,
что никакая другая нить не может стать текущей), то вы можете
использовать точки наблюдения как обычно.  Однако, GDB может не
заметить, когда действия в не текущей нити изменяют выражение.


<P>
<EM>Предупреждение для HP-UX:</EM> В многонитевых программах, программные
точки наблюдения
являются лишь частично полезными.  Если GDB создает программную
точку наблюдения, она может наблюдать только за величиной выражения
<EM>в одной нити</EM>.  Если вы уверены, что выражение может измениться
только вследствие действий внутри текущей нити (и если вы также уверены,
что никакая другая нить не может стать текущей), то вы можете использовать
программные точки наблюдения как обычно.  Однако, GDB может не
заметить, когда действия в не текущей нити изменяют выражение.
(Аппаратные же точки наблюдения напротив, наблюдают за выражением во
всех нитях.)
</BLOCKQUOTE>



<H3><A NAME="SEC30" HREF="gdb_toc.html#TOC30">Установка точек перехвата</A></H3>
<P>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>


<P>
Вы можете использовать <EM>точки перехвата</EM>, чтобы вызвать остановку
отладчика в ответ на определенные типы событий в программе, такие как
исключения в Си++ или загрузка разделяемой библиотеки.  Для установки
точки перехвата используйте команду <CODE>catch</CODE>.


<DL COMPACT>

<DT><CODE>catch <VAR>событие</VAR></CODE>
<DD>
<A NAME="IDX167"></A>
 
Остановиться, когда происходит <VAR>событие</VAR>.  <VAR>Событие</VAR> может быть
одним из:
<DL COMPACT>

<DT><CODE>throw</CODE>
<DD>
<A NAME="IDX168"></A>
Выбрасывание исключения Си++.

<DT><CODE>catch</CODE>
<DD>
<A NAME="IDX169"></A>
Перехват исключения Си++.

<DT><CODE>exec</CODE>
<DD>
<A NAME="IDX170"></A>
Вызов <CODE>exec</CODE>.  В настоящее время это доступно только на HP-UX.

<DT><CODE>fork</CODE>
<DD>
<A NAME="IDX171"></A>
Вызов <CODE>fork</CODE>.  В настоящее время это доступно только на HP-UX.

<DT><CODE>vfork</CODE>
<DD>
<A NAME="IDX172"></A>
Вызов <CODE>vfork</CODE>.  В настоящее время это доступно только на HP-UX.

<DT><CODE>load</CODE>
<DD>
<DT><CODE>load <VAR>имя-библ</VAR></CODE>
<DD>
<A NAME="IDX173"></A>
Динамическая загрузка любой разделяемой библиотеки, или загрузка
библиотеки <VAR>имя-библ</VAR>.  В настоящее время это доступно только на
HP-UX.

<DT><CODE>unload</CODE>
<DD>
<DT><CODE>unload <VAR>имя-библ</VAR></CODE>
<DD>
<A NAME="IDX174"></A>
Выгрузка любой динамически загруженной разделяемой библиотеки, или
выгрузка библиотеки <VAR>имя-библ</VAR>.  В настоящее время это доступно
только на HP-UX.
</DL>

<DT><CODE>tcatch <VAR>событие</VAR></CODE>
<DD>
Установить точку перехвата, которая включена только до первой
активации.  Точка перехвата автоматически уничтожается после того, как
событие перехвачено первый раз.

</DL>

<P>
Используйте команду <CODE>info break</CODE> для получения списка текущих точек
перехвата.


<P>
В настоящее время, в GDB существуют некоторые ограничения на
обработку исключений Си++ (<CODE>catch throw</CODE> и <CODE>catch catch</CODE>):



<UL>
<LI>

Если вы вызываете функцию интерактивно, GDB обычно возвращает
вам управление после того, как функция закончила выполнение.  Однако,
если вызов возбуждает исключение, он может обойти механизм, возвращающий
вам управление, и заставить вашу программу либо остановиться, либо просто
продолжить выполнение до тех пор, пока она не активирует точку останова,
получит сигнал, который ждет GDB, или выйдет.  Это имеет место
даже если вы установите точку перехвата для исключения; точки перехвата
для исключений отключены при интерактивных вызовов.

<LI>

Вы не можете возбуждать исключения интерактивно.

<LI>

Вы не можете интерактивно установить обработчик исключения.
</UL>

<P>
<A NAME="IDX175"></A>
Иногда <CODE>catch</CODE> не является лучшим способом отладки обработки
исключений: если вам необходимо точно знать, где исключение возбуждено,
то лучше остановиться <EM>до</EM> того, как вызван обработчик исключения,
так как в этом случае вы можете увидеть стек до того, как произойдет
какое-либо развертывание.
Если вместо этого вы установите точку останова в обработчике исключений,
то может быть нелегко определить, где исключение было возбуждено.


<P>
Для остановки сразу перед вызовом обработчика исключений, вам необходимы
некоторые знания о реализации.  В случае GNU Си++, исключения
возбуждаются путем вызова библиотечной функции <CODE>__raise_exception</CODE>,
которая имеет следующий интерфейс ANSI Си:



<PRE>
    /* <VAR>addr</VAR> -- где хранится идентификатор исключения.
       <VAR>id</VAR> -- идентификатор исключения.  */
    void __raise_exception (void **addr, void *id);
</PRE>

<P>
Для того, чтобы отладчик перехватывал все исключения до того, как
произойтет развертывание стека, установите точку останова на
<CODE>__raise_exception</CODE>  (see section <A HREF="gdb_6.html#SEC27">Точки останова, точки наблюдения и точки перехвата</A>).


<P>
С помощью условных точек останова (see section <A HREF="gdb_6.html#SEC33">Условия останова</A>),
зависящих от величины <VAR>id</VAR>, вы можете остановить вашу программу,
когда возбуждается определенное исключение.  Вы можете использовать
несколько условных точек останова, чтобы остановить программу, когда
возбуждается любое из нескольких исключений.




<H3><A NAME="SEC31" HREF="gdb_toc.html#TOC31">Удаление точек останова</A></H3>

<P>
<A NAME="IDX176"></A>
<A NAME="IDX177"></A>
Часто бывает необходимо уничтожить точку останова, наблюдения или
перехвата, когда она сделала свое дело и вы больше не хотите
останавливать там свою программу.  Это называется <EM>уничтожением</EM>
точки останова.  Точка останова, которая была уничтожена, более не
существует; она забыта.


<P>
С помощью команды <CODE>clear</CODE> вы можете удалять точки останова в
соответствии с тем, где они находятся в вашей программе.  С помощью
команды <CODE>delete</CODE> вы можете удалять отдельные точки останова,
наблюдения или перехвата, указывая их номера.


<P>
Не обязательно удалять точку останова, чтобы продолжить выполнение после
нее.  GDB автоматически игнорирует точки останова на первой
инструкции, которая должна быть выполнена, когда вы продолжаете
исполнение без изменения адреса выполнения.


<DL COMPACT>

<DT><CODE>clear</CODE>
<DD>
<A NAME="IDX178"></A>
 
Удаляет любые точки останова, установленные на следующей инструкции,
которая должна быть выполнена в выбранном кадре стека (see section <A HREF="gdb_7.html#SEC43">Выбор кадра</A>).  Когда выбран самый внутренний кадр, это хороший способ
удалить ту точку останова, на которой ваша программа только что
остановилась.

<DT><CODE>clear <VAR>функция</VAR></CODE>
<DD>
<DT><CODE>clear <VAR>имя-файла</VAR>:<VAR>функция</VAR></CODE>
<DD>
Удалить любые точки останова, установленные на входе в <VAR>функцию</VAR>.

<DT><CODE>clear <VAR>номер-строки</VAR></CODE>
<DD>
<DT><CODE>clear <VAR>имя-файла</VAR>:<VAR>номер-строки</VAR></CODE>
<DD>
Удалить все точки останова, установленные на или внутри кода на
указанной строке.

<A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<A NAME="IDX181"></A>
<DT><CODE>delete [breakpoints] [<VAR>диапазон</VAR>...]</CODE>
<DD>
Удалить точки останова, наблюдения или перехвата из диапазона, указанного
в качестве аргумента.  Если аргумент не задан, удалить все точки
останова (GDB запрашивает подтверждение, если у вас не
установлено <CODE>set confirm off</CODE>).  Вы можете сократить это команду
как <CODE>d</CODE>.
</DL>



<H3><A NAME="SEC32" HREF="gdb_toc.html#TOC32">Отключение точек останова</A></H3>

<P>
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>
Вместо того, чтобы удалять точку останова, наблюдения или перехвата, вам
может быть удобнее <EM>отключить</EM> ее.  Это делает точку останова
бездействующей, как если бы она была удалена, но информация о ней
запоминается, так что вы можете позже <EM>включить</EM> ее
снова.


<P>
Вы отключаете и включаете точки останова, наблюдения и перехвата
командами <CODE>enable</CODE> и <CODE>disable</CODE>, возможно указывая один или
более номеров точек останова в качестве аргументов.  Используйте
<CODE>info break</CODE> или <CODE>info watch</CODE> для распечатки списка точек
останова, наблюдения и перехвата, если вы не знаете какие номера
использовать.


<P>
Точка останова, наблюдения или перехвата может находиться в одном из четырех
состояний:



<UL>
<LI>

Включена.  Точка останова останавливает вашу программу.  Точка останова,
установленная командой <CODE>break</CODE>, изначально находится в таком состоянии.
<LI>

Отключена.  Точка останова не оказывает воздействия на вашу программу.
<LI>

Включена до первого срабатывания.  Точка останова останавливает вашу
программу, но потом становится отключенной.
<LI>

Включена для удаления.  Точка останова останавливает вашу программу, но
сразу после этого она удаляется навсегда.  Точка останова, установленная
командой <CODE>tbreak</CODE>, изначально находится в этом состоянии.
</UL>

<P>
Вы можете использовать следующие команды для включения или отключения
точек останова, наблюдения и перехвата:


<DL COMPACT>

<DT><CODE>disable [breakpoints] [<VAR>диапазон</VAR>...]</CODE>
<DD>
<A NAME="IDX184"></A>
 <A NAME="IDX185"></A>
 <A NAME="IDX186"></A>
 
Отключить указанные точки останова, или все точки останова, если ни
одна не перечислена.  Отключенная точка останова не оказывает никакого
действия, но она не забывается.  Все параметры, такие как счетчик
игнорирований, условия и команды запоминаются, на случай, если точка
останова позже будет снова включена.  Вы можете сокращать <CODE>disable</CODE>
как <CODE>dis</CODE>.

<A NAME="IDX187"></A>
<A NAME="IDX188"></A>
<DT><CODE>enable [breakpoints] [<VAR>диапазон</VAR>...]</CODE>
<DD>
Включает указанные (или все определенные) точки останова.  Они
снова становятся значимыми для остановки вашей программы.

<DT><CODE>enable [breakpoints] once <VAR>диапазон</VAR>...</CODE>
<DD>
Временно включить указанные точки останова.  GDB отключает
любую из этих точек останова немедленно после срабатывания.

<DT><CODE>enable [breakpoints] delete <VAR>диапазон</VAR>...</CODE>
<DD>
Включить указанные точки останова до первого срабатывания, затем
уничтожить.  GDB удаляет любую из этих точек останова, как
только ваша программа останавливается на ней.
</DL>

<P>
Кроме точек останова, установленных командой <CODE>tbreak</CODE>
(see section <A HREF="gdb_6.html#SEC28">Установка точек останова</A>),
установленные вами точки останова изначально включены; следовательно,
они становятся отключенными или включенными только когда вы используете
одну из вышеперечисленных команд.  (Команда <CODE>until</CODE> может
устанавливать и удалять свою собственную точку останова, но она не
изменяет состояние ваших других точек останова; см. section <A HREF="gdb_6.html#SEC37">Продолжение и выполнение по шагам</A>.)




<H3><A NAME="SEC33" HREF="gdb_toc.html#TOC33">Условия останова</A></H3>
<P>
<A NAME="IDX189"></A>
<A NAME="IDX190"></A>


<P>
Простейшая точка останова останавливает вашу программу каждый раз, когда
управление достигает заданного места.  Вы можете также указать
<EM>условие</EM> для точки останова.  Условие является просто булевым
выражением в вашем языке программирования (see section <A HREF="gdb_9.html#SEC51">Выражения</A>).  Точка останова с условием вычисляет выражение каждый раз,
когда ваша программа достигает ее, и ваша программа остановится только в
том случае, если условие <EM>истинно</EM>.


<P>
Это противоположно использованию утверждений для проверки правильности
программы; в этом случае, вы хотите остановиться, когда утверждение
нарушается---то есть, когда условие ложно.  В Си, если вы хотите
проверить утверждение, выраженное условием <VAR>assert</VAR>, вы должны
установить условие <SAMP>`! <VAR>assert</VAR>'</SAMP> на соответствующей точке
останова.


<P>
Условия также допускаются для точек наблюдения; вам они могут не
понадобиться, так как точка наблюдения так или иначе контролирует значение
выражения---но может оказаться проще, скажем, просто установить точку
наблюдения на имя переменной и указать условие, проверяющее, является ли
новое значение тем, которое нас интересует.


<P>
Условия останова могут иметь побочные эффекты, и даже могут вызывать
функции в вашей программе.  Это может быть полезным, например, для
активации функций, которые запоминают продвижение выполнения вашей
программы, или для использования ваших собственных функций печати для
форматирования специальных структур данных.  Результаты полностью
предсказуемы, если нет другой включенной точки останова по тому же
адресу.  (В этом случае, GDB может сначала увидеть другую точку
останова и остановить вашу программу программу без проверки условия
первой точки останова.)  Заметьте, что команды точек останова обычно
более удобны и гибки, чем условия останова, для выполнения побочных
эффектов, когда достигается точка останова
(see section <A HREF="gdb_6.html#SEC34">Команды точки останова</A>).


<P>
Условия останова могут быть заданы в момент установки точки останова,
используя <SAMP>`if'</SAMP> в аргументах команды <CODE>break</CODE>.  See section <A HREF="gdb_6.html#SEC28">Установка точек останова</A>.  Они могут быть также
изменены в любой момент с помощью команды <CODE>condition</CODE>.


<P>
Вы также можете использовать ключевое слово <CODE>if</CODE> с командой
<CODE>watch</CODE>.  Команда <CODE>catch</CODE> не распознает ключевое слово
<CODE>if</CODE>; <CODE>condition</CODE> является единственным способом наложить
дальнейшие условия на точку перехвата.


<DL COMPACT>

<DT><CODE>condition <VAR>номер</VAR> <VAR>выражение</VAR></CODE>
<DD>
<A NAME="IDX191"></A>
 
Задайте <VAR>выражение</VAR> как условие остановки для точки останова,
наблюдения или перехвата с номером <VAR>номер</VAR>.  После того, как вы
установили условие, данная точка останова остановит вашу программу только
если значение <VAR>выражения</VAR> будет истинным (ненулевым, в Си).  Когда
вы используете <CODE>condition</CODE>, GDB немедленно проверяет
<VAR>выражение</VAR> на синтаксическую корректность и для определения, что
символы в нем имеют объекты ссылки в контексте вашей точки останова.
Если <VAR>выражение</VAR> использует символы, не существующие в контексте
точки останова, GDB выведет сообщение об ошибке:


<PRE>
No symbol "foo" in current context.<A NAME="DOCF8" HREF="gdb_foot.html#FOOT8">(8)</A>
</PRE>

Однако, GDB в действительности не вычисляет <VAR>выражение</VAR> в
момент подачи команды <CODE>condition</CODE> (или команды, устанавливающей
точку останова с условием, такой как <CODE>break if ...</CODE>).
See section <A HREF="gdb_9.html#SEC51">Выражения</A>.

<DT><CODE>condition <VAR>номер</VAR></CODE>
<DD>
Снимает условие с точки останова с номером <VAR>номер</VAR>.  Она становится
обычной безусловной точкой останова.
</DL>

<P>
<A NAME="IDX192"></A>
Специальным случаем условия для точки останова является остановка только
когда точка останова была достигнута определенное число раз.  Это
настолько полезно, что существует специальный способ сделать это,
используя <EM>счетчик игнорирования</EM> точки останова.  Каждая точка
останова имеет счетчик игнорирования, являющийся целым числом.
Как правило, счетчик игнорирования равен нулю, и,
следовательно, не производит никакого действия.  Но если ваша программа
достигает точки останова, чей счетчик игнорирования положителен, тогда
вместо того чтобы остановиться, она лишь уменьшит его на единицу и
продолжит выполнение.  В результате, если величина счетчика
игнорирования равна <VAR>n</VAR>, точка останова не остановит программу
следующие <VAR>n</VAR> раз, когда программа его достигнет.


<DL COMPACT>

<DT><CODE>ignore <VAR>номер</VAR> <VAR>значение</VAR></CODE>
<DD>
<A NAME="IDX193"></A>
 
Устанавливает счетчик игнорирований точки останова с номером <VAR>номер</VAR> в
<VAR>значение</VAR>.  Следующие <VAR>значение</VAR> раз, когда точка останова
будет достигнута, выполнение вашей программы не будет остановлено; кроме
как уменьшить счетчик игнорирований, GDB не производит никаких
действий.

Чтобы точка останова сработала при следующем достижении, установите
счетчик в ноль.

Когда вы используете <CODE>continue</CODE> для возобновления выполнения вашей
программы от точки останова, вы можете установить счетчик игнорирований
непосредственно как аргумент к <CODE>continue</CODE>, а не использовать
<CODE>ignore</CODE>.  See section <A HREF="gdb_6.html#SEC37">Продолжение и выполнение по шагам</A>.

Если точка останова имеет положительный счетчик игнорирований и условие,
то условие не проверяется.  Как только счетчик игнорирований достигнет
нуля, GDB возобновит проверку условия.

Вы можете достигнуть эффекта счетчика игнорирований с помощью такого
условия, как <SAMP>`$foo-- &#60;= 0'</SAMP>, используя вспомогательную
переменную отладчика, которая уменьшается каждый раз.
See section <A HREF="gdb_9.html#SEC59">Вспомогательные переменные</A>.
</DL>

<P>
Счетчики игнорирований можно использовать с точками останова, точками
наблюдения и точками перехвата.




<H3><A NAME="SEC34" HREF="gdb_toc.html#TOC34">Команды точки останова</A></H3>

<P>
<A NAME="IDX194"></A>
Вы можете подать любой точке останова (наблюдения или
перехвата) ряд команд, которые будут выполняться при остановке вашей
программы на этой точке останова.  Например, вы можете захотеть вывести
значения определенных выражений, или включить другие точки останова.


<DL COMPACT>

<DT><CODE>commands [<VAR>номер</VAR>]</CODE>
<DD>
<A NAME="IDX195"></A>
 <A NAME="IDX196"></A>
 
<DT><CODE>... <VAR>список-команд</VAR> ...</CODE>
<DD>
<DT><CODE>end</CODE>
<DD>
Определяет список команд для точки останова с номером <VAR>номер</VAR>.  Сами
команды указываются в следующих строках.  Для завершения списка команд,
введите строку, содержащую только <CODE>end</CODE>.

Чтобы удалить все команды от точки останова, введите <CODE>commands</CODE> и
немедленно за этим <CODE>end</CODE>, то есть задайте пустой список команд.

Без аргумента <VAR>номер</VAR>, <CODE>commands</CODE> относится к последней
установленной точке останова, наблюдения или перехвата (но не к
последней встреченной).
</DL>

<P>
Нажатие <KBD>RET</KBD>, как средство повторения последней команды
GDB, отключено внутри <VAR>списка-команд</VAR>.


<P>
Вы можете использовать команды для точки останова, чтобы снова запустить
вашу программу на выполнение.  Просто используйте команду <CODE>continue</CODE>, или
<CODE>step</CODE>, или любую другую команду, возобновляющую выполнение.


<P>
После команды, возобновляющей выполнение, любые другие команды в списке
игнорируются.  Так сделано потому, что каждый раз, когда вы
возобновляете выполнение (даже просто с помощью <CODE>next</CODE> или
<CODE>step</CODE>), вы можете встретить другую точку останова---которая может
иметь свой собственный список команд, что приведет к неоднозначности,
какой из списков выполнять.


<P>
<A NAME="IDX197"></A>
Если в качестве первой команды в списке команд вы укажете <CODE>silent</CODE>,
обычное сообщение об остановке на точке останова не будет выводиться.
Это может быть желательно для точек останова, которые должны вывести
определенное сообщение, и затем продолжить выполнение.  Если никакая из
оставшихся команд ничего не выводит, вы не увидите никакого знака о том,
что точка останова была достигнута.  <CODE>silent</CODE> имеет смысл только в
начале списка команд точки останова.


<P>
Команды <CODE>echo</CODE>, <CODE>output</CODE> и <CODE>printf</CODE> позволяют вам
более точно контролировать выводимый текст, и часто полезны в "тихих"
точках останова.  See section <A HREF="gdb_17.html#SEC176">Команды для управляемого вывода</A>.


<P>
Например, вот как вы можете использовать команды точки останова для
вывода величины <CODE>x</CODE> на входе в <CODE>foo</CODE>, когда <CODE>x</CODE>
положительна.



<PRE>
break foo if x&#62;0
commands
silent
printf "x is %d\n",x
cont
end
</PRE>

<P>
Одним из применений команд точки останова является компенсация одной
ошибки, так, чтобы вы могли искать другую.  Поместите точку останова
сразу после строки кода, содержащей ошибку, задайте ей условие для
определения случая, в котором было сделано что-то ошибочное, и
определите команды для присвоения правильных значений тем переменным,
для которых это требуется.  Закончите командой <CODE>continue</CODE>, чтобы
ваше программа не останавливалась, а начните с команды <CODE>silent</CODE>,
чтобы не было никакого вывода.  Вот пример:



<PRE>
break 403
commands
silent
set x = y + 4
cont
end
</PRE>



<H3><A NAME="SEC35" HREF="gdb_toc.html#TOC35">Меню точки останова</A></H3>
<P>
<A NAME="IDX198"></A>
<A NAME="IDX199"></A>


<P>
Некоторые языки программирования (особенно Си++) допускают, чтобы одно и
то же имя функции было определено несколько раз, для применения в
различных контекстах.  Это называется <EM>перегрузкой</EM>.  Когда имя
функции перегружается, <SAMP>`break <VAR>функция</VAR>'</SAMP> не достаточно, чтобы
указать GDB, где вы хотите установить точку останова.
Если вы столкнулись с этой проблемой, вы можете использовать что-то типа
<SAMP>`break <VAR>функция</VAR>(<VAR>типы</VAR>)'</SAMP> для указания, какую конкретную
версию функции вы имеете в виду.  В противном случае, GDB
предлагает вам выбор из пронумерованных вариантов для различных
возможных точек останова, и ждет вашего выбора с приглашением
<SAMP>`&#62;'</SAMP>.  Первыми двумя вариантами всегда являются <SAMP>`[0] cancel'</SAMP>
и <SAMP>`[1] all'</SAMP>.  Ввод <KBD>1</KBD> устанавливает точку останова на каждом
определении <VAR>функции</VAR>, и ввод <KBD>0</KBD> прерывает команду <CODE>break</CODE>
без установки новых точек останова.


<P>
Например, следующая выдержка из сеанса иллюстрирует попытку установить
точку останова на перегруженном символе <CODE>String::after</CODE>.  Мы
выбрали три конкретных определения имени функции:



<PRE>
(gdb) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
&#62; 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the "delete" command to delete unwanted
 breakpoints.
(gdb)
</PRE>



<H3><A NAME="SEC36" HREF="gdb_toc.html#TOC36">"Не удается поместить точки останова"</A></H3>

<P>
В некоторых операционных системах точки останова не могут быть
использованы в программе, если какой-либо другой процесс выполняет эту
программу.  В этом случае, попытка выполнить или продолжить выполнение
программы с точкой останова приводит тому, что GDB печатает
сообщение об ошибке:



<PRE>
Cannot insert breakpoints.
The same program may be running in another process.<A NAME="DOCF9" HREF="gdb_foot.html#FOOT9">(9)</A>
</PRE>

<P>
Когда это происходит, у вас есть три варианта дальнейших действий:



<OL>
<LI>

Удалить или отключить точки останова, и затем продолжить.

<LI>

Приостановить GDB и скопировать файл, содержащий вашу
программу, под другим иненем.  Возобновить работу GDB и
использовать команду <CODE>exec-file</CODE> для указания, что GDB
должен выполнять вашу программу под этим именем.  Затем запустите вашу
программу снова.

<LI>

Скомпоновать заново вашу программу так, чтобы сегмент текста был
неразделяемым, используя ключ компоновщика <SAMP>`-N'</SAMP>.  Ограничения
операционной системы могут не распространяться на неразделяемые
выполняемые файлы.
</OL>

<P>
Аналогичное сообщение может выводиться, если вы запрашиваете слишком
много активных аппаратно-поддерживаемых точек останова и наблюдения:



<PRE>
Stopped; cannot insert breakpoints.
You may have requested too many hardware breakpoints and watchpoints.<A NAME="DOCF10" HREF="gdb_foot.html#FOOT10">(10)</A>
</PRE>

<P>
Это сообщение выводится, когда вы пытаетесь возобновить выполнение
программы, так как только тогда GDB знает точно, сколько аппаратных
точек останова и наблюдения ему нужно установить.


<P>
Когда это сообщение выводится, вам необходимо отключить или удалить
некоторые аппаратно-поддерживаемые точки останова и наблюдения, и затем
продолжить.




<H2><A NAME="SEC37" HREF="gdb_toc.html#TOC37">Продолжение и выполнение по шагам</A></H2>

<P>
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
<A NAME="IDX202"></A>
<EM>Продолжение</EM> означает возобновление выполнения программы до ее
нормального завершения.  Напротив, <EM>пошаговое выполнение</EM> означает
выполнение еще одного "шага" вашей программы, где "шаг" быть либо
одной строкой исходного кода, либо одной машинной инструкцией (в
зависимости от того, какую именно команду вы используете).  И в
случае продолжения, и в случае выполнения по шагам, ваша программа
может остановиться и раньше, вследствие точки останова или сигнала.
(Если она останавливается по сигналу, вы можете использовать
<CODE>handle</CODE>, или <SAMP>`signal 0'</SAMP> для возобновления выполнения.
See section <A HREF="gdb_6.html#SEC38">Сигналы</A>.)


<DL COMPACT>

<DT><CODE>continue [<VAR>счетчик-игнор</VAR>]</CODE>
<DD>
<A NAME="IDX203"></A>
 <A NAME="IDX204"></A>
 <A NAME="IDX205"></A>
 
<DT><CODE>c [<VAR>счетчик-игнор</VAR>]</CODE>
<DD>
<DT><CODE>fg [<VAR>счетчик-игнор</VAR>]</CODE>
<DD>
Возобновить выполнение программы, с того адреса, где ваша программа
остановилась последний раз; все точки останова, установленные по этому
адресу, пропускаются.  Необязательный аргумент <VAR>счетчик-игнор</VAR>
позволяет вам задать количество последующих игнорирований точки останова
в этом месте; его действие совпадает с действием <CODE>ignore</CODE>
(see section <A HREF="gdb_6.html#SEC33">Условия останова</A>).

Аргумент <VAR>счетчик-игнор</VAR> имеет смысл только если ваша программа
остановилась в точке останова.  В остальных случаях, аргумент к
<CODE>continue</CODE> игнорируется.

Синонимы <CODE>c</CODE> и <CODE>fg</CODE> (от <EM>foregroung</EM>, так как отлаживаемая
программа считается фоновой), предоставляются исключительно для
удобства, и имеют в точности тот же смысл, что и <CODE>continue</CODE>.
</DL>

<P>
Чтобы возобновить выполнение с другого места, вы можете использовать
<CODE>return</CODE> (see section <A HREF="gdb_12.html#SEC100">Возврат из функции</A>) чтобы вернуться
назад к вызывающей функции; или <CODE>jump</CODE> (see section <A HREF="gdb_12.html#SEC98">Продолжение исполнения с другого адреса</A>) для перехода к произвольному месту в
вашей программе.


<P>
Типичная техника для использования пошагового выполнения заключается в
установке точки останова (see section <A HREF="gdb_6.html#SEC27">Точки останова, точки наблюдения и точки перехвата</A>) на начале функции или раздела вашей программы,
где предположительно находится ошибка, выполнении вашей программы до
остановки на этой точке останова, и затем пошаговом выполнении
подозреваемого участка, с исследованием интересуемых переменных, пока вы
не увидите, что случилась ошибка.


<DL COMPACT>

<DT><CODE>step</CODE>
<DD>
<A NAME="IDX206"></A>
 <A NAME="IDX207"></A>
 
Продолжить выполнение вашей программы, пока управление не достигнет
другой строки исходного текста, затем остановить ее и возвратить
управление GDB.  Эту команду можно сокращать до <CODE>s</CODE>.


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Если вы используете команду <CODE>step</CODE>, когда
управление находится внутри функции, которая была скомпилирована без
отладочной информации, выполнение продолжается, пока управление не
достигнет функции, которая <EM>имеет</EM> ее.  Аналогично, пошаговое
выполнение не будет заходить в функцию, скомпилированную без отладочной
информации.  Для пошагового выполнения таких функций
используйте команду <CODE>stepi</CODE>, описанную ниже.
</BLOCKQUOTE>

Команда <CODE>step</CODE> останавливается только на первой инструкции строки
исходного текста.  Это предотвращает множественные остановки, которые
в противном случае могут возникнуть в операторе <CODE>switch</CODE>, цикле
<CODE>for</CODE>, и так далее.  <CODE>step</CODE> продолжает останавливаться, если
функция, имеющая отладочную информацию, вызывается внутри строки.
Другими словами, <CODE>step</CODE> <EM>заходит внутрь</EM> функций, вызываемых в
данной строке.

Также, команда <CODE>step</CODE> входит в функцию только если для нее существует
информация о номерах строк.  Иначе она действует как команда
<CODE>next</CODE>.  Это позволяет избежать проблем, появляющихся при
использовании <CODE>cc -gl</CODE> на машинах MIPS.  Раньше <CODE>step</CODE>
заходила в подпрограмму, если существовала хоть какая-нибудь отладочная
информация о подпрограмме.

<DT><CODE>step <CODE>число</CODE></CODE>
<DD>
Продолжает выполнение как по команде <CODE>step</CODE>, но делает это
<VAR>число</VAR> раз.  Если достигается точка останова, или приходит
сигнал, не связанный с пошаговым выполнением, до выполнения <VAR>числа</VAR>
шагов, пошаговое выполнение сразу останавливается.

<A NAME="IDX208"></A>
<A NAME="IDX209"></A>
<DT><CODE>next [<VAR>число</VAR>]</CODE>
<DD>
Продолжает выполнение до следующей строки исходного текста в текущем
(внутреннем) кадре стека.  Это аналогично <CODE>step</CODE>, но вызовы
функций, которые появляются внутри строки кода, выполняются без
остановки.  Выполнение останавливается, когда управление достигает другой
строки кода в исходном уровне стека, который выполнялся, когда вы дали
команду <CODE>next</CODE>.  Эта команда сокращается как <CODE>n</CODE>.

Аргумент <VAR>число</VAR> является счетчиком повторений, как для <CODE>step</CODE>.

Команда <CODE>next</CODE> останавливается только на первой инструкции исходной
строки.  Это предотвращает множественные остановки, которые
иначе могут возникнуть в операторах <CODE>switch</CODE>, циклах <CODE>for</CODE>, и
так далее.

<A NAME="IDX210"></A>
<DT><CODE>finish</CODE>
<DD>
Продолжить выполнение до возврата из функции в выбранном кадре стека.
Напечатать возвращенное значение (если таковое существует).

Сравните это с командой <CODE>return</CODE> (see section <A HREF="gdb_12.html#SEC100">Возврат из функции</A>).

<A NAME="IDX211"></A>
<A NAME="IDX212"></A>
<DT><CODE>until</CODE>
<DD>
<DT><CODE>u</CODE>
<DD>
Продолжить выполнение до достижения строки исходного текста, следующей за
текущей, в текущем кадре стека.  Эта команда используется для избежания
выполнения цикла по шагам больше одного раза.
Она похожа на команду <CODE>next</CODE>, за исключением
того, что когда <CODE>until</CODE> встречает переход, она автоматически
продолжает выполнение, пока счетчик выполнения программы не станет
больше, чем адрес перехода.

Это означает, что когда вы достигаете конца цикла после его выполнения по
шагам, <CODE>until</CODE> продолжает выполнение вашей программы, пока она не
выйдет из цикла.  Напротив, команда <CODE>next</CODE> в конце цикла просто
переходит назад в начало цикла, что заставляет вас выполнять по
шагам следующую итерацию.

<CODE>until</CODE> всегда останавливает вашу программу, если она пытается выйти
из текущего кадра стека.

<CODE>until</CODE> может привести к несколько неожиданным результатам, если
порядок машинных кодов не совпадает с порядком строк исходного текста.
Например, в следующем отрывке сеанса отладки, команда <CODE>f</CODE>
(<CODE>frame</CODE>) показывает, что выполнение остановилось на строке
<CODE>206</CODE>; хотя, когда мы используем <CODE>until</CODE>, мы переходим к строке
<CODE>195</CODE>:


<PRE>
(gdb) f
#0  main (argc=4, argv=0xf7fffae8) at m4.c:206
206                 expand_input();
(gdb) until
195             for ( ; argc &#62; 0; NEXTARG) {
</PRE>

Это произошло потому, что для эффектвности выполнения компилятор
сгенерировал код для проверки окончания цикла в конце, а не в начале
цикла---даже если проверка в цикле <CODE>for</CODE> Си написана до тела
цикла.  Кажется, что команда <CODE>until</CODE> переместилась назад к началу
цикла, когда двигалась к этому выражению; однако, в действительности она
не переходила к более раннему оператору---в терминах фактического
машинного кода.

<CODE>until</CODE> без аргументов работает посредством пошагового выполнения
отдельных инструкций, и, следовательно, является более медленной, чем
<CODE>until</CODE> с аргументом.

<DT><CODE>until <VAR>положение</VAR></CODE>
<DD>
<DT><CODE>u <VAR>положение</VAR></CODE>
<DD>
Продолжить выполнение вашей программы, пока либо указанное место не
будет достигнуто, либо не произойдет возврат из текущего кадра стека.
<VAR>положение</VAR> может быть любой из доступных форм аргумента для
<CODE>break</CODE> (see section <A HREF="gdb_6.html#SEC28">Установка точек останова</A>).  Эта форма команды использует точки останова, и,
следовательно, является более быстрой, чем <CODE>until</CODE> без аргумента.

<A NAME="IDX213"></A>
<A NAME="IDX214"></A>
<DT><CODE>stepi</CODE>
<DD>
<DT><CODE>stepi <VAR>арг</VAR></CODE>
<DD>
<DT><CODE>si</CODE>
<DD>
Выполнить одну машинную инструкцию, затем остановиться и вернуться в
отладчик.

При пошаговом выполнении машинных инструкций, часто бывает полезным
сделать <SAMP>`display/i $pc'</SAMP>.  Это велит GDB автоматически
отображать инструкцию, которая будет выполняться следующей, каждый раз,
когда ваша программа останавливается.  See section <A HREF="gdb_9.html#SEC56">Автоматическое отображение</A>.

Аргумент является счетчиком повторений, как для <CODE>step</CODE>.

<A NAME="IDX215"></A>
<A NAME="IDX216"></A>
<DT><CODE>nexti</CODE>
<DD>
<DT><CODE>nexti <VAR>арг</VAR></CODE>
<DD>
<DT><CODE>ni</CODE>
<DD>
Выполнить одну машинную инструкцию, но если это вызов функции,
продолжать до возврата из нее.

Аргумент является счетчиком повторений, как для <CODE>next</CODE>.
</DL>



<H2><A NAME="SEC38" HREF="gdb_toc.html#TOC38">Сигналы</A></H2>
<P>
<A NAME="IDX217"></A>


<P>
Сигнал---это асинхронное событие, которое может произойти в программе.
Операционная система определяет возможные типы сигналов и дает каждому
типу имя и номер.  В Unix, например, <CODE>SIGINT</CODE>---это сигнал, получаемый
программой, когда вы вводите знак прерывания (часто <KBD>C-c</KBD>);
<CODE>SIGSEGV</CODE>---сигнал, получаемый программой при ссылке на область
памяти, отличную от всех используемых областей; <CODE>SIGALRM</CODE> появляется
при срабатывании интервального таймера (возникает только, если ваша
программа запросила временной сигнал).


<P>
<A NAME="IDX218"></A>
Некоторые сигналы, такие как <CODE>SIGALRM</CODE>, являются обычной частью
функционирования вашей программы.  Другие, такие как <CODE>SIGSEGV</CODE>,
обозначают ошибки; эти сигналы являются <EM>фатальными</EM> (они немедленно
убивают вашу программу), если программа не определила заранее другой
способ их обработки.  <CODE>SIGINT</CODE> не указывает на ошибку в вашей
программе, но обычно является фатальным, так что он может выполнять
функцию прерывания: убить программу.


<P>
GDB способен обнаружить любое появление сигнала в вашей
программе.  Вы можете заранее сообщить GDB, что делать для
каждого типа сигнала.


<P>
<A NAME="IDX219"></A>
Обычно, GDB установлен так, чтобы игнорировать неошибочные сигналы,
такие как <CODE>SIGALRM</CODE> (чтобы не мешать их действию при исполнении вашей
программы), но немедленно останавливать вашу программу всякий раз, когда
возникает сигнал об ошибке.  Вы можете изменить эти установки командой
<CODE>handle</CODE>.


<DL COMPACT>

<DT><CODE>info signals</CODE>
<DD>
<A NAME="IDX220"></A>
 
<DT><CODE>info handle</CODE>
<DD>
Напечатать таблицу всех типов сигналов и описания, как GDB
будет обрабатывать каждый из них.  Вы можете использовать эту команду, чтобы
посмотреть номера всех определенных типов сигналов.

<CODE>info handle</CODE> является синонимом для <CODE>info signals</CODE>.

<A NAME="IDX221"></A>
<DT><CODE>handle <VAR>сигнал</VAR> <VAR>ключевые-слова</VAR>...</CODE>
<DD>
Изменить способ, которым GDB обрабатывает <VAR>сигнал</VAR>.
<VAR>сигнал</VAR> может быть номером сигнала или его именем (с <SAMP>`SIG'</SAMP> или
без него в начале).  <VAR>Ключевые-слова</VAR> определяют, какие сделать изменения.
</DL>

<P>
Ключевые слова, допускаемые командой <CODE>handle</CODE>, могут быть
сокращены.  Вот их полные имена:


<DL COMPACT>

<DT><CODE>nostop</CODE>
<DD>
GDB не должен останавливать вашу программу при получении
этого сигнала.  Все же он может вывести сообщение, уведомляющее о
получении сигнала.

<DT><CODE>stop</CODE>
<DD>
GDB должен остановить вашу программу при получении этого
сигнала.  Это также подразумевает ключевое слово <CODE>print</CODE>.

<DT><CODE>print</CODE>
<DD>
GDB должен вывести сообщение при возникновении данного сигнала.

<DT><CODE>noprint</CODE>
<DD>
GDB вообще не должен замечать возникновение сигнала.  Это также
подразумевает ключевое слово <CODE>nostop</CODE>.

<DT><CODE>pass</CODE>
<DD>
GDB должен позволить вашей программе увидеть этот сигнал; ваша
программа может обработать сигнал, или же она может завершиться,
если сигнал фатальный и не обработан.

<DT><CODE>nopass</CODE>
<DD>
GDB не должен позволять вашей программе видеть этот сигнал.
</DL>

<P>
Когда сигнал останавливает вашу программу, он невидим для нее,
пока вы не продолжите выполнение.  Затем ваша программа видит
сигнал, если <EM>в данный момент</EM> на рассматриваемый сигнал
распространяется действие команды <CODE>pass</CODE>.  Другими словами, после
того, как GDB сообщит о сигнале, вы можете использовать команду
<CODE>handle</CODE> c <CODE>pass</CODE> или <CODE>nopass</CODE>, чтобы
указать, должна ли ваша программа увидеть этот сигнал при продолжении.


<P>
Вы также можете использовать команду <CODE>signal</CODE> для того, чтобы
помешать вашей программе увидеть сигнал или, наоборот, заставить ее
заметить обычно игнорируемый сигнал, или чтобы подать ей произвольный
сигнал в любое время.  Например, если ваша программа остановилась
вследствие какой-либо ошибки обращения к памяти, вы можете сохранить
правильные значения в ошибочные переменные и продолжить выполнение, в
надежде посмотреть на дальнейшее выполнение, но ваша программа вероятно
немедленно остановилась бы из-за фатального сигнала, как только она бы
его заметила.  Чтобы помешать этому, вы можете продолжить выполнение с
<SAMP>`signal 0'</SAMP>.  See section <A HREF="gdb_12.html#SEC99">Подача сигнала вашей программе</A>.




<H2><A NAME="SEC39" HREF="gdb_toc.html#TOC39">Остановка и запуск многонитевых программ</A></H2>

<P>
Когда ваша программа имеет несколько нитей выполнения
(see section <A HREF="gdb_5.html#SEC24">Отладка программ с несколькими нитями</A>), вы можете выбрать,
установить точки останова либо во всех, либо в каких-то отдельных нитях.


<DL COMPACT>

<DT><CODE>break <VAR>ном-строки</VAR> thread <VAR>номер-нити</VAR></CODE>
<DD>
<A NAME="IDX222"></A>
 <A NAME="IDX223"></A>
 <A NAME="IDX224"></A>
 
<DT><CODE>break <VAR>ном-строки</VAR> thread <VAR>номер-нити</VAR> if ...</CODE>
<DD>
<VAR>ном-строки</VAR> определяет строки исходного текста; существует
несколько способов их задания, но результат всегда один и тот
же---указать строку исходного текста.

Используйте классификатор <SAMP>`thread <VAR>номер-нити</VAR>'</SAMP> с командой точки
останова, чтобы указать GDB, что вы хотите остановить программу,
только когда определенная нить достигнет этой точки.
<VAR>номер-нити</VAR>---это один из числовых идентификаторов нити,
присвоенный GDB, показываемый в первой колонке при выводе
<SAMP>`info threads'</SAMP>.

Если при установке точки останова вы не укажете <SAMP>`thread
<VAR>номер-нити</VAR>'</SAMP>, точка останова будет действовать для <EM>всех</EM>
нитей вашей программы.

Вы также можете использовать классификатор <CODE>thread</CODE> для условных
точек останова; в этом случае, поместите <SAMP>`thread <VAR>номер-нити</VAR>'</SAMP>
перед условием точки останова, вот так:


<PRE>
(gdb) break frik.c:13 thread 28 if bartab &#62; lim
</PRE>

</DL>

<P>
<A NAME="IDX225"></A>
<A NAME="IDX226"></A>
При любой остановке вашей программы под управлением GDB,
прекращается выполнение <EM>всех</EM> нитей, а не только текущей.  Это
позволяет вам исследовать полное состояние программы, включая
переключение между нитями, не опасаясь, что это может изменить что-либо в
дальнейшем.


<P>
<A NAME="IDX227"></A>
<A NAME="IDX228"></A>
Наоборот, когда вы снова запускаете программу, <EM>все</EM> нити
начинают выполняться.  <EM>Это верно даже при пошаговом выполнении</EM>
такими командами, как <CODE>step</CODE> или <CODE>next</CODE>.


<P>
В частности, GDB не может пошагово выполнять все нити
параллельно.  Так как планированием выполнения нити занимается
операционная система отлаживаемой цели (не контролируемая GDB),
то пока в текущей
нити выполняется один шаг, в других может выполниться несколько.  Более
того, когда выполнение программы останавливается, другие потоки вообще могут
остановиться в середине операторов, а не на границе между ними.


<P>
Вы даже можете обнаружить, что после продолжения исполнения или
после пошагового выполнения ваша программа остановилась в другой
нити.  Это случается всякий раз, когда другая нить достигает точки
останова, получает сигнал или в ней возникает исключительная ситуация,
прежде чем первая нить завершает выполнение того, что вы запросили.


<P>
В некоторых операционных системах вы можете заблокировать планировщик
заданий и тем самым позволить выполняться только одной нити.


<DL COMPACT>

<DT><CODE>set scheduler-locking <VAR>режим</VAR></CODE>
<DD>
Устанавливает режим блокировки планировщика заданий.  Если он установлен
в <CODE>off</CODE>, то блокировки нет и любая нить может выполняться в любое
время.  Если этот режим установлен в <CODE>on</CODE>, то только текущая нить
может выполняться, когда выполнение продолжается.
Режим <CODE>step</CODE> производит оптимизацию для пошагового выполнения.  Он
не дает другим нитям "захватывать приглашение" путем приоритетного
прерывания обслуживания текущей нити во время пошагового выполнения.
Другие нити едва ли получат возможность начать выполнение, когда вы
выполняете очередной шаг.  С большей вероятностью они начнут выполняться,
когда вы выполняете команду <CODE>next</CODE> на вызове функции, и им не что
не помешает выполняться, когда вы используете такие команды, как
<SAMP>`continue'</SAMP>, <SAMP>`until'</SAMP> или <SAMP>`finish'</SAMP>.  Однако, если другие
нити не достигнут точки останова в течение отведенного ему для
выполнения времени, они никогда не перехватят приглашение GDB у
отлаживаемой вами нити.

<DT><CODE>show scheduler-locking</CODE>
<DD>
Отобразить текущий режим блокировки.
</DL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_5.html">previous</A>, <A HREF="gdb_7.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
