<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Изменение выполнения</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_11.html">previous</A>, <A HREF="gdb_13.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC96" HREF="gdb_toc.html#TOC96">Изменение выполнения</A></H1>

<P>
Если вы думаете, что нашли ошибку в своей программе, вы можете захотеть
выяснить наверняка, приведет ли исправление кажущейся ошибки к
правильным результатам в остальной части программы.  Вы можете получить
ответ экспериментируя, используя средства GDB для изменения
выполнения программы.


<P>
Например, вы можете сохранить новые значения в переменных или
ячейках памяти, подать своей программе сигнал, перезапустить ее
с другого адреса или даже преждевременно вернуться из функции.




<H2><A NAME="SEC97" HREF="gdb_toc.html#TOC97">Присваивание значений пеpеменным</A></H2>

<P>
<A NAME="IDX469"></A>
<A NAME="IDX470"></A>
Для изменения значения переменной, вычислите выражение присваивания.
See section <A HREF="gdb_9.html#SEC51">Выражения</A>.  Например,



<PRE>
print x=4
</PRE>

<P>
сохраняет значение 4 в переменной <CODE>x</CODE> и затем выводит значение данного
выражения (которое равно 4).  See section <A HREF="gdb_10.html#SEC62">Использование GDB с различными языками программирования</A>, для получения большей инфоpмации
об операторах в поддерживаемых языках.


<P>
<A NAME="IDX471"></A>
<A NAME="IDX472"></A>
Если вы не хотите видеть значение присваивания, используйте команду
<CODE>set</CODE> вместо <CODE>print</CODE>.  Команда <CODE>set</CODE> аналогична команде
<CODE>print</CODE> за исключением того, что значение выражения не выводится и не
заносится в историю значений (see section <A HREF="gdb_9.html#SEC58">История значений</A>).  Выражение вычисляется только ради его действия.


<P>
Если начало строки параметров команды <CODE>set</CODE> выглядит идентично
подкоманде <CODE>set</CODE>, используйте вместо нее команду <CODE>set
variable</CODE>.  Эта команда аналогична <CODE>set</CODE>, но не имеет подкоманд.
Например, если в вашей программе есть переменная <CODE>width</CODE>, то вы получите
ошибку, если попытаетесь установить новое значение просто с помощью
<SAMP>`set width=13'</SAMP>, потому что GDB имеет команду
<CODE>set width</CODE>:



<PRE>
(gdb) whatis width
type = double
(gdb) p width
$4 = 13
(gdb) set width=47
Invalid syntax in expression.
</PRE>

<P>
Недопустимое выражение, это, конечно, <SAMP>`=47'</SAMP>.  Для того чтобы
действительно установить переменную программы <CODE>width</CODE>, используйте



<PRE>
(gdb) set var width=47
</PRE>

<P>
Так как команда <CODE>set</CODE> имеет много подкоманд, которые могут
конфликтовать с именами переменных в программе, то хорошей практикой
является использование команды <CODE>set variable</CODE> вместо просто
<CODE>set</CODE>.  Например, если ваша программа имеет переменную <CODE>g</CODE>, у
вас возникнут проблемы, если вы попытаетесь установить новое значение
с помощью <SAMP>`set g=4'</SAMP>, потому что GDB имеет команду
<CODE>set gnutarget</CODE>, которая сокращается как <CODE>set g</CODE>:



<PRE>
(gdb) whatis g
type = double
(gdb) p g
$1 = 1
(gdb) set g=4
(gdb) p g
$2 = 1
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/smith/cc_progs/a.out
"/home/smith/cc_progs/a.out": can't open to read symbols:
                                 Invalid bfd target.
(gdb) show g
The current BFD target is "=4".
</PRE>

<P>
Переменная программы <CODE>g</CODE> не изменилась, и вы незаметно установили
<CODE>gnutarget</CODE> в неверное значение.  Для установки значения переменной
<CODE>g</CODE>, используйте



<PRE>
(gdb) set var g=4
</PRE>

<P>
GDB допускает больше неявных преобразований в присваиваниях,
чем Си; вы можете свободно сохранить целое значение в
переменной-указателе и наоборот, преобразовать любую структуру к любой
другой, которая имеет ту же длину или короче.


<P>
Для сохранения значений в произвольных местах
памяти, используйте конструкцию <SAMP>`{...}'</SAMP> для создания
значения определенного типа по определенному адресу памяти
(see section <A HREF="gdb_9.html#SEC51">Выражения</A>).  Например, <CODE>{int}0x83040</CODE>
ссылается на ячейку памяти <CODE>0x83040</CODE> как на целое (что
предполагает соответствующий размер и представление в памяти), и



<PRE>
set {int}0x83040 = 4
</PRE>

<P>
записывает в эту ячейку памяти значение 4.




<H2><A NAME="SEC98" HREF="gdb_toc.html#TOC98">Продолжение исполнения с другого адреса</A></H2>

<P>
Обычно, когда вы продолжаете выполнение программы, вы делаете это
с того места, где она остановилась, командой <CODE>continue</CODE>.  Вместо
этого, вы можете продолжить выполнение с любого выбранного адреса
при помощи следующих команд:


<DL COMPACT>

<DT><CODE>jump <VAR>указ-стр</VAR></CODE>
<DD>
<A NAME="IDX473"></A>
 
Возобновить выполнение со строки <VAR>указ-стр</VAR>.  Если там есть точка
останова, выполнение немедленно прекращается.  See section <A HREF="gdb_8.html#SEC46">Вывод строк исходного текста</A>, для описания различных форм <VAR>указ-стр</VAR>.
Использование команды <CODE>tbreak</CODE> вместе с <CODE>jump</CODE> является
обычной практикой.  See section <A HREF="gdb_6.html#SEC28">Установка точек останова</A>.

Команда <CODE>jump</CODE> не изменяет ни текущий кадр стека, ни
указатель стека, ни содержимое каких-либо ячеек памяти или регистров, кроме
счетчика программы.  Если строка <VAR>указ-стр</VAR> находится вне
выполняющейся в настоящее время функции,
результаты могут быть странными, если эти
функции используют аргументы или локальные переменные разных типов.  По
этой причине, команда <CODE>jump</CODE> запрашивает подтверждение, если
указанная строка не находится в функции, выполняющейся в настоящее
время.  Однако, даже странные результаты предсказуемы, если вы хорошо
знакомы с машинным кодом вашей программы.

<DT><CODE>jump *<VAR>адрес</VAR></CODE>
<DD>
Возобновить выполнение с инструкции, находящейся по адресу <VAR>адрес</VAR>.
</DL>

<P>
На многих системах, вы можете достичь такого же результата, как и с командой
<CODE>jump</CODE>, сохранением нового значения в регистр <CODE>$pc</CODE>.  Отличие в
заключается том, что это не начинает выполнение вашей программы, а лишь
изменяет адрес, с которого <EM>будет</EM> выполняться программа,
когда вы продолжите выполнение.  Например,



<PRE>
set $pc = 0x485
</PRE>

<P>
выполняет следующую команду <CODE>continue</CODE> или команду пошагового
выполнения с адреса <CODE>0x485</CODE>, а не с того адреса, где ваша программа
остановилась.  See section <A HREF="gdb_6.html#SEC37">Продолжение и выполнение по шагам</A>.


<P>
Наиболее общий случай использования команды <CODE>jump</CODE> состоит в
возврате к выполнению части программы, возможно с большим количеством
установленных точек останова, которая уже выполнилась, для того чтобы
исследовать выполнение более детально.




<H2><A NAME="SEC99" HREF="gdb_toc.html#TOC99">Подача сигнала вашей программе</A></H2>

<DL COMPACT>

<DT><CODE>signal <VAR>сигнал</VAR></CODE>
<DD>
<A NAME="IDX474"></A>
 
Возобновить выполнение с места остановки вашей программы, но немедленно
подать ей сигнал <VAR>сигнал</VAR>.  <VAR>Сигнал</VAR> может быть именем или номером
сигнала.  Например, во многих системах <CODE>signal 2</CODE> и <CODE>signal
SIGINT</CODE>---два способа подать сигнал прерывания.

Наоборот, если <VAR>сигнал</VAR> является нулем, выполнение продолжается без
подачи сигнала.  Это полезно, если ваша программа остановилась из-за
сигнала и в обычном случае увидит его при возобновлении выполнения командой
<CODE>continue</CODE>; <SAMP>`signal 0'</SAMP> продолжит выполнение без сигнала.

<CODE>signal</CODE> не повторяется, когда вы нажимаете <KBD>RET</KBD> второй раз
после выполнения команды.
</DL>

<P>
Вызов команды <CODE>signal</CODE> отличается от вызова утилиты <CODE>kill</CODE> из
оболочки.  Подача сигнала посредством <CODE>kill</CODE> заставляет
GDB решать, что делать с сигналом, в зависимости от таблиц
обработки сигналов (see section <A HREF="gdb_6.html#SEC38">Сигналы</A>).  Команда <CODE>signal</CODE> передает
сигнал непосредственно вашей программе.




<H2><A NAME="SEC100" HREF="gdb_toc.html#TOC100">Возврат из функции</A></H2>

<DL COMPACT>

<DT><CODE>return</CODE>
<DD>
<A NAME="IDX475"></A>
 <A NAME="IDX476"></A>
 
<DT><CODE>return <VAR>выражение</VAR></CODE>
<DD>
Вы можете отменить выполнение вызова функции с помощью команды <CODE>return</CODE>.
Если вы задаете параметр <VAR>выражение</VAR>, его значение используется
в качестве возвращаемого значения.
</DL>

<P>
Когда вы используете <CODE>return</CODE>, GDB уничтожает выбранный
кадр стека (и все кадры внутри него).  Вы можете считать это
преждевременным возвратом из уничтоженного кадра.  Если вы хотите
указать возвращаемое значение, задайте его в качестве аргумента к
<CODE>return</CODE>.


<P>
Это выталкивает выбранный кадр стека (see section <A HREF="gdb_7.html#SEC43">Выбор кадра</A>)
и все другие кадры внутри него, оставляя самым внутренним кадр, из
которого произошел вызов.  Этот кадр становится выбранным.  Указанное
значение сохраняется в регистрах, используемых для возвращаемых функцией
значений.


<P>
Команда <CODE>return</CODE> не возобновляет выполнение; она оставляет
программу остановленной в том состоянии, в котором бы она была сразу
после возврата из функции.  Напротив, команда <CODE>finish</CODE>
(see section <A HREF="gdb_6.html#SEC37">Продолжение и выполнение по шагам</A>) возобновляет выполнение до естественного возврата из
выбранного кадра стека.




<H2><A NAME="SEC101" HREF="gdb_toc.html#TOC101">Вызов функций программы</A></H2>

<P>
<A NAME="IDX477"></A>
<A NAME="IDX478"></A>
<DL COMPACT>

<DT><CODE>call <VAR>выраж</VAR></CODE>
<DD>
Вычислить выражение <VAR>выраж</VAR> без отображения пустых (<CODE>void</CODE>)
возвращенных значений.
</DL>

<P>
Вы можете использовать этот вариант команды <CODE>print</CODE>, если хотите
выполнить функцию из вашей программы, не засоряя вывод пустыми возвращенными
значениями.  Если результат не пустой, он выводится и
сохраняется в истории значений.


<P>
Для A29K, устанавливаемая пользователем переменная
<CODE>call_scratch_address</CODE> задает положение рабочей области, которая
будет использоваться, когда GDB вызывает функцию на целевой машине.
Это необходимо, так как обычный метод размещения рабочей области в стеке
не работает в системах с раздельными областями команд и данных.




<H2><A NAME="SEC102" HREF="gdb_toc.html#TOC102">Внесение изменений в программу</A></H2>

<P>
<A NAME="IDX479"></A>
<A NAME="IDX480"></A>
<A NAME="IDX481"></A>


<P>
По умолчанию, GDB открывает файл, содержащий исполняемый код вашей
программы (или файл дампа памяти), в режиме только для чтения.  Это
предотвращает случайные изменения машинного кода; но это также предотвращает
и преднамеренное исправление двоичного файла вашей программы.


<P>
Если вы хотите иметь возможность исправлять двоичный код, вы можете
указать это явно с помощью команды <CODE>set write</CODE>.  Например, вы
можете захотеть установить внутренние флаги отладки или даже сделать
аварийные исправления.


<DL COMPACT>

<DT><CODE>set write on</CODE>
<DD>
<A NAME="IDX482"></A>
 
<DT><CODE>set write off</CODE>
<DD>
Если вы установите <SAMP>`set write on'</SAMP>, GDB открывает исполняемые
файлы и файлы дампов памяти в режиме для чтения и записи; если вы
укажете <SAMP>`set write off'</SAMP> (устанавливается по умолчанию), GDB
открывает их в режиме только для чтения.

Если вы уже загрузили файл, то после установки <CODE>set write</CODE> вам
необходимо загрузить его снова (используя команды <CODE>exec-file</CODE> или
<CODE>core-file</CODE>), чтобы новые установки вступили в силу.

<DT><CODE>show write</CODE>
<DD>
<A NAME="IDX483"></A>
Показать, открыты исполняемые файлы и файлы дампов памяти для
записи или нет.
</DL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_11.html">previous</A>, <A HREF="gdb_13.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
