<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Интерфейс gdb/mi</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_19.html">previous</A>, <A HREF="gdb_21.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC191" HREF="gdb_toc.html#TOC191">Интерфейс GDB/MI</A></H1>



<H2><A NAME="SEC192" HREF="gdb_toc.html#TOC192">Назначение и цель</A></H2>

<P>
<A NAME="IDX868"></A>
GDB/MI является построчным, машинно-ориентированным текстовым
интерфейсом к GDB.  Он предназначен специально для поддержки
разработки систем, которые используют отладчик лишь как одну маленькую
компоненту большой системы.


<P>
Эта глава является спецификацией интерфейса GDB/MI.  Она написана в
форме справочного руководства.


<P>
Заметьте, что GDB/MI все еще находится в стадии разработки, так что
некоторые описанные ниже возможности являются неполными и могут быть изменены.




<H2><A NAME="SEC193" HREF="gdb_toc.html#TOC193">Система обозначений и терминология</A></H2>

<P>
<A NAME="IDX869"></A>
Эта глава использует следующую систему обозначений:



<UL>
<LI>

<CODE>|</CODE> разделяет две альтернативы.

<LI>

<CODE>[ <VAR>нечто</VAR> ]</CODE> указывает, что <VAR>нечто</VAR> является
необязательным: оно может быть задано, а может и нет.

<LI>

<CODE>( <VAR>группа</VAR> )*</CODE> означает, что <VAR>группа</VAR> в скобках может
повторяться ноль и более раз.

<LI>

<CODE>( <VAR>группа</VAR> )+</CODE> означает, что <VAR>группа</VAR> в скобках может 
повторяться один и более раз.

<LI>

<CODE>"<VAR>строка</VAR>"</CODE> обозначает текст <VAR>строка</VAR>.
</UL>


<H2>Выражения признательности</H2>

<P>
В алфавитном порядке: Елена Заннони, Эндрю Кагни, Фернандо Нассер и
Стан Шебс.




<H2><A NAME="SEC194" HREF="gdb_toc.html#TOC194">Синтаксис команд GDB/MI</A></H2>



<H3><A NAME="SEC195" HREF="gdb_toc.html#TOC195">Входной синтаксис GDB/MI</A></H3>

<P>
<A NAME="IDX870"></A>
<A NAME="IDX871"></A>
<DL COMPACT>

<DT><CODE><VAR>команда</VAR> ==></CODE>
<DD>
<CODE><VAR>команда-cli</VAR> | <VAR>команда-mi</VAR></CODE>

<DT><CODE><VAR>команда-cli</VAR> ==></CODE>
<DD>
<CODE>[ <VAR>лексема</VAR> ] <VAR>команда-cli</VAR> <VAR>nl</VAR></CODE>, где
<VAR>команда-cli</VAR> есть любая существующая команда GDB CLI.

<DT><CODE><VAR>команда-mi</VAR> ==></CODE>
<DD>
<CODE>[ <VAR>лексема</VAR> ] "-" <VAR>действие</VAR> ( " " <VAR>ключ</VAR> )*
<CODE>[</CODE> " --" <CODE>]</CODE> ( " " <VAR>параметр</VAR> )* <VAR>nl</VAR></CODE>

<DT><CODE><VAR>лексема</VAR> ==></CODE>
<DD>
"любая последовательность цифр"

<DT><CODE><VAR>ключ</VAR> ==></CODE>
<DD>
<CODE>"-" <VAR>параметр</VAR> [ " " <VAR>параметр</VAR> ]</CODE>

<DT><CODE><VAR>параметр</VAR> ==></CODE>
<DD>
<CODE><VAR>непустая-последовательность</VAR> | <VAR>строка-си</VAR></CODE>

<DT><CODE><VAR>действие</VAR> ==></CODE>
<DD>
<EM>любое из действий, описанных в этой главе</EM>

<DT><CODE><VAR>непустая-последовательность</VAR> ==></CODE>
<DD>
<EM>все что угодно, не содержащее специальных знаков, таких как
"-", <VAR>nl</VAR>, """ и, конечно, " "</EM>

<DT><CODE><VAR>строка-си</VAR> ==></CODE>
<DD>
<CODE>""" <VAR>содержимое-семибитной-строки-iso-си</VAR> """</CODE>

<DT><CODE><VAR>nl</VAR> ==></CODE>
<DD>
<CODE>CR | CR-LF</CODE>
</DL>

<P>
Замечания:



<UL>
<LI>

Команды CLI все еще обрабатываются интерпретатором MI; их вывод
описан ниже.

<LI>

<CODE><VAR>Лексема</VAR></CODE>, если присутствует, передается назад, когда
выполнение команды завершается.

<LI>

Некоторые команды MI допускают необязательные аргументы как часть
списка параметров.  Каждый ключ идентифицируется предшествующей ему
чертой <SAMP>`-'</SAMP>, и за ним может следовать в качестве параметра
необязательный аргумент.  Ключи появляются в начале списка параметров и
могут быть отделены от обычных параметров при помощи <SAMP>`--'</SAMP> (это
полезно, когда некоторые параметры начинаются с черты).
</UL>

<P>
Прагматические соображения:



<UL>
<LI>

Мы хотим получить простой доступ к существующему синтаксису CLI (для отладки).

<LI>

Мы хотим, чтобы работа MI была легко заметна.
</UL>



<H3><A NAME="SEC196" HREF="gdb_toc.html#TOC196">Выходной синтаксис GDB/MI</A></H3>

<P>
<A NAME="IDX872"></A>
<A NAME="IDX873"></A>
Вывод GDB/MI состоит из нуля или более внеочередных
записей, за которыми может следовать одна результирующая запись.  Эта
запись относится к самой последней команде.  Последовательность
выводимых записей завершается <SAMP>`(gdb)'</SAMP>.


<P>
Если входная команда начиналась с префикса <CODE><VAR>лексема</VAR></CODE>, то
соответствующий вывод для этой команды также будет начинаться с того же
префикса <VAR>лексема</VAR>.


<DL COMPACT>

<DT><CODE><VAR>вывод</VAR> ==></CODE>
<DD>
<CODE>( <VAR>внеочередная-запись</VAR> )* [ <VAR>результирующая-запись</VAR> ] "(gdb)" <VAR>nl</VAR></CODE>

<DT><CODE><VAR>результирующая-запись</VAR> ==></CODE>
<DD>
<CODE> [ <VAR>лексема</VAR> ] "^" <VAR>результирующий-класс</VAR> ( "," <VAR>результат</VAR> )* <VAR>nl</VAR></CODE>

<DT><CODE><VAR>внеочередная-запись</VAR> ==></CODE>
<DD>
<CODE><VAR>асинхр-запись</VAR> | <VAR>поточн-запись</VAR></CODE>

<DT><CODE><VAR>асинхр-запись</VAR> ==></CODE>
<DD>
<CODE><VAR>асинхр-вывод-выполн</VAR> | <VAR>асинхр-вывод-статуса</VAR> | <VAR>асинхр-вывод-уведомл</VAR></CODE>

<DT><CODE><VAR>асинхр-вывод-выполн</VAR> ==></CODE>
<DD>
<CODE>[ <VAR>лексема</VAR> ] "*" <VAR>асинхр-вывод</VAR></CODE>

<DT><CODE><VAR>асинхр-вывод-статуса</VAR> ==></CODE>
<DD>
<CODE>[ <VAR>лексема</VAR> ] "+" <VAR>асинхр-вывод</VAR></CODE>

<DT><CODE><VAR>асинхр-вывод-уведомл</VAR> ==></CODE>
<DD>
<CODE>[ <VAR>лексема</VAR> ] "=" <VAR>асинхр-вывод</VAR></CODE>

<DT><CODE><VAR>асинхр-вывод</VAR> ==></CODE>
<DD>
<CODE><VAR>асинхр-класс</VAR> ( "," <VAR>результат</VAR> )* <VAR>nl</VAR></CODE>

<DT><CODE><VAR>результ-класс</VAR> ==></CODE>
<DD>
<CODE>"done" | "running" | "connected" | "error" | "exit"</CODE>

<DT><CODE><VAR>асинхр-класс</VAR> ==></CODE>
<DD>
<CODE>"stopped" | <VAR>другое</VAR></CODE> (где <VAR>другое</VAR> будет добавлено
по необходимости---это все еще находится в стадии разработки).

<DT><CODE><VAR>результат</VAR> ==></CODE>
<DD>
<CODE>[ <VAR>строка</VAR> "=" ] <VAR>значение</VAR></CODE>

<DT><CODE><VAR>значение</VAR> ==></CODE>
<DD>
<CODE><VAR>константа</VAR> | "{" <VAR>результат</VAR> ( "," <VAR>результат</VAR> )* "}"</CODE>

<DT><CODE><VAR>константа</VAR> ==></CODE>
<DD>
<CODE><VAR>строка-си</VAR></CODE>

<DT><CODE><VAR>поточн-запись</VAR> ==></CODE>
<DD>
<CODE><VAR>консольн-поточн-вывод</VAR> | <VAR>целев-поточн-вывод</VAR> | <VAR>журн-поточн-вывод</VAR></CODE>

<DT><CODE><VAR>консольн-поточн-вывод</VAR> ==></CODE>
<DD>
<CODE>"~" <VAR>строка-си</VAR></CODE>

<DT><CODE><VAR>целев-поточн-вывод</VAR> ==></CODE>
<DD>
<CODE>"@" <VAR>строка-си</VAR></CODE>

<DT><CODE><VAR>журн-поточн-вывод</VAR> ==></CODE>
<DD>
<CODE>"&#38;" <VAR>строка-си</VAR></CODE>

<DT><CODE><VAR>nl</VAR> ==></CODE>
<DD>
<CODE>CR | CR-LF</CODE>

<DT><CODE><VAR>лексема</VAR> ==></CODE>
<DD>
<EM>любая последовательность цифр</EM>.
</DL>

<P>
Кроме того, следующее все еще находится в стадии разработки:


<DL COMPACT>

<DT><CODE><VAR>запрос</VAR></CODE>
<DD>
Это действие пока не определено.
</DL>

<P>
Замечания:


<P>

<UL>
<LI>

Все выходные последовательности заканчиваются одной строкой, содержащей
точку.

<LI>

<CODE><VAR>Лексема</VAR></CODE> берется из соответствующего запроса.  Если
выполнение команды прерывается командой <SAMP>`-exec-interrupt'</SAMP>,
<VAR>лексема</VAR>, ассоциированная с сообщением <SAMP>`*stopped'</SAMP>, является
лексемой исходной выполняемой команды, а не лексемой
команды прерывания.

<LI>

<A NAME="IDX874"></A>
<VAR>Асинхр-вывод-статуса</VAR> содержит последующую информацию состояния о
выполнении медленной операции.  Она может быть отброшена.  Весь вывод
состояния начинается с префикса <SAMP>`+'</SAMP>.

<LI>

<A NAME="IDX875"></A>
<VAR>Асинхр-вывод-выполн</VAR> содержит асинхронное изменения состояния на цели
(остановлена, запущена, исчезла).  Весь асинхронный вывод начинается с
префикса <SAMP>`*'</SAMP>.

<LI>

<A NAME="IDX876"></A>
<VAR>Асинхр-вывод-уведомл</VAR> содержит сопровождающую информацию, которую
должен обработать клиент (например, информацию о новой точке останова).
Весь уведомительный вывод начинается с префикса <SAMP>`='</SAMP>.

<LI>

<A NAME="IDX877"></A>
<VAR>Консольн-поточн-вывод</VAR> является выводом, который должен быть
отображен на консоли без изменений.  Он является текстовым
ответом на команду CLI.  Весь консольный вывод начинается с префикса
<SAMP>`~'</SAMP>.

<LI>

<A NAME="IDX878"></A>
<VAR>Целев-поточн-вывод</VAR> является выводом, произведенным целевой
программой.  Весь целевой вывод начинается с префикса <SAMP>`@'</SAMP>.

<LI>

<A NAME="IDX879"></A>
<VAR>Журн-поточн-вывод</VAR> является выходным текстом, происходящим от
внутренней реализации GDB, например, сообщения, которые должны
быть отображены как часть журнала ошибок.  Весь журнальный вывод
начинается с префикса <SAMP>`&#38;'</SAMP>.
</UL>

<P>
See section <A HREF="gdb_20.html#SEC201">Поточные записи GDB/MI</A>, для
более подробной информации о различных выводимых записях.


<P>
See section <A HREF="gdb_20.html#SEC214">Черновик изменений к выходному синтаксису GDB/MI</A>, для предлагаемых изменений
к выходному синтаксису.




<H3><A NAME="SEC197" HREF="gdb_toc.html#TOC197">Простые примеры взаимодействия с GDB/MI</A></H3>
<P>
<A NAME="IDX880"></A>


<P>
Этот подраздел представляет несколько простых примеров взаимодействия с
использованием интерфейса GDB/MI.  В этих примерах, <SAMP>`-&#62;'</SAMP>
означает, что следующая строка передается GDB/MI в качестве ввода,
а <SAMP>`&#60;-'</SAMP> означает вывод, полученный от GDB/MI.



<H4>Останов цели</H4>

<P>
Вот пример останова подчиненного процесса:



<PRE>
-&#62; -stop
&#60;- (gdb)
</PRE>

<P>
и затем:



<PRE>
&#60;- *stop,reason="stop",address="0x123",source="a.c:123"
&#60;- (gdb)
</PRE>


<H4>Простая команда CLI</H4>

<P>
Вот пример простой команды CLI, передаваемой ему через GDB/MI.



<PRE>
-&#62; print 1+2
&#60;- ~3\n
&#60;- (gdb)
</PRE>


<H4>Команда с побочными эффектами</H4>


<PRE>
-&#62; -symbol-file xyz.exe
&#60;- *breakpoint,nr="3",address="0x123",source="a.c:123"
&#60;- (gdb)
</PRE>


<H4>Плохая команда</H4>

<P>
Вот что происходит, если вы передаете несуществующую команду:



<PRE>
-&#62; -rubbish
&#60;- error,"Rubbish not found"
&#60;- (gdb)
</PRE>



<H2><A NAME="SEC198" HREF="gdb_toc.html#TOC198">Совместимость GDB/MI с CLI</A></H2>

<P>
<A NAME="IDX881"></A>
<A NAME="IDX882"></A>
Чтобы помочь пользователям, знакомым с существующим в GDB
интерфейсом CLI, GDB/MI принимает существующие команды CLI.
Как определено синтаксисом, такие команды могут быть непосредственно
введены в интерфейс GDB/MI, и GDB будет отвечать.


<P>
Этот механизм предоставляется для помощи разработчикам клиентов
GDB/MI, а не как надежный интерфейс к CLI.  Так как команда
интерпретируется в среде, которая подразумевает поведение GDB/MI,
точные результаты таких команд в конечном итоге скорее всего
станут неудобоваримой смесью вывода GDB/MI и CLI.




<H2><A NAME="SEC199" HREF="gdb_toc.html#TOC199">Выходные записи GDB/MI</A></H2>



<H3><A NAME="SEC200" HREF="gdb_toc.html#TOC200">Результирующие записи GDB/MI</A></H3>

<P>
<A NAME="IDX883"></A>
<A NAME="IDX884"></A>
В дополнение к множеству внеочередных уведомлений, ответ на команду
GDB/MI включает один из следующих указателей результата:


<DL COMPACT>

<DT><CODE>"^done" [ "," <VAR>результаты</VAR> ]</CODE>
<DD>
<A NAME="IDX885"></A>
 
Синхронная операция прошла успешно, возвращаемыми значениями являются
<CODE><VAR>результаты</VAR></CODE>.

<DT><CODE>"^running"</CODE>
<DD>
<A NAME="IDX886"></A>
Асинхронная операция была успешно начата.  Цель выполняется.

<DT><CODE>"^error" "," <VAR>строка-си</VAR></CODE>
<DD>
<A NAME="IDX887"></A>
Операция завершилась с ошибкой.  <CODE><VAR>Строка-си</VAR></CODE> содержит
соответствующее сообщение об ошибке.
</DL>



<H3><A NAME="SEC201" HREF="gdb_toc.html#TOC201">Поточные записи GDB/MI</A></H3>

<P>
<A NAME="IDX888"></A>
<A NAME="IDX889"></A>
GDB хранит число выходных потоков: консоль, цель и журнал.
Вывод, предназначенный для этих потоков, пропускается через интерфейс
GDB/MI при помощи <EM>поточных записей</EM>.


<P>
Каждая поточная запись начинается с уникального <EM>префиксного
символа</EM>, который идентифицирует свой поток (see section <A HREF="gdb_20.html#SEC196">Выходной синтаксис GDB/MI</A>).  Помимо префикса, каждая
поточная запись содержит <CODE><VAR>строку-вывод</VAR></CODE>.  Это либо простой
текст (с подразумеваемым знаком новой строки), или Си-строка в кавычках
(которая не содержит подразумеваемого знака новой строки).


<DL COMPACT>

<DT><CODE>"~" <VAR>строка-вывод</VAR></CODE>
<DD>
Консольный поток вывода содержит текст, который должен быть отображен в
консольном окне CLI.  Он содержит текстовые ответы на команды CLI.

<DT><CODE>"@" <VAR>строка-вывод</VAR></CODE>
<DD>
Целевой поток вывода содержит произвольный текстовый вывод от
выполняемой цели.

<DT><CODE>"&#38;" <VAR>строка-вывод</VAR></CODE>
<DD>
Журнальный поток содержит отладочные сообщения, которые создает сам
GDB.
</DL>



<H3><A NAME="SEC202" HREF="gdb_toc.html#TOC202">Внеочередные записи GDB/MI</A></H3>

<P>
<A NAME="IDX890"></A>
<A NAME="IDX891"></A>
<EM>Внеочередные</EM> записи используются для уведомления клиента GDB/MI
о произошедших дополнительных изменениях.  Эти изменения могут либо
исходить от GDB/MI (например, измененная точка останова), либо быть
результатом действий цели (например, цель остановилась).


<P>
Ниже приведен предварительный список возможных внеочередных записей.


<DL COMPACT>

<DT><CODE>"*" "stop"</CODE>
<DD>
</DL>



<H2><A NAME="SEC203" HREF="gdb_toc.html#TOC203">Формат описания команд GDB/MI</A></H2>

<P>
Оставшиеся разделы описывают блоки команд.  Каждый блок команд
схематично аналогичен этому разделу.


<P>
Заметьте, что разбиения строк в примерах присутствуют только для
удобства чтения.  Они не появляются в реальном выводе.  Учтите также,
что команды с недоступными примерами (Н.П.) еще не реализованы.



<H3>Мотивация</H3>

<P>
Мотивация для этого набора команд.



<H3>Введение</H3>

<P>
Краткое введение в этот набор команд в целом.



<H3>Команды</H3>

<P>
Для каждой команды в блоке, описано следующее:



<H4>Краткое описание</H4>


<PRE>
 -command <VAR>арг</VAR>...
</PRE>


<H4>Команда GDB</H4>

<P>
Соответствующая команда CLI GDB.



<H4>Результат</H4>


<H4>Внеочередные сообщения</H4>


<H4>Примечания</H4>


<H4>Пример</H4>



<H2><A NAME="SEC204" HREF="gdb_toc.html#TOC204">Команды GDB/MI для таблицы точек останова</A></H2>

<P>
<A NAME="IDX892"></A>
<A NAME="IDX893"></A>
Этот раздел описывает команды GDB/MI для управления точками
останова.



<H3>Команда <CODE>-break-after</CODE></H3>
<P>
<A NAME="IDX894"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-after <VAR>номер</VAR> <VAR>число</VAR>
</PRE>

<P>
Точка останова с номером <VAR>номер</VAR> не срабатывает, пока она не будет
достигнута <VAR>число</VAR> раз.  Чтобы увидеть, как это отражается на выводе
команды <SAMP>`-break-list'</SAMP>, смотрите ниже описание команды
<SAMP>`-break-list'</SAMP>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`ignore'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-insert main
^done,bkpt={number="1",addr="0x000100d0",file="hello.c",line="5"}
(gdb)
-break-after 1 3
~
^done
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x000100d0",func="main",file="hello.c",line="5",times="0",
ignore="3"}}
(gdb)
</PRE>


<H3>Команда <CODE>-break-condition</CODE></H3>
<P>
<A NAME="IDX895"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-condition <VAR>номер</VAR> <VAR>выраж</VAR>
</PRE>

<P>
Точка останова <VAR>номер</VAR> остановит программу, только если условие
<VAR>выраж</VAR> истино.  Условие становится частью вывода <SAMP>`-break-list'</SAMP>
(смотрите ниже описание команды <SAMP>`-break-list'</SAMP>).



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`condition'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-condition 1 1
^done
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x000100d0",func="main",file="hello.c",line="5",cond="1",
times="0",ignore="3"}}
(gdb)
</PRE>


<H3>Команда <CODE>-break-delete</CODE></H3>
<P>
<A NAME="IDX896"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-delete ( <VAR>точка-останова</VAR> )+
</PRE>

<P>
Удалить точки останова, чьи номера указаны в списке аргументов.  Это,
очевидно, отражается на списке точек останова.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`delete'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-delete 1
^done
(gdb)
-break-list
^done,BreakpointTable={}
(gdb)
</PRE>


<H3>Команда <CODE>-break-disable</CODE></H3>
<P>
<A NAME="IDX897"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-disable ( <VAR>точка-останова</VAR> )+
</PRE>

<P>
Отключить упомянутые <VAR>точки-останова</VAR>.  Для указанных
<VAR>точек-останова</VAR> поле <SAMP>`enabled'</SAMP> в списке точек останова
теперь установлено в <SAMP>`n'</SAMP>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`disable'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-disable 2
^done
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="2",type="breakpoint",disp="keep",enabled="n",
addr="0x000100d0",func="main",file="hello.c",line="5",times="0"}}
(gdb)
</PRE>


<H3>Команда <CODE>-break-enable</CODE></H3>
<P>
<A NAME="IDX898"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-enable ( <VAR>точка-останова</VAR> )+
</PRE>

<P>
Включить (ранее отключенные) <VAR>точки-останова</VAR>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`enable'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-enable 2
^done
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="2",type="breakpoint",disp="keep",enabled="y",
addr="0x000100d0",func="main",file="hello.c",line="5",times="0"}}
(gdb)
</PRE>


<H3>Команда <CODE>-break-info</CODE></H3>
<P>
<A NAME="IDX899"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-info <VAR>точка-останова</VAR>
</PRE>

<P>
Получить информацию об одной точке останова.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info break
<VAR>точка-останова</VAR>'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-break-insert</CODE></H3>
<P>
<A NAME="IDX900"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-insert [ -t ] [ -h ] [ -r ]
    [ -c <VAR>условие</VAR> ] [ -i <VAR>счетчик-игнорирований</VAR> ]
    [ -p <VAR>нить</VAR> ] [ <VAR>строка</VAR> | <VAR>адрес</VAR> ]
</PRE>

<P>
<VAR>Строка</VAR>, если указана, может быть одной из:



<UL>
<LI>функция

<LI>имя-файла:номер-строки

<LI>имя-файла:функция

<LI>*адрес

</UL>

<P>
Вот возможные необязательные параметры этой команды:


<DL COMPACT>

<DT><SAMP>`-t'</SAMP>
<DD>
Вставить временную точку останова.
<DT><SAMP>`-h'</SAMP>
<DD>
Вставить аппаратную точку останова.
<DT><SAMP>`-c <VAR>условие</VAR>'</SAMP>
<DD>
Сделать точку останова условной с заданным <VAR>условием</VAR>.
<DT><SAMP>`-i <VAR>счетчик-игнорирований</VAR>'</SAMP>
<DD>
Инициализировать <VAR>счетчик-игнорирований</VAR>.
<DT><SAMP>`-r'</SAMP>
<DD>
Вставить обычную точку останова во всех функциях, чьи имена
удовлетворяют данному регулярному выражению.  Другие флаги к регулярному
выражению неприменимы.
</DL>


<H4>Результат</H4>

<P>
Результат имеет форму:



<PRE>
 ^done,bkptno="<VAR>номер</VAR>",func="<VAR>имя-функции</VAR>",
  file="<VAR>имя-файла</VAR>",line="<VAR>ном-строки</VAR>"
</PRE>

<P>
где <VAR>номер</VAR> является номером этой точки останова в GDB,
<VAR>имя-функции</VAR>---имя функции, в которой была вставлена точка
останова, <VAR>имя-файла</VAR>---имя исходного файла, в котором находится эта
функция, а <VAR>ном-строки</VAR> является номером строки исходного текста в
этом файле.


<P>
Замечание: этот формат может изменяться.



<H4>Команда GDB</H4>

<P>
Соответстующими командами GDB являются <SAMP>`break'</SAMP>,
<SAMP>`tbreak'</SAMP>, <SAMP>`hbreak'</SAMP>, <SAMP>`thbreak'</SAMP> и <SAMP>`rbreak'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-insert main
^done,bkpt={number="1",addr="0x0001072c",file="recursive2.c",line="4"}
(gdb)
-break-insert -t foo
^done,bkpt={number="2",addr="0x00010774",file="recursive2.c",line="11"}
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x0001072c", func="main",file="recursive2.c",line="4",times="0"},
bkpt={number="2",type="breakpoint",disp="del",enabled="y",
addr="0x00010774",func="foo",file="recursive2.c",line="11",times="0"}}
(gdb)
-break-insert -r foo.*
~int foo(int, int);
^done,bkpt={number="3",addr="0x00010774",file="recursive2.c",line="11"}
(gdb)
</PRE>


<H3>Команда <CODE>-break-list</CODE></H3>
<P>
<A NAME="IDX901"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-list
</PRE>

<P>
Отображает список установленных точек останова, показывая следующие
поля:


<DL COMPACT>

<DT><SAMP>`Number'</SAMP>
<DD>
номер точки останова
<DT><SAMP>`Type'</SAMP>
<DD>
тип точки останова: <SAMP>`breakpoint'</SAMP> или <SAMP>`watchpoint'</SAMP>
<DT><SAMP>`Disposition'</SAMP>
<DD>
эта точка останова должна быть удалена или отключена при срабатывании:
<SAMP>`keep'</SAMP> или <SAMP>`nokeep'</SAMP>
<DT><SAMP>`Enabled'</SAMP>
<DD>
включена точка останова или нет: <SAMP>`y'</SAMP> или <SAMP>`n'</SAMP>
<DT><SAMP>`Address'</SAMP>
<DD>
местоположение в памяти, где установлена точка останова
<DT><SAMP>`What'</SAMP>
<DD>
логическое положение точки останова, выраженное именем функции, именем
файла, номером строки
<DT><SAMP>`Times'</SAMP>
<DD>
Число раз, которое точка останова срабатывала
</DL>

<P>
Если точек останова или наблюдения нет, поле <CODE>BreakpointTable</CODE> является
пустым списком.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info break'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x000100d0",func="main",file="hello.c",line="5",times="0"},
bkpt={number="2",type="breakpoint",disp="keep",enabled="y",
addr="0x00010114",func="foo",file="hello.c",line="13",times="0"}}
(gdb)
</PRE>

<P>
Вот пример результата, когда точек останова нет:



<PRE>
(gdb)
-break-list
^done,BreakpointTable={}
(gdb)
</PRE>


<H3>Команда <CODE>-break-watch</CODE></H3>
<P>
<A NAME="IDX902"></A>



<H4>Краткое описание</H4>


<PRE>
 -break-watch [ -a | -r ]
</PRE>

<P>
Создать точку наблюдения.  С ключем <SAMP>`-a'</SAMP> будет создана точка
наблюдения за <EM>доступом</EM>, то есть такая точка наблюдения, которая
срабатывает либо при чтении, либо при записи в определенное
местоположение в памяти.  С ключем <SAMP>`-r'</SAMP> созданная точка наблюдения
будет точкой наблюдения за <EM>чтением</EM>, то есть она будет срабатывать
только когда к определенному местоположению в памяти осуществляется доступ на
чтение.  Без этих ключей будет создана обычная точка наблюдения, то есть
она будет срабатывать, когда к местоположению в памяти осуществляется
доступ для записи.
See section <A HREF="gdb_6.html#SEC29">Установка точек наблюдения</A>.


<P>
Заметьте, что <SAMP>`-break-list'</SAMP> выдаст единый список установленных
точек наблюдения и останова.



<H4>Комада GDB</H4>

<P>
Соответствующими командами GDB являются <SAMP>`watch'</SAMP>,
<SAMP>`awatch'</SAMP> и <SAMP>`rwatch'</SAMP>.



<H4>Пример</H4>

<P>
Установка точки наблюдения за переменной в функции <CODE>main</CODE>:



<PRE>
(gdb)
-break-watch x
^done,wpt={number="2",exp="x"}
(gdb)
-exec-continue
^running
^done,reason="watchpoint-trigger",wpt={number="2",exp="x"},
value={old="-268439212",new="55"},
frame={func="main",args={},file="recursive2.c",line="5"}
(gdb)
</PRE>

<P>
Установка точки наблюдения за локальной переменной функции.
GDB дважды остановит выполнение программы: сначала при
изменении значения переменной, затем при выходе точки наблюдения из
области видимости.



<PRE>
(gdb)
-break-watch C
^done,wpt={number="5",exp="C"}
(gdb)
-exec-continue
^running
^done,reason="watchpoint-trigger",
wpt={number="5",exp="C"},value={old="-276895068",new="3"},
frame={func="callee4",args={},
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="13"}
(gdb)
-exec-continue
^running
^done,reason="watchpoint-scope",wpnum="5",
frame={func="callee3",args={{name="strarg",
value="0x11940 \"A string argument.\""}},
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
(gdb)
</PRE>

<P>
Список точек останова и наблюдения, в разных местах выполнения
программы.  Заметьте, что как только точка наблюдения выходит из области
видимости, она удаляется.



<PRE>
(gdb)
-break-watch C
^done,wpt={number="2",exp="C"}
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x00010734",func="callee4",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"},
bkpt={number="2",type="watchpoint",disp="keep",
enabled="y",addr="",what="C",times="0"}}
(gdb)
-exec-continue
^running
^done,reason="watchpoint-trigger",wpt={number="2",exp="C"},
value={old="-276895068",new="3"},
frame={func="callee4",args={},
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="13"}
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x00010734",func="callee4",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"},
bkpt={number="2",type="watchpoint",disp="keep",
enabled="y",addr="",what="C",times="-5"}}
(gdb)
-exec-continue
^running
^done,reason="watchpoint-scope",wpnum="2",
frame={func="callee3",args={{name="strarg",
value="0x11940 \"A string argument.\""}},
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
(gdb)
-break-list
^done,BreakpointTable={hdr={"Num","Type","Disp","Enb","Address","What"},
bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
addr="0x00010734",func="callee4",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"}}
(gdb)
</PRE>



<H2><A NAME="SEC205" HREF="gdb_toc.html#TOC205">Управление данными GDB/MI</A></H2>

<P>
<A NAME="IDX903"></A>
<A NAME="IDX904"></A>
Этот раздел описывает команды GDB/MI для управления данными:
исследование памяти и регистров, вычисление выражений, и так далее.



<H3>Команда <CODE>-data-disassemble</CODE></H3>
<P>
<A NAME="IDX905"></A>



<H4>Краткое описание</H4>


<PRE>
 -data-disassemble
    [ -s <VAR>нач-адр</VAR> -e <VAR>кон-адр</VAR> ]
  | [ -f <VAR>имя-файла</VAR> -l <VAR>ном-строки</VAR> [ -n <VAR>ст</VAR> ] ]
  -- <VAR>режим</VAR>
</PRE>

<P>
Где:


<DL COMPACT>

<DT><SAMP>`<VAR>нач-адр</VAR>'</SAMP>
<DD>
начальный адрес (или <CODE>$pc</CODE>)
<DT><SAMP>`<VAR>кон-адр</VAR>'</SAMP>
<DD>
конечный адрес
<DT><SAMP>`<VAR>имя-файла</VAR>'</SAMP>
<DD>
имя файла для дисассемблирования
<DT><SAMP>`<VAR>ном-строки</VAR>'</SAMP>
<DD>
номер строки, в районе которой проводить дисассемблирование
<DT><SAMP>`<VAR>ст</VAR>'</SAMP>
<DD>
число строк дисассемблирования, которое необходимо произвести.  Если
равно -1 и <VAR>кон-адр</VAR> не указан, то будет дисассемблирована целая
функция.  Если <VAR>кон-адр</VAR> указан и не равен нулю, и
<VAR>ст</VAR> меньше, чем количество строк дисассемблирования между
<VAR>нач-адр</VAR> и <VAR>кон-адр</VAR>, отображаются только <VAR>ст</VAR> строк.
Если <VAR>ст</VAR> больше, чем число строк между <VAR>нач-адр</VAR> и
<VAR>кон-адр</VAR>, отображаются только строки до <VAR>кон-адр</VAR>.
<DT><SAMP>`<VAR>режим</VAR>'</SAMP>
<DD>
либо 0 (означает только результат дисассемблирования), либо 1 (означает
смесь исходного текста и результата дисассемблирования).
</DL>


<H4>Результат</H4>

<P>
Вывод для каждой инструкции состоит из четырех полей:



<UL>
<LI>Адрес

<LI>Имя-Функции

<LI>Смещение

<LI>Инструкция

</UL>

<P>
Заметьте, что то, что включено в поле инструкции, не обрабатывается
непосредственно GDB/MI, то есть изменить его формат невозможно.



<H4>Команда GDB</H4>

<P>
Непосредственного отображения этой команды в CLI нет.



<H4>Пример</H4>

<P>
Дисассемблирование от текущего значения <CODE>$pc</CODE> до <CODE>$pc + 20</CODE>:



<PRE>
(gdb)
-data-disassemble -s $pc -e "$pc + 20" -- 0
^done,
asm_insns={
{address="0x000107c0",func-name="main",offset="4",
inst="mov  2, %o0"},
{address="0x000107c4",func-name="main",offset="8",
inst="sethi  %hi(0x11800), %o2"},
{address="0x000107c8",func-name="main",offset="12",
inst="or  %o2, 0x140, %o1\t! 0x11940 &#60;_lib_version+8&#62;"},
{address="0x000107cc",func-name="main",offset="16",
inst="sethi  %hi(0x11800), %o2"},
{address="0x000107d0",func-name="main",offset="20",
inst="or  %o2, 0x168, %o4\t! 0x11968 &#60;_lib_version+48&#62;"}}
(gdb)
</PRE>

<P>
Дисассемблирование всей функции <CODE>main</CODE>.  Строка 32 является частью
<CODE>main</CODE>.



<PRE>
-data-disassemble -f basics.c -l 32 -- 0
^done,asm_insns={
{address="0x000107bc",func-name="main",offset="0",
inst="save  %sp, -112, %sp"},
{address="0x000107c0",func-name="main",offset="4",
inst="mov   2, %o0"},
{address="0x000107c4",func-name="main",offset="8",
inst="sethi %hi(0x11800), %o2"},
[...]
{address="0x0001081c",func-name="main",offset="96",inst="ret "},
{address="0x00010820",func-name="main",offset="100",inst="restore "}}
(gdb)
</PRE>

<P>
Дисассемблирование 3 инструкций от начала <CODE>main</CODE>:



<PRE>
(gdb)
-data-disassemble -f basics.c -l 32 -n 3 -- 0
^done,asm_insns={
{address="0x000107bc",func-name="main",offset="0",
inst="save  %sp, -112, %sp"},
{address="0x000107c0",func-name="main",offset="4",
inst="mov  2, %o0"},
{address="0x000107c4",func-name="main",offset="8",
inst="sethi  %hi(0x11800), %o2"}}
(gdb)
</PRE>

<P>
Дисассемблирование 3 инструкций от начала <CODE>main</CODE> в смешаном режиме:



<PRE>
(gdb)
-data-disassemble -f basics.c -l 32 -n 3 -- 1
^done,asm_insns={
src_and_asm_line={line="31",
file="/kwikemart/marge/ezannoni/flathead-dev/devo/gdb/ \
  testsuite/gdb.mi/basics.c",line_asm_insn={
{address="0x000107bc",func-name="main",offset="0",
inst="save  %sp, -112, %sp"}}},

src_and_asm_line={line="32",
file="/kwikemart/marge/ezannoni/flathead-dev/devo/gdb/ \
  testsuite/gdb.mi/basics.c",line_asm_insn={
{address="0x000107c0",func-name="main",offset="4",
inst="mov  2, %o0"},
{address="0x000107c4",func-name="main",offset="8",
inst="sethi  %hi(0x11800), %o2"}}}}
(gdb)
</PRE>


<H3>Команда <CODE>-data-evaluate-expression</CODE></H3>
<P>
<A NAME="IDX906"></A>



<H4>Краткое описание</H4>


<PRE>
 -data-evaluate-expression <VAR>выраж</VAR>
</PRE>

<P>
Вычислить выражение <VAR>выраж</VAR>.  Выражение может содержать подчиненный
вызов функции.  Вызов функции быдет выполнен синхронно.  Если выражение
содержит пробелы, оно должно быть заключено в двойные кавычки.



<H4>Команда GDB</H4>

<P>
Соответствующими командами GDB являются <SAMP>`print'</SAMP>,
<SAMP>`output'</SAMP> и <SAMP>`call'</SAMP>.  В <CODE>gdbtk</CODE> есть
соответствующая команда <SAMP>`gdb_eval'</SAMP>.



<H4>Пример</H4>

<P>
В следующем примере числа, предшествующие командам, суть <EM>лексемы</EM>.
Для их описания, см. section <A HREF="gdb_20.html#SEC194">Синтаксис команд GDB/MI</A>.  Обратите внимание на то, как GDB/MI возвращает
те же лексемы в своем выводе.



<PRE>
211-data-evaluate-expression A
211^done,value="1"
(gdb)
311-data-evaluate-expression &#38;A
311^done,value="0xefffeb7c"
(gdb)
411-data-evaluate-expression A+3
411^done,value="4"
(gdb)
511-data-evaluate-expression "A + 3"
511^done,value="4"
(gdb)
</PRE>


<H3>Команда <CODE>-data-list-changed-registers</CODE></H3>
<P>
<A NAME="IDX907"></A>



<H4>Краткое описание</H4>


<PRE>
 -data-list-changed-registers
</PRE>

<P>
Выводит список регистров, которые изменились.



<H4>Команда GDB</H4>

<P>
GDB не имеет прямого аналога этой команды; соответствующей
командой <CODE>gdbtk</CODE> является <SAMP>`gdb_changed_register_list'</SAMP>.



<H4>Пример</H4>

<P>
На плате PPC MBX:



<PRE>
(gdb)
-exec-continue
^running

(gdb)
*stopped,reason="breakpoint-hit",bkptno="1",frame={func="main",
args={},file="try.c",line="5"}
(gdb)
-data-list-changed-registers
^done,changed-registers={"0","1","2","4","5","6","7","8","9",
"10","11","13","14","15","16","17","18","19","20","21","22","23",
"24","25","26","27","28","30","31","64","65","66","67","69"}
(gdb)
</PRE>


<H3>Команда <CODE>-data-list-register-names</CODE></H3>
<P>
<A NAME="IDX908"></A>



<H4>Краткое описание</H4>


<PRE>
 -data-list-register-names [ ( <VAR>ном-рег</VAR> )+ ]
</PRE>

<P>
Показать список имен регистров текущей цели.  Если аргументы не заданы,
показывается список имен всех регистров.  Если в качестве аргументов
заданы целые числа, команда напечатает список имен регистров,
соответствующих аргументам.



<H4>Команда GDB</H4>

<P>
В GDB нет команды, которая соответствует
<SAMP>`-data-list-register-names'</SAMP>.  В <CODE>gdbtk</CODE> соответствующей
командой является <SAMP>`gdb_regnames'</SAMP>.



<H4>Пример</H4>

<P>
Для платы PPC MBX:

<PRE>
(gdb)
-data-list-register-names
^done,register-names={"r0","r1","r2","r3","r4","r5","r6","r7",
"r8","r9","r10","r11","r12","r13","r14","r15","r16","r17","r18",
"r19","r20","r21","r22","r23","r24","r25","r26","r27","r28","r29",
"r30","r31","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9",
"f10","f11","f12","f13","f14","f15","f16","f17","f18","f19","f20",
"f21","f22","f23","f24","f25","f26","f27","f28","f29","f30","f31",
"pc","ps","cr","lr","ctr","xer"}
(gdb)
-data-list-register-names 1 2 3
^done,register-names={"r1","r2","r3"}
(gdb)
</PRE>


<H3>Команда <CODE>-data-list-register-values</CODE></H3>
<P>
<A NAME="IDX909"></A>



<H4>Краткое описание</H4>


<PRE>
 -data-list-register-values <VAR>фмт</VAR> [ ( <VAR>ном-рег</VAR> )*]
</PRE>

<P>
Отобразить содержимое регистров.  <VAR>Фмт</VAR> является форматом, в
соответствии с которым должно быть возвращено содержимое регистров, за
которым следует необязательный список чисел, указывающих регистры,
подлежащие отображению.  Отсутствие списка чисел означает, что должно быть
возвращено содержимое всех регистров.


<P>
Вот допустимые форматы для <VAR>фмт</VAR>:


<DL COMPACT>

<DT><CODE>x</CODE>
<DD>
Шестнадцатеричный
<DT><CODE>o</CODE>
<DD>
Восьмеричный
<DT><CODE>t</CODE>
<DD>
Двоичный
<DT><CODE>d</CODE>
<DD>
Десятичный
<DT><CODE>r</CODE>
<DD>
Без преобразования
<DT><CODE>N</CODE>
<DD>
Натуральный
</DL>


<H4>Команда GDB</H4>

<P>
Соответствующими командами GDB являются <SAMP>`info reg'</SAMP>,
<SAMP>`info all-reg'</SAMP> и (в <CODE>gdbtk</CODE>) <SAMP>`gdb_fetch_registers'</SAMP>.



<H4>Пример</H4>

<P>
Для платы PPC MBX (имейте ввиду: переносы строк даны только для удобства
чтения, они не появляются в реальном выводе):



<PRE>
(gdb)
-data-list-register-values r 64 65
^done,register-values={{number="64",value="0xfe00a300"},
{number="65",value="0x00029002"}}
(gdb)
-data-list-register-values x
^done,register-values={{number="0",value="0xfe0043c8"},
{number="1",value="0x3fff88"},{number="2",value="0xfffffffe"},
{number="3",value="0x0"},{number="4",value="0xa"},
{number="5",value="0x3fff68"},{number="6",value="0x3fff58"},
{number="7",value="0xfe011e98"},{number="8",value="0x2"},
{number="9",value="0xfa202820"},{number="10",value="0xfa202808"},
{number="11",value="0x1"},{number="12",value="0x0"},
{number="13",value="0x4544"},{number="14",value="0xffdfffff"},
{number="15",value="0xffffffff"},{number="16",value="0xfffffeff"},
{number="17",value="0xefffffed"},{number="18",value="0xfffffffe"},
{number="19",value="0xffffffff"},{number="20",value="0xffffffff"},
{number="21",value="0xffffffff"},{number="22",value="0xfffffff7"},
{number="23",value="0xffffffff"},{number="24",value="0xffffffff"},
{number="25",value="0xffffffff"},{number="26",value="0xfffffffb"},
{number="27",value="0xffffffff"},{number="28",value="0xf7bfffff"},
{number="29",value="0x0"},{number="30",value="0xfe010000"},
{number="31",value="0x0"},{number="32",value="0x0"},
{number="33",value="0x0"},{number="34",value="0x0"},
{number="35",value="0x0"},{number="36",value="0x0"},
{number="37",value="0x0"},{number="38",value="0x0"},
{number="39",value="0x0"},{number="40",value="0x0"},
{number="41",value="0x0"},{number="42",value="0x0"},
{number="43",value="0x0"},{number="44",value="0x0"},
{number="45",value="0x0"},{number="46",value="0x0"},
{number="47",value="0x0"},{number="48",value="0x0"},
{number="49",value="0x0"},{number="50",value="0x0"},
{number="51",value="0x0"},{number="52",value="0x0"},
{number="53",value="0x0"},{number="54",value="0x0"},
{number="55",value="0x0"},{number="56",value="0x0"},
{number="57",value="0x0"},{number="58",value="0x0"},
{number="59",value="0x0"},{number="60",value="0x0"},
{number="61",value="0x0"},{number="62",value="0x0"},
{number="63",value="0x0"},{number="64",value="0xfe00a300"},
{number="65",value="0x29002"},{number="66",value="0x202f04b5"},
{number="67",value="0xfe0043b0"},{number="68",value="0xfe00b3e4"},
{number="69",value="0x20002b03"}}
(gdb)
</PRE>


<H3>Команда <CODE>-data-read-memory</CODE></H3>
<P>
<A NAME="IDX910"></A>



<H4>Краткое описание</H4>


<PRE>
 -data-read-memory [ -o <VAR>смещение</VAR> ]
   <VAR>адрес</VAR> <VAR>формат-слова</VAR> <VAR>размер-слова</VAR>
   <VAR>число-строк</VAR> <VAR>число-колонок</VAR> [ <VAR>asсимв</VAR> ]
</PRE>

<P>
где:


<DL COMPACT>

<DT><SAMP>`<VAR>адрес</VAR>'</SAMP>
<DD>
Выражение, определяющее адрес в памяти первого слова, которое надо
прочитать.  Сложные выражения, содержащие пробельные символы, должны
заключаться в кавычки с использованием соглашений Си.

<DT><SAMP>`<VAR>формат-слова</VAR>'</SAMP>
<DD>
Формат, который должен быть использован для печати слов памяти.
Обозначения те же, что и для команды GDB <CODE>print</CODE>
(see section <A HREF="gdb_9.html#SEC54">Форматы вывода</A>).

<DT><SAMP>`<VAR>размер-слова</VAR>'</SAMP>
<DD>
Размер в байтах каждого слова в памяти.

<DT><SAMP>`<VAR>число-строк</VAR>'</SAMP>
<DD>
Число строк в выходной таблице.

<DT><SAMP>`<VAR>число-колонок</VAR>'</SAMP>
<DD>
Число колонок в выходной таблице.

<DT><SAMP>`<VAR>asсимв</VAR>'</SAMP>
<DD>
В настоящее время означает, что каждая строка должна включать
ASCII-дамп.  Значение <VAR>asсимв</VAR> используется в качестве
заполняющего символа, когда байт не является элементом набора печатных
знаков ASCII (печатные знаки ASCII это те знаки, чьи коды
находятся между 32 и 126 включительно).

<DT><SAMP>`<VAR>смещение</VAR>'</SAMP>
<DD>
Смещение, которое надо добавить к <VAR>адресу</VAR> перед тем, как начать
извлечение из памяти.
</DL>

<P>
Эта команда отображает содержимое памяти в виде таблицы из
<VAR>число-строк</VAR> на <VAR>число-колонок</VAR> слов, причем каждое слово
занимает <VAR>размер-слова</VAR> байт.  В общей сложности считывается
<CODE><VAR>число-строк</VAR> * <VAR>число-колонок</VAR> * <VAR>размер-слова</VAR></CODE>
байт (возвращается как <SAMP>`total-bytes'</SAMP>).  Если цель должна возвратить
меньше запрошенного числа байт, отсутствующие слова идентифицируются при
помощи <SAMP>`N/A'</SAMP>.  Число байт, прочитанное с цели, возвращается в
<SAMP>`nr-bytes'</SAMP>, а начальный адрес, использованный для чтении памяти, в
<SAMP>`addr'</SAMP>.


<P>
Адрес следующей/предыдущей строки или страницы доступен в
<SAMP>`next-row'</SAMP> и <SAMP>`prev-row'</SAMP>, <SAMP>`next-page'</SAMP> и <SAMP>`prev-page'</SAMP>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`x'</SAMP>.  <CODE>gdbtk</CODE>
имеет команду чтения памяти <SAMP>`gdb_get_mem'</SAMP>.



<H4>Пример</H4>

<P>
Прочитать шесть байт памяти, начиная с <CODE>bytes+6</CODE>, но сместиться на
<CODE>-6</CODE> байт.  Форматировать в три ряда по две колонки.  Один байт на
слово.  Отображать каждое слово в шестнадцатеричном виде.



<PRE>
(gdb)
9-data-read-memory -o -6 -- bytes+6 x 1 3 2
9^done,addr="0x00001390",nr-bytes="6",total-bytes="6",
next-row="0x00001396",prev-row="0x0000138e",next-page="0x00001396",
prev-page="0x0000138a",memory={
{addr="0x00001390",data={"0x00","0x01"}},
{addr="0x00001392",data={"0x02","0x03"}},
{addr="0x00001394",data={"0x04","0x05"}}}
(gdb)
</PRE>

<P>
Прочитать два байта памяти, начиная с адреса <CODE>shorts + 64</CODE> и
отобразить в виде одного слова в десятичном виде.



<PRE>
(gdb)
5-data-read-memory shorts+64 d 2 1 1
5^done,addr="0x00001510",nr-bytes="2",total-bytes="2",
next-row="0x00001512",prev-row="0x0000150e",
next-page="0x00001512",prev-page="0x0000150e",memory={
{addr="0x00001510",data={"128"}}}
(gdb)
</PRE>

<P>
Прочитать тридцать два байта памяти, начиная с <CODE>bytes+16</CODE>, и
форматировать на восемь рядов по четыре колонки.  Включить строку,
закодированную с использованием <SAMP>`x'</SAMP> в качестве непечатного символа.



<PRE>
(gdb)
4-data-read-memory bytes+16 x 1 8 4 x
4^done,addr="0x000013a0",nr-bytes="32",total-bytes="32",
next-row="0x000013c0",prev-row="0x0000139c",
next-page="0x000013c0",prev-page="0x00001380",memory={
{addr="0x000013a0",data={"0x10","0x11","0x12","0x13"},ascii="xxxx"},
{addr="0x000013a4",data={"0x14","0x15","0x16","0x17"},ascii="xxxx"},
{addr="0x000013a8",data={"0x18","0x19","0x1a","0x1b"},ascii="xxxx"},
{addr="0x000013ac",data={"0x1c","0x1d","0x1e","0x1f"},ascii="xxxx"},
{addr="0x000013b0",data={"0x20","0x21","0x22","0x23"},ascii=" !\"#"},
{addr="0x000013b4",data={"0x24","0x25","0x26","0x27"},ascii="$%&#38;'"},
{addr="0x000013b8",data={"0x28","0x29","0x2a","0x2b"},ascii="()*+"},
{addr="0x000013bc",data={"0x2c","0x2d","0x2e","0x2f"},ascii=",-./"}}
(gdb)
</PRE>


<H3>Команда <CODE>-display-delete</CODE></H3>
<P>
<A NAME="IDX911"></A>



<H4>Краткое описание</H4>


<PRE>
 -display-delete <VAR>число</VAR>
</PRE>

<P>
Удалить элемент <VAR>номер</VAR> из списка выражений, подлежащих
отображению.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`delete display'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-display-disable</CODE></H3>
<P>
<A NAME="IDX912"></A>



<H4>Краткое описание</H4>


<PRE>
 -display-disable <VAR>номер</VAR>
</PRE>

<P>
Отключить элемент <VAR>номер</VAR> списка выражений, подлежащих
отображению.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`disable display'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-display-enable</CODE></H3>
<P>
<A NAME="IDX913"></A>



<H4>Краткое описание</H4>


<PRE>
 -display-enable <VAR>номер</VAR>
</PRE>

<P>
Включить элемент <VAR>номер</VAR> списка выражений, подлежащих
отображению.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`enable display'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-display-insert</CODE></H3>
<P>
<A NAME="IDX914"></A>



<H4>Краткое описание</H4>


<PRE>
 -display-insert <VAR>выражение</VAR>
</PRE>

<P>
Отображать <VAR>выражение</VAR> всякий раз, когда программа останавливается.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`display'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-display-list</CODE></H3>
<P>
<A NAME="IDX915"></A>



<H4>Краткое описание</H4>


<PRE>
 -display-list
</PRE>

<P>
Перечислить элементы списка выражений, подлежащих автоматическому
отображению.  Текущие значения не показывать.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info display'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-environment-cd</CODE></H3>
<P>
<A NAME="IDX916"></A>



<H4>Краткое описание</H4>


<PRE>
 -environment-cd <VAR>кат</VAR>
</PRE>

<P>
Установить рабочий каталог GDB.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`cd'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-environment-cd /kwikemart/marge/ezannoni/flathead-dev/devo/gdb
^done
(gdb)
</PRE>


<H3>Команда <CODE>-environment-directory</CODE></H3>
<P>
<A NAME="IDX917"></A>



<H4>Краткое описание</H4>


<PRE>
 -environment-directory <VAR>кат</VAR>
</PRE>

<P>
Добавить каталог <VAR>кат</VAR> в начало пути поиска исходных файлов.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`dir'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-environment-directory /kwikemart/marge/ezannoni/flathead-dev/devo/gdb
^done
(gdb)
</PRE>


<H3>Команда <CODE>-environment-path</CODE></H3>
<P>
<A NAME="IDX918"></A>



<H4>Краткое описание</H4>


<PRE>
 -environment-path ( <VAR>кат</VAR> )+
</PRE>

<P>
Добавить каталоги <VAR>кат</VAR> в начало пути поиска объектных файлов.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`path'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-environment-path /kwikemart/marge/ezannoni/flathead-dev/ppc-eabi/gdb
^done
(gdb)
</PRE>


<H3>Команда <CODE>-environment-pwd</CODE></H3>
<P>
<A NAME="IDX919"></A>



<H4>Краткое описание</H4>


<PRE>
 -environment-pwd
</PRE>

<P>
Показать текущий рабочий каталог.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`pwd'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-environment-pwd
~Working directory /kwikemart/marge/ezannoni/flathead-dev/devo/gdb.
^done
(gdb)
</PRE>



<H2><A NAME="SEC206" HREF="gdb_toc.html#TOC206">Управление программой GDB/MI</A></H2>


<H4>Завершение программы</H4>

<P>
В процессе выполнения, подчиненная программа может достигнуть конца,
если она не встретит ни одной точки останова.  В этом случае вывод будет
включать код завершения, если программа завершилась ненормально.



<H4>Примеры</H4>

<P>
Программа завершилась нормально:



<PRE>
(gdb)
-exec-run
^running
(gdb)
x = 55
*stopped,reason="exited-normally"
(gdb)
</PRE>

<P>
Программа завершилась ненормально:



<PRE>
(gdb)
-exec-run
^running
(gdb)
x = 55
*stopped,reason="exited",exit-code="01"
(gdb)
</PRE>

<P>
Кроме того, программа может завершиться так, как если бы она получила
сигнал, например <CODE>SIGINT</CODE>.  В этом случае, GDB/MI отображает
следующее:



<PRE>
(gdb)
*stopped,reason="exited-signalled",signal-name="SIGINT",
signal-meaning="Interrupt"
</PRE>


<H3>Команда <CODE>-exec-abort</CODE></H3>
<P>
<A NAME="IDX920"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-abort
</PRE>

<P>
Убить выполняющуюся подчиненную программу.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`kill'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-exec-arguments</CODE></H3>
<P>
<A NAME="IDX921"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-arguments <VAR>арг</VAR>
</PRE>

<P>
Установить аргументы подчиненной программы, которые должны быть
использованы при следующем <SAMP>`-exec-run'</SAMP>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`set args'</SAMP>.



<H4>Пример</H4>

<P>
Пока нет.



<H3>Команда <CODE>-exec-continue</CODE></H3>
<P>
<A NAME="IDX922"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-continue
</PRE>

<P>
Асинхронная команда.  Возобновляет выполнение подчиненной программы до
тех пор, пока не будет встречена точка останова, или пока подчиненная
программа не завершится.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`continue'</SAMP>.



<H4>Пример</H4>


<PRE>
-exec-continue
^running
(gdb)
@Hello world
*stopped,reason="breakpoint-hit",bkptno="2",frame={func="foo",args={},
file="hello.c",line="13"}
(gdb)
</PRE>


<H3>Команда <CODE>-exec-finish</CODE></H3>
<P>
<A NAME="IDX923"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-finish
</PRE>

<P>
Асинхронная команда.  Возобновляет выполнение подчиненной программы до
тех пор, пока не завершится текущая функция.  Отображает результаты,
возвращенные функцией.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`finish'</SAMP>.



<H4>Пример</H4>

<P>
Функция, возвращающая <CODE>void</CODE>.



<PRE>
-exec-finish
^running
(gdb)
@hello from foo
*stopped,reason="function-finished",frame={func="main",args={},
file="hello.c",line="7"}
(gdb)
</PRE>

<P>
Функция, возвращающая что-либо отличное от <CODE>void</CODE>.  Печатается имя
внутренней переменной GDB, хранящей результат, а также и сам
результат.



<PRE>
-exec-finish
^running
(gdb)
*stopped,reason="function-finished",frame={addr="0x000107b0",func="foo",
args={{name="a",value="1"},{name="b",value="9"}},
file="recursive2.c",line="14"},
gdb-result-var="$1",return-value="0"
(gdb)
</PRE>


<H3>Команда <CODE>-exec-interrupt</CODE></H3>
<P>
<A NAME="IDX924"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-interrupt
</PRE>

<P>
Асинхронная команда.  Прерывает фоновое исполнение цели.  Заметьте, что
лексема, ассоциированная с сообщением об останове, совпадает с лексемой
для выполнения команды, которая была прервана.  Лексема для самого
прерывания появляется только в выводе <SAMP>`^done'</SAMP>.  Если пользователь
пытается прервать невыполняющуюся программу, будет выведено сообщение об
ошибке.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`interrupt'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
111-exec-continue
111^running

(gdb)
222-exec-interrupt
222^done
(gdb)
111*stopped,signal-name="SIGINT",signal-meaning="Interrupt",
frame={addr="0x00010140",func="foo",args={},file="try.c",line="13"}
(gdb)

(gdb)
-exec-interrupt
^error,msg="mi_cmd_exec_interrupt: Inferior not executing."
(gdb)
</PRE>


<H3>Команда <CODE>-exec-next</CODE></H3>
<P>
<A NAME="IDX925"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-next
</PRE>

<P>
Асинхронная команда.  Возобновляет выполнение подчиненной программы,
останавливая ее, когда достигается начало следующей строки исходного
текста.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`next'</SAMP>.



<H4>Пример</H4>


<PRE>
-exec-next
^running
(gdb)
*stopped,reason="end-stepping-range",line="8",file="hello.c"
(gdb)
</PRE>


<H3>Команда <CODE>-exec-next-instruction</CODE></H3>
<P>
<A NAME="IDX926"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-next-instruction
</PRE>

<P>
Асинхронная команда.  Выполняет одну машинную инструкцию.  Если
инструкция является вызовом функции, выполнение продолжается до возврата
из функции.  Если программа останавливается на инструкции в середине
строки исходного текста, печатается также адрес.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`nexti'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-exec-next-instruction
^running

(gdb)
*stopped,reason="end-stepping-range",
addr="0x000100d4",line="5",file="hello.c"
(gdb)
</PRE>


<H3>Команда <CODE>-exec-return</CODE></H3>
<P>
<A NAME="IDX927"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-return
</PRE>

<P>
Велит текущей функции немедленно вернуться.  Не выполняет подчиненную
программу.  Отображает новый текущий кадр.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`return'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
200-break-insert callee4
200^done,bkpt={number="1",addr="0x00010734",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"}
(gdb)
000-exec-run
000^running
(gdb)
000*stopped,reason="breakpoint-hit",bkptno="1",
frame={func="callee4",args={},
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"}
(gdb)
205-break-delete
205^done
(gdb)
111-exec-return
111^done,frame={level="0 ",func="callee3",
args={{name="strarg",
value="0x11940 \"A string argument.\""}},
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
(gdb)
</PRE>


<H3>Команда <CODE>-exec-run</CODE></H3>
<P>
<A NAME="IDX928"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-run
</PRE>

<P>
Асинхронная команда.  Начинает выполнение подчиненной программы с начала.
Она выполняется до тех пор, пока либо не встретится точка останова, либо
программа не завершится.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`run'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-break-insert main
^done,bkpt={number="1",addr="0x0001072c",file="recursive2.c",line="4"}
(gdb)
-exec-run
^running
(gdb)
*stopped,reason="breakpoint-hit",bkptno="1",
frame={func="main",args={},file="recursive2.c",line="4"}
(gdb)
</PRE>


<H3>Команда <CODE>-exec-show-arguments</CODE></H3>
<P>
<A NAME="IDX929"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-show-arguments
</PRE>

<P>
Печатает аргументы программы.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`show args'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-exec-step</CODE></H3>
<P>
<A NAME="IDX930"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-step
</PRE>

<P>
Асинхронная команда.  Возобновляет выполнение подчиненной программы,
останавливая ее, когда будет достигнуто начало следующей строки исходного
файла, при условии, что она не является вызовом функции.  Если же
следующая строка является вызовом функции, программа останавливается на
первой инструкции этой функции.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`step'</SAMP>.



<H4>Пример</H4>

<P>
Пошаговый вход в функцию:



<PRE>
-exec-step
^running
(gdb)
*stopped,reason="end-stepping-range",
frame={func="foo",args={{name="a",value="10"},
{name="b",value="0"}},file="recursive2.c",line="11"}
(gdb)
</PRE>

<P>
Обычное пошаговое выполнение:



<PRE>
-exec-step
^running
(gdb)
*stopped,reason="end-stepping-range",line="14",file="recursive2.c"
(gdb)
</PRE>


<H3>Команда <CODE>-exec-step-instruction</CODE></H3>
<P>
<A NAME="IDX931"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-step-instruction
</PRE>

<P>
Асинхронная команда.  Возобновляет выполнение подчиненной программы,
выполняя одну машинную инструкцию.  Вывод, когда GDB
остановится, будет различаться в зависимости от того, остановились мы в
середине исходной строки или нет.  В первом случае, адрес, по которому
программа остановлена, также будет напечатан.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`stepi'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-exec-step-instruction
^running

(gdb)
*stopped,reason="end-stepping-range",
frame={func="foo",args={},file="try.c",line="10"}
(gdb)
-exec-step-instruction
^running

(gdb)
*stopped,reason="end-stepping-range",
frame={addr="0x000100f4",func="foo",args={},file="try.c",line="10"}
(gdb)
</PRE>


<H3>Команда <CODE>-exec-until</CODE></H3>
<P>
<A NAME="IDX932"></A>



<H4>Краткое описание</H4>


<PRE>
 -exec-until [ <VAR>местоположение</VAR> ]
</PRE>

<P>
Асинхронная команда.  Выполняет подчиненную программу до тех пор, пока
не будет достигнуто указанное в аргументе <VAR>местоположение</VAR>.  Если
аргумента нет, подчиненная программа выполняется, пока не будет
достигнута строка исходного текста, превышающая текущую.  В этом случае,
причиной остановки будет <SAMP>`location-reached'</SAMP>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`until'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-exec-until recursive2.c:6
^running
(gdb)
x = 55
*stopped,reason="location-reached",frame={func="main",args={},
file="recursive2.c",line="6"}
(gdb)
</PRE>


<H3>Команда <CODE>-file-exec-and-symbols</CODE></H3>
<P>
<A NAME="IDX933"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-exec-and-symbols <VAR>файл</VAR>
</PRE>

<P>
Указать выполняемый файл для отладки.  Это тот файл, из которого также
читается таблица символов.  Если файл не указан, команда очищает
информацию о выполняемом файле и символах.  Если при использовании этой
команды без аргументов установлены точки останова, GDB выдаст
сообщение об ошибке.  В противном случае, никакого вывода не будет, за
исключением уведомления о завершении.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`file'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-file-exec-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
^done
(gdb)
</PRE>


<H3>Команда <CODE>-file-exec-file</CODE></H3>
<P>
<A NAME="IDX934"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-exec-file <VAR>файл</VAR>
</PRE>

<P>
Указать выполняемый файл для отладки.  В отличие от
<SAMP>`-file-exec-and-symbols'</SAMP>, таблица символов <EM>не</EM> считывается из
этого файла.  При использовании без аргумента, GDB очищает
информацию о выполняемом файле.  Никакого вывода не производится, за
исключением уведомления о завершении.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`exec-file'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-file-exec-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
^done
(gdb)
</PRE>


<H3>Команда <CODE>-file-list-exec-sections</CODE></H3>
<P>
<A NAME="IDX935"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-list-exec-sections
</PRE>

<P>
Перечисляет разделы текущего выполняемого файла.



<H4>Команда GDB</H4>

<P>
Команда GDB <SAMP>`info file'</SAMP> показывает, помимо всего прочего,
ту же информацию, что и эта команда.  <CODE>gdbtk</CODE> имеет соответствующую
команду <SAMP>`gdb_load_info'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-file-list-exec-source-files</CODE></H3>
<P>
<A NAME="IDX936"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-list-exec-source-files
</PRE>

<P>
Перечисляет исходные файлы для текущего выполняемого файла.



<H4>Команда GDB</H4>

<P>
В GDB нет команды, непосредственно соответсвующей этой.
<CODE>gdbtk</CODE> имеет аналогичную команду <SAMP>`gdb_listfiles'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-file-list-shared-libraries</CODE></H3>
<P>
<A NAME="IDX937"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-list-shared-libraries
</PRE>

<P>
Перечисляет используемые программой разделяемые библиотеки.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info shared'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-file-list-symbol-files</CODE></H3>
<P>
<A NAME="IDX938"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-list-symbol-files
</PRE>

<P>
Перечисляет файлы символов.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info file'</SAMP> (ее
часть).



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-file-symbol-file</CODE></H3>
<P>
<A NAME="IDX939"></A>



<H4>Краткое описание</H4>


<PRE>
 -file-symbol-file <VAR>файл</VAR>
</PRE>

<P>
Прочитать информацию символьной таблицы из указанного в аргументе
<VAR>файла</VAR>.  Будучи использованной без аргументов, очищиет таблицу
символьной информации GDB.  Никакого вывода не производится,
кроме уведомления о завершении.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`symbol-file'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-file-symbol-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
^done
(gdb)
</PRE>



<H2><A NAME="SEC207" HREF="gdb_toc.html#TOC207">Разные команды GDB в GDB/MI</A></H2>


<H3>Команда <CODE>-gdb-exit</CODE></H3>
<P>
<A NAME="IDX940"></A>



<H4>Краткое описание</H4>


<PRE>
 -gdb-exit
</PRE>

<P>
Немедленно выйти из GDB.



<H4>Команда GDB</H4>

<P>
Примерно соответствует команде <SAMP>`quit'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-gdb-exit
</PRE>


<H3>Команда <CODE>-gdb-set</CODE></H3>
<P>
<A NAME="IDX941"></A>



<H4>Краткое описание</H4>


<PRE>
 -gdb-set
</PRE>

<P>
Установить внутреннюю переменную GDB.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`set'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-gdb-set $foo=3
^done
(gdb)
</PRE>


<H3>Команда <CODE>-gdb-show</CODE></H3>
<P>
<A NAME="IDX942"></A>



<H4>Краткое описание</H4>


<PRE>
 -gdb-show
</PRE>

<P>
Показать текущее значение переменной GDB.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`show'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-gdb-show annotate
^done,value="0"
(gdb)
</PRE>


<H3>Команда <CODE>-gdb-version</CODE></H3>
<P>
<A NAME="IDX943"></A>



<H4>Краткое описание</H4>


<PRE>
 -gdb-version
</PRE>

<P>
Вывести информацию о версии GDB.  Используется преимущественно
при тестировании.



<H4>Команда GDB</H4>

<P>
Эквивалентной команды GDB нет.  По умолчанию, GDB
показывает эту информацию, когда вы вызываете интерактивный сеанс.



<H4>Пример</H4>


<PRE>
(gdb)
-gdb-version
~GNU gdb 5.2.1
~Copyright 2000 Free Software Foundation, Inc.
~GDB is free software, covered by the GNU General Public License, and
~you are welcome to change it and/or distribute copies of it under
~ certain conditions.
~Type "show copying" to see the conditions.
~There is absolutely no warranty for GDB.  Type "show warranty" for
~ details.
~This GDB was configured as 
 "--host=sparc-sun-solaris2.5.1 --target=ppc-eabi".
^done
(gdb)
</PRE>



<H2><A NAME="SEC208" HREF="gdb_toc.html#TOC208">Команды управления стеком в GDB/MI</A></H2>


<H3>Команда <CODE>-stack-info-frame</CODE></H3>
<P>
<A NAME="IDX944"></A>



<H4>Краткое описание</H4>


<PRE>
 -stack-info-frame
</PRE>

<P>
Получить информацию о текущем кадре.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info frame'</SAMP> или
<SAMP>`frame'</SAMP> (без аргументов).



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-stack-info-depth</CODE></H3>
<P>
<A NAME="IDX945"></A>



<H4>Краткое описание</H4>


<PRE>
 -stack-info-depth [ <VAR>макс-глуб</VAR> ]
</PRE>

<P>
Возвращает глубину стека.  Если указан целочисленный аргумент
<VAR>макс-глуб</VAR>, не считать более <VAR>макс-глуб</VAR> кадров.



<H4>Команда GDB</H4>

<P>
Эквивалентной команды GDB нет.



<H4>Пример</H4>

<P>
Для стека с уровнями кадров от 0 до 11:



<PRE>
(gdb)
-stack-info-depth
^done,depth="12"
(gdb)
-stack-info-depth 4
^done,depth="4"
(gdb)
-stack-info-depth 12
^done,depth="12"
(gdb)
-stack-info-depth 11
^done,depth="11"
(gdb)
-stack-info-depth 13
^done,depth="12"
(gdb)
</PRE>


<H3>Команда <CODE>-stack-list-arguments</CODE></H3>
<P>
<A NAME="IDX946"></A>



<H4>Краткое описание</H4>


<PRE>
 -stack-list-arguments <VAR>показ-знач</VAR>
    [ <VAR>нижн-кадр</VAR> <VAR>верхн-кадр</VAR> ]
</PRE>

<P>
Отобразить список аргументов для кадров от <VAR>нижн-кадр</VAR> до
<VAR>верхн-кадр</VAR> (включительно).  Если <VAR>нижн-кадр</VAR> и
<VAR>верхн-кадр</VAR> не указаны, перечислить аргументы для всего стека
вызовов.


<P>
Аргумент <VAR>показ-знач</VAR> должен иметь значение 0 или 1.  Значение 0
означает, что выводятся только имена аргументов, а 1,---что
печатаются как имена, так и значения аргументов.



<H4>Команда GDB</H4>

<P>
GDB не имеет эквивалентной команды.  В <CODE>gdbtk</CODE> есть
команда <SAMP>`gdb_get_args'</SAMP>, которая частично перекрывается с действием
<SAMP>`-stack-list-arguments'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-stack-list-frames
^done,
stack={
frame={level="0 ",addr="0x00010734",func="callee4",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"},
frame={level="1 ",addr="0x0001076c",func="callee3",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="17"},
frame={level="2 ",addr="0x0001078c",func="callee2",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="22"},
frame={level="3 ",addr="0x000107b4",func="callee1",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="27"},
frame={level="4 ",addr="0x000107e0",func="main",
file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="32"}}
(gdb)
-stack-list-arguments 0
^done,
stack-args={
frame={level="0",args={}},
frame={level="1",args={name="strarg"}},
frame={level="2",args={name="intarg",name="strarg"}},
frame={level="3",args={name="intarg",name="strarg",name="fltarg"}},
frame={level="4",args={}}}
(gdb)
-stack-list-arguments 1
^done,
stack-args={
frame={level="0",args={}},
frame={level="1",
 args={{name="strarg",value="0x11940 \"Строковый аргумент.\""}}},
frame={level="2",args={
{name="intarg",value="2"},
{name="strarg",value="0x11940 \"Строковый аргумент.\""}}},
{frame={level="3",args={
{name="intarg",value="2"},
{name="strarg",value="0x11940 \"Строковый аргумент.\""},
{name="fltarg",value="3.5"}}},
frame={level="4",args={}}}
(gdb)
-stack-list-arguments 0 2 2
^done,stack-args={frame={level="2",args={name="intarg",name="strarg"}}}
(gdb)
-stack-list-arguments 1 2 2
^done,stack-args={frame={level="2",
args={{name="intarg",value="2"},
{name="strarg",value="0x11940 \"Строковый аргумент.\""}}}}
(gdb)
</PRE>


<H3>Команда <CODE>-stack-list-frames</CODE></H3>
<P>
<A NAME="IDX947"></A>



<H4>Краткое описание</H4>


<PRE>
 -stack-list-frames [ <VAR>нижн-кадр</VAR> <VAR>верхн-кадр</VAR> ]
</PRE>

<P>
Перечисляет кадры, находящиеся в данный момент в стеке.  Для каждого
кадра, команда отображает следующую информацию:


<DL COMPACT>

<DT><SAMP>`<VAR>level</VAR>'</SAMP>
<DD>
Номер кадра, 0 для самого верхнего, то есть для самой внутренней
функции.
<DT><SAMP>`<VAR>addr</VAR>'</SAMP>
<DD>
Значение <CODE>$pc</CODE> для этого кадра.
<DT><SAMP>`<VAR>func</VAR>'</SAMP>
<DD>
Имя функции.
<DT><SAMP>`<VAR>file</VAR>'</SAMP>
<DD>
Имя исходного файла, где находится функция.
<DT><SAMP>`<VAR>line</VAR>'</SAMP>
<DD>
Номер строки, соответствующий <CODE>$pc</CODE>.
</DL>

<P>
Будучи вызванной без аргументов, эта команда печатает цепочку вызовов
для всего стека.  Если задано два целочисленных аргумента, она
показывает кадры с уровнями между этими аргументами (включительно).
Если аргументы равны, она показывает один единственный кадр
соответствующего уровня.



<H4>Команда GDB</H4>

<P>
Соответствующими командами GDB являются <SAMP>`backtrace'</SAMP> и
<SAMP>`where'</SAMP>.



<H4>Пример</H4>

<P>
Цепочка вызовов стека целиком:



<PRE>
(gdb)
-stack-list-frames
^done,stack=
{frame={level="0 ",addr="0x0001076c",func="foo",
  file="recursive2.c",line="11"},
frame={level="1 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="2 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="3 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="4 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="5 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="6 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="7 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="8 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="9 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="10",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="11",addr="0x00010738",func="main",
  file="recursive2.c",line="4"}}
(gdb)
</PRE>

<P>
Показать кадры между <VAR>нижн-кадр</VAR> и <VAR>верхн-кадр</VAR>:



<PRE>
(gdb)
-stack-list-frames 3 5
^done,stack=
{frame={level="3 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="4 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"},
frame={level="5 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"}}
(gdb)
</PRE>

<P>
Показать один кадр:



<PRE>
(gdb)
-stack-list-frames 3 3
^done,stack=
{frame={level="3 ",addr="0x000107a4",func="foo",
  file="recursive2.c",line="14"}}
(gdb)
</PRE>


<H3>Команда <CODE>-stack-list-locals</CODE></H3>
<P>
<A NAME="IDX948"></A>



<H4>Краткое описание</H4>


<PRE>
 -stack-list-locals <VAR>печатать-значения</VAR>
</PRE>

<P>
Вывести имена локальных переменных для текущего кадра.  С параметром 0
выводит только имена переменных, с параметром 1 выводит также их
значения.



<H4>Команда GDB</H4>

<P>
<SAMP>`info locals'</SAMP> в GDB, <SAMP>`gdb_get_locals'</SAMP> в <CODE>gdbtk</CODE>.



<H4>Пример</H4>


<PRE>
(gdb)
-stack-list-locals 0
^done,locals={name="A",name="B",name="C"}
(gdb)
-stack-list-locals 1
^done,locals={{name="A",value="1"},{name="B",value="2"},
  {name="C",value="3"}}
(gdb)
</PRE>


<H3>Команда <CODE>-stack-select-frame</CODE></H3>
<P>
<A NAME="IDX949"></A>



<H4>Краткое описание</H4>


<PRE>
 -stack-select-frame <VAR>ном-кадра</VAR>
</PRE>

<P>
Изменить текущий кадр.  Выбрать другой кадр <VAR>ном-кадра</VAR> в стеке.



<H4>Команда GDB</H4>

<P>
Соответствующими командами GDB являются <SAMP>`frame'</SAMP>,
<SAMP>`up'</SAMP>, <SAMP>`down'</SAMP>, <SAMP>`select-frame'</SAMP>, <SAMP>`up-silent'</SAMP> и
<SAMP>`down-silent'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-stack-select-frame 2
^done
(gdb)
</PRE>



<H2><A NAME="SEC209" HREF="gdb_toc.html#TOC209">Команды GDB/MI запросов о символах</A></H2>


<H3>Команда <CODE>-symbol-info-address</CODE></H3>
<P>
<A NAME="IDX950"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-info-address <VAR>символ</VAR>
</PRE>

<P>
Описать, где хранится <VAR>символ</VAR>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info address'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-info-file</CODE></H3>
<P>
<A NAME="IDX951"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-info-file
</PRE>

<P>
Показать файл для символа.



<H4>Команда GDB</H4>

<P>
Эквивалентной команды GDB нет.  В <CODE>gdbtk</CODE> есть команда
<SAMP>`gdb_find_file'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-info-function</CODE></H3>
<P>
<A NAME="IDX952"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-info-function
</PRE>

<P>
Показать, в какой функции находится символ.



<H4>Команда GDB</H4>

<P>
<SAMP>`gdb_get_function'</SAMP> в <CODE>gdbtk</CODE>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-info-line</CODE></H3>
<P>
<A NAME="IDX953"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-info-line
</PRE>

<P>
Показать адреса памяти кода для текущей строки.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info line'</SAMP>.  В
<CODE>gdbtk</CODE> есть команды <SAMP>`gdb_get_line'</SAMP> и <SAMP>`gdb_get_file'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-info-symbol</CODE></H3>
<P>
<A NAME="IDX954"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-info-symbol <VAR>адрес</VAR>
</PRE>

<P>
Описать, какой символ находится в местоположении <VAR>адрес</VAR>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`info symbol'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-list-functions</CODE></H3>
<P>
<A NAME="IDX955"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-list-functions
</PRE>

<P>
Перечислить функции, находящиеся в выполняемом файле.



<H4>Команда GDB</H4>

<P>
<SAMP>`info functions'</SAMP> в GDB, <SAMP>`gdb_listfunc'</SAMP> и
<SAMP>`gdb_search'</SAMP> в <CODE>gdbtk</CODE>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-list-types</CODE></H3>
<P>
<A NAME="IDX956"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-list-types
</PRE>

<P>
Перечислить все имена типов.



<H4>Команда GDB</H4>

<P>
Соответствующими командами являются <SAMP>`info types'</SAMP> в GDB и
<SAMP>`gdb_search'</SAMP> в <CODE>gdbtk</CODE>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-list-variables</CODE></H3>
<P>
<A NAME="IDX957"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-list-variables
</PRE>

<P>
Перечислить имена всех глобальных и статических переменных.



<H4>Команда GDB</H4>

<P>
<SAMP>`info variables'</SAMP> в GDB, <SAMP>`gdb_search'</SAMP> в <CODE>gdbtk</CODE>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-locate</CODE></H3>
<P>
<A NAME="IDX958"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-locate
</PRE>


<H4>Команда GDB</H4>

<P>
<SAMP>`gdb_loc'</SAMP> в <CODE>gdbtk</CODE>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-symbol-type</CODE></H3>
<P>
<A NAME="IDX959"></A>



<H4>Краткое описание</H4>


<PRE>
 -symbol-type <VAR>переменная</VAR>
</PRE>

<P>
Показать тип <VAR>переменной</VAR>.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`ptype'</SAMP>, в
<CODE>gdbtk</CODE> есть команда <SAMP>`gdb_obj_variable'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.




<H2><A NAME="SEC210" HREF="gdb_toc.html#TOC210">Команды GDB/MI управления целью</A></H2>


<H3>Команда <CODE>-target-attach</CODE></H3>
<P>
<A NAME="IDX960"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-attach <VAR>ид-проц</VAR> | <VAR>файл</VAR>
</PRE>

<P>
Присоединиться к процессу <VAR>ид-проц</VAR> или файлу <VAR>файл</VAR> вне
GDB.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`attach'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-target-compare-sections</CODE></H3>
<P>
<A NAME="IDX961"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-compare-sections [ <VAR>раздел</VAR> ]
</PRE>

<P>
Сравнить данные раздела <VAR>раздел</VAR> на цели с выполняемым файлом.  Без
аргумента сравниваются все разделы.



<H4>Команда GDB</H4>

<P>
Эквивалентной командой в GDB является <SAMP>`compare-sections'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-target-detach</CODE></H3>
<P>
<A NAME="IDX962"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-detach
</PRE>

<P>
Отсоединиться от удаленной цели.  Никакого вывода не производится.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`detach'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-target-detach
^done
(gdb)
</PRE>


<H3>Команда <CODE>-target-download</CODE></H3>
<P>
<A NAME="IDX963"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-download
</PRE>

<P>
Загружает выполняемый файл на удаленную цель.  Команда два раза в
секунду обновляет сообщение, которое включает поля:


<DL COMPACT>

<DT><SAMP>`section'</SAMP>
<DD>
Имя раздела.
<DT><SAMP>`section-sent'</SAMP>
<DD>
Размер переданного на данный момент участка для этого раздела.
<DT><SAMP>`section-size'</SAMP>
<DD>
Размер раздела.
<DT><SAMP>`total-sent'</SAMP>
<DD>
Общий размер переданной на данный момент информации (текущий и
предыдущие разделы).
<DT><SAMP>`total-size'</SAMP>
<DD>
Размер всего выполняемого файла, подлежащего загрузке.
</DL>

<P>
Каждое сообщение посылается в виде сообщения статуса (see section <A HREF="gdb_20.html#SEC196">Выходной синтаксис GDB/MI</A>).


<P>
Кроме того, команда печатает имена и размеры разделов, по мере их
загрузки.  Эти сообщения включают следующие поля:


<DL COMPACT>

<DT><SAMP>`section'</SAMP>
<DD>
Имя раздела.
<DT><SAMP>`section-size'</SAMP>
<DD>
Размер раздела.
<DT><SAMP>`total-size'</SAMP>
<DD>
Размер всего выполняемого файла, подлежащего загрузке.
</DL>

<P>
В конце печатается суммарная информация.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`load'</SAMP>.



<H4>Пример</H4>

<P>
Замечание: каждое сообщение статуса появляется на одной строке.  Здесь
сообщения были разбиты на несколько строк, чтобы они могли влезть на страницу.



<PRE>
(gdb)
-target-download
+download,{section=".text",section-size="6668",total-size="9880"}
+download,{section=".text",section-sent="512",section-size="6668",
total-sent="512",total-size="9880"}
+download,{section=".text",section-sent="1024",section-size="6668",
total-sent="1024",total-size="9880"}
+download,{section=".text",section-sent="1536",section-size="6668",
total-sent="1536",total-size="9880"}
+download,{section=".text",section-sent="2048",section-size="6668",
total-sent="2048",total-size="9880"}
+download,{section=".text",section-sent="2560",section-size="6668",
total-sent="2560",total-size="9880"}
+download,{section=".text",section-sent="3072",section-size="6668",
total-sent="3072",total-size="9880"}
+download,{section=".text",section-sent="3584",section-size="6668",
total-sent="3584",total-size="9880"}
+download,{section=".text",section-sent="4096",section-size="6668",
total-sent="4096",total-size="9880"}
+download,{section=".text",section-sent="4608",section-size="6668",
total-sent="4608",total-size="9880"}
+download,{section=".text",section-sent="5120",section-size="6668",
total-sent="5120",total-size="9880"}
+download,{section=".text",section-sent="5632",section-size="6668",
total-sent="5632",total-size="9880"}
+download,{section=".text",section-sent="6144",section-size="6668",
total-sent="6144",total-size="9880"}
+download,{section=".text",section-sent="6656",section-size="6668",
total-sent="6656",total-size="9880"}
+download,{section=".init",section-size="28",total-size="9880"}
+download,{section=".fini",section-size="28",total-size="9880"}
+download,{section=".data",section-size="3156",total-size="9880"}
+download,{section=".data",section-sent="512",section-size="3156",
total-sent="7236",total-size="9880"}
+download,{section=".data",section-sent="1024",section-size="3156",
total-sent="7748",total-size="9880"}
+download,{section=".data",section-sent="1536",section-size="3156",
total-sent="8260",total-size="9880"}
+download,{section=".data",section-sent="2048",section-size="3156",
total-sent="8772",total-size="9880"}
+download,{section=".data",section-sent="2560",section-size="3156",
total-sent="9284",total-size="9880"}
+download,{section=".data",section-sent="3072",section-size="3156",
total-sent="9796",total-size="9880"}
^done,address="0x10004",load-size="9880",transfer-rate="6586",
write-rate="429"
(gdb)
</PRE>


<H3>Команда <CODE>-target-exec-status</CODE></H3>
<P>
<A NAME="IDX964"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-exec-status
</PRE>

<P>
Предоставить информацию о состоянии цели (например, выполняется она или
нет).



<H4>Команда GDB</H4>

<P>
Эквивалентной команды GDB нет.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-target-list-available-targets</CODE></H3>
<P>
<A NAME="IDX965"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-list-available-targets
</PRE>

<P>
Перечислить цели, к которым можно установить соединение.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`help target'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-target-list-current-targets</CODE></H3>
<P>
<A NAME="IDX966"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-list-current-targets
</PRE>

<P>
Описать текущую цель.



<H4>Команда GDB</H4>

<P>
Соответствующая информация (вместе с другой) печатается командой
<SAMP>`info file'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-target-list-parameters</CODE></H3>
<P>
<A NAME="IDX967"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-list-parameters
</PRE>


<H4>Команда GDB</H4>

<P>
Эквивалента нет.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-target-select</CODE></H3>
<P>
<A NAME="IDX968"></A>



<H4>Краткое описание</H4>


<PRE>
 -target-select <VAR>тип</VAR> <VAR>параметры ...</VAR>
</PRE>

<P>
Соединить GDB с удаленной целью.  Эта команда допускает два
аргумента:


<DL COMPACT>

<DT><SAMP>`<VAR>тип</VAR>'</SAMP>
<DD>
Тип цели, например, <SAMP>`async'</SAMP>, <SAMP>`remote'</SAMP>, и т.д.
<DT><SAMP>`<VAR>параметры</VAR>'</SAMP>
<DD>
Имена устройств, названия машин и тому подобное.  See section <A HREF="gdb_14.html#SEC108">Команды для управления целями</A>, для более полной информации.
</DL>

<P>
Результатом является уведомление о соединении, за которым следует адрес,
по которому находится целевая программа, в следующей форме:



<PRE>
^connected,addr="<VAR>адрес</VAR>",func="<VAR>имя функции</VAR>",
  args={<VAR>список аргументов</VAR>}
</PRE>


<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`target'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-target-select async /dev/ttya
^connected,addr="0xfe00a300",func="??",args={}
(gdb)
</PRE>



<H2><A NAME="SEC211" HREF="gdb_toc.html#TOC211">Команды GDB/MI для нитей</A></H2>


<H3>Команда <CODE>-thread-info</CODE></H3>
<P>
<A NAME="IDX969"></A>



<H4>Краткое описание</H4>


<PRE>
 -thread-info
</PRE>


<H4>Команда GDB</H4>

<P>
Эквивалента нет.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-thread-list-all-threads</CODE></H3>
<P>
<A NAME="IDX970"></A>



<H4>Краткое описание</H4>


<PRE>
 -thread-list-all-threads
</PRE>


<H4>Команда GDB</H4>

<P>
Эквивалентной командой GDB является <SAMP>`info threads'</SAMP>.



<H4>Пример</H4>
<P>
Н.П.



<H3>Команда <CODE>-thread-list-ids</CODE></H3>
<P>
<A NAME="IDX971"></A>



<H4>Краткое описание</H4>


<PRE>
 -thread-list-ids
</PRE>

<P>
Выводит список известных GDB в данный момент идентификаторов
нитей.  В конце списка также выводится общее число таких нитей.



<H4>Команда GDB</H4>

<P>
Часть <SAMP>`info threads'</SAMP> предоставляет ту же информацию.



<H4>Пример</H4>

<P>
Кроме основного процесса нет ни одной нити:



<PRE>
(gdb)
-thread-list-ids
^done,thread-ids={},number-of-threads="0"
(gdb)
</PRE>

<P>
Несколько нитей:



<PRE>
(gdb)
-thread-list-ids
^done,thread-ids={thread-id="3",thread-id="2",thread-id="1"},
number-of-threads="3"
(gdb)
</PRE>


<H3>Команда <CODE>-thread-select</CODE></H3>
<P>
<A NAME="IDX972"></A>



<H4>Краткое описание</H4>


<PRE>
 -thread-select <VAR>номер-нити</VAR>
</PRE>

<P>
Сделать нить <VAR>номер-нити</VAR> текущей.  Команда выводит номер новой
текущей нити и самый верхний кадр для нее.



<H4>Команда GDB</H4>

<P>
Соответствующей командой GDB является <SAMP>`thread'</SAMP>.



<H4>Пример</H4>


<PRE>
(gdb)
-exec-next
^running
(gdb)
*stopped,reason="end-stepping-range",thread-id="2",line="187",
file="../../../devo/gdb/testsuite/gdb.threads/linux-dp.c"
(gdb)
-thread-list-ids
^done,
thread-ids={thread-id="3",thread-id="2",thread-id="1"},
number-of-threads="3"
(gdb)
-thread-select 3
^done,new-thread-id="3",
frame={level="0 ",func="vprintf",
args={{name="format",value="0x8048e9c \"%*s%c %d %c\\n\""},
{name="arg",value="0x2"}},file="vprintf.c",line="31"}
(gdb)
</PRE>



<H2><A NAME="SEC212" HREF="gdb_toc.html#TOC212">Команды GDB/MI для точек трассировки</A></H2>

<P>
Команды для точек трассировки еще не реализованы.




<H2><A NAME="SEC213" HREF="gdb_toc.html#TOC213">Изменяемые объекты GDB/MI</A></H2>


<H3>Обоснование для изменяемых объектов в GDB/MI</H3>

<P>
Для реализации изменяемого отладочного окна (локальные переменные,
наблюдаемые выражения, и т.д.), мы предлагаем модификацию существующего
кода, используемого в <CODE>Insight</CODE>.


<P>
Вот две основные причины для этого:



<OL>
<LI>

Он был проверен на практике (это уже его второе поколение).

<LI>

Это сократит время разработки (не стоит говорить, как это сейчас важно).
</OL>

<P>
Первоначальный интерейс был разработан для использование кодом Tcl, так
что он был немного изменен, чтобы его можно было использовать через
GDB/MI.  Этот раздел описывает операции GDB/MI, которые будут
доступны, и дает некоторые советы по их использованию.


<P>
<EM>Замечание</EM>: В дополнение к описанному здесь набору операций, мы
ожидаем, что GUI-реализация изменяемого окна будет требовать, как
минимум, следующие операции:



<UL>
<LI><CODE>-gdb-show</CODE> <CODE>output-radix</CODE>

<LI><CODE>-stack-list-arguments</CODE>

<LI><CODE>-stack-list-locals</CODE>

<LI><CODE>-stack-select-frame</CODE>

</UL>


<H3>Введение в изменяемые объекты в GDB/MI</H3>

<P>
<A NAME="IDX973"></A>
Основной идеей изменяемых объектов является создание именованного
объекта для представления переменной, выражения, местоположения в памяти
или даже регистра ЦП.  Для каждого созданного объекта существует набор
операций для изучения или изменения его свойств.


<P>
Более того, сложные типы данных, такие как структуры Си, представлены в
древовидном формате.  Например, переменная типа <CODE>struct</CODE> является
корнем, а потомки будут представлять элементы этой структуры.  Если
потомок сам является сложным типом, он также будет иметь своих потомков.
Соответствующие различия языков учитываются для Си, Си<TT>++</TT> и Java.


<P>
При возврате реальных значений объектов, эта возможность позволяет
отдельно выбирать формат отображения, используемый при создании
результата.  Он может быть выбран из: двоичный, десятичный,
шестнадцатеричный, восьмеричный и обычный.  Обычный ссылается на формат
по умолчанию, выбираемый автоматически в зависимости от типа переменной
(например, десятичный для <CODE>int</CODE>, шестнадцатеричный для указателей,
и т.д.).


<P>
Далее следует полный набор операций GDB/MI, определенный для
доступа к этим возможностям:


<TABLE BORDER>

<TR><TD><STRONG>Операция</STRONG></TD>

</TD><TD> <STRONG>Описание</STRONG>

</TR>
<TR><TD><CODE>-var-create</CODE></TD>

</TD><TD> создать изменяемый объект
</TR>
<TR><TD><CODE>-var-delete</CODE></TD>

</TD><TD> удалить изменяемый объект и его потомков
</TR>
<TR><TD><CODE>-var-set-format</CODE></TD>

</TD><TD> установить формат отображения для этой переменной
</TR>
<TR><TD><CODE>-var-show-format</CODE></TD>

</TD><TD> показать формат отображения для этой переменной
</TR>
<TR><TD><CODE>-var-info-num-children</CODE></TD>

</TD><TD> сообщает, сколько потомков имеет данный объект
</TR>
<TR><TD><CODE>-var-list-children</CODE></TD>

</TD><TD> возвращает список потомков объекта
</TR>
<TR><TD><CODE>-var-info-type</CODE></TD>

</TD><TD> показать тип этого изменяемого объекта
</TR>
<TR><TD><CODE>-var-info-expression</CODE></TD>

</TD><TD> напечатать, что представляет этот изменяемый объект
</TR>
<TR><TD><CODE>-var-show-attributes</CODE></TD>

</TD><TD> является ли эта переменная редактируемой? она здесь существует?
</TR>
<TR><TD><CODE>-var-evaluate-expression</CODE></TD>

</TD><TD> получить значение этой переменной
</TR>
<TR><TD><CODE>-var-assign</CODE></TD>

</TD><TD> установить значение этой переменной
</TR>
<TR><TD><CODE>-var-update</CODE></TD>

</TD><TD> скорректировать переменную и ее потомков
</TR></TABLE>

<P>
В следующем подразделе мы подробно описываем каждую операцию и
предлагаем возможный способ ее использования.



<H3>Описание и использование операций для изменяемых объектов</H3>


<H3>Команда <CODE>-var-create</CODE></H3>
<P>
<A NAME="IDX974"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-create {<VAR>имя</VAR> | "-"}
    {<VAR>адрес-кадра</VAR> | "*"} <VAR>выражение</VAR>
</PRE>

<P>
Данная операция создает изменяемый объект.  Это позволяет наблюдать за
переменной, результатом выражения, ячейкой памяти или регистром ЦП.


<P>
Параметр <VAR>имя</VAR> является строкой, по которой можно ссылаться на
объект.  Она должен быть уникальной.  Если указан <SAMP>`-'</SAMP>, система
изменяемых объектов автоматически сгенерирует строку "varNNNNNN".  Она
будет уникальной, при условии, что <VAR>имя</VAR> не будет указано в этом
формате.  Команда завершается ошибкой, если найдено повторяющееся имя.


<P>
В <VAR>адресе-кадра</VAR> может быть задан кадр, в котором должно быть
вычислено выражение.  <SAMP>`*'</SAMP> указывает, что должен использоваться
текущий кадр.


<P>
<VAR>Выражение</VAR>---это произвольное выражение, правильное в текущем
наборе языков (не должно начинаться со <SAMP>`*'</SAMP>), или одно из
следующего:



<UL>
<LI>

<SAMP>`*<VAR>адрес</VAR>'</SAMP>, где <VAR>адрес</VAR> есть адрес ячейки памяти

<LI>

<SAMP>`*<VAR>адрес</VAR>-<VAR>адрес</VAR>'</SAMP> -- диапазон адресов памяти (TBD)

<LI>

<SAMP>`$<VAR>имя-рег</VAR>'</SAMP> -- имя регистра ЦП
</UL>


<H4>Результат</H4>

<P>
Эта операция возвращает имя, число потомков и тип созданного объекта.
Тип возвращается как строка, как будто она создана GDB CLI:



<PRE>
 name="<VAR>имя</VAR>",numchild="N",type="<VAR>тип</VAR>"
</PRE>


<H3>Команда <CODE>-var-delete</CODE></H3>
<P>
<A NAME="IDX975"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-delete <VAR>имя</VAR>
</PRE>

<P>
Удаляет созданный ранее изменяемый объект и всех его потомков.


<P>
Возвращает ошибку, если объект с именем <VAR>имя</VAR> не найден.



<H3>Команда <CODE>-var-set-format</CODE></H3>
<P>
<A NAME="IDX976"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-set-format <VAR>имя</VAR> <VAR>специф-формата</VAR>
</PRE>

<P>
Устанавливает формат вывода в <VAR>специф-формата</VAR> для значения объекта
<VAR>имя</VAR>.


<P>
Синтаксис <VAR>специф-формата</VAR> следующий:



<PRE>
 <VAR>специф-формата</VAR> ==>
 {binary | decimal | hexadecimal | octal | natural}
</PRE>


<H3>Команда <CODE>-var-show-format</CODE></H3>
<P>
<A NAME="IDX977"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-show-format <VAR>имя</VAR>
</PRE>

<P>
Возвращает формат, используемый для отображения значений объекта <VAR>имя</VAR>.



<PRE>
 <VAR>формат</VAR> ==>
 <VAR>специф-формата</VAR>
</PRE>


<H3>Команда <CODE>-var-info-num-children</CODE></H3>
<P>
<A NAME="IDX978"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-info-num-children <VAR>имя</VAR>
</PRE>

<P>
Возвращает число потомков изменяемого объекта с именем <VAR>имя</VAR>:



<PRE>
 numchild=<VAR>n</VAR>
</PRE>


<H3>Команда <CODE>-var-list-children</CODE></H3>
<P>
<A NAME="IDX979"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-list-children <VAR>имя</VAR>
</PRE>

<P>
Возвращает список потомков указанного изменяемого объекта:



<PRE>
 numchild=<VAR>n</VAR>,children={{name=<VAR>имя</VAR>,
 numchild=<VAR>n</VAR>,type=<VAR>тип</VAR>},(повторяется N раз)}
</PRE>


<H3>Команда <CODE>-var-info-type</CODE></H3>
<P>
<A NAME="IDX980"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-info-type <VAR>имя</VAR>
</PRE>

<P>
Возвращает тип указанного изменяемого объекта <VAR>имя</VAR>.  Тип
возвращается как строка в том же формате, в котором она выдается
GDB CLI:



<PRE>
 type=<VAR>имя-типа</VAR>
</PRE>


<H3>Команда <CODE>-var-info-expression</CODE></H3>
<P>
<A NAME="IDX981"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-info-expression <VAR>имя</VAR>
</PRE>

<P>
Возвращает то, что представляет изменяемый объект с именем <VAR>имя</VAR>:



<PRE>
 lang=<VAR>специф-языка</VAR>,exp=<VAR>выражение</VAR>
</PRE>

<P>
где <VAR>специф-языка</VAR> есть <CODE>{"C" | "C++" | "Java"}</CODE>.



<H3>Команда <CODE>-var-show-attributes</CODE></H3>
<P>
<A NAME="IDX982"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-show-attributes <VAR>имя</VAR>
</PRE>

<P>
Перечисляет атрибуты заданного изменяемого объекта <VAR>имя</VAR>:



<PRE>
 status=<VAR>атр</VAR> [ ( ,<VAR>атр</VAR> )* ]
</PRE>

<P>
где <VAR>атр</VAR> есть <CODE>{ { editable | noneditable } | TBD }</CODE>.



<H3>Команда <CODE>-var-evaluate-expression</CODE></H3>
<P>
<A NAME="IDX983"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-evaluate-expression <VAR>имя</VAR>
</PRE>

<P>
Вычисляет выражение, которое представлено указанным изменяемым объектом
и возвращает его значение в виде строки в текущем формате, определенном
для объекта:



<PRE>
 value=<VAR>значение</VAR>
</PRE>


<H3>Команда <CODE>-var-assign</CODE></H3>
<P>
<A NAME="IDX984"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-assign <VAR>имя</VAR> <VAR>выражение</VAR>
</PRE>

<P>
Присваивает значение <VAR>выражения</VAR> изменяемому объекту, заданному
<VAR>именем</VAR>.  Объект должен быть в состоянии <SAMP>`editable'</SAMP>.



<H3>Команда <CODE>-var-update</CODE></H3>
<P>
<A NAME="IDX985"></A>



<H4>Краткое описание</H4>


<PRE>
 -var-update {<VAR>имя</VAR> | "*"}
</PRE>

<P>
Обновить значение изменяемого объекта с именем <VAR>имя</VAR> путем
вычисления его выражения, после получения всех новых значений из памяти
или регистров.  <SAMP>`*'</SAMP> приводит к обновлению всех существующих
изменяемых объектов.




<H2><A NAME="SEC214" HREF="gdb_toc.html#TOC214">Черновик изменений к выходному синтаксису GDB/MI</A></H2>

<P>
<A NAME="IDX986"></A>
<A NAME="IDX987"></A>


<P>
Одной проблемой, обнаруженной в существующем синтаксисе вывода
GDB/MI, была трудность в нахождении отличий между наборами вроде
этого:



<PRE>
{number="1",type="breakpoint",disp="keep",enabled="y"}
</PRE>

<P>
где каждое значение имеет уникальную метку, и таким списком:



<PRE>
{"1","2","4"}
{bp="1",bp="2",bp="4"}
</PRE>

<P>
где значения не имеют меток, или метки повторяются.


<P>
Далее представлен черновик изменений к спецификации вывода, который
решает эту проблему.


<P>
Вывод GDB/MI состоит из нуля или более внеочередных
записей, за которыми может следовать одна результирующая запись, причем
она относится к самой последней введенной команде.  Последовательность
завершается <SAMP>`gdb'</SAMP>.


<P>
Асинхронный вывод GDB/MI такой же.


<P>
Каждая выходная запись, непосредственно связанная с входной командой, 
начинается с префикса <CODE><VAR>лексема</VAR></CODE> входной команды.


<DL COMPACT>

<DT><CODE><VAR>вывод</VAR> ==></CODE>
<DD>
{ <VAR>внеочередная-запись</VAR> } <CODE>[</CODE> <VAR>рез-запись</VAR> <CODE>]</CODE> "<CODE>(gdb)</CODE>" <VAR>nl</VAR>

<DT><CODE><VAR>рез-запись</VAR> ==></CODE>
<DD>
<CODE>[</CODE> <VAR>лексема</VAR> <CODE>]</CODE> "^" <VAR>рез-класс</VAR> { "," <VAR>результат</VAR> } <VAR>nl</VAR>

<DT><CODE><VAR>внеочередная-запись</VAR> ==></CODE>
<DD>
<VAR>асинхр-запись</VAR> <CODE>|</CODE> <VAR>поточн-запись</VAR>

<DT><CODE><VAR>асинхр-запись</VAR> ==></CODE>
<DD>
<VAR>асинхр-вывод-выполн</VAR> <CODE>|</CODE> <VAR>асинхр-вывод-статуса</VAR> <CODE>|</CODE> <VAR>асинхр-вывод-уведомл</VAR>

<DT><CODE><VAR>асинхр-вывод-выполн</VAR> ==></CODE>
<DD>
<CODE>[</CODE> <VAR>лексема</VAR> <CODE>]</CODE> "*" <VAR>асинхр-вывод</VAR>

<DT><CODE><VAR>асинхр-вывод-статуса</VAR> ==></CODE>
<DD>
<CODE>[</CODE> <VAR>лексема</VAR> <CODE>]</CODE> "+" <VAR>асинхр-вывод</VAR>

<DT><CODE><VAR>асинхр-вывод-уведомл</VAR> ==></CODE>
<DD>
<CODE>[</CODE> <VAR>лексема</VAR> <CODE>]</CODE> "=" <VAR>асинхр-вывод</VAR>

<DT><CODE><VAR>асинхр-вывод</VAR> ==></CODE>
<DD>
<VAR>асинхр-класс</VAR> { "," <VAR>результат</VAR> } <VAR>nl</VAR>

<DT><CODE><VAR>результ-класс</VAR> ==></CODE>
<DD>
"done" <CODE>|</CODE> "running" <CODE>|</CODE> "connected" <CODE>|</CODE> "error" <CODE>|</CODE> "exit"

<DT><CODE><VAR>асинхр-класс</VAR> ==></CODE>
<DD>
"stopped" <CODE>|</CODE> <EM>другое по необходимости, т.к. находится в
стадии разработки</EM>

<DT><CODE><VAR>результат</VAR> ==></CODE>
<DD>
<VAR>строка</VAR> "=" <VAR>значение</VAR>

<DT><CODE><VAR>значение</VAR> ==></CODE>
<DD>
<VAR>строка-си</VAR> <CODE>|</CODE> <VAR>набор</VAR> <CODE>|</CODE> <VAR>список</VAR>

<DT><CODE><VAR>набор</VAR> ==></CODE>
<DD>
"{}" <CODE>|</CODE> "{" <VAR>результат</VAR> { "," <VAR>результат</VAR> } "}"

<DT><CODE><VAR>список</VAR> ==></CODE>
<DD>
"<CODE>[]</CODE>" <CODE>|</CODE> "<CODE>[</CODE>" <VAR>значение</VAR> { "," <VAR>значение</VAR> } "<CODE>]</CODE>"

<DT><CODE><VAR>строка</VAR> ==></CODE>
<DD>
<EM>[-A-Za-z\.0-9_]*</EM>

<DT><CODE><VAR>строка-си</VAR> ==></CODE>
<DD>
<EM>Смотри спецификацию ввода</EM>

<DT><CODE><VAR>поточн-запись</VAR> ==></CODE>
<DD>
<VAR>консольн-поточн-вывод</VAR> <CODE>|</CODE> <VAR>целев-поточн-вывод</VAR> <CODE>|</CODE> <VAR>журн-поточн-вывод</VAR>

<DT><CODE><VAR>консольн-поточн-вывод</VAR> ==></CODE>
<DD>
"~" <VAR>строка-си</VAR>

<DT><CODE><VAR>целев-поточн-вывод</VAR> ==></CODE>
<DD>
"@" <VAR>строка-си</VAR>

<DT><CODE><VAR>журн-поточн-вывод</VAR> ==></CODE>
<DD>
"&#38;" <VAR>строка-си</VAR>

<DT><CODE><VAR>nl</VAR> ==></CODE>
<DD>
CR <CODE>|</CODE> CR-LF

<DT><CODE><VAR>лексема</VAR> ==></CODE>
<DD>
"любая последовательность цифр"

</DL>

<P>
Кроме того, следующее находится в стадии разработки.


<DL COMPACT>

<DT><CODE><VAR>запрос</VAR></CODE>
<DD>
Это действие пока не определено.

</DL>

<P>
Замечания:



<UL>

<LI>

Все выходные последовательности заканчиваются строкой, содержащей точку.

<LI>

<CODE><VAR>Лексема</VAR></CODE> берется из соответствующего запроса.  Если
выполняющаяся команда прерывается командой <CODE>-exec-interrupt</CODE>,
лексема, ассоциированная с сообщением `*stopped', берется из исходной
выполнявшейся команды, а не из команды прерывания.

<LI>

<VAR>Асинхр-вывод-статуса</VAR> содержит информацию о статусе выполнения
медленной операции.  Она может быть отброшена.  Вся информация о статусе
начинается с префикса <SAMP>`+'</SAMP>.

<LI>

<VAR>Асинхр-вывод-выполн</VAR> содержит изменения асинхронного состояния на
цели (остановлена, запущена, исчезла).  Весь асинхронный вывод
начинается с префикса <SAMP>`*'</SAMP>.

<LI>

<VAR>Асинхр-вывод-уведомл</VAR> содержит дополнительную информацию, которую
должен обработать клиент (информация о новой точке останова).  Весь
уведомительный вывод начинается с префикса <SAMP>`='</SAMP>.

<LI>

<VAR>Консольн-поточн-вывод</VAR> является выводом, который должен быть
отображен на консоли без изменений.  Это текстовая реакция на команду
CLI.  Весь консольный вывод начинается с префикса <SAMP>`~'</SAMP>.

<LI>

<VAR>Целев-поточн-вывод</VAR> является выводом, произведенным целевой
программой.  Весь целевой вывод начинается с префикса <SAMP>`@'</SAMP>.

<LI>

<VAR>Журн-поточн-вывод</VAR> является текстом, исходящим изнутри
GDB, например, сообщения, которые должны быть выведены как
часть журнала ошибок.  Весь журнальный вывод начинается с префикса
<SAMP>`&#38;'</SAMP>.

</UL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_19.html">previous</A>, <A HREF="gdb_21.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
