<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gdb.texinfo on 1 November 2000 -->

<TITLE>Отладка с помощью GDB - Определение отладочной цели</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_13.html">previous</A>, <A HREF="gdb_15.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC106" HREF="gdb_toc.html#TOC106">Определение отладочной цели</A></H1>

<P>
<A NAME="IDX512"></A>
<A NAME="IDX513"></A>


<P>
<EM>Цель</EM>---это среда выполнения, занятая вашей программой.


<P>
Часто GDB выполняется в той же рабочей среде, что и ваша
программа; в этом случае, отладочная цель задается неявно в момент
использования команд <CODE>file</CODE> или <CODE>core</CODE>.  Когда вам нужна
большая гибкость---например, выполнение GDB на другой машине, или
управление автономной системой через последовательный порт или системой
реального времени через соединение TCP/IP---вы можете использовать
команду <CODE>target</CODE> для определения цели одного из типов,
сконфигурированных для GDB (see section <A HREF="gdb_14.html#SEC108">Команды для управления целями</A>).




<H2><A NAME="SEC107" HREF="gdb_toc.html#TOC107">Активные цели</A></H2>

<P>
<A NAME="IDX514"></A>
<A NAME="IDX515"></A>
<A NAME="IDX516"></A>


<P>
Существует три класса целей: процессы, файлы дампов памяти и
выполняемые файлы.  GDB может обрабатывать одновременно до трех
активных целей, по одной в каждом классе.  Это позволяет вам (например)
запустить процесс и проверять его действия, не прерывая вашу работу над
файлом дампа.


<P>
Например, если вы выполняете <SAMP>`gdb a.out'</SAMP>, то исполняемый файл
<CODE>a.out</CODE> является единственной активной целью.  Если вы назначите также
файл дампа---возможно от предыдущего выполнения, завершившегося ошибкой
и создавшего дамп---
тогда GDB имеет две активные цели и использует их вместе,
просматривая сначала файл дампа, а затем исполняемый файл, для выполнения
запросов к адресам памяти.  (Обычно эти два класса целей дополняют друг
друга, так как файлы дампа памяти содержит только память программы,
доступную для чтения и записи
(переменные и тому подобное), и машинное состояние, в то время как исполняемый
файлы содержат только текст программы и инициализированные данные.)


<P>
Когда вы вводите <CODE>run</CODE>, ваш исполняемый файл становится также активным
целевым процессом.  Когда целевой процесс активен, все команды GDB,
запрашивающие адреса памяти, относятся к этой цели; адреса в активной
цели файла дампа или выполняемого файла неизвестны, пока активен
целевой процесс.


<P>
Используйте команды <CODE>core-file</CODE> и <CODE>exec-file</CODE> для выбора новой
цели файла дампа памяти или выполняемого файла (see section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>).  Для определения в качестве цели
процесса, который уже выполняется, используйте команду <CODE>attach</CODE>
(see section <A HREF="gdb_5.html#SEC22">Отладка запущенного ранее процесса</A>).




<H2><A NAME="SEC108" HREF="gdb_toc.html#TOC108">Команды для управления целями</A></H2>

<DL COMPACT>

<DT><CODE>target <VAR>тип</VAR> <VAR>параметры</VAR></CODE>
<DD>
Соединяет рабочую среду GDB с целевой машиной или процессом.
Целью обычно является протокол для взаимодействия со средствами отладки.
Параметр <VAR>тип</VAR> используется, чтобы определить тип или протокол
целевой машины.

Дальнейшие <VAR>параметры</VAR> интерпретируются целевым
протоколом, но обычно включают такие вещи, как имена
устройств или имена рабочих машин, с которыми осуществляется
связь, номера процессов и скорости в бодах.

Команда <CODE>target</CODE> не повторяется при повторном нажатии <KBD>RET</KBD> после
ее выполнения.

<A NAME="IDX517"></A>
<DT><CODE>help target</CODE>
<DD>
Отображает имена всех доступных целей.  Чтобы отобразить выбранные в
данный момент цели, используйте либо <CODE>info target</CODE>, либо <CODE>info
files</CODE> (see section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>).

<DT><CODE>help target <VAR>имя</VAR></CODE>
<DD>
Описывает определенную цель, включая любые параметры, необходимые для ее
выбора.

<A NAME="IDX518"></A>
<DT><CODE>set gnutarget <VAR>арг</VAR></CODE>
<DD>
GDB использует свою собственную библиотеку BFD<A NAME="DOCF14" HREF="gdb_foot.html#FOOT14">(14)</A> для чтения ваших
файлов.  GDB знает, читает ли он <EM>выполняемый файл</EM>,
<EM>файл дампа памяти</EM> или <EM>объектный (.o)</EM> файл; однако вы можете
определить формат файла командой <CODE>set gnutarget</CODE>.  В отличие от
большинства команд <CODE>target</CODE>, с <CODE>gnutarget</CODE>, команда <CODE>target</CODE>
относится к программе, а не к машине.


<BLOCKQUOTE>
<P>
<EM>Предупреждение:</EM> Для определения формата файла посредством <CODE>set
gnutarget</CODE>, вы должны знать фактическое имя BFD.
</BLOCKQUOTE>

See section <A HREF="gdb_13.html#SEC104">Команды для задания файлов</A>.

<A NAME="IDX519"></A>
<DT><CODE>show gnutarget</CODE>
<DD>
Используйте команду <CODE>show gnutarget</CODE> для отображения, какого
формата файлы <CODE>gnutarget</CODE> установлен считывать.  Если вы не
установили <CODE>gnutarget</CODE>, GDB определит формат для каждого файла
автоматически, и <CODE>show gnutarget</CODE> выведет <SAMP>`The current BFD target
is "auto"'</SAMP>.
</DL>

<P>
Ниже приведены некоторые наиболее распространенные цели (доступные или нет, в
зависимоси от конфигурации GDB):


<DL COMPACT>

<DT><CODE>target exec <VAR>программа</VAR></CODE>
<DD>
<A NAME="IDX520"></A>
 
Выполняемый файл.  <SAMP>`target exec <VAR>программа</VAR>'</SAMP> то же самое, что и
<SAMP>`exec-file <VAR>программа</VAR>'</SAMP>.

<A NAME="IDX521"></A>
<DT><CODE>target core <VAR>имя-файла</VAR></CODE>
<DD>
Файл дампа памяти.  <SAMP>`target core <VAR>имя-файла</VAR>'</SAMP> то же самое, что и
<SAMP>`core-file <VAR>имя-файла</VAR>'</SAMP>.

<A NAME="IDX522"></A>
<DT><CODE>target remote <VAR>устр</VAR></CODE>
<DD>
Удаленная последовательная цель является уникальным для GDB
протоколом.  Параметр <VAR>устр</VAR> определяет, какое последовательное
устройство использовать для соединения (например, <TT>`/dev/ttya'</TT>).
See section <A HREF="gdb_14.html#SEC110">Удаленная отладка</A>.  <CODE>target remote</CODE>
поддерживает команду <CODE>load</CODE>.  Это полезно, только если вы можете
получить заглушку для целевой системы каким-нибудь другим
способом и можете разместить ее в памяти, где она не будет
затерта загрузкой.

<A NAME="IDX523"></A>
<DT><CODE>target sim</CODE>
<DD>
Встроенный эмулятор ЦП.  GDB включает эмуляторы для большинства
архитектур.  Вообще,

<PRE>
        target sim
        load
        run
</PRE>

работает; однако, вы не можете предположить, что доступны определенное
отображение памяти, драйверы устройств, или даже основные функции
ввода-вывода, хотя некоторые эмуляторы действительно предоставляют это.  Для
информации о деталях эмуляторов для конкретного процессора, смотрите
соответствующий section <A HREF="gdb_15.html#SEC128">Встроенные процессоры</A>.

</DL>

<P>
Некоторые конфигурации могут также включать такие цели:


<DL COMPACT>

<DT><CODE>target nrom <VAR>устр</VAR></CODE>
<DD>
<A NAME="IDX524"></A>
 
Эмулятор NetROM ROM.  Эта цель поддерживает только загрузку.

</DL>

<P>
Для различных конфигураций GDB доступны различные цели; ваша
конфигурация может иметь больше или меньше целей.


<P>
Многие удаленные цели требуют, чтобы вы загрузили код выполняемого
файла, после того как вы успешно установили соединение.


<DL COMPACT>

<DT><CODE>load <VAR>имя-файла</VAR></CODE>
<DD>
<A NAME="IDX525"></A>
 
В зависимости от того, какие возможности удаленной отладки
сконфигурированы в GDB, может быть доступна команда
<CODE>load</CODE>.  Если она существует, ее задачей является сделать
<VAR>имя-файла</VAR> (выполняемый файл) доступным для отладки на удаленной
системе---например, путем загрузки или динамической сборки.
<CODE>load</CODE> также записывает таблицу символов <VAR>имя-файла</VAR> в
GDB, как команда <CODE>add-symbol-file</CODE>.

Если ваш GDB не имеет команды <CODE>load</CODE>, попытка выполнить ее
выдает сообщение об ошибке "<CODE>You can't do that when your
target is ...</CODE>".

Файл загружается по адресу, указанному в выполняемом файле.  Для
некоторых форматов объектных файлов, вы можете задать адрес загрузки при
сборке программы; для других форматов, таких как a.out, формат
объектного файла задает фиксированный адрес.

<CODE>load</CODE> не повторяется, если вы нажимаете <KBD>RET</KBD> снова после ее
использования.
</DL>



<H2><A NAME="SEC109" HREF="gdb_toc.html#TOC109">Выбор целевого порядка байтов</A></H2>

<P>
<A NAME="IDX526"></A>
<A NAME="IDX527"></A>


<P>
Некоторые типы процессоров, такие как MIPS, PowerPC и Hitachi SH,
предоставляют возможность выполнения либо с порядком байтов от старшего,
либо с порядком байтов от младшего.  Обычно, выполняемый файл или
символы содержат информацию для определения используемого порядка
байтов, и вам не нужно об этом заботиться.  Однако, иногда вам все же
может пригодиться вручную изменить порядок байтов процессора,
определенный GDB.


<DL COMPACT>

<DT><CODE>set endian big</CODE>
<DD>
<A NAME="IDX528"></A>
 
Велит GDB считать, что целевой порядок байтов от старшего.

<A NAME="IDX529"></A>
<DT><CODE>set endian little</CODE>
<DD>
Велит GDB считать, что целевой порядок байтов от младшего.

<A NAME="IDX530"></A>
<DT><CODE>set endian auto</CODE>
<DD>
Велит GDB использовать порядок байтов, указанный в выполняемом
файле.

<DT><CODE>show endian</CODE>
<DD>
Отображает текущую установку GDB для целевого порядка байтов.

</DL>

<P>
Заметьте, что эти команды управляют только интерпретацией символьных
данных в рабочей системе, и они совершенно не оказывают действия на
целевую систему.




<H2><A NAME="SEC110" HREF="gdb_toc.html#TOC110">Удаленная отладка</A></H2>
<P>
<A NAME="IDX531"></A>


<P>
Если вы пытаетесь отлаживать программу, выполняющуюся на машине,
которая не может запустить GDB обычным способом, часто бывает полезна
удаленная отладка.  Например, вы можете использовать удаленную
отладку для ядра операционной системы или для малой системы, которая не
имеет достаточно мощной операционной системы общего назначения для
вызова отладчика со всеми возможностями.


<P>
Некоторые конфигурации GDB имеют специальный последовательный или
TCP/IP интерфейсы для того, чтобы это работало с конкретными отладочными
целями.  Кроме того, GDB распространяется с общим
последовательным протоколом (уникальным для GDB, но не для
конкретной целевой системы), который вы можете использовать, если пишете
удаленные заглушки---код, выполняемый в удаленной системе для связи с
GDB.


<P>
В вашей конфигурации GDB могут быть доступны другие удаленные
цели; используете <CODE>help target</CODE>, чтобы их перечислить.




<H3><A NAME="SEC111" HREF="gdb_toc.html#TOC111">Удаленный последовательный протокол GDB</A></H3>

<P>
<A NAME="IDX532"></A>
Для отладки программы, выполняемой на другой машине (отладочной
<EM>целевой</EM> машине), вы сперва должны создать все обычные
предпосылки для самостоятельного выполнения программы.  Например, для
программы на Си вам нужны:



<OL>
<LI>

Процедура запуска для установки среды выполнения Си; она обычно
имеет имя типа <TT>`crt0'</TT>.  Процедура запуска может быть
обеспечена вашими аппаратными средствами, или вы должны
написать свою собственную.

<LI>

Библиотека подпрограмм Си для поддержки вызовов подпрограмм вашей
программы, особенно для управления вводом и выводом.

<LI>

Способ установки вашей программы на другую машину---например,
программа загрузки.  Такие программы часто предоставляются поставщиками
аппаратных средств, но вам может потребоваться написать вашу
собственную, пользуясь документацией к аппаратному обеспечению.
</OL>

<P>
Следующим шагом будет принятие мер по использованию вашей
программой последовательного порта для связи с машиной, где
выполняется GDB (<EM>рабочей</EM> машиной).  В общих чертах, схема
выглядит следующим образом:


<DL COMPACT>

<DT><EM>На рабочей машине</EM>
<DD>
GDB уже понимает, как использовать этот протокол; после установки
всего остального, вы можете просто использовать
команду <SAMP>`target remote'</SAMP> (see section <A HREF="gdb_14.html#SEC106">Определение отладочной цели</A>).

<DT><EM>На целевой машине</EM>
<DD>
вы должны скомпоновать вместе с вашей программой несколько подпрограмм
специального назначения, которые реализуют удаленный последовательный
протокол GDB.  Файл, содержащий эти подпрограммы, называется
<EM>отладочной заглушкой</EM>.

На некоторых удаленных целях, вы можете использовать вспомогательную
программу <CODE>gdbserver</CODE> вместо компоновки заглушки вместе с вашей
программой.  See section <A HREF="gdb_14.html#SEC116">Использование программы <CODE>gdbserver</CODE></A>,
для детального изучения.
</DL>

<P>
Отладочная заглушка специфична для архитектуры удаленной машины;
например, используйте <TT>`sparc-stub.c'</TT> для отладки программ на
машинах SPARC.


<P>
<A NAME="IDX533"></A>
Следующие работающие удаленные заглушки распространяются вместе с GDB:


<DL COMPACT>

<DT><CODE>i386-stub.c</CODE>
<DD>
<A NAME="IDX534"></A>
<A NAME="IDX535"></A>
<A NAME="IDX536"></A>
Для Intel 386 и совместимых архитектур.

<DT><CODE>m68k-stub.c</CODE>
<DD>
<A NAME="IDX537"></A>
<A NAME="IDX538"></A>
<A NAME="IDX539"></A>
Для архитектур Motorola 680x0.

<DT><CODE>sh-stub.c</CODE>
<DD>
<A NAME="IDX540"></A>
<A NAME="IDX541"></A>
<A NAME="IDX542"></A>
Для архитектур Hitachi SH.

<DT><CODE>sparc-stub.c</CODE>
<DD>
<A NAME="IDX543"></A>
<A NAME="IDX544"></A>
Для архитектур SPARC.

<DT><CODE>sparcl-stub.c</CODE>
<DD>
<A NAME="IDX545"></A>
<A NAME="IDX546"></A>
<A NAME="IDX547"></A>
Для архитектур Fujitsu SPACRLITE.

</DL>

<P>
Файл <TT>`README'</TT> в поставке GDB может содержать другие
недавно добавленные заглушки.




<H4><A NAME="SEC112" HREF="gdb_toc.html#TOC112">Что заглушка может сделать для вас</A></H4>

<P>
<A NAME="IDX548"></A>
Отладочная заглушка для вашей архитектуры содержит следующие
три подпрограммы:


<DL COMPACT>

<DT><CODE>set_debug_traps</CODE>
<DD>
<A NAME="IDX549"></A>
<A NAME="IDX550"></A>
Когда ваша программа останавливается, эта подпрограмма организует
выполнение <CODE>handle_exception</CODE>.  Вы должны явно вызвать эту
подпрограмму в начале вашей программы.

<DT><CODE>handle_exception</CODE>
<DD>
<A NAME="IDX551"></A>
<A NAME="IDX552"></A>
Это главная рабочая лошадка, но ваша программа никогда не вызывает ее
явно---установочный код организует запуск <CODE>handle_exception</CODE>, когда
вызывается ловушка.

<CODE>handle_exception</CODE> получает управление, когда ваша программа
останавливается во время выполнения (например, в точке останова), и
организует связь с GDB на рабочей машине.  Именно здесь
реализуется протокол связи; <CODE>handle_exception</CODE> действует как
представитель GDB на целевой машине.  Сперва она посылает
суммарную информацию о состоянии вашей программы, затем продолжает
выполняться, извлекая и передавая любую информацию, требующуюся
GDB, пока вы не выполните команду GDB, возобновляющую
выполнение вашей программы; в этом месте <CODE>handle_exception</CODE>
возвращает управление вашему коду на целевой машине.

<DT><CODE>breakpoint</CODE>
<DD>
<A NAME="IDX553"></A>
Используйте эту вспомогательную подпрограмму для установки в вашей
программе точек останова.  В зависимости от конкретной ситуации, это
может быть единственным способом для GDB получить управление.
Например, если ваша целевая машина имеет некую клавишу прерывания, вам
не нужно вызывать эту подпрограмму; нажатие клавиши прерывания передаст
управление <CODE>handle_exception</CODE>---в действительности, GDB.
На некоторых машинах простое получение символов на последовательный порт
может также вызвать ловушку; опять, в этой ситуации вам не нужно вызывать
<CODE>breakpoint</CODE> из вашей программы---простое выполнение <SAMP>`target
remote'</SAMP> из рабочего сеанса GDB передаст управление.

Вызывайте <CODE>breakpoint</CODE>, если ни одно из этих предположений не верно,
или вы просто хотите быть уверенным, что ваша программа остановится в
предопределенной точке от начала вашего сеанса отладки.
</DL>



<H4><A NAME="SEC113" HREF="gdb_toc.html#TOC113">Что вы должны сделать для заглушки</A></H4>

<P>
<A NAME="IDX554"></A>
Отладочные заглушки, поставляемые с GDB, ориентированы на
микропроцессоры определенной архитектуры, но они не имеют информации
об остальной части вашей целевой отладочной машины.


<P>
В первую очередь, вам нужно сообщить заглушке, как связаться с
последовательным портом.


<DL COMPACT>

<DT><CODE>int getDebugChar()</CODE>
<DD>
<A NAME="IDX555"></A>
Напишите эту подпрограмму для чтения одного символа из
последовательного порта.  Она может быть идентична <CODE>getchar</CODE> для
вашей целевой системы; разные имена используются, чтобы позволить
вам их различать, если вы этого хотите.

<DT><CODE>void putDebugChar(int)</CODE>
<DD>
<A NAME="IDX556"></A>
Напишите эту подпрограмму для записи одного символа в
последовательный порт.  Она может быть идентична <CODE>putchar</CODE> для
вашей целевой системы; разные имена используются, чтобы позволить
вам их различать, если вы этого хотите.
</DL>

<P>
<A NAME="IDX557"></A>
<A NAME="IDX558"></A>
Если вы хотите, чтобы GDB мог остановить вашу программу во
время ее выполнения, вам нужно использовать управляемый прерываниями
последовательный драйвер и настроить его для остановки при получении
<CODE>^C</CODE> (<SAMP>`\003'</SAMP>, символ control-C).  Это тот символ, который
GDB использует для указания удаленной системе остановиться.


<P>
Указание отладочной цели вернуть GDB правильный статус,
вероятно, требует изменений стандартной заглушки; один быстрый и
неаккуратный способ состоит в выполнении лишь инструкции точки останова
("неаккуратность" состоит в том, что GDB выдает
<CODE>SIGTRAP</CODE> вместо <CODE>SIGINT</CODE>).


<P>
Вот другие процедуры, которые вы должны обеспечить:


<DL COMPACT>

<DT><CODE>void exceptionHandler (int <VAR>номер-исключения</VAR>, void *<VAR>адрес-исключения</VAR>)</CODE>
<DD>
<A NAME="IDX559"></A>
Напишите эту функцию для установки <VAR>адреса-исключения</VAR> в таблицы
обработки исключительных ситуаций.  Вам нужно сделать это, потому
что у заглушки нет способа узнать, как устроены таблицы обработки
исключений в вашей целевой системе (например, процессорная
таблица может быть в пзу, и содержать элементы, указывающие на
таблицу в озу).  <VAR>Номер-исключения</VAR>---это номер исключительной
ситуации, которая должна быть изменена; его значение зависит от
архитектуры (например, различные номера могут представлять
деление на ноль, доступ с нарушением выравнивания, и так далее).  Когда
это исключение возникает, управление должно быть передано
непосредственно <VAR>адресу-исключения</VAR>, и процессорное
состояние (стек, регистры и так далее) должно быть таким же, как
во время возникновения процессорного исключения.  Так что если вы хотите
использовать инструкцию перехода для достижения <VAR>адреса-исключения</VAR>,
это должен быть простой переход, не переход к подпрограмме.

Для 386, <VAR>адрес-исключения</VAR> должен быть установлен как обработчик
затвора вызова
прерывания, чтобы во время его выполнения остальные прерывания маскировались.
Он должен иметь уровень полномочий 0 (наибольшие полномочия).  Заглушки
SPARC и 68k могут маскировать прерывания самостоятельно без помощи
<CODE>exceptionHandler</CODE>.

<DT><CODE>void flush_i_cache()</CODE>
<DD>
<A NAME="IDX560"></A>
Только для SPARC и SPARCLITE.  Напишите эту попрограмму для
очистки кеша инструкций, если он есть, на вашей целевой машине.
Если кеша инструкций нет, эта подпрограмма может ничего не делать.

На целевых машинах, имеющих кеш инструкций, GDB требует эту
функцию, чтобы удостовериться, что состояние вашей программы
стабильное.
</DL>

<P>
Вы должны также удостовериться, что эта библиотечная процедура доступна:


<DL COMPACT>

<DT><CODE>void *memset(void *, int, int)</CODE>
<DD>
<A NAME="IDX561"></A>
Это стандартная библиотечная функция <CODE>memset</CODE>, которая
устанавливает область памяти в заданное значение.  Если вы имеете
одну из свободных версий <CODE>libc.a</CODE>, <CODE>memset</CODE> может быть найдена
там; иначе вы должны или получить ее от изготовителя аппаратного
обеспечения, или написать свою собственную.
</DL>

<P>
Если вы не используете компилятор GNU Си, вам также могут
понадобиться другие стандартные библиотечные подпрограммы; это
меняется от одной заглушки к другой, но в общем, заглушки
часто используют различные общие библиотечные подпрограммы, которые
<CODE>gcc</CODE> генерирует как встроенный код.




<H4><A NAME="SEC114" HREF="gdb_toc.html#TOC114">Собираем все вместе</A></H4>

<P>
<A NAME="IDX562"></A>
Вкратце, когда ваша программа готова к отладке, вы должны проделать
следующие шаги.



<OL>
<LI>

Убедитесь, что вы определили поддерживающие процедуры низкого уровня
(see section <A HREF="gdb_14.html#SEC113">Что вы должны сделать для заглушки</A>):

<PRE>
<CODE>getDebugChar</CODE>, <CODE>putDebugChar</CODE>,
<CODE>flush_i_cache</CODE>, <CODE>memset</CODE>, <CODE>exceptionHandler</CODE>.
</PRE>

<LI>

Вставьте следующие строки в начале вашей программы:


<PRE>
set_debug_traps();
breakpoint();
</PRE>

<LI>

Для заглушки 680x0, вы должны предоставить переменную
<CODE>exceptionHook</CODE>.  Обычно вы используете просто:


<PRE>
void (*exceptionHook)() = 0;
</PRE>

если до вызова <CODE>set_debug_traps</CODE> вы установили ее для
указания на функцию в вашей программе.  Эта функция вызывается, когда
GDB продолжает выполнение после останова на ловушке (например,
ошибка шины).
Функция, указанная <CODE>exceptionHook</CODE>, вызывается с одним
параметром типа <CODE>int</CODE>, который является номером исключения.

<LI>

Откомпилируйте и скомпонуйте вместе: вашу программу, отладочную
заглушку GDB для вашей целевой архитектуры и
подпрограммы поддержки.

<LI>

Убедитесь, что у вас есть последовательное соединение между вашей целевой
и рабочей машинами, и идентифицируйте последовательный порт на
рабочей машине.

<LI>

Загрузите вашу программу на целевую машину (или поместите ее туда
любыми средствами, предоставляемыми производителем) и запустите ее.

<LI>

Для начала удаленной отладки, запустите GDB на рабочей машине
и укажите в качестве выполняемого файла программу, которая выполняется
на удаленной машине.  Это сообщает GDB, как найти символы и
содержание неизменяемых областей вашей программы.

<LI>

<A NAME="IDX563"></A>
Установите связь, используя команду <CODE>target remote</CODE>.  Ее
аргументы определяют, как взаимодействовать с целевой машиной---
либо через устройство, подключенное к последовательной линии,
либо через порт TCP (обычно подключенный к терминальному серверу, который,
в свою очередь, имеет последовательную линию до цели).  Например,
чтобы использовать последовательную линию, присоединенную к устройству
<TT>`/dev/ttyb'</TT>, выполните:


<PRE>
target remote /dev/ttyb
</PRE>

<A NAME="IDX564"></A>
Чтобы использовать TCP-соединение, используйте аргумент в форме
<CODE><VAR>машина</VAR>:порт</CODE>.  Например, для соединения с портом 2828 на
терминальном сервере <CODE>manyfarms</CODE>:


<PRE>
target remote manyfarms:2828
</PRE>

</OL>

<P>
Теперь вы можете использовать все обычные команды для исследования и изменения
данных, пошагового выполнения и продолжения исполнения удаленной
программы.


<P>
Для возобновления выполнения удаленной программы и прекращения ее
отладки, используйте команду <CODE>detach</CODE>.


<P>
<A NAME="IDX565"></A>
<A NAME="IDX566"></A>
Всякий раз, когда GDB ожидает удаленную программу, если вы вводите
символ прерывания (часто <KBD>C-C</KBD>), GDB пытается остановить
программу.  Это может привести или не привести к успеху, частично в
зависимости от аппаратных средств и последовательных драйверов, которые
использует удаленная система.  Если вы снова введете символ прерывания,
GDB выведет такое приглашение:



<PRE>
Interrupted while waiting for the program.
Give up (and stop debugging it)?  (y or n)
</PRE>

<P>
Если вы введете <KBD>y</KBD>, GDB прекратит сеанс удаленной отладки.
(Если вы решите позже, что хотите попытаться снова, вы можете вновь
использовать <CODE>target remote</CODE>, чтобы соединиться еще раз.)  Если вы
введете <KBD>n</KBD>, GDB вернется к ожиданию.




<H4><A NAME="SEC115" HREF="gdb_toc.html#TOC115">Коммуникационный протокол</A></H4>

<P>
<A NAME="IDX567"></A>
<A NAME="IDX568"></A>
<A NAME="IDX569"></A>
Файлы заглушек, поставляемые с GDB, реализуют коммуникационный
протокол со стороны целевой машины, а со стороны GDB он
реализуется в исходном файле GDB <TT>`remote.c'</TT>.  Обычно вы
можете просто позволить этим программам взаимодействовать, и
не вдаваться в детали.  (Если вы разрабатываете свой собственный файл
заглушки, вы также можете игнорировать детали: начните с одного из
существующих файлов заглушки.  <TT>`sparc-stub.c'</TT> организован наилучшим
образом, и потому его легче всего читать.)


<P>
Однако, бывают случаи, когда вам необходимо что-нибудь знать о
протоколе---например, если существует только один последовательный порт
на вашей целевой машине, вы можете захотеть, чтобы ваша программа делала
что-нибудь особенное, если она распознает предназначенный для GDB
пакет.


<P>
В следующих примерах, <SAMP>`&#60;-'</SAMP> и <SAMP>`-&#62;'</SAMP> используются для обозначения
переданных и полученных данных соответственно.


<P>
<A NAME="IDX570"></A>
<A NAME="IDX571"></A>
<A NAME="IDX572"></A>
Все команды и ответы GDB (не подтверждения),
посылаются в виде <VAR>пакета</VAR>.  <VAR>Пакет</VAR> представлен символом <SAMP>`$'</SAMP>,
реальными <VAR>данными-пакета</VAR> завершающим символом <SAMP>`#'</SAMP>, за которым
следуют две цифры <VAR>контрольной-суммы</VAR>:



<PRE>
<CODE>$</CODE><VAR>данные-пакета</VAR><CODE>#</CODE><VAR>контрольная-сумма</VAR>
</PRE>

<P>


<P>
<A NAME="IDX573"></A>
Двухциферная <VAR>контрольная-сумма</VAR> вычисляется как сумма по модулю 256
всех символов между начальным <SAMP>`$'</SAMP> и конечным <SAMP>`#'</SAMP> (восьмибитная
беззнаковая контрольная сумма).


<P>
Разработчикам следует учесть, что до GDB версии 5.0
спецификация протокола также включала необязательный двухциферный
<VAR>ид-последов</VAR>:



<PRE>
<CODE>$</CODE><VAR>ид-последов</VAR><CODE>:</CODE><VAR>данные-пакета</VAR><CODE>#</CODE><VAR>контрольная-сумма</VAR>
</PRE>

<P>
<A NAME="IDX574"></A>
Этот <VAR>ид-последов</VAR> добавлялся к подтверждению.
GDB никогда не генерировал <VAR>ид-последов</VAR>.
Заглушки, занимающиеся обработкой пакетов, добавленные в GDB
начиная с версии 5.0, не должны принимать пакеты с
<VAR>ид-последов</VAR>.


<P>
<A NAME="IDX575"></A>
Когда или рабочая, или целевая машина получает пакет, первым ожидаемым
ответом является подтверждение: или <SAMP>`+'</SAMP> (для указания, что пакет
получен корректно), или <SAMP>`-'</SAMP> (чтобы запросить повторную передачу):



<PRE>
&#60;- <CODE>$</CODE><VAR>данные-пакета</VAR><CODE>#</CODE><VAR>контрольная-сумма</VAR>
-&#62; <CODE>+</CODE>
</PRE>

<P>


<P>
Рабочая машина (GDB) посылает <VAR>команды</VAR>, а целевая (отладочная
заглушка, включенная в вашу программу) посылает <VAR>ответ</VAR>.  В случае
<VAR>команд</VAR> пошагового выполнения и продолжения, ответ посылается
только тогда, когда операция закончена (цель снова остановлена).


<P>
<VAR>Данные-пакета</VAR> состоят из последовательности знаков, за исключением
<SAMP>`#'</SAMP> и <SAMP>`$'</SAMP> (для дополнительных исключений, смотрите пакет
<SAMP>`X'</SAMP>).


<P>
Поля внутри пакета должны разделяться при помощи <SAMP>`,'</SAMP>, <SAMP>`;'</SAMP> или
<SAMP>`:'</SAMP>.  Если не оговорено противное, все числа представлены в
шестнадцатеричном виде без начальных нулей.


<P>
Разработчикам следует учесть, что до GDB версии 5.0, символ
<SAMP>`:'</SAMP> не мог появляться третим символом в пакете (так как
потенциально это могло привести к конфликту с
<VAR>ид-последов</VAR>).


<P>
Ответ <VAR>данные</VAR> может быть закодированным с помощью кодирования
методом длины серий, чтобы
сохранить место.  <SAMP>`*'</SAMP> означает, что следующий символ является
ASCII-кодом, который означает количество повторений символа,
предшествующего <SAMP>`*'</SAMP>.  Кодировкой является <CODE>n+29</CODE>, что дает печатный
знак для <CODE>n &#62;=3</CODE> (когда кодировка переменной длины дает
преимущества).  Печатные знаки <SAMP>`$'</SAMP>, <SAMP>`#'</SAMP>, <SAMP>`+'</SAMP>, <SAMP>`-'</SAMP>,
или с номерами, большими 126, использоваться не должны.


<P>
Некоторые удаленные системы использовали другой механизм кодировки с
переменной длиной, иногда называемый cisco-кодировкой.  За <SAMP>`*'</SAMP>
следуют две шестнадцатеричные цифры, обозначающие размер пакета.


<P>
Итак:

<PRE>
"<CODE>0* </CODE>"
</PRE>

<P>
означает то же, что и "0000".


<P>
При ошибке, ответ, возвращаемый для некоторых пакетов, включает
двухсимвольный номер ошибки.  Этот номер определен смутно.


<P>
Для любой <VAR>команды</VAR>, не поддерживаемой заглушкой, должен быть
возвращен пустой ответ (<SAMP>`$#00'</SAMP>).  Таким образом, протокол можно
расширять.  Новые версии GDB могут определить, поддерживается
ли пакет, основываясь на ответе.


<P>
От заглушки требуется поддержка <VAR>команд</VAR> <SAMP>`g'</SAMP>, <SAMP>`G'</SAMP>,
<SAMP>`m'</SAMP>, <SAMP>`M'</SAMP>, <SAMP>`c'</SAMP> и <SAMP>`s'</SAMP>.  Все остальные <VAR>команды</VAR>
являются необязательными.


<P>
Вот полный список всех определенных на данный момент <VAR>команд</VAR>, и
соответствующих им ответов <VAR>данные</VAR>:
<TABLE BORDER>

<TR><TD>Пакет</TD>

</TD><TD> Запрос
</TD><TD> Описание

</TR>
<TR><TD>расширенные операции</TD>

</TD><TD> <CODE>!</CODE>
</TD><TD>
Использовать расширенный удаленный протокол.  Имеет постоянное
действие---требует установки только один раз.  Расширенный удаленный
протокол поддерживает пакеты <SAMP>`R'</SAMP>.
</TR>
<TR><TD></TD>

</TD><TD> ответ <SAMP>`'</SAMP>
</TD><TD>
Заглушки, поддерживающие расширенный удаленный протокол, возвращают
<SAMP>`'</SAMP>, что, к сожалению, совпадает с ответом, возвращаемым заглушками,
которые не поддерживают расширения протокола.

</TR>
<TR><TD>последний сигнал</TD>

</TD><TD> <CODE>?</CODE>
</TD><TD>
Указывает причину, по которой цель остановилась.  Ответ такой же, как
для пошагового выполнения и продолжения.
</TR>
<TR><TD></TD>

</TD><TD> ответ
</TD><TD> смотрите ниже

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>a</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>установить аргументы программы <STRONG>(зарезервировано)</STRONG></TD>

</TD><TD> <CODE>A</CODE><VAR>длина-арг</VAR><CODE>,</CODE><VAR>число-арг</VAR><CODE>,</CODE><VAR>арг</VAR><CODE>,...</CODE>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
В программу передается инициализированный массив <SAMP>`argv[]'</SAMP>.
<VAR>Длина-арг</VAR> задает число байт в закодированном в шестнадцатеричный
вид потоке байт <VAR>арг</VAR>.  Смотрите <TT>`gdbserver'</TT> для
дополнительной информации.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>

</TR>
<TR><TD>установить скорость <STRONG>(не рекомендовано)</STRONG></TD>

</TD><TD> <CODE>b</CODE><VAR>бод</VAR>
</TD><TD>
Установить скорость последовательной линии в <VAR>бод</VAR>.

</TR>
<TR><TD>установить точку останова <STRONG>(не рекомендовано)</STRONG></TD>

</TD><TD> <CODE>B</CODE><VAR>адрес</VAR>,<VAR>режим</VAR>
</TD><TD>
Установить (<VAR>режим</VAR> <SAMP>`S'</SAMP>) или удалить (<VAR>режим</VAR> <SAMP>`C'</SAMP>)
точку останова по адресу <VAR>адрес</VAR>.  <EM>Это было замещено пакетами
<SAMP>`Z'</SAMP> и <SAMP>`z'</SAMP>.</EM>

</TR>
<TR><TD>продолжить</TD>

</TD><TD> <CODE>c</CODE><VAR>адрес</VAR>
</TD><TD>
<VAR>Адрес</VAR>---это адрес для возобновления выполнения.  Если он
опущен, возобновить с текущего адреса.
</TR>
<TR><TD></TD>

</TD><TD> ответ
</TD><TD> смотрите ниже

</TR>
<TR><TD>продолжить с сигналом</TD>

</TD><TD> <CODE>C</CODE><VAR>сиг</VAR><CODE>;</CODE><VAR>адрес</VAR>
</TD><TD>
Продолжить с сигналом <VAR>сиг</VAR> (шестнадцатеричный номер сигнала).  Если
`<CODE>;</CODE><VAR>адрес</VAR>' опущено, выполнение возобновляется с прежнего
адреса.
</TR>
<TR><TD></TD>

</TD><TD> ответ
</TD><TD> смотрите ниже

</TR>
<TR><TD>переключить режим отладки <STRONG>(не рекомендовано)</STRONG></TD>

</TD><TD> <CODE>d</CODE>
</TD><TD>
переключить флаг отладки.

</TR>
<TR><TD>отсоединиться</TD>

</TD><TD> <CODE>D</CODE>
</TD><TD>
Отсоединить GDB от удаленной системы.  Посылается удаленной
системе перед тем, как GDB отсоединится.
</TR>
<TR><TD></TD>

</TD><TD> ответ <EM>нет ответа</EM>
</TD><TD>
GDB не ждет никакого ответа после посылки этого пакета.

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>e</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>E</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>f</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>F</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>чтение регистров</TD>

</TD><TD> <CODE>g</CODE>
</TD><TD> Чтение регистров общего назначения.
</TR>
<TR><TD></TD>

</TD><TD> ответ <VAR>XX...</VAR>
</TD><TD>
Каждый байт данных регистра описывается двумя шестнадцатеричными
цифрами.  Они передаются с целевым порядком байтов.  Размер каждого
регистра и его позиция внутри <VAR>пакета</VAR> <SAMP>`g'</SAMP> определяются
внутренними макросами GDB <VAR>REGISTER_RAW_SIZE</VAR> и
<VAR>REGISTER_NAME</VAR>.  Спецификация нескольких стандартных пакетов
<SAMP>`g'</SAMP> приведена ниже.
</TR>
<TR><TD></TD>

</TD><TD> <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> в случае ошибки.

</TR>
<TR><TD>запись в регистры</TD>

</TD><TD> <CODE>G</CODE><VAR>XX...</VAR>
</TD><TD>
Смотрите <SAMP>`g'</SAMP> для описания данных <VAR>XX...</VAR> .
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> в случае успеха
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> в случае ошибки

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>h</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>выбрать нить</TD>

</TD><TD> <CODE>H</CODE><VAR>c</VAR><VAR>t...</VAR>
</TD><TD>
Установить нить для последующих операций (<SAMP>`m'</SAMP>, <SAMP>`M'</SAMP>, <SAMP>`g'</SAMP>,
<SAMP>`G'</SAMP>, и другие).  <VAR>c</VAR> = <SAMP>`c'</SAMP> для нитей, используемых при
пошаговом выполнении и продолжении; <VAR>t...</VAR> может быть -1 для всех
нитей.  <VAR>c</VAR> = <SAMP>`g'</SAMP> для нитей, используемых в других операциях.
Если ноль---выбрать любую нить.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> в случае успеха
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> в случае ошибки

</TR>
<TR><TD>пошаговое выполнение по тактовому циклу <STRONG>(черновик)</STRONG></TD>

</TD><TD> <CODE>i</CODE><VAR>адрес</VAR><CODE>,</CODE><VAR>nnn</VAR>
</TD><TD>
Выполнить один тактовый цикл на удаленной машине.  Если
`<CODE>,</CODE><VAR>nnn</VAR>' указано, выполнить <VAR>nnn</VAR> циклов.  Если
указан <VAR>адрес</VAR>, пошаговое выполнение по одному тактовому циклу
начинается этого адреса.

</TR>
<TR><TD>сигнал, затем выполнение по тактовым циклам <STRONG>(зарезервировано)</STRONG></TD>

</TD><TD> <CODE>I</CODE>
</TD><TD>
Смотрите <SAMP>`i'</SAMP> и <SAMP>`S'</SAMP>, там аналогичный синтаксис и семантика.

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>j</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>J</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>убить</TD>

</TD><TD> <CODE>k</CODE>
</TD><TD>
FIXME: <EM>Нет описания, как действовать в случае, если был выбран
контекст определенной нити (то есть <SAMP>`k'</SAMP> убивает только эту нить?)</EM>.

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>l</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>L</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>чтение памяти</TD>

</TD><TD> <CODE>m</CODE><VAR>адрес</VAR><CODE>,</CODE><VAR>длина</VAR>
</TD><TD>
Прочитать <VAR>длину</VAR> байт памяти, начиная с адреса <VAR>адрес</VAR>.  Ни
GDB, ни заглушка не предполагают, что передача области памяти
происходит по адресам, выровненным по границе слова.  FIXME: <EM>Нужен
механизм передачи области памяти, выровненной по границе слова.</EM>
</TR>
<TR><TD></TD>

</TD><TD> ответ <VAR>XX...</VAR>
</TD><TD>
<VAR>XX...</VAR> представляет собой содержимое памяти.  Может содержать
меньше запрошенного числа байт, если удалось прочитать только часть
данных.  Ни GDB, ни заглушка не предполагают, что передача
области памяти происходит по адресам, выровненным по границе слова.
FIXME: <EM>Нужен механизм передачи области памяти, выровненной по
границе слова.</EM>
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> <VAR>NN</VAR> представляет номер ошибки

</TR>
<TR><TD>запись в память</TD>

</TD><TD> <CODE>M</CODE><VAR>адрес</VAR>,<VAR>длина</VAR><CODE>:</CODE><VAR>XX...</VAR>
</TD><TD>
Записать <VAR>длину</VAR> байт памяти, начиная с адреса <VAR>адрес</VAR>.
<VAR>XX...</VAR>---это данные.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> при успехе
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD>
при ошибке (это включает случай, когда была записана только часть
данных).

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>n</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>N</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>o</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>O</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>чтение регистров <STRONG>(зарезервировано)</STRONG></TD>

</TD><TD> <CODE>p</CODE><VAR>n...</VAR>
</TD><TD>
Смотрите запись регистров.
</TR>
<TR><TD></TD>

</TD><TD> возврат <VAR>r....</VAR>
</TD><TD> Значение регистра в целевом порядке байт, закодированное в
шестнадцатеричном виде.

</TR>
<TR><TD>запись регистров</TD>

</TD><TD> <CODE>P</CODE><VAR>n...</VAR><CODE>=</CODE><VAR>r...</VAR>
</TD><TD>
Записать в регистр <VAR>n...</VAR> значение <VAR>r...</VAR>, которое содержит две
шестнадцатеричные цифры для каждого байта в регистре (целевой порядок
байтов).
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> в случае успеха
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> при ошибке

</TR>
<TR><TD>общий запрос</TD>

</TD><TD> <CODE>q</CODE><VAR>запрос</VAR>
</TD><TD>
Запросить информацию о <VAR>запросе</VAR>.  Вообще, запросы
GDB имеют первую заглавную букву.  Специальные запросы от
производителей должны использовать приставку компании (из маленьких
букв).  Например: <SAMP>`qfsf.var'</SAMP>.  За <VAR>запросом</VAR> может следовать
необязательный список, разделенный <SAMP>`,'</SAMP> или <SAMP>`;'</SAMP>.  Заглушки
должны проверять, что они производят сравнение с полным именем
<VAR>запроса</VAR>.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>XX...</CODE>
</TD><TD> Данные от запроса, закодированные шестнадцатеричными цифрами.
Ответ не может быть пустым.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> ответ при ошибке
</TR>
<TR><TD></TD>

</TD><TD> ответ <SAMP>`'</SAMP>
</TD><TD> Указывает на нераспознанный <VAR>запрос</VAR>.

</TR>
<TR><TD>общая установка</TD>

</TD><TD> <CODE>Q</CODE><VAR>перем</VAR><CODE>=</CODE><VAR>знач</VAR>
</TD><TD>
Установить значение <VAR>перем</VAR> в <VAR>знач</VAR>.  Смотрите <SAMP>`q'</SAMP> для
обсуждения соглашений, касающихся имен.

</TR>
<TR><TD>сброс <STRONG>(не рекомендовано)</STRONG></TD>

</TD><TD> <CODE>r</CODE>
</TD><TD>
Установка всей системы в исходное состояние.

</TR>
<TR><TD>удаленная перезагрузка</TD>

</TD><TD> <CODE>R</CODE><VAR>XX</VAR>
</TD><TD>
Перезапустить удаленный сервер.  <VAR>XX</VAR>, где оно требуется, не имеет
ясного определения.  FIXME: <EM>Нужен пример взаимодействия,
объясняющий как эти пакеты используются в расширенном удаленном режиме</EM>.

</TR>
<TR><TD>пошагавое выполнение</TD>

</TD><TD> <CODE>s</CODE><VAR>адрес</VAR>
</TD><TD>
<VAR>Адрес</VAR>---это адрес для возобновления выполнения.  Если <VAR>адрес</VAR>
опущен, возобновить выполнение с того же адреса.
</TR>
<TR><TD></TD>

</TD><TD> ответ
</TD><TD> смотрите ниже

</TR>
<TR><TD>пошаговое выполнение с сигналом</TD>

</TD><TD> <CODE>S</CODE><VAR>сиг</VAR><CODE>;</CODE><VAR>адрес</VAR>
</TD><TD>
Как <CODE>C</CODE>, но разница такая же, как между <CODE>step</CODE> и
<CODE>continue</CODE>.
</TR>
<TR><TD></TD>

</TD><TD> ответ
</TD><TD> смотрите ниже

</TR>
<TR><TD>поиск</TD>

</TD><TD> <CODE>t</CODE><VAR>адрес</VAR><CODE>:</CODE><VAR>PP</VAR><CODE>,</CODE><VAR>MM</VAR>
</TD><TD>
Поиск в обратном направлении, начиная с адреса <VAR>адрес</VAR>, до
совпадения с шаблоном <VAR>PP</VAR> и маской <VAR>MM</VAR>.  <VAR>PP</VAR> и
<VAR>MM</VAR>---4 байта.  <VAR>Адрес</VAR> должен быть не менее трех цифр.

</TR>
<TR><TD>жива ли нить</TD>

</TD><TD> <CODE>T</CODE><VAR>XX</VAR>
</TD><TD> Определить, жива ли нить <VAR>XX</VAR>.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> нить все еще жива
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> нить мертва

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>u</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>U</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>v</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>V</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>w</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>W</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>x</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>запись в память (двоичная)</TD>

</TD><TD> <CODE>X</CODE><VAR>адрес</VAR><CODE>,</CODE><VAR>длина</VAR><VAR>:</VAR><VAR>XX...</VAR>
</TD><TD>
<VAR>Адрес</VAR> это адрес, <VAR>длина</VAR> это число байт, <VAR>XX...</VAR> это
двоичные данные.  Символы <CODE>$</CODE>, <CODE>#</CODE> и <CODE>0x7d</CODE> экранируются
с помощью <CODE>0x7d</CODE>.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> в случае успеха
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> в случае ошибки

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>y</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> <CODE>Y</CODE>
</TD><TD> Зарезервировано для использования в будущем

</TR>
<TR><TD>удалить точку останова или наблюдения <STRONG>(черновик)</STRONG></TD>

</TD><TD> <CODE>z</CODE><VAR>t</VAR><CODE>,</CODE><VAR>адрес</VAR><CODE>,</CODE><VAR>длина</VAR>
</TD><TD>
Смотрите <SAMP>`Z'</SAMP>.

</TR>
<TR><TD>поместить точку останова или наблюдения <STRONG>(черновик)</STRONG></TD>

</TD><TD> <CODE>Z</CODE><VAR>t</VAR><CODE>,</CODE><VAR>адрес</VAR><CODE>,</CODE><VAR>длина</VAR>
</TD><TD>
<VAR>t</VAR> представляет тип: <SAMP>`0'</SAMP> в случае программной точки останова,
<SAMP>`1'</SAMP>---аппаратная точка останова, <SAMP>`2'</SAMP>---точка наблюдения за
записью, <SAMP>`3'</SAMP>---точка наблюдения за чтением, <SAMP>`4'</SAMP>---точка
наблюдения за доступом; <VAR>адрес</VAR>---это адрес; <VAR>длина</VAR> задается в
байтах.  Для программной точки останова, <VAR>длина</VAR> задает размер
инструкции, на которую надо поместить заплату.  Для аппаратных точек
останова и наблюдения, <VAR>длина</VAR> указывает размер области памяти
для наблюдения.  Чтобы избежать потенциальных проблем с повторными
пакетами, операции должны быть идемпотентным образом.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> в случае ошибки
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD> в случае успеха
</TR>
<TR><TD></TD>

</TD><TD> <SAMP>`'</SAMP>
</TD><TD> Если не поддерживается.

</TR>
<TR><TD>зарезервировано</TD>

</TD><TD> &#60;другое&#62;
</TD><TD> Зарезервировано для использования в будущем

</TR></TABLE>

<P>
Пакеты <SAMP>`C'</SAMP>, <SAMP>`c'</SAMP>, <SAMP>`S'</SAMP>, <SAMP>`s'</SAMP> и <SAMP>`?'</SAMP> могут получить
в качестве ответа все нижеперечисленное.  В случае пакетов <SAMP>`C'</SAMP>,
<SAMP>`c'</SAMP>, <SAMP>`S'</SAMP> и <SAMP>`s'</SAMP>, этот ответ возвращается только тогда,
когда цель останавливается.  Ниже, точное значение <SAMP>`номера сигнала'</SAMP>
определено нечетко.  Вообще, используется одно из соглашений
UNIX о номерах сигналов.


<TABLE BORDER>

<TR><TD><CODE>S</CODE><VAR>AA</VAR></TD>

</TD><TD> <VAR>AA</VAR>---это номер сигнала

</TR>
<TR><TD><CODE>T</CODE><VAR>AA</VAR><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE></TD>

</TD><TD>
<VAR>AA</VAR> = две шестнадцатеричные цифры номера сигнала; <VAR>n...</VAR> =
(шестнадцатеричный) номер регистра, <VAR>r...</VAR> = содержимое регистра в
целевом порядке байт, размер определяется <CODE>REGISTER_RAW_SIZE</CODE>;
<VAR>n...</VAR> = <SAMP>`thread'</SAMP>, <VAR>r...</VAR> = идентификатор процесса нити, это
шестнадцатеричное целое; <VAR>n...</VAR> = другая строка, не начинающаяся с
шестнадцатеричной цифры.  GDB должен игнорировать эту пару
<VAR>n...</VAR>, <VAR>r...</VAR> и переходить к следующей.  Таким образом мы можем
расширять протокол.

</TR>
<TR><TD><CODE>W</CODE><VAR>AA</VAR></TD>

</TD><TD>
Процесс завершается с кодом выхода <VAR>AA</VAR>.  Это применимо только к
определенным типам целей.

</TR>
<TR><TD><CODE>X</CODE><VAR>AA</VAR></TD>

</TD><TD>
Процесс завершается с сигналом <VAR>AA</VAR>.

</TR>
<TR><TD><CODE>N</CODE><VAR>AA</VAR><CODE>;</CODE><VAR>t...</VAR><CODE>;</CODE><VAR>d...</VAR><CODE>;</CODE><VAR>b...</VAR> <STRONG>(устарело)</STRONG></TD>

</TD><TD>
<VAR>AA</VAR> = номер сигнала; <VAR>t...</VAR> = адрес символа "_start";
<VAR>d...</VAR> = база раздела данных; <VAR>b...</VAR> = база раздела bss.
<EM>Примечание: используется только целями Cisco Systems.  Разница
между этим ответом и запросом "qOffsets" заключается в том, что пакет
'N' может прибыть самопроизвольно, тогда как запрос 'qOffsets'
инициируется рабочим отладчиком.</EM>

</TR>
<TR><TD><CODE>O</CODE><VAR>XX...</VAR></TD>

</TD><TD>
<VAR>XX...</VAR>---шестнадцатеричное представление ASCII-данных.  Это
может произойти в любой момент, пока программа выполняется и отладчик
должен продолжать ждать 'W', 'T', и т.п.

</TR></TABLE>

<P>
Следующие пакеты для установок и запросов уже были определены.


<TABLE BORDER>

<TR><TD>текущая нить</TD>

</TD><TD> <CODE>q</CODE><CODE>C</CODE>
</TD><TD> Возвратить идентификатор текущей нити.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>QC</CODE><VAR>идент-проц</VAR>
</TD><TD>
Где <VAR>идент-проц</VAR>---16-битный идентификатор процесса, представленный
шестнадцатеричнами цифрами.
</TR>
<TR><TD></TD>

</TD><TD> ответ *
</TD><TD> Любой другой ответ подразумевает старый идентификатор процесса.

</TR>
<TR><TD>идентификаторы всех нитей</TD>

</TD><TD> <CODE>q</CODE><CODE>fThreadInfo</CODE>
</TR>
<TR><TD></TD>

</TD><TD> <CODE>q</CODE><CODE>sThreadInfo</CODE>
</TD><TD>
Получить список идентификаторов активных нитей от целевой ОС.  Так как
число активных нитей может оказаться слишком большим и не поместиться в
пакет ответа, этот запрос работает итерациями: он может требовать более
одной последовательности запрос/ответ, для получения полного
списка нитей.  Первым запросом последовательности будет
<CODE>qf</CODE><CODE>ThreadInfo</CODE>; последующими запросами последовательности
будут запросы <CODE>qs</CODE><CODE>ThreadInfo</CODE>.
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD> Замечание: замещает запрос <CODE>qL</CODE> (смотрите ниже).
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>m</CODE><VAR>&#60;ид&#62;</VAR>
</TD><TD> Идентификатор одной нити
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>m</CODE><VAR>&#60;ид&#62;</VAR>,<VAR>&#60;ид&#62;...</VAR>
</TD><TD> список идентификаторов нитей, разделенных запятыми
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>l</CODE>
</TD><TD> (буква 'l' в нижнем регистре) обозначает конец списка.
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
В ответ на каждый запрос, цель будет отвечать списком из разделенных
запятыми идентификаторов нитей, в шестнадцатеричном представлении, с
порядком байт от старшего.  GDB будет отвечать на каждый ответ
запросом других идентификаторов (используя форму <CODE>qs</CODE> запроса),
пока цель не ответит <CODE>l</CODE> (буква 'l' в нижнем регистре, от
английского слова <CODE>'last'</CODE>).

</TR>
<TR><TD>дополнительная информация о нити</TD>

</TD><TD> <CODE>q</CODE><CODE>ThreadExtraInfo</CODE><CODE>,</CODE><VAR>ид</VAR>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
Здесь <VAR>ид</VAR> является идентификатором нити в шестнадцатеричном
представлении, в порядке байт от старшего.  Получает печатаемое описание
строки атрибутов нити от целевой ОС.  Эта строка может содержать
все что угодно, что целевая ОС сочтет интересным для
GDB сообщить пользователю о нити.  Эта строка выводится в
отображении GDB <SAMP>`info threads'</SAMP>.  Примерами возможной
дополнительной информации являются "Runnable" или "Blocked on Mutex".
</TR>
<TR><TD></TD>

</TD><TD> ответ <VAR>XX...</VAR>
</TD><TD>
Где <VAR>XX...</VAR>---ASCII-данные в шестнадцатеричном представлении,
содержащие печатную строку с дополнительной информацией об атрибутах
нити.

</TR>
<TR><TD>запрос <VAR>список</VAR> или <VAR>список-нитей</VAR> <STRONG>(не рекомендовано)</STRONG></TD>

</TD><TD> <CODE>q</CODE><CODE>L</CODE><VAR>нач-флаг</VAR><VAR>число-нитей</VAR><VAR>след-нить</VAR>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
Получить информацию о нити от операционной системы, где происходит
выполнение.  Здесь: <VAR>нач-флаг</VAR> (одна шестнадцатеричная цифра) есть
единица, что указывает на первый запрос, или ноль, что определяет
последующий запрос; <VAR>число-нитей</VAR> (две шестнадцатеричные
цифры)---максимальное число нитей, которое может содержать пакет ответа;
и <VAR>след-нить</VAR> (восемь шестнадцатеричных цифр), для последующих
запросов (<VAR>нач-флаг</VAR> равен нулю), возвращается в ответ как
<VAR>арг-нить</VAR>.
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD> Замечание: этот запрос был замещен запросом
<CODE>q</CODE><CODE>fThreadInfo</CODE> (смотрите выше).
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>q</CODE><CODE>M</CODE><VAR>число</VAR><VAR>конец</VAR><VAR>арг-нить</VAR><VAR>нить...</VAR>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
Здесь: <VAR>число</VAR> (две шестнадцатеричные цифры)---число возвращаемых
нитей; <VAR>конец</VAR> (одна шестнадцатеричная цифра), есть ноль, который
определяет, что есть еще нити, и единица, определяющая, что
больше нитей нет; <VAR>арг-нить</VAR> (восемь шестнадцатеричных цифр)
представляет собой <VAR>след-нить</VAR> из пакета запроса;
<VAR>нить...</VAR>---это последовательность идентификаторов нитей от цели.
<VAR>Идент-нити</VAR> (восемь шестнадцатеричных цифр).  Смотрите
<CODE>remote.c:parse_threadlist_response()</CODE>.

</TR>
<TR><TD>вычислить CRC блока памяти</TD>

</TD><TD> <CODE>q</CODE><CODE>CRC:</CODE><VAR>адрес</VAR><CODE>,</CODE><VAR>длина</VAR>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD> Ошибка (например, ошибка доступа к памяти)
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>C</CODE><VAR>CRC32</VAR>
</TD><TD> Лишняя 32-битная циклическая проверка указанной области памяти.

</TR>
<TR><TD>запросить смещения разделов</TD>

</TD><TD> <CODE>q</CODE><CODE>Offsets</CODE>
</TD><TD>
Получить смещения разделов, которые целевая машина использовала при
повторном размещении загруженного образа.  <EM>Замечание: если
смещение <CODE>Bss</CODE> включено в ответ, GDB это игнорирует и
вместо этого применяет  к разделу <CODE>Bss</CODE> смещение <CODE>Data</CODE>.</EM>
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>Text=</CODE><VAR>xxx</VAR><CODE>;Data=</CODE><VAR>yyy</VAR><CODE>;Bss=</CODE><VAR>zzz</VAR>

</TR>
<TR><TD>запросить информацию о нити</TD>

</TD><TD> <CODE>q</CODE><CODE>P</CODE><VAR>режим</VAR><VAR>идент-нити</VAR>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
Возвращает информацию об <VAR>идент-нити</VAR>.  Здесь: <VAR>режим</VAR> является
32-битным режимом в шестнадцатеричном представлении;
<VAR>идент-нити</VAR>---64-битный идентификатор нити в шестнадцатеричном
представлении.
</TR>
<TR><TD></TD>

</TD><TD> ответ *
</TD><TD>
Смотрите <CODE>remote.c:remote_unpack_thread_info_response()</CODE>.

</TR>
<TR><TD>удаленная команда</TD>

</TD><TD> <CODE>q</CODE><CODE>Rcmd,</CODE><VAR>КОМАНДА</VAR>
</TD><TD>
</TR>
<TR><TD></TD>

</TD><TD>
</TD><TD>
<VAR>КОМАНДА</VAR> (в шестнадцатеричном представлении) передается для
выполнения локальному интерпретатору.  Неверные команды должны
сообщаться при помощи выходной строки.  Перед конечным результирующим
пакетом, целевая машина может также ответить некоторым количеством
промежуточных <CODE>O</CODE><VAR>ВЫВОД</VAR> пакетов вывода на консоль.
<EM>Разработчики должны учесть, что предоставление доступа к
интерпретатору заглушки может иметь последствия для безопасности</EM>.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>OK</CODE>
</TD><TD>
Ответ на команду без вывода.
</TR>
<TR><TD></TD>

</TD><TD> ответ <VAR>ВЫВОД</VAR>
</TD><TD>
Ответ на команду со строкой вывода <VAR>ВЫВОД</VAR>, в шестнадцатеричном
представлении.
</TR>
<TR><TD></TD>

</TD><TD> ответ <CODE>E</CODE><VAR>NN</VAR>
</TD><TD>
Указывает на неправильно сформированный запрос.

</TR>
<TR><TD></TD>

</TD><TD> reply <SAMP>`'</SAMP>
</TD><TD>
Когда <SAMP>`q'</SAMP><SAMP>`Rcmd'</SAMP> не распознана.

</TR></TABLE>

<P>
Следующие пакеты <SAMP>`g'</SAMP>/<SAMP>`G'</SAMP> были определены раньше.  Ниже,
некоторые 32-битные регистры передаются в виде 64 бит.  Эти регистры
должны быть расширены нулем/знаком (как?), чтобы заполнять выделенное
место.  Байты регистра передаются в целевом порядке байтов.  Две части в
байте регистра передаются от более значимого к менее значимому.


<TABLE BORDER>

<TR><TD>MIPS32</TD>

</TD><TD>
Все регистры передаются как 32-битные величины в таком порядке: 32 общего
назначения; sr; lo; hi; bad; cause; pc; 32 регистра с плавающей точкой;
fsr; fir; fp.

</TR>
<TR><TD>MIPS64</TD>

</TD><TD>
Все регистры передаются как 64-битные величины (включая такие 32-битные
регистры, как <CODE>sr</CODE>).  Порядок такой же, как для <CODE>MIPS32</CODE>.

</TR></TABLE>

<P>
Вот пример последовательности для перезапускаемой цели.  Заметьте, что
перезапуск не получает никакого непосредственного вывода:



<PRE>
&#60;- <CODE>R00</CODE>
-&#62; <CODE>+</CODE>
<EM>target restarts</EM>
&#60;- <CODE>?</CODE>
-&#62; <CODE>+</CODE>
-&#62; <CODE>T001:1234123412341234</CODE>
&#60;- <CODE>+</CODE>
</PRE>

<P>
Пример последовательности при при пошаговом выполнении цели по одной
инструкции:



<PRE>
&#60;- <CODE>G1445...</CODE>
-&#62; <CODE>+</CODE>
&#60;- <CODE>s</CODE>
-&#62; <CODE>+</CODE>
<EM>time passes</EM>
-&#62; <CODE>T001:1234123412341234</CODE>
&#60;- <CODE>+</CODE>
&#60;- <CODE>g</CODE>
-&#62; <CODE>+</CODE>
-&#62; <CODE>1455...</CODE>
&#60;- <CODE>+</CODE>
</PRE>



<H4><A NAME="SEC116" HREF="gdb_toc.html#TOC116">Использование программы <CODE>gdbserver</CODE></A></H4>

<P>
<A NAME="IDX576"></A>
<A NAME="IDX577"></A>
<CODE>gdbserver</CODE> является управляющей программой для Unix-подобных
систем, которая позволяет вам установить соединение вашей программы с
удаленным GDB посредством <CODE>target remote</CODE>, но без
компоновки с обычной отладочной заглушкой.


<P>
<CODE>gdbserver</CODE> не является полной заменой отладочных заглушек, потому что
требует по существу тех же средств операционной системы, что и сам
GDB.  Фактически, система, на которой может выполняться
<CODE>gdbserver</CODE> для соединения с удаленным GDB, может также
выполнять GDB локально!  Тем не менее, <CODE>gdbserver</CODE> иногда
полезен, так как по размеру эта программа гораздо меньше, чем
GDB.  <CODE>gdbserver</CODE> также легче переносить, чем
весь GDB, так что вы сможете быстрее начать работать в новой системе,
используя его.  Наконец, если вы разрабатываете программы для
систем реального времени, вы можете обнаружить, что накладные расходы,
связанные с операциями реального времени, делают более удобным
проведение всей возможной разработки на другой системе, например, с помощью
кросс-компиляции.  Вы можете использовать <CODE>gdbserver</CODE>, чтобы
реализовать аналогичный выбор для отладки.


<P>
GDB и <CODE>gdbserver</CODE> общаются или через последовательную
линию, или через соединение TCP, используя стандартный удаленный
последовательный протокол GDB.


<DL COMPACT>

<DT><EM>На целевой машине</EM>
<DD>
вам необходимо иметь копию программы, которую вы хотите отладить.
<CODE>gdbserver</CODE> не нуждается в таблице символов вашей программы, так
что вы можете ее исключить, если необходимо сохранить
пространство.  Всю обработку символов осуществляет GDB на
рабочей машине.

Чтобы использовать сервер, вы должны сообщить ему, как взаимодействовать с
GDB, имя вашей программы и ее аргументы.  Синтаксис следующий:


<PRE>
target&#62; gdbserver <VAR>comm</VAR> <VAR>программа</VAR> [ <VAR>арг</VAR> ... ]
</PRE>

<VAR>comm</VAR>---это или имя устройства (для использования последовательной линии),
или имя рабочей машины и номер порта TCP.  Например, для
отладки Emacs с параметром <SAMP>`foo.txt'</SAMP> и взаимодействия с
GDB через последовательный порт <TT>`/dev/com1'</TT>:


<PRE>
target&#62; gdbserver /dev/com1 emacs foo.txt
</PRE>

<CODE>gdbserver</CODE> пассивно ждет рабочего GDB для связи с ним.

При использовании TCP-соединения вместо последовательной линии:


<PRE>
target&#62; gdbserver host:2345 emacs foo.txt
</PRE>

Единственное отличие от предыдущего примера состоит в первом параметре,
определяющем, что вы связываетесь с рабочим GDB через TCP.
Параметр <SAMP>`host:2345'</SAMP> означает, что <CODE>gdbserver</CODE> должен ожидать
TCP-соединение от машины <SAMP>`host'</SAMP> к локальному порту TCP 2345. (В
настояшее время часть <SAMP>`host'</SAMP> игнорируется.)  Вы можете выбрать
любой номер порта, какой захотите, если при этом он не конфликтует с
какими-либо портами TCP, уже использующимися на целевой системе
(например, <CODE>23</CODE> зарезервирован для <CODE>telnet</CODE>).<A NAME="DOCF15" HREF="gdb_foot.html#FOOT15">(15)</A>  Вы
должны использовать тот же номер порта с командой рабочего GDB
<CODE>target remote</CODE>.

<DT><EM>На рабочей машине GDB</EM>
<DD>
вам нужна копия вашей программы с символьными данными, так как
GDB нужна информация о символах и отладочная информация.
Запустите GDB как обычно, используя имя локальной копии вашей
программы в качестве первого аргумента.  (Вам также может понадобиться
ключ <SAMP>`--baud'</SAMP>, если последовательная линия работает на скорости,
отличной от 9600бит/сек.)  После этого, используйте <CODE>target remote</CODE>,
чтобы установить связь с <CODE>gdbserver</CODE>.  Ее параметры---либо
имя устройства (обычно последовательного устройства, такого как
<TT>`/dev/ttyb'</TT>), либо дескриптор порта TCP в форме
<CODE><VAR>машина</VAR>:<VAR>порт</VAR></CODE>.  Например:


<PRE>
(gdb) target remote /dev/ttyb
</PRE>

взаимодействует с сервером через последовательную линию <TT>`/dev/ttyb'</TT>, а


<PRE>
(gdb) target remote the-target:2345
</PRE>

взаимодействует через TCP-соединение с портом 2345 на рабочей машине
<TT>`the-target'</TT>.  Для TCP-соединения, вы должны запустить
<CODE>gdbserver</CODE> до использования команды <CODE>target remote</CODE>.  Иначе
вы можете получить ошибку, текст которой зависит от рабочей системы, но
обычно он выглядит примерно так: <SAMP>`Connection refused'</SAMP>.
</DL>



<H4><A NAME="SEC117" HREF="gdb_toc.html#TOC117">Использование программы <CODE>gdbserve.nlm</CODE></A></H4>

<P>
<A NAME="IDX578"></A>
<CODE>gdbserve.nlm</CODE>---это управляющая программа для систем NetWare,
которая позволяет вам установить соединение вашей программы с
удаленным GDB посредством <CODE>target remote</CODE>.


<P>
GDB и <CODE>gdbserve.nlm</CODE> общаются через последовательную линию,
используя стандартный удаленный последовательный протокол GDB.


<DL COMPACT>

<DT><EM>На целевой машине</EM>
<DD>
вам необходимо иметь копию программы, которую вы хотите отладить.
<CODE>gdbserve.nlm</CODE> не нуждается в таблице символов вашей программы,
так что вы можете ее исключить, если необходимо сохранить пространство.
GDB осуществляет всю обработку символов на рабочей машине.

Чтобы использовать сервер, вы должны сообщить ему как взаимодействовать с
GDB, имя вашей программы и ее аргументы.  Синтаксис следующий:


<PRE>
load gdbserve [ BOARD=<VAR>плата</VAR> ] [ PORT=<VAR>порт</VAR> ]
              [ BAUD=<VAR>бод</VAR> ] <VAR>программа</VAR> [ <VAR>арг</VAR> ... ]
</PRE>

<VAR>Плата</VAR> и <VAR>порт</VAR> определяют последовательную линию; <VAR>бод</VAR>
определяет скорость в бодах, используемую соединением.  Значения
<VAR>порт</VAR> и <VAR>node</VAR> по умолчанию равны 0, <VAR>бод</VAR> по умолчанию
9600бит/сек.

Например, для отладки Emacs с параметром <SAMP>`foo.txt'</SAMP> и взаимодействия
с GDB через последовательный порт номер 2 на плате 1, используя
соединение 19200бит/сек:


<PRE>
load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt
</PRE>

<DT><EM>На рабочей машине GDB</EM>
<DD>
вам нужна копия вашей программы с символьными данными, так как
GDB требуется символьная и отладочная информация.  Запустите
GDB как обычно, используя имя локальной копии вашей программы в
качестве первого параметра.  (Вам также может понадобиться ключ
<SAMP>`--baud'</SAMP>, если последовательная линия работает на скорости,
отличной от 9600бит/сек.)  После этого, используйте <CODE>target
remote</CODE> для установки связи с <CODE>gdbserve.nlm</CODE>.  Ее
аргумент---имя устройства (обычно последовательного устройства,
такого как <TT>`/dev/ttyb'</TT>).  Например:


<PRE>
(gdb) target remote /dev/ttyb
</PRE>

соединение с сервером через последовательную линию <TT>`/dev/ttyb'</TT>.
</DL>



<H2><A NAME="SEC118" HREF="gdb_toc.html#TOC118">Отображение объектов ядра</A></H2>

<P>
<A NAME="IDX579"></A>
<A NAME="IDX580"></A>


<P>
Некоторые цели поддерживают отображение объектов ядра.  При помощи этих
возможностей, GDB взаимодействует непосредственно с
операционной системой и может выводить информацию об объектах уровня
операционной системы, например, о блокировках
и других объектах синхронизации.  Какие именно объекты могут быть
отображены, определяется в зависимости от конкретной ОС.


<P>
Используйте команду <CODE>set os</CODE>, чтобы установить тип операционной
системы.  Это говорит GDB, какой модуль отображения объектов
ядра инициализировать:



<PRE>
(gdb) set os cisco
</PRE>

<P>
Если команда <CODE>set os</CODE> выполнится успешно, GDB выведет
некоторую информацию об операционной системе, и создаст новую команду
<CODE>info</CODE>, которая может быть использована для посылки запросов на
целевую машину.  Название команды <CODE>info</CODE> выбирается в зависимости
от операционной системы:



<PRE>
(gdb) info cisco
List of Cisco Kernel Objects
Object     Description
any        Any and all objects
</PRE>

<P>
Дальнейшие подкоманды могут использоваться для запросов о конкретных
объектах, информация о которых есть в ядре.


<P>
В настоящее время не существует другого способа определить,
поддерживается та или иная операционная система, кроме как попробовать.


<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_13.html">previous</A>, <A HREF="gdb_15.html">next</A>, <A HREF="gdb_26.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
