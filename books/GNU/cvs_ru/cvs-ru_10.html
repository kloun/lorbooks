<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Несколько разработчиков</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_9.html">previous</A>, <A HREF="cvs-ru_11.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC82" HREF="cvs-ru_toc.html#TOC82">Несколько разработчиков</A></H1>
<P>
<A NAME="IDX342"></A>
<A NAME="IDX343"></A>
<A NAME="IDX344"></A>
<A NAME="IDX345"></A>
<A NAME="IDX346"></A>
<A NAME="IDX347"></A>
<A NAME="IDX348"></A>
<A NAME="IDX349"></A>
<A NAME="IDX350"></A>
<A NAME="IDX351"></A>


<P>
Когда над программным проектом работает более одного человека,
все усложняется.  Зачастую два разработчика одновременно пытаются
редактировать один и тот же файл.  Одно из решений, известное как
<EM>блокировка файлов</EM> или <EM>блокированное извлечение</EM>, -- в
каждый момент времени позволять редактировать файл только одному
человеку.  Это -- единственное решение при использовании
некоторых систем контроля версий, включая RCS и SCCS.
В настоящее время единственным способом совершить блокированное
извлечение рабочей копии с помощью CVS -- использовать
команду <CODE>cvs admin -l</CODE> (see section <A HREF="cvs-ru_16.html#SEC119">Ключи команды admin</A>).  Это
не столь красиво интегрировано в CVS, как функции слежения,
описанные ниже, но кажется, что всех, кому требуются блокированное 
извлечение, эта команда устраивает.


<P>
Для избежания одновременного редактирования файла можно также
использовать возможность слежения, описанную ниже, вместе с
соответствующими процедурами (не контролируемыми с помощью
программы).


<P>
Модель, используемая в CVS по умолчанию, называется
<EM>неблокированные извлечения</EM>.  В этой модели разработчики
редактируют свои собственные <EM>рабочие копии</EM> файла.  Первый,
зафиксировавший свои изменения, не может автоматически узнать,
что второй также начал редактировать файл.  Второй получит
сообщения об ошибке, когда попытается зафиксировать файл.  Он
должен использовать соответствующие команды CVS, чтобы
его рабочая копия соответствовала свежайшей ревизии, находящейся
в репозитории.  Весь этот процесс проходит почти автоматически.


<P>
CVS также поддерживает механизмы различных способов
коммуникации, никак не настаивая на выполнении каких-либо правил, 
в отличие от блокированных извлечений.


<P>
Оставшаяся часть главы описывает, как работают все эти различные
модели, а также некоторые вопросы, связанные с выбором того или
иного варианта.




<H2><A NAME="SEC83" HREF="cvs-ru_toc.html#TOC83">Статус файла</A></H2>
<P>
<A NAME="IDX352"></A>
<A NAME="IDX353"></A>


<P>
Основываясь на операциях, которые производятся над извлеченным
файлом, а также на операциях, которые производятся над этим
файлом в репозитории, можно классифицировать несколько состояний
файла.  Команда <CODE>status</CODE> рапортует об этих состояниях.  Они
таковы: 


<DL COMPACT>

<DT>Up-to-date
<DD>
<A NAME="IDX354"></A>
 
Файл идентичен последней ревизии в репозитории, находящейся на
используемой ветке.

<DT>Locally Modified
<DD>
<A NAME="IDX355"></A>
Вы редактировали этот файл и еще не зафиксировали изменения.

<DT>Locally Added
<DD>
<A NAME="IDX356"></A>
Вы добавили этот файл с помощью <CODE>cvs add</CODE>, и еще не
зафиксировали изменения.

<DT>Locally Removed
<DD>
<A NAME="IDX357"></A>
Вы удалили файл с помощью <CODE>cvs remove</CODE> и еще не
зафиксировали изменения.

<DT>Needs Checkout
<DD>
<A NAME="IDX358"></A>
Кто-то еще поместил новую ревизию в репозиторий.  Название
немного сбивает с толку, потому что требуется использовать
команду <CODE>cvs update</CODE>, а не <CODE>cvs checkout</CODE>, чтобы
получить свежайшую версию.

<DT>Needs Patch
<DD>
<A NAME="IDX359"></A>
Похоже на "Needs Checkout", но CVS-сервер пошлет заплату, а
не целый файл.  В принципе это приведет к тому же самому
результату.

<DT>Needs Merge
<DD>
<A NAME="IDX360"></A>
Кто-то еще поместил новую ревизию в репозиторий, а вы также
изменили этот файл.

<DT>File had conflicts on merge
<DD>
<A NAME="IDX361"></A>
Похоже на "Locally Modified", только последняя выполненная
команда <CODE>cvs update</CODE> обнаружила конфликт.  Если вы еще не
исправили его, сделайте это, как описано в section <A HREF="cvs-ru_10.html#SEC85">Пример конфликта</A>.

<DT>Unknown
<DD>
<A NAME="IDX362"></A>
CVS ничего не знает об этом файле.  Например, вы создали
новый файл и еще не выполнили <CODE>cvs add</CODE>.
</DL>

<P>
Чтобы уточнить состояние файла, <CODE>cvs status</CODE> также сообщает
о <CODE>Working revision</CODE>, являющейся ревизией, на основе которой 
создан файл в рабочем каталоге, и <CODE>Repository revision</CODE>,
являющейся свежайшей ревизией в репозитории, находящейся на
используемой ветке.


<P>
Ключи команды <CODE>status</CODE> перечислены в section <A HREF="cvs-ru_17.html#SEC152">Краткий справочник по командам CVS</A>.
Информация о <CODE>Sticky tag</CODE> и <CODE>Sticky date</CODE> находится в
section <A HREF="cvs-ru_4.html#SEC53">Липкие метки</A>.  Информация о <CODE>Sticky options</CODE> находится 
в описании флага <SAMP>`-k'</SAMP> в section <A HREF="cvs-ru_16.html#SEC150">Ключи команды update</A>.


<P>
Команды <CODE>status</CODE> и <CODE>update</CODE> можно рассматривать как
соответствующие друг другу.  <CODE>update</CODE> используется для
извлечения самых свежих файлов, а <CODE>status</CODE> -- для
выяснения, что же произойдет, если выполнить <CODE>update</CODE>
(конечно, состояние репозитория может измениться до того, как вы
выполните <CODE>update</CODE>).  В действительность, если вы хотите
узнать состояние файлов в более краткой форме, выполните


<P>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>

<PRE>
$ cvs -n -q update
</PRE>

<P>
Ключ командной строки <SAMP>`-n'</SAMP> указывает не выполнять
обновление, а просто сообщить о состоянии файлов; <SAMP>`-q'</SAMP> не
печатает имена каждого каталога.  Прочуя информацию о команде
<CODE>update</CODE> можно найти в section <A HREF="cvs-ru_17.html#SEC152">Краткий справочник по командам CVS</A>.




<H2><A NAME="SEC84" HREF="cvs-ru_toc.html#TOC84">Извлечение свежей ревизии файла</A></H2>
<P>
<A NAME="IDX365"></A>
<A NAME="IDX366"></A>
<A NAME="IDX367"></A>
<A NAME="IDX368"></A>
<A NAME="IDX369"></A>
<A NAME="IDX370"></A>


<P>
Если вы хотите получить новую ревизию файла или объединить его с
другой ревизией, используйте команду <CODE>update</CODE>.  Если вы
имеете старую ревизию файла, то эта команда эквивалентна
<CODE>checkout</CODE>: свежая ревизия извлекается из репозитория и
помещается в рабочий каталог.


<P>
Ваши изменения в файле не теряются, когда вы используете
<CODE>update</CODE>.  Если более свежей ревизии не существует,
выполнение <CODE>update</CODE> ничего не сделает.  Если вы
редактировали файл, а в репозитории появилась его более новая
ревизия, изменения будут объединены с вашей рабочей копией.


<P>
Например, представим себе, что вы извлекли ревизию 1.4 и начали
редактировать ее.  В это время кто-то еще поместил в репозиторий
ревизию 1.5 и, вскорости, ревизию 1.6.  Если теперь вы выполните
команду <CODE>update</CODE>, CVS внедрит изменения между ревизиями
1.4 и 1.6 в ваш файл.


<P>
<A NAME="IDX371"></A>
Если изменения между ревизиями 1.4 и 1.6 случились слишком близко
к вашим изменениям, происходит <EM>пересечение</EM>.  В таких
случаях на экран выдается предупреждение, а в результирующем
файле оказываются обе версии пересекающихся строк, разделенные
специальными маркерами.  See section <A HREF="cvs-ru_16.html#SEC149">Команда update: обновить рабочий каталог из репозитория</A>, где полностью описана
команда <CODE>update</CODE>.




<H2><A NAME="SEC85" HREF="cvs-ru_toc.html#TOC85">Пример конфликта</A></H2>
<P>
<A NAME="IDX372"></A>
<A NAME="IDX373"></A>
<A NAME="IDX374"></A>
<A NAME="IDX375"></A>


<P>
Предположим, что ревизия 1.4 файла <TT>`driver.c'</TT> содержит такой 
код:



<PRE>
#include &#60;stdio.h&#62;

void main()
{
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? 0 : 1);
}
</PRE>

<P>
Ревизия 1.6 файла <TT>`driver.c'</TT> содержит такой код:



<PRE>
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(!!nerr);
}
</PRE>

<P>
Ваша рабочая копия файла <TT>`driver.c'</TT>, основанная на ревизии
1.4, перед выполнением <SAMP>`cvs update'</SAMP> содержит такой код:



<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

void main()
{
    init_scanner();
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</PRE>

<P>
Вы выполняете <SAMP>`cvs update'</SAMP>:



<PRE>
$ cvs update driver.c
RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
retrieving revision 1.4
retrieving revision 1.6
Merging differences between 1.4 and 1.6 into driver.c
rcsmerge warning: overlaps during merge
cvs update: conflicts found in driver.c
C driver.c
</PRE>

<P>
<A NAME="IDX376"></A>
CVS сообщает, что вы встретились с конфликтами.  Ваш
исходный рабочий файл сохранен в <TT>`.#driver.c.1.4'</TT>.  Новая
версия <TT>`driver.c'</TT> содержит такой код:



<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
&#60;&#60;&#60;&#60;&#60;&#60;&#60; driver.c
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
=======
    exit(!!nerr);
&#62;&#62;&#62;&#62;&#62;&#62;&#62; 1.6
}
</PRE>

<P>
<A NAME="IDX377"></A>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>
<A NAME="IDX380"></A>
<A NAME="IDX381"></A>
Заметьте, что непересекающиеся модификации включены в вашу
рабочую копию, а пересекающаяся секция четко обозначена строками
<SAMP>`&#60;&#60;&#60;&#60;&#60;&#60;&#60;'</SAMP>, <SAMP>`======='</SAMP> and <SAMP>`&#62;&#62;&#62;&#62;&#62;&#62;&#62;'</SAMP>.


<P>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>
Разрешить конфликт можно, отредактировав файл, удалив маркеры и
неверный вариант.  Предположим, в результате у вас получился
такой файл:

<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</PRE>

<P>
Теперь вы можете поместить этот файл в репозиторий в качестве
ревизии 1.7.



<PRE>
$ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
Checking in driver.c;
/usr/local/cvsroot/yoyodyne/tc/driver.c,v  &#60;--  driver.c
new revision: 1.7; previous revision: 1.6
done
</PRE>

<P>
Чтобы защитить вас, CVS откажется фиксировать файл, если в
нем произошел конфликт и вы с ним не справились.  В настоящий
момент для разрешения конфликта нужно изменить дату модификации
файла.  В предыдущих версиях CVS вам также требовалось
убедиться, что файл не содержит маркеров конфликта.  Так как ваш
файл действительно может содержать маркеры конфликтов (символы
<SAMP>`&#62;&#62;&#62;&#62;&#62;&#62;&#62;&#62;'</SAMP> в начале строки, не обозначающие конфликта), то в 
текущей версии CVS выдает предупреждение и фиксирует файл.


<P>
<A NAME="IDX384"></A>
Если вы используете <CODE>pcl-cvs</CODE> (оболочка к CVS для
Emacs) версии 1.04 или позже, вы можете использовать пакет
emerge, помогающий разрешать конфликты.  Смотрите документацию по 
<CODE>pcl-cvs</CODE>.




<H2><A NAME="SEC86" HREF="cvs-ru_toc.html#TOC86">Информирование коллег о фиксировании ревизий</A></H2>
<P>
<A NAME="IDX385"></A>
<A NAME="IDX386"></A>
<A NAME="IDX387"></A>


<P>
Часто бывает полезно информировать своих коллег, когда вы
фиксируете новую ревизию файла.  Можно использовать ключ
<SAMP>`-i'</SAMP> в файле <TT>`modules'</TT> или файле <TT>`loginfo'</TT> для
автоматизации этого процесса.  See section <A HREF="cvs-ru_18.html#SEC154">Файл <TT>`modules'</TT></A>.  See section <A HREF="cvs-ru_18.html#SEC167">Файл loginfo</A>.  Можно использовать эти возможности CVS для того,
чтобы указать CVS, например, отсылать почтовые сообщения
всем разработчикам или помещать сообщение в локальную группу
новостей.




<H2><A NAME="SEC87" HREF="cvs-ru_toc.html#TOC87">Совместный доступ нескольких разработчиков к CVS</A></H2>

<P>
<A NAME="IDX388"></A>
Если несколько разработчиков попытаются одновременно выполнить
CVS, один из них получит такое сообщение:



<PRE>
[11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo
</PRE>

<P>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>
CVS попытается повторить операцию каждые 30 секунд, и либо
успешно выполнит ее, либо опять напечатает сообщение, если опять
нужно ждать.  Если блокировка сохраняется слишком долго, найдите
того, кто создал ее и спросите его, что за команду он выполняет.
Если он не выполняет команд CVS, загляните в каталог
репозитория, упомянутый в сообщении, и удалите файлы, чьи имена
начинаются с <TT>`#cvs.rfl'</TT>, <TT>`#cvs.wfl'</TT>, или
<TT>`#cvs.lock'</TT>, принадлежащие указанному пользователю.


<P>
Заметьте, что эти блокировки предназначаются для защиты
внутренних структур данных CVS и не имеют никакого отношения 
к слову <EM>блокировка</EM> в том смысле, который используется в
RCS и означает блокированные извлечения (see section <A HREF="cvs-ru_10.html#SEC82">Несколько разработчиков</A>). 


<P>
Неограниченное количество пользователей может одновременно читать
репозиторий; только когда кто-либо пишет туда, блокировки
препятствуют прочим как читать, так и писать.


<P>
<A NAME="IDX392"></A>
<A NAME="IDX393"></A>
Можно было бы надеяться, что верно следующее утверждение:



<PRE>
Если кто-либо фиксирует несколько изменений одной командой
CVS, то команда <CODE>update</CODE>, выполненная кем-то еще,
получит либо все изменения, либо ни одно из них.
</PRE>

<P>
К сожалению, при работе с CVS это утверждение
<EM>неверно</EM>.  Например, если имеются файлы



<PRE>
a/one.c
a/two.c
b/three.c
b/four.c
</PRE>

<P>
и кто-то выполняет



<PRE>
cvs ci a/two.c b/three.c
</PRE>

<P>
а затем кто-то еще в то же самое время выполняет <CODE>cvs
update</CODE>, то он может получить изменения для <TT>`b/three.c'</TT>, и
не получить изменения в <TT>`a/two.c'</TT>.




<H2><A NAME="SEC88" HREF="cvs-ru_toc.html#TOC88">Как отследить, кто редактирует файлы?</A></H2>
<P>
<A NAME="IDX394"></A>


<P>
Для большинства групп использования CVS в режиме по
умолчанию совершенно достаточно.  Пользователи иногда могут,
попытавшись зафиксировать изменение, обнаружить, что мешает
другое изменение, но они справятся с этим и все же зафиксируют
свое изменение.  В других группах предпочитают знать, кто какие
файлы редактирует, так что если два человека захотят
редактировать один и тот же файл, то они предпочтут договориться
друг с другом, кто что будет делать, чтобы не получать проблем
при каждом фиксировании.  Возможности, описанные в этой главе,
помогают такой координации, сохраняя возможность редактирования
одного файла двум разработчикам одновременно.


<P>
Для получения максимального преимущества разработчики должны
использовать <CODE>cvs edit</CODE> (а не <CODE>chmod</CODE>), чтобы сделать
файлы доступными для чтения/записи, и <CODE>cvs release</CODE> (а не
<CODE>rm</CODE>) для удаления рабочего каталога, который более не
используется.  CVS не может вынудить их делать так. 




<H3><A NAME="SEC89" HREF="cvs-ru_toc.html#TOC89">Как с помощью CVS следить за определенными файлами?</A></H3>

<P>
Для того, чтобы включить использование функции слежения, сначала
укажите, за какими файлами нужно следить. 


<P>
<A NAME="IDX395"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watch on</B> <I>[<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX396"></A>


<P>
<A NAME="IDX397"></A>
<A NAME="IDX398"></A>
Команда означает, что разработчикам нужно выполнить команду
<CODE>cvs edit</CODE> перед редактированием <VAR>файлов</VAR>.  Для того,
чтобы напомнить об этом разработчикам, CVS создаст рабочие
копии <VAR>файлов</VAR> в режиме только для чтения.


<P>
Если среди <VAR>файлов</VAR> есть имя каталога, CVS включает
слежение за всем файлами, находящимися в соответствующем каталоге
репозитория и автоматически включает режим слежения за всеми
файлами, которые будут в дальнейшем добавлены в каталог; это
позволяет пользователю задать стратегию уведомлений для каждого
каталога.  Содержимое каталога обрабатывается рекурсивно, если
только не задан ключ командной строки <CODE>-l</CODE>.  Ключ <CODE>-R</CODE>
позволяет включить рекурсивное поведение, если в файле
<TT>`~/.cvsrc'</TT> оно было выключено с помощью ключа <CODE>-l</CODE>
(see section <A HREF="cvs-ru_16.html#SEC115">Ключи по умолчанию и файл ~/.cvsrc</A>).


<P>
Если список файлов пропущен, по умолчанию обрабатывается текущий
каталог.


<P>
<A NAME="IDX399"></A>
</DL>


<P>
<DL>
<DT><U>Команда:</U> <B>cvs watch off</B> <I>[<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX400"></A>


<P>
Команда означает, что при извлечении не нужно создавать
<VAR>файлы</VAR> в режиме только для чтения; таким образом,
разработчики не будут получать напоминания о необходимости
использования <CODE>cvs edit</CODE> и <CODE>cvs unedit</CODE>.  CVS
будет извлекать <VAR>файлы</VAR> в обычном режиме, если только на
файле не установлены специальные права доступа, разрешенные с
помощью ключевого слова <CODE>PreservePermissions</CODE> в
административном файле <TT>`config'</TT> (см. section <A HREF="cvs-ru_15.html#SEC111">Специальные файлы</A>
и See section <A HREF="cvs-ru_18.html#SEC174">Файл конфигурации CVSROOT/config</A>).


<P>
<VAR>Файлы</VAR> и ключи командной строки обрабатываются точно так же, 
как и для <CODE>cvs watch on</CODE>.


</DL>



<H3><A NAME="SEC90" HREF="cvs-ru_toc.html#TOC90">CVS может посылать вам уведомления</A></H3>

<P>
Вы можете сказать CVS, что хотели бы получать уведомления о
разнообразных действиях, совершенных с файлом.  В принципе вы
можете сделать это без использования <CODE>cvs watch on</CODE>, но
обычно все же будете использовать как раз <CODE>cvs watch on</CODE>,
чтобы другие разработчики использовали команду <CODE>cvs edit</CODE>.


<P>
<A NAME="IDX401"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watch add</B> <I>[<CODE>-a</CODE> действие] [<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX402"></A>


<P>
Добавить текущего пользователя в список лиц, которые будут
получать уведомления о действиях, совершавшихся с <VAR>файлами</VAR>.


<P>
Ключ командной строки <CODE>-a</CODE> задает тип событий, о которых
следует посылать уведомления.  <VAR>действие</VAR> -- это


<DL COMPACT>

<DT><CODE>edit</CODE>
<DD>
Другой пользователь выполнил для файла команду <CODE>cvs edit</CODE>
(описанную ниже).

<DT><CODE>unedit</CODE>
<DD>
Другой пользователь выполнил команду <CODE>cvs unedit</CODE> (описанную 
ниже) или команду <CODE>cvs release</CODE>, или удалил файл и позволил
команде <CODE>cvs update</CODE> создать его заново.

<DT><CODE>commit</CODE>
<DD>
Другой пользователь зафиксировал изменения в файле.

<DT><CODE>all</CODE>
<DD>
Все эти действия.

<DT><CODE>none</CODE>
<DD>
Ни одно из этих действий.  (Это полезно вместе с <CODE>cvs edit</CODE>, 
описанной ниже.)

</DL>

<P>
Ключ <CODE>-a</CODE> можно указать несколько раз или вообще не
указывать, в этом случае по умолчанию используется <CODE>all</CODE>.


<P>
<VAR>Файлы</VAR> и ключи командной строки обрабатываются так же, как и 
в команде <CODE>cvs watch</CODE>.


</DL>

<P>
<A NAME="IDX403"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watch remove</B> <I>[<CODE>-a</CODE> действие] [<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX404"></A>


<P>
Удалить запрос на уведомление, созданный с помощью <CODE>cvs
watch add</CODE>; аргументы те же самые.  Если присутствует ключ
командной строки <CODE>-a</CODE>, то только удаляются только слежения
за указанными действиями.


</DL>

<P>
<A NAME="IDX405"></A>
Когда требуется отправить уведомление, CVS обращается к
административному файлу <TT>`notify'</TT>.  Этот файл можно
отредактировать точно так же, как и другие административные файл
(see section <A HREF="cvs-ru_2.html#SEC20">Административные файлы</A>).  Синтаксис этого
файла подобен другим административным файлам
(see section <A HREF="cvs-ru_18.html#SEC162">Обычный синтаксис</A>), где каждая строка состоит из регулярного
выражения и команды, которую надо выполнить.  Команда должна
содержать одно единственное упоминание символов <SAMP>`%s'</SAMP>,
которые будут заменены на имя пользователя, которого нужно
уведомить;  остальная информация передается этой команде на
стандартный вход.  Обычно в файл <TT>`notify'</TT> помещается такая
строка:



<PRE>
ALL mail %s -s \"CVS notification\"
</PRE>

<P>
В результате всего этого пользователи получают уведомления по
электронной почте.


<P>
<A NAME="IDX406"></A>
Заметьте, что если вы настроите все именно так, как рассказано
выше, то пользователи будут получать уведомления на сервере.
Конечно же, можно написать скрипт <TT>`notify'</TT>, который
перенаправляет уведомления на другой адрес, но, для простоты,
CVS позволяет задать адрес, по которому следует отсылать
уведомления пользователю.  Для этого создайте в <TT>`CVSROOT'</TT>
файл <TT>`users'</TT>, в котором каждая строка имеет вид
<VAR>пользователь</VAR>:<VAR>адрес</VAR>.  Тогда вместо того, чтобы
использовать имя пользователя, CVS будет использовать
<VAR>адрес</VAR>. 


<P>
CVS не уведомляет вас о ваших собственных изменениях.  В
настоящий момент проверка производится, основываясь на имени
пользователя, который совершает действия, приводящие к отсылке
уведомления.  Вообще, функция слежения каждый раз сообщает только
об одном изменении, сделанном одним пользователем.  Вероятно,
было бы более полезно, если бы отдельно отслеживались целые
рабочие каталоги, поэтому такое поведение было бы полезно
изменить.




<H3><A NAME="SEC91" HREF="cvs-ru_toc.html#TOC91">Как редактировать файлы, за которыми наблюдают?</A></H3>

<P>
<A NAME="IDX407"></A>
Так как файл, за которым следит кто-либо, извлекается в режиме
только для чтения, то вы не можете просто взять и отредактировать
его.  Для того, чтобы сделать его доступным для записи и сообщить
остальным, что вы планируете отредактировать этот файл,
используйте команду <CODE>cvs edit</CODE>.  Некоторые системы называют
это <EM>извлечение</EM>, но пользователи CVS уже используют
этот термин в смысле "получение копии исходных текстов"
(see section <A HREF="cvs-ru_1.html#SEC5">Получение исходного кода</A>), а эту операцию, в свою
очередь, другие системы называют <EM>взять</EM>.


<P>
<A NAME="IDX408"></A>
<DL>
<DT><U>Команда:</U> <B>cvs edit</B> <I>[ключи] файлы ...</I>
<DD><A NAME="IDX409"></A>


<P>
Подготовить для редактирования рабочие файлы.  CVS делает
<VAR>файлы</VAR> доступными для чтения и записи и уведомляет
пользователей, которые уведомления о редактировании какого-нибудь 
из указанных файлов. 


<P>
Команда <CODE>cvs edit</CODE> принимает такие же ключи командной
строки, что и команда <CODE>cvs watch add</CODE>, и устанавливает
временное слежение за <VAR>файлами</VAR> для пользователя; CVS
прекратит слежение, когда будет выполнена команда <CODE>unedit</CODE>
или команда <CODE>commit</CODE>.  Если пользователь не хочет получать
уведомления, он должен указать ключ <CODE>-a none</CODE>.


<P>
<VAR>Файлы</VAR> и ключи командной строки обрабатываются точно так же, 
как и для команды <CODE>cvs watch</CODE>.


<P>
<STRONG>Предупреждение:</STRONG> если в репозитории разрешена опция
<CODE>PreservePermissions</CODE> (see section <A HREF="cvs-ru_18.html#SEC174">Файл конфигурации CVSROOT/config</A>), то CVS не
будет менять прав доступа к <VAR>файлам</VAR>.  Причина этого
изменения -- убедиться, что <CODE>cvs edit</CODE> не мешает хранению
прав доступа к файлам в CVS-репозитории.


</DL>

<P>
Обычно, когда вы закончите редактирование файлов, используйте
команду <CODE>cvs commit</CODE>, которая проверит ваши изменения и
вернет файлы, за которыми производилось слежение, в обычное
состояние только для чтения.  Если же вы вместо этого решите
отменить изменения, или просто не станете ничего менять,
используйте команду <CODE>cvs unedit</CODE>.


<P>
<A NAME="IDX410"></A>
<A NAME="IDX411"></A>
<A NAME="IDX412"></A>
<DL>
<DT><U>Command:</U> <B>cvs unedit</B> <I>[<CODE>-lR</CODE>] files ...</I>
<DD><A NAME="IDX413"></A>


<P>
Отбросить все изменения в рабочих файлах <VAR>files</VAR> и привести
их в соответствие с ревизией в репозитории.  Если кто-либо
запросил уведомление об изменениях каких-либо файлов, то CVS 
делает эти файлы доступными только для чтения.  CVS
уведомляет пользователей, которые запросили уведомление о команде 
<CODE>unedit</CODE>.


<P>
Ключи командной строки и список файлов обрабатываются точно так
же, как для команды <CODE>cvs watch</CODE>.


<P>
Если слежение не используется, команда <CODE>unedit</CODE>, вероятно,
не работает, и единственный способ вернуть файл в репозиторное
состояние -- удалить его и использовать <CODE>cvs update</CODE> для
получения новой копии.  Семантика этой операции идентична команде 
<CODE>unedit</CODE>: удаление и обновление может внести также и 
изменения, которые были помещены в репозиторий с тех пор, как вы
в последний раз обновляли свою рабочую копию.
</DL>


<P>
При использовании сетевого CVS вы можете использовать
команды <CODE>cvs edit</CODE> и <CODE>cvs unedit</CODE>, даже если CVS
не смогла успешно соединиться с сервером.  Уведомления будут
посланы при следующем успешном выполнении какой-либо команды
CVS.




<H3><A NAME="SEC92" HREF="cvs-ru_toc.html#TOC92">Информация о том, кто следит и кто редактирует</A></H3>

<P>
<A NAME="IDX414"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watchers</B> <I>[<CODE>-lR</CODE>] files ...</I>
<DD><A NAME="IDX415"></A>


<P>
Выдает список пользователей, которые отслеживают изменения в
<VAR>files</VAR>.  Сообщаются имена файлов и почтовые адреса каждого
следящего.


<P>
Ключи командной строки и список файлов обрабатываются так же, как 
и в команде <CODE>cvs watch</CODE>.


</DL>

<P>
<A NAME="IDX416"></A>
<DL>
<DT><U>Команда:</U> <B>cvs editors</B> <I>[<CODE>-lR</CODE>] files ...</I>
<DD><A NAME="IDX417"></A>


<P>
Выдает список пользователей, которые в текущий момент работают
над файлами <VAR>files</VAR>.  Сообщаются почтовые адреса
пользователей, время, когда пользователь начал работу с файлом, а 
также машина и рабочий каталог на ней, в котором находится каждый 
файл.


<P>
Список файлов и ключи командной строки обрабатываются точно так
же, как и в команде <CODE>cvs watch</CODE>.


</DL>



<H3><A NAME="SEC93" HREF="cvs-ru_toc.html#TOC93">Использование слежений со старыми версиями CVS</A></H3>

<P>
<A NAME="IDX418"></A>
<A NAME="IDX419"></A>
Если вы используете возможность слежения за репозиторием, то в
нем создаются каталоги <TT>`CVS/'</TT>, в которых хранится информация 
о слежениях за файлами из соответствующего каталога.  Если вы
попытаетесь использовать в этом репозитории CVS версии 1.6 и 
ранее, вы получите такое сообщение об ошибке:



<PRE>
cvs update: cannot open CVS/Entries for reading:
No such file or directory
</PRE>

<P>
Выполняемая команда, скорее всего, будет прервана.  Для
использования возможности слежения обновите все копии CVS,
которые используют этот репозиторий в локальном или серверном
режиме.  Если вы не можете совершить обновление, используйте
команды <CODE>watch off</CODE> и <CODE>watch remove</CODE>, чтобы удалить все 
слежения, а затем восстановите репозиторий в состояние, с которым 
может работать CVS 1.6.




<H2><A NAME="SEC94" HREF="cvs-ru_toc.html#TOC94">Выбор между блокированными и неблокированными извлечениями</A></H2>
<P>
<A NAME="IDX420"></A>


<P>
Блокированные и неблокированные извлечения имеют свои "за" и
"против".  Достаточно сказать, что это в основном вопрос мнения,
или же принятого в группе стиле работы.  Впрочем же, вот краткое
описание некоторых возникающих вопросов.  Существует множество
способов организовать команду разработчиков.  CVS не
пытается насильно внедрить какой-либо способ. CVS -- это
просто инструмент, который можно использовать различными
способами.


<P>
Блокированные извлечения могут оказывать отрицательное влияние на 
производительность.  Если два человека хотят отредактировать
различные части файла, какие могут быть причины помешать
кому-нибудь из них сделать это?  Обычным делом также является
заблокировать файл, предполагая поредактировать его, а затем
забыть снять блокировку.


<P>
Люди, обычно те, кто хорошо знаком с блокированными извлечениями, 
обычно спрашивают, как часто случаются конфликты при
использовании неблокированных извлечений, и сколь сложно их
разрешить.  Опыт разнообразных групп показал, что такие конфликты 
случаются редко и обычно их можно разрешить относительно
спокойно.


<P>
Редкость серьёзных конфликтов может удивить, пока не осознаешь,
что они случаются только когда два разработчика расходятся во
мнениях о должном дизайне определенного куска кода; такое
расхождение свидетельствует о том, что команда, прежде всего, не
общалась друг с другом должным образом.  Для того, чтобы
сотрудничать в условиях <EM>любой</EM> системы контроля исходных
текстов, разработчики должны не иметь разногласий по поводу
общего дизайна системы; при отсутствии таковых, пересекающиеся
изменения обычно разрешаются напрямую.


<P>
В некоторых случаях неблокированные извлечения совершенно точно
являются неподходящими.  Если для файлов, которые вы
редактируете, не существует инструмента для слияния (например,
файлы, созданные текстовым процессором, или же файлы, созданные с
помощью CAD-системы), а переход на программу, которая использует
формат файлов с возможностью слияния, нежелателен, то разрешение
конфликтов, скорее всего, будет столь неприятным, что будет проще
избежать их, используя блокированные извлечения.


<P>
Возможность слежения, описанная выше, в главе section <A HREF="cvs-ru_10.html#SEC88">Как отследить, кто редактирует файлы?</A>,
может считаться промежуточной моделью между блокированными и
неблокированными изменениями.  Когда вы редактируете файл, можно
узнать, кто ещё редактирует его.  Система, вместо того, чтобы
просто запретить двум людям редактировать файл, может описать
ситуацию и позволить вам самому решить, является ли этот
конкретный случай проблемой или нет.  Таким образом, для
некоторых групп механизм слежения может считаться объединением
лучших черт блокированных и неблокированных изменений.


<P><HR><P>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_9.html">previous</A>, <A HREF="cvs-ru_11.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
