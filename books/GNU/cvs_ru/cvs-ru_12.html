<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Подстановка ключевых слов</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_11.html">previous</A>, <A HREF="cvs-ru_13.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC97" HREF="cvs-ru_toc.html#TOC97">Подстановка ключевых слов</A></H1>
<P>
<A NAME="IDX426"></A>
<A NAME="IDX427"></A>
<A NAME="IDX428"></A>
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>


<P>
Пока вы редактируете исходные файлы в рабочем каталоге, вы всегда 
можете узнать их статус с помощью <SAMP>`cvs status'</SAMP> и <SAMP>`cvs
log'</SAMP>.  Как только вы экспортируете файлы из вашей среды
разработки, становится гораздо сложнее узнать, какую ревизию эти
файлы имеют.


<P>
CVS может использовать механизм, известный как
<EM>подстановка ключевых слов</EM> (или <EM>замена ключевых слов</EM>),
чтобы помочь в идентификации файлов.  Строки вида
<CODE>$<VAR>keyword</VAR>$</CODE> и <CODE>$<VAR>keyword</VAR>:...$</CODE> в файле
заменяются строками вида <CODE>$<VAR>keyword</VAR>:<VAR>value</VAR>$</CODE>
каждый раз, когда вы получаете новую ревизию файла.




<H2><A NAME="SEC98" HREF="cvs-ru_toc.html#TOC98">Список ключевых слов</A></H2>
<P>
<A NAME="IDX431"></A>


<P>
Вот список ключевых слов:


<DL COMPACT>

<DT><CODE>$Author$</CODE>
<DD>
<A NAME="IDX432"></A>
 <A NAME="IDX433"></A>
 
Имя пользователя, который поместил ревизию в репозиторий.

<A NAME="IDX434"></A>
<A NAME="IDX435"></A>
<DT><CODE>$Date$</CODE>
<DD>
Дата и время (в UTC), когда была зафиксирована ревизия.

<A NAME="IDX436"></A>
<A NAME="IDX437"></A>
<DT><CODE>$Header$</CODE>
<DD>
Стандартный заголовок, содержащий полное имя RCS-файла,
номер ревизии, дату в UTC, имя автора, состояние и имя
блокировавшего этот файл (если файл заблокирован).  Файлы обычно
не блокируются при использовании CVS.

<A NAME="IDX438"></A>
<A NAME="IDX439"></A>
<DT><CODE>$Id$</CODE>
<DD>
Точно так же, как <CODE>$Header$</CODE>, только имя
RCS-файла указано без полного пути.

<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
<DT><CODE>$Name$</CODE>
<DD>
Имя метки, использованной при извлечении этого файла.  Это
ключевое слово заменяется только если при извлечении было явно
задано имя метки.  Например, при выполнении команды <CODE>cvs co
-r first</CODE> это ключевое слово заменяется на <SAMP>`Name: first'</SAMP>.

<A NAME="IDX442"></A>
<A NAME="IDX443"></A>
<DT><CODE>$Locker$</CODE>
<DD>
Имя пользователя, который заблокировал эту ревизию (пустое, если
файл не заблокирован, как обычно и бывает, если не использовалась 
команда <CODE>cvs admin -l</CODE>).

<A NAME="IDX444"></A>
<A NAME="IDX445"></A>
<DT><CODE>$Log$</CODE>
<DD>
Журнальное сообщение, которое было введено во время фиксации
изменений, перед которым идет имя RCS-файла, номер ревизии,
имя автора и дата в UTC.  Существующие журнальные сообшения
<EM>не</EM> заменяются.  Вместо этого, новое журнальное сообщение
добавляется после <CODE>$Log:...$</CODE>.  Каждая новая
строка содержит в начале ту же самую строку, которая находится
перед ключевым словом <CODE>$Log$</CODE>.  Например, если в
файле находится


<PRE>
  /* Here is what people have been up to:
   *
   * $Log: frob.c,v $
   * Revision 1.1  1997/01/03 14:23:51  joe
   * Add the superfrobnicate option
   *
   */
</PRE>

то перед дополнительными строками, которые добавляются при замене
ключевого слова <CODE>$Log$</CODE>, будет находиться 
<SAMP>`   * '</SAMP>.  В отличие от предыдущих версий CVS и
RCS, <EM>префикс комментария</EM> из RCS-файла не
используется.  Ключевое слово <CODE>$Log</CODE> полезно при накоплении
полного журнала изменений в исходном файле, но по нескольким
причинам это может привести к определенным проблемам.
See section <A HREF="cvs-ru_12.html#SEC102">Проблемы с ключевым словом $Log$.</A>.

<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
<DT><CODE>$RCSfile$</CODE>
<DD>
Имя RCS-файла без полного пути.

<A NAME="IDX448"></A>
<A NAME="IDX449"></A>
<DT><CODE>$Revision$</CODE>
<DD>
Номер ревизии.

<A NAME="IDX450"></A>
<A NAME="IDX451"></A>
<DT><CODE>$Source$</CODE>
<DD>
Полное имя RCS-файла.

<A NAME="IDX452"></A>
<A NAME="IDX453"></A>
<DT><CODE>$State$</CODE>
<DD>
Состояние, присвоенное ревизии.  Состояния могут назначаться с
помощью <CODE>cvs admin -s</CODE> -- см. section <A HREF="cvs-ru_16.html#SEC119">Ключи команды admin</A>.

</DL>



<H2><A NAME="SEC99" HREF="cvs-ru_toc.html#TOC99">Использование ключевых слов</A></H2>

<P>
Для того, чтобы поместить в файл ключевое слово, вы просто
пишете в нём, например, <CODE>$Id$</CODE>, а затем фиксируете
файл.  CVS автоматически заменит ключевое слово во время
операции фиксирования.


<P>
Обычной практикой является помещение строки <CODE>$</CODE>Id$ в
исходные файлы, чтобы они оказались в файлах, созданных из
исходных.  Например, если вы управляете исходным кодом
компьютерной программы, вы можете создать переменную, которая
инициализируется этой строкой.  Некоторые компиляторы языка C
поддерживают директиву <CODE>#pragma ident</CODE>.  Система управления
документами может обеспечивать способ для передачи строки в
сгенерированные файлы.


<P>
<A NAME="IDX454"></A>
<A NAME="IDX455"></A>
Команда <CODE>ident</CODE>, являющаяся частью пакета RCS, может
использоваться для извлечения из файла ключевых слов и их
значений.  Это полезно для работы с текстовыми файлами, и
особенно полезно для извлечения ключевых слов из двоичных
файлов. 



<PRE>
$ ident samp.c
samp.c:
     $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
$ gcc samp.c
$ ident a.out
a.out:
     $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
</PRE>

<P>
<A NAME="IDX456"></A>
SCCS -- другая популярная система контроля ревизий.  В её
состав входит команда <CODE>what</CODE>, очень похожая на <CODE>ident</CODE>
и использующаяся в тех же целях.  Во многих местах, где не
установлен RCS, стои SCCS.  Так как <CODE>what</CODE> ищет
последовательность символов <CODE>@(#)</CODE>, то можно довольно
просто вставлять ключевые слова, которые обнаруживаются обеими
командами.  Просто поместите перед ключевым словом RCS
волшебную фразу SCCS, например:



<PRE>
static char *id="@(#) $Id: ab.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";
</PRE>



<H2><A NAME="SEC100" HREF="cvs-ru_toc.html#TOC100">Как избежать подстановки</A></H2>

<P>
Подстановка ключевых слов имеет свои недостатки.  Иногда бывает
нужно, чтобы строка <SAMP>`$'</SAMP>Author$ появилась в файле без
того, чтобы CVS интерпретировала её как ключевое слово и
заменила на что-нибудь типа <SAMP>`$'</SAMP>Author: ceder $.


<P>
К сожалению, нельзя выборочно отключить подстановку ключевых
слов.  Можно использовать ключ командной строки <SAMP>`-ko'</SAMP>
(see section <A HREF="cvs-ru_12.html#SEC101">Режимы подстановки</A>), чтобы полностью выключить
подстановку.


<P>
Во многих случаях вам нужно избежать использования ключевых слов
в исходном тексте, даже несмотря на то, что они появятся в
конечном продукте.  Например, исходный текст этого руководства
содержит <SAMP>`$@asis{}Author$'</SAMP> везде, где должна появиться
строка <SAMP>`$'</SAMP>Author$.  При использовании <CODE>nroff</CODE> и
<CODE>troff</CODE> можно поместить в ключевое слово нулевой символ
<CODE>\&#38;</CODE>, чтобы добиться подобного эффекта.




<H2><A NAME="SEC101" HREF="cvs-ru_toc.html#TOC101">Режимы подстановки</A></H2>
<P>
<A NAME="IDX457"></A>
<A NAME="IDX458"></A>


<P>
Вместе с каждым файлом хранится режим подстановки по умолчанию, и 
каждая копия файла в рабочем каталоге также имеет режим
подстановки.  Режим по умолчанию задается с помощью ключа
<SAMP>`-k'</SAMP> команд <CODE>cvs add</CODE> и <CODE>cvs admin</CODE>;  режим в
рабочем каталоге задается с помощью ключей <SAMP>`-k'</SAMP> и <SAMP>`-A'</SAMP>
команд <CODE>cvs checkout</CODE> и <CODE>cvs update</CODE>.  Команда
<CODE>cvs diff</CODE> также имеет ключ <SAMP>`-k'</SAMP>.  Некоторые примеры
приведены в section <A HREF="cvs-ru_9.html#SEC79">Обработка двоичных файлов</A>.


<P>
Доступные режимы таковы:


<DL COMPACT>

<DT><SAMP>`-kkv'</SAMP>
<DD>
Генерировать строки из ключевых слов стандартным образом, то есть
из ключевого слова <CODE>Revision</CODE> получается
<CODE>$</CODE>Revision: 5.7 $.

<DT><SAMP>`-kkvl'</SAMP>
<DD>
Подобно <SAMP>`-kkv'</SAMP>, только всегда указывается имя блокировщика,
если данная ревизия в настоящий момент заблокирована.  Имя
блокировщика имеет смысл только если используется <CODE>cvs admin
-l</CODE>.

<DT><SAMP>`-kk'</SAMP>
<DD>
Генерировать только имена ключевых слов и опускать их значения.
Например, для ключевого слова <CODE>Revision</CODE> получается строка
<CODE>$</CODE>Revision$, а не <CODE>$</CODE>Revision: 5.7 $.
Этот ключ полезен для игнорирования изменения, возникших в
результате подстановки ключевых слов, при сравнении разных
ревизий файла.

<DT><SAMP>`-ko'</SAMP>
<DD>
Генерирует старую строку, присутствовавшую в рабочем файле перед
тем, как он был зафиксирован.  Например, для ключевого слова
<CODE>Revision</CODE> генерируется строка <CODE>$</CODE>Revision: 1.1
$ вместо <CODE>$</CODE>Revision: 5.7 $, если она была записана
именно так, когда файл был помещен в репозиторий.

<DT><SAMP>`-kb'</SAMP>
<DD>
Подобно <SAMP>`-ko'</SAMP>, но также предотвращает преобразование
символов конца строк между канонической формой, в которой они
хранятся в репозитории (только символ перевода строки), и формой,
принятой в используемой операционной системе.  Для систем,
подобных UNIX, в которых для завершения строк используется
символ перевод строки, этот режим совпадает с <SAMP>`-ko'</SAMP>.
Дальнейшая информация о двоичных файлах находится в section <A HREF="cvs-ru_9.html#SEC79">Обработка двоичных файлов</A>.

<DT><SAMP>`-kv'</SAMP>
<DD>
Генерирует только значения ключевых строк.  Например, для
ключевого слова <CODE>Revision</CODE> генерируется строка <CODE>5.7</CODE>
вместо <CODE>$</CODE>Revision: 5.7 $.  Это может помочь при
генерации файлов в языках программирования, в которых сложно
отщепить разделители, такие как <CODE>$</CODE>Revision: $, от
конца строки.  Однако, дальнейшая подстановка ключевых слов не
может быть осуществлена, когда удалены ключевые слова, поэтому
этот ключ нужно использовать осторожно.

Часто бывает полезно использовать <SAMP>`-kv'</SAMP> совместно с командой
<CODE>cvs export</CODE> -- see section <A HREF="cvs-ru_16.html#SEC131">Команда export: экспортировать исходные тексты</A>.  Помните только,
что этот ключ некорректно экспортирует двоичные файлы.

</DL>



<H2><A NAME="SEC102" HREF="cvs-ru_toc.html#TOC102">Проблемы с ключевым словом $Log$.</A></H2>

<P>
Ключевое слово <CODE>$</CODE>Log$ довольно-таки спорно.  Пока вы 
работаете над проектом, информация легко доступна даже без
использования ключевого слова <CODE>$</CODE>Log$:  просто
вызовите <CODE>cvs log</CODE>.  Когда вы экспортируете файл, информация 
об его истории в любом случае практически бесполезна.


<P>
Более серьёзным обстоятельством является то, что CVS не
слишком хорошо справляется с пунктами <CODE>$</CODE>Log$, когда
ветка объединяется с основным стволом.  В результате такого
объединения часто возникают конфликты.


<P>
Люди часто стараются "исправить" журнальные записи в файле,
исправляя орфографические и даже фактические ошибки.  В
результате информация от <CODE>cvs log</CODE> не совпадает с
информацией в файле.  Это может быть, а может и не быть проблемой
в реальной жизни.


<P>
Звучали рекомендации помещать ключевое слово <CODE>$</CODE>Log$
в конец файла (если вообще использовать это слово).  В этом
случае длинный список сообщений об изменениях не будет мешать
чтению исходного файла.


<P><HR><P>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_11.html">previous</A>, <A HREF="cvs-ru_13.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
