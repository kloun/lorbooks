<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Обзор</TITLE>
</HEAD>
<BODY>
Go to the first, previous, <A HREF="cvs-ru_2.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>

<P>
Управление версиями
с помощью
CVS
для CVS 1.10
Per Cederqvist et al
Перевод на русский язык -- Алексей Махоткин


<P>
Copyright (C) 1992, 1993 Signum Support AB\*
Copyright (C) 1999 Alexey Mahotkin (translation into Russian)


<P>
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.


<P>
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


<P>
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.


<P>
Перевод того же самого уведомления на русский язык (перевод, в
отличие от уведомления на английском языке, законной силы не
имеет):


<P>
Разрешается создавать и распространять неизмененные копии этого
руководства, при условии, что на всех копиях сохраняется
уведомление о копирайте и это разрешение об использовании.


<P>
Разрешается копировать и распространять измененные версии этого
руководства на условиях копирования без изменений, а также при
условии, что вся порожденная работа распространяется с
разрешением использования, идентичному этому разрешению.


<P>
Разрешается копировать и распространять переводы этого
руководства на другой язык, с точно такими же условиями
использования измененных версий, за исключением того, что это
разрешение может быть переведено, а перевод должен быть одобрен
Фондом Свободного Программного Обеспечения.




<H1><A NAME="SEC1" HREF="cvs-ru_toc.html#TOC1">Обзор</A></H1>
<P>
<A NAME="IDX1"></A>


<P>
Эта глава предназначена для людей, никогда ранее не
использовавших CVS и, возможно, никогда не использовавших
управление версиями. 


<P>
Если вы уже знакомы с CVS и просто хотите изучить конкретную 
возможность или вспомнить определенную команду, вы, вероятно,
можете пропустить всю главу.




<H2><A NAME="SEC2" HREF="cvs-ru_toc.html#TOC2">Что такое CVS?</A></H2>
<P>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>
<A NAME="IDX4"></A>



<PRE>
Не помнящие прошлого обречены повторять его.

-- Джордж Сантаяна
</PRE>

<P>
CVS -- это система контроля версий.  Используя ее, вы
можете вести историю ваших файлов с исходными текстами.


<P>
Например, иногда при определенном изменении в коде могут
появиться ошибки, которые вы не сможете обнаружить в течение
длительного времени.  С помощью CVS вы легко можете
обратиться к старым версиям, чтобы точно выяснить, что именно
привело к ошибке.  Иногда это сильно помогает.


<P>
Конечно, вы можете хранить каждую версию каждого файла, которые
вы создаете.  Это будет стоить вам невероятного объема дискового
пространства.  CVS хранит все версии файла в одном файле
таким образом, что запоминаются лишь изменения между версиями.


<P>
CVS также поможет, если вы являетесь членом группы
разработчиков одного проекта.  Очень легко попортить чужие
изменения, если только вы не крайне аккуратны.  Некоторые
редакторы, такие как GNU Emacs, стараются проследить, чтобы
два человека не изменяли одновременно один и тот же файл.  К
сожалению, если кто-то использует другой редактор, эта
предосторожность не сработает.  CVS решает эту проблему,
изолируя разработчиков друг от друга.  Каждый работает в своем
собственном каталоге, а затем CVS объединяет законченные
работы.


<P>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
CVS появился из набора sh-скриптов, автором которых был Dick
Grune, опубликованных в ньюсгруппе <CODE>comp.sources.unix</CODE> в
томе 6 в декабре 1986 года.  Несмотря на то, что ни строчки кода
из тех скриптов не присутствует в CVS, основы алгоритма
устранения конфликтов взяты именно оттуда.


<P>
В апреле 1989 года Brian Berliner спроектировал и реализовал
CVS.  Jeff Polk позднее помог ему с поддержкой модулей и
ветвей поставщика.


<P>
<A NAME="IDX8"></A>
Получить CVS можно разными способами, включая свободное
получение в Интернете.  За информацией о получении и по другим
вопросам обращайтесь на:



<PRE>
http://www.cyclic.com/
http://www.loria.fr/~molli/cvs-index.html
</PRE>

<P>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
Имеется список рассылки <CODE>info-cvs</CODE>, посвященный обсуждению
CVS.  Чтобы подписаться на него или отписаться, пишите на
<CODE>info-cvs-request@gnu.org</CODE>.


<P>
Если вы предпочитаете группы новостей usenet, найдите
<CODE>comp.software.config-mgmt</CODE>, посвященную обсуждению
разнообразных систем управления конфигурацией, не только
CVS.  В будущем возможно создание
<CODE>comp.software.config-mgmt.cvs</CODE>, если в
<CODE>comp.software.config-mgmt</CODE> будет наличествовать достаточное
количество обсуждений CVS.


<P>
Можно также подписаться на список рассылки <CODE>bug-cvs</CODE>, о
котором подробно рассказывается в section <A HREF="cvs-ru_23.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>.  Чтобы
подписаться, напишите на <CODE>bug-cvs-request@gnu.org</CODE>.




<H2><A NAME="SEC3" HREF="cvs-ru_toc.html#TOC3">Чем не является CVS?</A></H2>
<P>
<A NAME="IDX11"></A>


<P>
CVS сделает для вас множество вещей, но не пытается быть
всем сразу.


<DL COMPACT>

<DT>CVS не является системой управления сборкой.
<DD>
Несмотря на то, что структуры вашего репозитория и файла модулей
взаимодействуют с системой управления сборкой (то есть файлами
<TT>`Makefile'</TT>), они принципиально независимы.

CVS не указывает, как собирать тот или иной проект.  Она
просто хранит файлы, предоставляя возможность обращаться к ним,
используя задуманную вами структуру дерева.

CVS не указывает, как использовать дисковое пространство в
извлеченных каталогах.  Если вы создадите <TT>`Makefile'</TT> или
скрипты в каждом каталоге так, что они должны знать относительную
позицию всего остального, то дело кончится тем, что придется
извлекать весь репозиторий.

Если вы модуляризуете вашу работу и создадите систему сборки,
которая будет совместно использовать файлы, (посредством ссылок,
монтирования, <CODE>VPATH</CODE> в <TT>`Makefile'</TT>'ах и т. д.), то
сможете использовать дисковое пространство любым угодным вам
способом.

Помните только, что <EM>любая</EM> подобная система требует
серьезной работы по созданию и поддержанию.  CVS не пытается
справиться с возникающими при этом вопросами.

Конечно же, вам следует поместить средства, созданные для
поддержки системы сборки (скрипты, <TT>`Makefile'</TT>'ы, и т. д.),
под CVS.

Выяснение того, какие файлы следует перекомпилировать при
каком-либо изменении, опять же, не является задачей CVS.
Традиционным подходом является использование <CODE>make</CODE> для
сборки, и использование специальной утилиты для генерации
зависимостей, используемых программой <CODE>make</CODE>.

Смотри главу section <A HREF="cvs-ru_14.html#SEC110">Как ваша система сборки взаимодействует с CVS</A> за дальнейшей информацией о
сборках проектов с участием CVS.

<DT>CVS не является заменой руководителю
<DD>
Предполагается, что вы общаетесь с вашим начальником и лидером
проекта достаточно часто, чтобы знать о графике работ, точках
слияния, именах веток и датах выпуска.  Если это не так, что
CVS никак не сможет помочь.

CVS -- это инструмент, заставляющий ваш код плясать под
вашу дудку. Но вы и композитор, и исполнитель.  Ни один
инструмент не играет сам и не сочиняет собственной музыки.

<DT>CVS не является заменой общения разработчиков.
<DD>
Встретившись с конфликтом, состоящим из единственной строки,
большинство разработчиков справляются с ними без особого труда.
Однако, более общее определение <EM>конфликта</EM> включает в себя
проблемы, которые слишком трудно решить без взаимодействия
разработчиков.

CVS не может обнаружить, что синхронные изменения в одном
или нескольких файлах привели к логическому конфликту.  Понятие
<EM>конфликт</EM>, которое использует CVS, строго текстуально.
Такие конфликты появляются, когда изменения в основном файле
достаточно близки, чтобы напугать программу слияния (то есть
<CODE>diff3</CODE>).

CVS совершенно неспособна помочь в устранении нетекстуальных
или распределенных конфликтов в логике программы.

Пример: предположим, вы изменили аргументы функции <CODE>X</CODE>,
описанной в файле <TT>`A'</TT>.  В то же самое время кто-то еще
редактирует файл <TT>`B'</TT>, добавив новый вызов функции <CODE>X</CODE>,
используя старые аргументы.  CVS ничем не сможет помочь.

Возьмите привычку читать спецификации и беседовать с коллегами.

<DT>CVS не ведет контроля изменений
<DD>
Под <EM>контролем изменений</EM> имеется в виду несколько вещей.
Во-первых, это может означать <EM>отслеживание ошибок</EM>, то есть
хранение базы данных обнаруженных ошибок и состояние каждой
(исправлена ли она? в какой версии? согласился ли обнаруживший
ее, что она исправлена?).  О взаимодействии с внешней системой
отслеживания ошибок можно прочитать в файлах <TT>`rcsinfo'</TT> и
<TT>`verifymsg'</TT> (see section <A HREF="cvs-ru_18.html#SEC153">Справочник по административным файлам</A>).

Другим аспектом контроля изменений является отслеживание того
факта, что изменения в нескольких файлах в действительности
являются одним и тем же согласованным изменением.  Если вы
фиксируете несколько файлов одной командой <CODE>cvs commit</CODE>, то
CVS забывает, что эти файлы были зафиксированы одновременно,
и единственная вещь, их объединяющая -- это одинаковые
журнальные записи.  В данном случае может помочь ведение файла
<TT>`ChangeLog'</TT> в стиле GNU.

Еще одним аспектом контроля изменений, в некоторых системах
является возможность отслеживать статус каждого изменения.
Некоторые изменения были написаны разработчиком, некоторые были
изучены другим разработчиком, и так далее.  Обычно при работе с
CVS в этом случае создается diff-файл, (используя <CODE>cvs
diff</CODE> или <CODE>diff</CODE>), который посылается по электронной почте
кому-нибудь, кто потом применит этот diff-файл, используя
программу <CODE>patch</CODE>.  Это очень гибко, но зависит от внешних
по отношению к CVS механизмов, чтобы убедиться, что ничего
не упущено.

<DT>CVS не является системой автоматического тестирования
<DD>
Впрочем, имеется возможность принудительного выполнения серии
тестов, используя файл <TT>`commitinfo'</TT>.  Я, однако же, не очень
много знаю о проектах, использовавших эту возможность, и есть ли
в ней какие-нибудь ловушки и подводные камни.

<DT>CVS не имеет встроенной модели процесса
<DD>
Некоторые системы обеспечивают способы убедиться, что изменения и
релизы проходят через определенные ступени, получая одобрение на
каждой.  Вообще говоря, этого можно добиться с помощью CVS,
но это может потребовать немного больше работы.  В некоторых
случаях вы будете использовать файлы <TT>`commitinfo'</TT>,
<TT>`loginfo'</TT>, <TT>`rcsinfo'</TT> или <TT>`verifymsg'</TT>, чтобы
убедиться, что предприняты определенные шаги, прежде чем CVS
позволит зафиксировать изменение.  Подумайте также, должны ли
использоваться такие возможности, как ветви разработки и метки,
чтобы, скажем, поработать над новой веткой разработки, а затем
объединять определенные изменения со стабильной веткой, когда эти
изменения одобрены.

</DL>



<H2><A NAME="SEC4" HREF="cvs-ru_toc.html#TOC4">Пример работы с CVS</A></H2>
<P>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>


<P>
В качестве введения в CVS мы приведем здесь типичную сессию
работы с CVS.  Первое, что необходимо понимать, это то, что
CVS хранит все файлы в централизованном <EM>репозитории</EM>
(see section <A HREF="cvs-ru_2.html#SEC9">Репозиторий</A>); в этой главе предполагается, что
репозиторий настроен.


<P>
Предположим, что вы работаете над простым компилятором.  Исходный 
текст состоит из нескольких C-файлов и <TT>`Makefile'</TT>'а.
Компилятор называется <SAMP>`tc'</SAMP> (Тривиальный Компилятор), а
репозиторий настроен так, что имеется модуль <SAMP>`tc'</SAMP>.




<H3><A NAME="SEC5" HREF="cvs-ru_toc.html#TOC5">Получение исходного кода</A></H3>
<P>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>


<P>
Сначала вам надо получить рабочую копию исходного кода для
<SAMP>`tc'</SAMP>.  Используйте команду



<PRE>
$ cvs checkout tc
</PRE>

<P>
при этом будет создан каталог <TT>`tc'</TT>, в который будут помещены
все файлы с исходными текстами.



<PRE>
$ cd tc
$ ls
CVS         Makefile    backend.c   driver.c    frontend.c  parser.c
</PRE>

<P>
Каталог <TT>`CVS'</TT> используется для внутренних нужд CVS.
Обычно вам не следует редактировать или удалять файлы,
находящиеся в этом каталоге.


<P>
Вы запускаете свой любимый редактор, работаете над
<TT>`backend.c'</TT> и через пару часов вы добавили фазу оптимизации
в компилятор.  Замечание для пользователей RCS и RCCS:
не требуется блокировать файлы, которые вы желаете
отредактировать.  See section <A HREF="cvs-ru_10.html#SEC82">Несколько разработчиков</A> за объяснением.




<H3><A NAME="SEC6" HREF="cvs-ru_toc.html#TOC6">Фиксирование изменений</A></H3>
<P>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
<A NAME="IDX26"></A>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>


<P>
После того, как вы проверили, что компилятор все еще
компилируется, вы решили создать новую версию <TT>`backend.c'</TT>.
При этом в репозитории появится ваш новый <TT>`backend.c'</TT>,
который станет доступным всем, использующим этот репозиторий.



<PRE>
$ cvs commit backend.c
</PRE>

<P>
CVS запускает редактор, чтобы позволить вам ввести
журнальную запись.  Вы набираете "Добавлена фаза оптимизации",
сохраняете временный файл и выходите из редактора.


<P>
Переменная окружения <CODE>$CVSEDITOR</CODE> определяет, какой именно
редактор будет вызван.  Если <CODE>$CVSEDITOR</CODE> не установлена, то
используется <CODE>$EDITOR</CODE>, если она, в свою очередь,
установлена.  Если обе переменные не установлены, используется
редактор по умолчанию для вашей операционной системы, например,
<CODE>vi</CODE> под UNIX или <CODE>notepad</CODE> для Windows 95/NT.


<P>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>
Вдобавок, CVS проверяет переменную окружения <CODE>VISUAL</CODE>.
Существуют различные мнения о том, требуется ли такое поведение и
должны ли дальнейшие версии CVS проверять переменную
<CODE>VISUAL</CODE> или игнорировать её.  В любом случае, лучше всего
будет убедиться, что <CODE>VISUAL</CODE> или вообще не установлена, или
установлена в то же значение, что и <CODE>EDITOR</CODE>.


<P>
Когда CVS запускает редактор, в шаблоне для ввода журнальной
записи перечислены измененные файлы.  Для клиента CVS этот
список создается путём сравнения времени изменения файла с его
временем изменения, когда он был получен или обновлен.  Таким
образом, если время изменения файла изменилось, а его содержимое
осталось прежним, он будет считаться измененным.  Проще всего в
данном случае не обращать на это внимания -- в процессе
фиксирования изменений CVS определит, что содержимое файла
не изменилось и поведет себя должным образом.  Следующая команда
<CODE>update</CODE> сообщит CVS, что файл не был изменен, и его
время изменения будет возвращено в прежнее значение, так что этот
файл не будет мешаться при дальнейших фиксированиях.


<P>
Если вы хотите избежать запуска редактора, укажите журнальную
запись в командной строке, используя флаг <SAMP>`-m'</SAMP>, например: 



<PRE>
$ cvs commit -m "Добавлена фаза оптимизации" backend.c
</PRE>



<H3><A NAME="SEC7" HREF="cvs-ru_toc.html#TOC7">Уборка за собой</A></H3>
<P>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>


<P>
Перед тем, как перейти к другим занятиям, вы решаете удалить
рабочую копию <CODE>tc</CODE>.  Конечно же, это можно сделать так:



<PRE>
$ cd ..
$ rm -r tc
</PRE>

<P>
но лучшим способом будет использование команды <CODE>release</CODE>
(see section <A HREF="cvs-ru_16.html#SEC145">Команда release: сообщить, что модуль более не используется</A>):



<PRE>
$ cd ..
$ cvs release -d tc
M driver.c
? tc
You have [1] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': n
** `release' aborted by user choice.
</PRE>

<P>
Команда <CODE>release</CODE> проверяет, что все ваши изменения были
зафиксированы.  Если включено журналирование истории, то в файле
истории появляется соответствующая пометка.  See section <A HREF="cvs-ru_18.html#SEC172">Файл history</A>.


<P>
Если вы используете команду <CODE>release</CODE> с флагом <SAMP>`-d'</SAMP>, то
она удаляет вашу рабочую копию.


<P>
В вышеприведенном примере команда <CODE>release</CODE> выдала несколько
строк. <SAMP>`? tc'</SAMP> означает, что файл <TT>`tc'</TT> неизвестен
CVS.  Беспокоиться не о чем, <TT>`tc'</TT> -- это исполняемый
файл компилятора, и его не следует хранить в репозитории.
See section <A HREF="cvs-ru_18.html#SEC171">Игнорирование файлов с помощью cvsignore</A> за информацией о том, как избежать этого
предупреждения.  See section <A HREF="cvs-ru_16.html#SEC147">Сообщения команды release</A> за полной
информацией о возможных сообщениях команды <CODE>release</CODE>.


<P>
<SAMP>`M driver.c'</SAMP> -- более серьезное сообщение.  Оно означает,
что файл <TT>`driver.c'</TT> был изменен с момента последнего
получения из репозитория.


<P>
Команда <CODE>release</CODE> всегда сообщает, сколько измененных файлов 
находится в вашей рабочей копии исходных кодов, а затем
спрашивает подтверждения перед удалением файлов или внесения
пометки в файл истории.


<P>
Вы решаете перестраховаться и отвечаете <KBD>n <KBD>RET</KBD></KBD>, когда
<CODE>release</CODE> просит подтверждения.




<H3><A NAME="SEC8" HREF="cvs-ru_toc.html#TOC8">Просмотр изменений</A></H3>
<P>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>


<P>
Вы не помните, что изменяли файл <TT>`driver.c'</TT>, поэтому хотите
посмотреть, что именно случилось с ним.



<PRE>
$ cd tc
$ cvs diff driver.c
</PRE>

<P>
Эта команда сравнивает версию файла <TT>`driver.c'</TT>, находящейся
в репозитории, с вашей рабочей копией.  Когда вы рассматриваете
изменения, вы вспоминаете, что добавили аргумент командной
строки, разрешающий фазу оптимизации.  Вы фиксируете это
изменение и высвобождаете модуль.



<PRE>
$ cvs commit -m "Добавлена фаза оптимизации" driver.c
Checking in driver.c;
/usr/local/cvsroot/tc/driver.c,v  &#60;--  driver.c
new revision: 1.2; previous revision: 1.1
done
$ cd ..
$ cvs release -d tc
? tc
You have [0] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': y
</PRE>

<P><HR><P>
Go to the first, previous, <A HREF="cvs-ru_2.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
