<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Репозиторий</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_1.html">previous</A>, <A HREF="cvs-ru_3.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC9" HREF="cvs-ru_toc.html#TOC9">Репозиторий</A></H1>
<P>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
<A NAME="IDX45"></A>


<P>
<EM>Репозиторий</EM> в CVS хранит полные копии всех файлов и
каталогов, находящихся под контролем версий.


<P>
Обычно вам никогда не придется напрямую обращаться к файлам в
репозитории.  Вместо этого вы будете использовать команды
CVS для получения вашей личной копии файлов в <EM>рабочем
каталоге</EM>, а затем будете работать с этими файлами.  Когда вы
внесли определенные изменения, вы <EM>фиксируете</EM> их в
репозитории.  Теперь в репозитории хранится информация о том,
какие изменения вы сделали, включая их точное содержание, время
изменения и тому подобную информацию.  Заметьте, что репозиторий
не является подкаталогом рабочего каталога, и обратное также
неверно; они находятся в совершенно разных местах.


<P>
<A NAME="IDX46"></A>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
CVS может обращаться к репозиторию большим количеством
способов.  Репозиторий может находиться на локальной машине, на
соседней машине или на машине, находящейся на другом континенте.
Чтобы различать пути доступа к репозиториям, их имена начинаются
с <EM>метода доступа</EM>.  Например, метод доступа <SAMP>`:local:'</SAMP>
означает, что репозиторий находится в локальном каталоге, то есть 
<SAMP>`:local:/usr/local/cvsroot'</SAMP> означает, что репозиторий
находится в <TT>`/usr/local/cvsroot'</TT> на компьютере, на котором
используется CVS.  Другие методы доступа описаны в
section <A HREF="cvs-ru_2.html#SEC26">Сетевые репозитории</A>.


<P>
Если метод доступа не указан, и имя репозитория не содержит
<SAMP>`:'</SAMP>, то предполагается метод <CODE>:local:</CODE>.  Если в имени
содержится <SAMP>`:'</SAMP>, то предполагается метод доступа <CODE>:ext:</CODE> 
или <CODE>:server:</CODE>.  Например, если ваш локальный репозиторий
находится в <TT>`/usr/local/cvsroot'</TT>, то вы можете использовать
<CODE>/usr/local/cvsroot</CODE> вместо
<CODE>:local:/usr/local/cvsroot</CODE>.  Но если, например, под
Windows NT ваш локальный репозиторий находится в
<TT>`c:\src\cvsroot'</TT>, то вы должны указать метод доступа, то
есть <CODE>:local:c:\src\cvsroot</CODE>. 


<P>
Репозиторий делится на две части.  <TT>`$CVSROOT/CVSROOT'</TT>
содержит административные файлы CVS.  Все прочие каталоги
содержат модули, определенные пользователем.




<H2><A NAME="SEC10" HREF="cvs-ru_toc.html#TOC10">Как сообщить CVS, где находится репозиторий</A></H2>

<P>
Существует несколько способов сообщить CVS, где искать
репозиторий.  Вы можете явно задать репозиторий в командной
строке с помощью опции <CODE>-d</CODE> ("directory", каталог):



<PRE>
cvs -d /usr/local/cvsroot checkout yoyodyne/tc
</PRE>

<P>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
Другим вариантом является установка переменной окружения
<CODE>$CVSROOT</CODE> в полный путь до корня репозитория, например,
<TT>`/usr/local/cvsroot'</TT>.  Чтобы установить <CODE>$CVSROOT</CODE>,
пользователи <CODE>csh</CODE> и <CODE>tcsh</CODE> должны поместить в свой
файл <TT>`.cshrc'</TT> или <TT>`.tcshrc'</TT> такую строку:



<PRE>
setenv CVSROOT /usr/local/cvsroot
</PRE>

<P>
Пользователи <CODE>sh</CODE> и <CODE>bash</CODE> должны поместить в свой файл 
<TT>`.profile'</TT> или <TT>`.bashrc'</TT> такие строки



<PRE>
CVSROOT=/usr/local/cvsroot
export CVSROOT
</PRE>

<P>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
Имя репозитория, указанное с помощью <CODE>-d</CODE>, будет
использоваться вместо указанного в переменной окружения
<CODE>$CVSROOT</CODE>.  Когда вы извлечете рабочую копию из
репозитория, эта копия будет помнить, из какого именно
репозитория ее извлекли (эта информация хранится в файле
<TT>`CVS/Root'</TT> в рабочем каталоге).


<P>
Опция <CODE>-d</CODE> и файл <TT>`CVS/Root'</TT> переопределяют
репозиторий, заданный в переменной окружения <CODE>$CVSROOT</CODE>.
Если репозиторий, заданный опцией <CODE>-d</CODE>, отличается от
репозитория, указанного в файле <TT>`CVS/Root'</TT>, используется
первый из них.  Конечно же, для правильного функционирования
должно быть несколько способов обращаться к одному и тому же
репозиторию.




<H2><A NAME="SEC11" HREF="cvs-ru_toc.html#TOC11">Как данные хранятся в репозитории</A></H2>
<P>
<A NAME="IDX56"></A>


<P>
В большинстве случаев неважно, <EM>как</EM> именно CVS хранит
информацию в репозитории.  В действительности, формат уже менялся 
однажды и, скорее всего, изменится в будущем.  Так как в
большинстве случаев весь доступ к репозиторию происходит
посредством команд CVS, такие изменения не приводят к
каким-либо разрушениям.


<P>
Однако, в некоторых случаях необходимо точно знать, как CVS
хранит данные в репозитории, например, если вы хотите отследить
блокировки файлов, которые делает CVS (see section <A HREF="cvs-ru_10.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>) или вам потребуется изменить права доступа к файлам в
репозитории.




<H3><A NAME="SEC12" HREF="cvs-ru_toc.html#TOC12">Где хранятся файлы в репозитории</A></H3>

<P>
Общая структура репозитория -- это дерево каталогов,
соответствующее каталогам в рабочей копии.  Предположим,
например, что репозиторий находится в 



<PRE>
/usr/local/cvsroot
</PRE>

<P>
Вот возможное дерево каталогов (показаны только каталоги):



<PRE>
<TT>/usr</TT>
 |
 +--<TT>local</TT>
 |   |
 |   +--<TT>cvsroot</TT>
 |   |    |
 |   |    +--<TT>CVSROOT</TT>
          |      (административные файлы)
          |
          +--<TT>gnu</TT>
          |   |
          |   +--<TT>diff</TT>
          |   |   (исходный текст GNU diff)
          |   |
          |   +--<TT>rcs</TT>
          |   |   (исходный текст RCS)
          |   |
          |   +--<TT>cvs</TT>
          |       (исходный текст CVS)
          |
          +--<TT>yoyodyne</TT>
              |
              +--<TT>tc</TT>
              |    |
              |    +--<TT>man</TT>
              |    |
              |    +--<TT>testing</TT>
              |
              +--(другое программное обеспечение фирмы Yoyodyne)
</PRE>

<P>
Внутри каталогов находятся <EM>файлы истории</EM> для каждого файла, 
находящегося под контролем версий.  Имя файла истории -- это имя
соответствующего файла с добавленным в конце <SAMP>`,v'</SAMP>.  Вот как
выглядит дерево каталогов для <TT>`yoyodyne/tc'</TT>:



<PRE>
  <CODE>$CVSROOT</CODE>
    |
    +--<TT>yoyodyne</TT>
    |   |
    |   +--<TT>tc</TT>
    |   |   |
            +--<TT>Makefile,v</TT>
            +--<TT>backend.c,v</TT>
            +--<TT>driver.c,v</TT>
            +--<TT>frontend.c,v</TT>
            +--<TT>parser.c,v</TT>
            +--<TT>man</TT>
            |    |
            |    +--<TT>tc.1,v</TT>
            |
            +--<TT>testing</TT>
                 |
                 +--<TT>testpgm.t,v</TT>
                 +--<TT>test2.t,v</TT>
</PRE>

<P>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>


<P>
Файл истории содержит, помимо всего прочего, достаточно
информации, чтобы воссоздать любую редакцию файла, журнал всех
зафиксированных изменений и имена всех пользователей, сделавших
эти изменения.  Файлы истории известны как <EM>RCS-файлы</EM>,
потому что первой программой, которая создавала файлы этого
формата, была система контроля версий RCS.  Полное описание
формата файлов находится на странице руководства
<CITE>rcsfile(5)</CITE>, распространяемого вместе с RCS, или в
файле <TT>`doc/RCSFILES'</TT> в комплекте исходных текстов CVS.
Этот формат файла используется повсеместно -- множество других
программ могут по меньшей мере импортировать файлы этого формата.


<P>
Файлы RCS, используемые в CVS, отличаются от
стандартного формата в нескольких местах.  Наличие волшебных
веток -- Самое большое отличие; смотри section <A HREF="cvs-ru_5.html#SEC59">Волшебные номера веток</A>.  Имена меток, которые позволяет использовать CVS,
являются подмножеством тех, что позволены в RCS; смотри
главу section <A HREF="cvs-ru_4.html#SEC48">Метки ревизий</A>.




<H3><A NAME="SEC13" HREF="cvs-ru_toc.html#TOC13">Права доступа к файлам</A></H3>
<P>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
Все файлы <SAMP>`,v'</SAMP> создаются с правами только для чтения, и вам
не следует изменять права доступа к этим файлам.  Каталоги в
репозитории должны быть доступны для записи тем, кому разрешено
изменять файлы в каждом каталоге.  Это обычно означает, что вам
нужно создать группу UNIX (см. <CODE>group(5)</CODE>), состоящую из
лиц, участвующих в создании проекта, и настроить репозиторий так, 
чтобы эта группа владела каталогом с проектом.


<P>
Это означает, что ограничивать доступ к файлам можно только на
уровне каталога.


<P>
Заметьте, что пользователи также должны иметь права на запись для 
извлечения файлов, потому что CVS должна создавать файлы
блокировки (see section <A HREF="cvs-ru_10.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>).


<P>
Заметьте также, что пользователи должны иметь права на запись в
файл <TT>`CVSROOT/val-tags'</TT>.  CVS использует этот файл,
чтобы отслеживать, какие метки разрешены (этот файл иногда
обновляется, когда используются и когда создаются метки).


<P>
Каждый RCS-файл принадлежит пользователю, который последним
зафиксировал изменения в этот файл.  Этот факт не столь важен,
главное -- кто владеет каталогами.


<P>
<A NAME="IDX65"></A>
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>
<A NAME="IDX68"></A>
CVS пытается установить адекватные права доступа к файлам
для новых каталогов, которые создаются в дереве, но если вам
требуется, чтобы новый каталог имел права доступа, отличающиеся
от его родительского каталога, вы должны задать это вручную.
Если вы установите переменную окружения <CODE>CVSUMASK</CODE>, то она
будет задавать, какие права доступа к файлам CVS использует
при создании каталогов и/или файлов в репозитории.
<CODE>CVSUMASK</CODE> не влияет на права доступа к файлам в рабочем
каталоге; такие файлы имеют права, обычные для новых файлов,
разве что только иногда CVS создает их с правами только для
чтения (смотри главу о слежении, section <A HREF="cvs-ru_13.html#SEC103">Слежение за чужими исходными текстами</A>; <CODE>-r</CODE>, section <A HREF="cvs-ru_16.html#SEC116">Глобальные ключи командной строки</A>; или <CODE>CVSREAD</CODE>,
section <A HREF="cvs-ru_19.html#SEC175">Все переменные окружения, используемые в CVS</A>).


<P>
Заметьте, что при использовании клиент-серверного CVS
(see section <A HREF="cvs-ru_2.html#SEC26">Сетевые репозитории</A>) не существует нормального способа
установить <CODE>CVSUMASK</CODE>; установка его на клиентской машине не 
играет роли.  Если вы соединяетесь с помощью <CODE>rsh</CODE>, вы
можете установить <CODE>CVSUMASK</CODE> в файле <TT>`.bashrc'</TT> или
<TT>`.cshrc'</TT>, как описано в документации на вашу операционную
систему.  Это поведение может измениться в будущей версии
CVS; не полагайтесь на то, что установка <CODE>CVSUMASK</CODE> на
клиентской машине не играет роли.


<P>
При использовании pserver обычно требуются гораздо более жесткие
права доступа к каталогу CVSROOT и каталогам, находящимся в
<CODE>CVSROOT</CODE>; see section <A HREF="cvs-ru_2.html#SEC30">Настройка сервера для парольной аутентификации</A>.


<P>
<A NAME="IDX69"></A>
<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
Некоторые операционные системы позволяют определенным программам
выполнять операции, которые не может выполнять тот, кто вызывает
эти программы.  Например, возможности setuid или setgid в UNIX
или установленные образы в VMS.  CVS не разрабатывался,
чтобы использовать такие возможности, и поэтому попытки
установить CVS таким образом обеспечат защиту только лишь от
случайных ошибок; те, кто желает обойти защиту, смогут это
сделать и, в зависимости от конкретных условий, смогут получить
доступ еще куда-либо помимо CVS.  Вы можете попробовать
использовать pserver.  Эта возможность также способна дать ложное
чувство безопасности или открыть дыру, больше чем та, которую вы
пытаетесь закрыть, поэтому внимательно прочтите документацию на
безопасность pserver, если вы собираетесь его использовать
(section <A HREF="cvs-ru_2.html#SEC30">Настройка сервера для парольной аутентификации</A>).




<H3><A NAME="SEC14" HREF="cvs-ru_toc.html#TOC14">Специфические для Windows права доступа</A></H3>
<P>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>


<P>
Некоторые вопросы, связанные с правами доступа, специфичны для
операционных систем класса Window (Windows 95/98, Windows NT и,
скорее всего, будущие подобные операционные системы.  Часть
нижесказанного может быть применима к OS/2, хотя я не уверен).




<H3><A NAME="SEC15" HREF="cvs-ru_toc.html#TOC15">Чердак</A></H3>
<P>
<A NAME="IDX75"></A>
<A NAME="IDX76"></A>


<P>
Вы заметите, что иногда CVS помещает RCS-файлы в
каталоге <CODE>Attic</CODE> ("чердак").  Например, если CVSROOT -- это
<TT>`/usr/local/cvsroot'</TT>, и мы говорим о файле <TT>`backend.c'</TT>
в каталоге <TT>`yoyodyne/tc'</TT>, то обычно этот файл находится в 



<PRE>
/usr/local/cvsroot/yoyodyne/tc/backend.c,v
</PRE>

<P>
Если же он попадает на чердак, то он будет находиться в 



<PRE>
/usr/local/cvsroot/yoyodyne/tc/Attic/backend.c,v
</PRE>

<P>
<A NAME="IDX77"></A>
<A NAME="IDX78"></A>
С точки зрения пользователя неважно, находится файл на чердаке
или нет, так как CVS сам следит за этим и при необходимости
заглядывает на чердак в поисках файла.  В случае же, если вы
хотите знать точно, то RCS-файл хранится на чердаке тогда и
только тогда, когда головная ревизия ствола находится в состоянии
<CODE>dead</CODE> ("мертвое").  "Мертвое" состояние означает, что файл
был удален или же никогда не добавлялся в эту ветку.  Например,
если вы добавите файл в ветку, то его стволовая ревизия будет в
"мертвом" состоянии, а ревизия на ветке -- нет.




<H3><A NAME="SEC16" HREF="cvs-ru_toc.html#TOC16">Каталог CVS в репозитории</A></H3>
<P>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>


<P>
Каталог <TT>`CVS'</TT> в каждом репозитории содержит информацию об
атрибутах файлов (в файле <TT>`CVS/fileattr'</TT>); смотри
<TT>`fileattr.h'</TT> среди исходных текстов CVS за дополнительной
информацией.  В будущем в этом каталоге могут оказать другие
дополнительные файлы, поэтому сегодняшние реализации должны
игнорировать неизвестные файлы.


<P>
Это поведение реализовано только в версиях CVS 1.7 и выше,
смотри section <A HREF="cvs-ru_10.html#SEC93">Использование слежений со старыми версиями CVS</A>.




<H3><A NAME="SEC17" HREF="cvs-ru_toc.html#TOC17">Блокировки в репозитории</A></H3>

<P>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>
Видимое пользователем поведение блокировок CVS описано в
section <A HREF="cvs-ru_10.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>.  Эта глава ориентирована на людей,
пишущих утилиты, обращающиеся к репозиторию CVS, не конфликтуя
при этом с другими программами, обращающимися к тому же
репозиторию.  Если вы запутаетесь в описываемых здесь концепциях, 
как то <EM>блокировка чтения</EM>, <EM>блокировка записи</EM> и
<EM>мертвая блокировка</EM>, то обратитесь к литературе по
операционным системам или базам данных.


<P>
<A NAME="IDX87"></A>
Файлы в репозитории, чьи имена начинаются с <TT>`#cvs.rfl'</TT> ---
это блокировки чтения.  Файл, чьи имена начинаются с
<TT>`#cvs.wfl'</TT> -- это блокировки записи.  Старые версии
CVS (перед CVS 1.5) создавали также файлы с именами,
начинающимися с <TT>`#cvs.tfl'</TT>, но такие файлы здесь не
обсуждаются.  Каталог <TT>`#cvs.lock'</TT> служит главной
блокировкой, то есть перед тем, как создавать какую-либо еще
блокировку, сначала необходимо создать главную блокировку.


<P>
Чтобы создать блокировку чтения, сначала создайте каталог
<TT>`#cvs.lock'</TT>.  В большинстве операционных систем операция
создания каталога атомарна.  Если попытка создания провалилась,
значит, главная блокировка уже существует, поэтому подождите
немного и попробуйте еще.  После получения блокировки
<TT>`#cvs.lock'</TT> создайте файл, чье имя состоит из
<TT>`#cvs.rfl'</TT>, и информацией по вашему выбору, например, имя
машины и номер процесса.  Потом удалите каталог <TT>`#cvs.lock'</TT>, 
чтобы отменить главную блокировку.  Теперь вы можете читать
репозиторий.  Когда чтение окончено, удалите файл
<TT>`#cvs.rfl'</TT>, чтобы отменить блокировку чтения. 


<P>
Чтобы получить блокировку записи, сначала создайте каталог
<TT>`#cvs.lock'</TT>, как и в случае с блокировкой чтения.  Затем
убедитесь, что в репозитории нет файлов, чьи имена начинаются с
<TT>`#cvs.rfl'</TT>.  Если они имеются, удалите <TT>`#cvs.lock'</TT>,
подождите немного и попробуйте снова.  Если блокировок чтения
нет, создайте файл с именем, состоящим из <TT>`#cvs.wfl'</TT> и
какой-нибудь информации по вашему выбору, например, имени машины
и номера процесса.  Не удаляйте блокировку <TT>`#cvs.lock'</TT>.
Теперь вы можете писать в репозиторий.  Когда запись окончена,
сначала удалите файл <TT>`#cvs.wfl'</TT>, а затем каталог
<TT>`#cvs.lock'</TT>.  Заметьте, что в отличие от файла
<TT>`#cvs.rfl'</TT>, файл <TT>`#cvs.wfl'</TT> имеет чисто информационное
значение; он не оказывает блокирующего эффекта, который в данном
случае достигается использованием главной блокировки
(<TT>`#cvs.lock'</TT>).


<P>
Заметьте, что каждая блокировка (чтения или записи) блокирует
единственный каталог в репозитории, включая <TT>`Attic'</TT> и
<TT>`CVS'</TT>, но не включая подкаталоги, которые представляют собой 
другие каталоги, находящиеся под контролем версий.  Чтобы
заблокировать целое дерево, вам следует заблокировать каждый
каталог (заметьте, что если вы не сможете получить хотя бы одну
блокировку в этом процессе, то следует отменить все уже
полученные блокировки, затем подождать и попробовать снова, во
избежание мертвых блокировок.)


<P>
Заметьте также, что CVS ожидает, что доступ к отдельным
файлам <TT>`foo,v'</TT> контролируется блокировками записи.
RCS использует в качестве блокировок файлы <TT>`,foo,'</TT>, но 
CVS не поддерживает такую схему, поэтому рекомендуется
использование блокировки записи.  Смотри комментарии к
<CODE>rcs_internal_lockfile</CODE> в исходном коде CVS, где
находится дополнительное обсуждение и мотивация.




<H3><A NAME="SEC18" HREF="cvs-ru_toc.html#TOC18">Как в каталоге CVSROOT хранятся файлы</A></H3>
<P>
<A NAME="IDX88"></A>


<P>
Каталог <TT>`$CVSROOT/CVSROOT'</TT> содержит различные
административные файлы.  В каком-то смысле этот каталог подобен
любому другому каталогу в репозитории; он содержит
RCS-файлы, чьи имена заканчиваются на <SAMP>`,v'</SAMP>, и многие
команды CVS оперируют с ними обычным образом.  Однако,
имеется несколько различий.


<P>
Для каждого административного файла, в дополнение к
RCS-файлу, хранится его последняя ревизия.  Например, есть
RCS-файл <TT>`loginfo,v'</TT> и файл <TT>`loginfo'</TT>, содержащий
последнюю ревизию, находящуюся в <TT>`loginfo,v'</TT>.  Когда вы
фиксируете административный файл, CVS должен написать:



<PRE>
cvs commit: Rebuilding administrative file database
</PRE>

<P>
<A NAME="IDX89"></A>
<A NAME="IDX90"></A>
и обновить его извлеченную копию в <TT>`$CVSROOT/CVSROOT'</TT>.  Если
это не так, значит, что-то случилось с CVS (see section <A HREF="cvs-ru_23.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>).  Чтобы ваши CVS обращался с вашими собственными
файлами точно так же, вы можете добавить их имена в
административный файл <TT>`checkoutlist'</TT>.


<P>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
По умолчанию, файл <TT>`modules'</TT> ведет себя как описано
выше.  Если же он становится очень большим, то хранение в виде
плоского файла может привести к медленному поиску модулей (я не
уверен, что это все еще столь же важно, как и тогда, когда эта
возможность впервые появилась; я не видел расчетов
быстродействия).  Таким образом, внеся определенные изменения в
исходный код CVS, можно хранить файл модулей в базе данных,
которая имеет интерфейс с <CODE>ndbm</CODE>, например, Berkeley db или
GDBM.  Если эта опция используется, то база данных модулей
будет храниться в файлах <TT>`modules.db'</TT>, <TT>`modules.pag'</TT>
и/или <TT>`modules.dir'</TT>.


<P>
Информация о назначении разнообразных административных файлов
находится в section <A HREF="cvs-ru_18.html#SEC153">Справочник по административным файлам</A>.




<H2><A NAME="SEC19" HREF="cvs-ru_toc.html#TOC19">Как данные хранятся в рабочем каталоге</A></H2>

<P>
<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
Пока мы описываем внутреннюю работу CVS, которая иногда
становится видна, мы можем также поговорить о том, что CVS
хранит в каталогах <TT>`CVS'</TT> в рабочих каталогах.  Как и в
случае с репозиторием, CVS обрабатывает эту информацию, и
обычно вы обращаетесь к ней посредством команд CVS.  В
некоторых случаях, однако, бывает полезно напрямую работать с
содержимым этих каталогов, например, в графической оболочке
<CODE>jCVS</CODE> или пакете <CODE>VC</CODE> для emacs.  Такие программы
должны следовать рекомендациям в этой главе, если они желают
нормально работать совместно с другими программами, использующими 
те же самые файлы, включая будущие их версии, а также с CVS, 
работающим из командной строки.


<P>
Каталог <TT>`CVS'</TT> содержит несколько файлов.  Программы,
читающие этот каталог, должны игнорировать файлы, находящиеся в
этом каталоге, но не документированные здесь, чтобы дать
возможность развития в будущем.


<P>
Файлы хранятся в текстовом формате, соответствующем соглашениям
операционной системы.  Это означает, что рабочие каталоги не
переносимы между системами с разными форматами хранения текстовых 
файлов.  Это сделано специально, исходя из того, что сами файлы,
находящиеся под управлением CVS, вероятно, также не
переносимы между такими платформами.


<DL COMPACT>

<DT><TT>`Root'</TT>
<DD>
Этот файл содержит текущий корневой каталог CVS, как описано
в section <A HREF="cvs-ru_2.html#SEC10">Как сообщить CVS, где находится репозиторий</A>.

<A NAME="IDX97"></A>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<DT><TT>`Repository'</TT>
<DD>
Этот файл содержит каталог в репозитории, которому соответствует
текущий каталог.  Здесь может быть имя с полным или относительным 
путем; CVS способна обрабатывать оба варианта, начиная с
версии 1.3.  Относительный путь отсчитывается от корня, хотя
использование абсолютного пути довольно распространено и
программы должны уметь обрабатывать оба варианта.  Например,
после команды


<PRE>
cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc
</PRE>

<TT>`Root'</TT> будет содержать


<PRE>
:local:/usr/local/cvsroot
</PRE>

а <TT>`Repository'</TT> будет содержать или


<PRE>
/usr/local/cvsroot/yoyodyne/tc
</PRE>

или


<PRE>
yoyodyne/tc
</PRE>

Если рабочий каталог не имеет соответствующего каталога в
репозитории, то <TT>`Repository'</TT> должен содержать
<TT>`CVSROOT/Emptydir'</TT>. 

<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
<A NAME="IDX102"></A>
<DT><TT>`Entries'</TT>
<DD>
В этом файле перечислены файлы и каталоги в рабочем каталоге.

Первый символ каждой строки указывает тип каждой строки.  Если
символ нераспознан, программа, читающая файл, должна спокойно
пропустить эту строку, чтобы дать возможность развития в
будущем. 

Если первый символ -- это <SAMP>`/'</SAMP>, то формат строки таков
If the first character is <SAMP>`/'</SAMP>, then the format is:


<PRE>
/<VAR>имя</VAR>/<VAR>ревизия</VAR>/<VAR>метка времени</VAR>[+<VAR>конфликт</VAR>]/<VAR>опции</VAR>/<VAR>тэг или дата</VAR>
</PRE>

где <SAMP>`['</SAMP> и <SAMP>`]'</SAMP> не являются частью строки, но указывают,
что <SAMP>`+'</SAMP> и отметка о конфликте не обязательны.  <VAR>name</VAR>
--- это имя файла в каталоге.  <VAR>ревизия</VAR> -- это номер
ревизии, на которой основан файл в рабочем каталоге, или <SAMP>`0'</SAMP>
для добавленного файла, или <SAMP>`-'</SAMP>, за которым следует номер
ревизии, для удаленного файла.  <VAR>метка времени</VAR> -- это время,
когда CVS создала этот файл; если это время отличается от
текущего времени модификации файла, значит, он был изменен.
Метка времени записывается в UTC (по гринвичу), в формате,
используемом функцией стандарта ISO C <CODE>asctime()</CODE> (например,
<SAMP>`Sun Apr 7 01:29:26 1996'</SAMP>).  Можно написать также строку в
другом формате, например, <SAMP>`Result of merge'</SAMP>, чтобы указать,
что файл всегда должен считаться измененным.  Эта строка -- вовсе
не специальный случай: чтобы узнать, изменился ли файл, CVS
берет дату модификации файла и просто сравнивает строку со
строкой <VAR>метка времени</VAR>. <VAR>конфликт</VAR> указывает, что
произошел конфликт.  Если эта строка совпадает с действительным
временем модификации, значит, пользователь еще не справился с
конфликтом.  <VAR>опции</VAR> содержат прилипшие ключи командной
строки (например, <SAMP>`-kb'</SAMP> для двоичных файлов).  <VAR>тэг или
дата</VAR> содержит либо <SAMP>`T'</SAMP>, за которой следует имя тэга, либо
<SAMP>`D'</SAMP>, за которой следует прилипший тэг или дата.  Заметьте,
что если <VAR>метка времени</VAR> содержит пару меток времени,
разделенных пробелом, а не единственную метку времени, значит, вы
имеете дело с версией CVS ранее 1.5 (этот случай здесь не
документирован).

Если первый символ в строке в файле <TT>`Entries'</TT> -- это
<SAMP>`D'</SAMP>, это означает подкаталог.  <SAMP>`D'</SAMP> на отдельной строке
указывает, что программа, которая создала файл <TT>`Entries'</TT>,
умеет обращаться с подкаталогами (то есть, если такая строка
присутствует, и нет других строк, начинающихся с <SAMP>`D'</SAMP>,
значит, подкаталогов нет).  В противном случае строка выглядит
так:


<PRE>
D/<VAR>имя</VAR>/<VAR>заполнитель1</VAR>/<VAR>заполнитель2</VAR>/<VAR>заполнитель3</VAR>/<VAR>заполнитель4</VAR>
</PRE>

где <VAR>имя</VAR> -- это имя подкаталога, а все поля
<VAR>заполнитель</VAR> должны игнорироваться, в целях будущих
расширений.  Программы, изменяющие файлы <TT>`Entries'</TT>, должны
сохранять значения этих полей.

Строки в файле <TT>`Entries'</TT> могут быть в любом порядке. 

<A NAME="IDX103"></A>
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
<DT><TT>`Entries.Log'</TT>
<DD>
В этом файле хранится та же самая информация, что и в файле
<TT>`Entries'</TT>, и с его помощью можно обновлять эту информацию
без необходимости полностью переписывать файл <TT>`Entries'</TT>,
включая возможность сохранять информацию, даже если программа,
писавшая в <TT>`Entries'</TT> и <TT>`Entries.Log'</TT> аварийно
завершилась.  Программы, читающие файл <TT>`Entries'</TT> должны
также проверять существование файла <TT>`Entries.Log'</TT>.  Если
последний существует, то они должны прочесть файл <TT>`Entries'</TT>
и внести в него изменения из файла <TT>`Entries.Log'</TT>, после чего 
рекуомендуется записать заново файл <TT>`Entries'</TT> и удалить файл 
<TT>`Entries.Log'</TT>. Формат строки файла <TT>`Entries.Log'</TT> ---
односимвольная команда, за которой следует строка, в формате
<TT>`Entries'</TT>.  Команда -- это либо <SAMP>`A'</SAMP> для указания, что
строка добавляется, либо <SAMP>`R'</SAMP> -- если строка удаляется, или
любой другой символ -- если эту строку следует проигнорировать
(для будущих расширений).  Если второй символ строки в файле
<TT>`Entries.Log'</TT> -- не пробел, значит, файл был создан старой
версией CVS (здесь не документируется).

Программы, которые пишут, но не читают, могут спокойно
игнорировать <TT>`Entries.Log'</TT>.

<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<DT><TT>`Entries.Backup'</TT>
<DD>
Это временный файл.  Рекомендованное использование -- записать
новый файл <TT>`Entries'</TT> в <TT>`Entries.Backup'</TT>, затем
переименовать его (атомарно, если возможно) в <TT>`Entries'</TT>.

<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<A NAME="IDX111"></A>
<DT><TT>`Entries.Static'</TT>
<DD>
Единственная вещь, интересующая нас об этом файле -- существует
он или нет.  Если существует, это значит, что была получена
только часть каталога и CVS не будет создавать в нем
дополнительных файлов.  Чтобы очистить этот файл, используйте
команду <CODE>update</CODE> с опцией <SAMP>`-d'</SAMP>, чтобы получить
дополнительные файлы и удалить <TT>`Entries.Static'</TT>.

<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<DT><TT>`Tag'</TT>
<DD>
В этом файле находятся прилипшие тэги и даты для этого каталога.
Первый символ -- <SAMP>`T'</SAMP> для тэга ветки, <SAMP>`N'</SAMP> для обычного
тэга или <SAMP>`D'</SAMP> для даты.  Другие символы должны
игнорироваться, для будущих расширений.  За этим символом следует
тэг илидата.  Заметьте, что прилипшие тэги и даты применяются к
добавляемым файлам; они могут отличаться от тэгов и дат,
прилипших к отдельным файлам.  Общая информация о прилипших тэгах 
и датах находится в section <A HREF="cvs-ru_4.html#SEC53">Липкие метки</A>.

<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<DT><TT>`Checkin.prog'</TT>
<DD>
<DT><TT>`Update.prog'</TT>
<DD>
В этих файлах хранятся имена программ, заданных опциями <SAMP>`-i'</SAMP> 
и <SAMP>`-u'</SAMP> в файле <TT>`modules'</TT>, соответственно.

<A NAME="IDX125"></A>
<A NAME="IDX126"></A>
<A NAME="IDX127"></A>
<DT><TT>`Notify'</TT>
<DD>
В этом файле хранятся уведомления (например, для <CODE>edit</CODE> или
<CODE>unedit</CODE>), которые еще не было отосланы на сервер.  Их
формат еще не документирован здесь.

<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<DT><TT>`Notify.tmp'</TT>
<DD>
Этот файл по отношению к файлу <TT>`Notify'</TT> является тем же, что 
<TT>`Entries.Backup'</TT> по отношению к <TT>`Entries'</TT>.  Чтобы
создать файл <TT>`Notify'</TT>, сначала запишите его новое содержимое 
в <TT>`Notify.tmp'</TT>, затем (атомарно, если возможно),
переименуйте его в <TT>`Notify'</TT>.

<A NAME="IDX131"></A>
<A NAME="IDX132"></A>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<DT><TT>`Base'</TT>
<DD>
Если используются слежения, то команда <CODE>edit</CODE> сохраняет
исходную копию файла в каталоге <TT>`Base'</TT>.  Это позволяет
команде <CODE>unedit</CODE> работать, даже если нет доступа к серверу.

<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<A NAME="IDX137"></A>
<DT><TT>`Baserev'</TT>
<DD>
В этом файле перечислены ревизии каждого файла в каталоге
<TT>`Base'</TT>.  Формат таков:


<PRE>
B<VAR>имя</VAR>/<VAR>ревизия</VAR>/<VAR>расширение</VAR>
</PRE>

поле <VAR>расширение</VAR> должно быть проигнорировано, для
будущих расширений.

<A NAME="IDX138"></A>
<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<DT><TT>`Baserev.tmp'</TT>
<DD>
Этот файл по отношению к <TT>`Baserev'</TT> является тем же, чем
<TT>`Entries.Backup'</TT> по отношению к <TT>`Entries'</TT>.  Чтобы
создать записать файл <TT>`Baserev'</TT>, сначала запишите его новое
содержимое в <TT>`Baserev.tmp'</TT>, затем (атомарно, если возможно), 
переименуйте его в <TT>`Baserev'</TT>.

<A NAME="IDX141"></A>
<A NAME="IDX142"></A>
<A NAME="IDX143"></A>
<DT><TT>`Template'</TT>
<DD>
Этот файл содержит шаблон, заданный файлом <TT>`rcsinfo'</TT>
(see section <A HREF="cvs-ru_18.html#SEC170">Файл rcsinfo</A>).  Он используется только клиентом;
не-клиент-серверные варианты CVS напрямую обращаются к
<TT>`rcsinfo'</TT>.
</DL>



<H2><A NAME="SEC20" HREF="cvs-ru_toc.html#TOC20">Административные файлы</A></H2>
<P>
<A NAME="IDX144"></A>
<A NAME="IDX145"></A>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>


<P>
Каталог <TT>`$CVSROOT/CVSROOT'</TT> содержит несколько
<EM>административных файлов</EM>.  Полное их описание в
See section <A HREF="cvs-ru_18.html#SEC153">Справочник по административным файлам</A>.  Можно использовать CVS и без этих
файлов, но некоторые команды лучше работают, если хотя бы файл
<TT>`modules'</TT> должным образом настроен.  В сущности, этот файл
является наиболее важным, в нем описываются все модули в
репозитории.  Вот пример этого файла:



<PRE>
CVSROOT         CVSROOT
modules         CVSROOT modules
cvs             gnu/cvs
rcs             gnu/rcs
diff            gnu/diff
tc              yoyodyne/tc
</PRE>

<P>
Файл <TT>`modules'</TT> представляет собой текстовый файл.  В
простейшем случае каждая строка содержит имя модуля, пробел и имя 
каталога, где находится этот модуль, относительно
<CODE>$CVSROOT</CODE>.


<P>
Строка, которая определяет модуль <SAMP>`modules'</SAMP>, использует
возможности, здесь не описанные.  Полное описание всех доступных
возможностей находится в See section <A HREF="cvs-ru_18.html#SEC154">Файл <TT>`modules'</TT></A>.




<H3><A NAME="SEC21" HREF="cvs-ru_toc.html#TOC21">Редактирование административных файлов</A></H3>
<P>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>


<P>
Административные файлы можно редактировать точно так же, как и
любой другой модуль.  Используйте <SAMP>`cvs checkout CVSROOT'</SAMP>,
чтобы получить рабочий каталог, редактируйте его и зафиксируйте
изменения обычным образом.


<P>
Случается, что фиксируется административный файл с ошибкой.
Обычно можно исправить ошибку и зафиксировать новую версию, но
иногда особенно серьезная ошибка может привести к невозможности
фиксирования изменений.




<H2><A NAME="SEC22" HREF="cvs-ru_toc.html#TOC22">Несколько репозиториев</A></H2>
<P>
<A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>


<P>
Иногда необходимо иметь много репозиториев, например, если у вас
есть две группы разработчиков, работающих над разными проектами,
у которых нет общего кода.  Все, что вам требуется, чтобы
работать с несколькими репозиториями -- указать необходимый,
используя переменную среды <CODE>CVSROOT</CODE>, опцию CVS
<SAMP>`-d'</SAMP> или (если у вас уже есть рабочий каталог) просто
работая по умолчанию с тем репозиторием, из которого был извлечен
рабочий каталог (see section <A HREF="cvs-ru_2.html#SEC10">Как сообщить CVS, где находится репозиторий</A>.


<P>
Серьезным преимуществом нескольких репозиториев является то, что
они могут находиться на различных серверах.  При использовании
CVS 1.10 единственная команда может работать с каталогами из 
разных репозиториев.  С помощью разрабатываемых версий CVS
можно извлекать исходные тексты с нескольких серверов.  CVS
сам разберется с обходом дерева каталогов и соединениями с
разными серверами при необходимости.  Вот пример создания
рабочего каталога:



<PRE>
cvs -d server1:/cvs co dir1
cd dir1
cvs -d server2:/root co sdir
cvs update
</PRE>

<P>
Команды <CODE>cvs co</CODE> создают рабочий каталог, а команда
<CODE>cvs update</CODE> соединится с <CODE>server2</CODE>, чтобы обновить
каталог <TT>`dir1/sdir'</TT>, и с <CODE>server1</CODE>, чтобы обновить все
остальное.




<H2><A NAME="SEC23" HREF="cvs-ru_toc.html#TOC23">Создание репозитория</A></H2>

<P>
<A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>


<P>
Чтобы настроить CVS-репозиторий, сначала выберите машину и
диск, на котором будет храниться история ревизий исходных
текстов.  Требования к процессору и памяти умеренны, поэтому
подойдет практически любая машина.  Детали описаны в
section <A HREF="cvs-ru_2.html#SEC27">Требования к серверу</A>.


<P>
Если вы импортируете RCS-файлы из другой системы, начальное
дисковое пространство можно оценить как суммарный размер этих
файлов.  В дальнейшем можно рассчитывать на троекратный размер
исходных текстов, которые вы будете хранить под контролем
версий (когда-нибудь вы перерастете этот предел, но не слишком
скоро).  На машинах разработчики требуется дисковое пространство
для рабочего каталога каждого разработчика (все дерево или его
кусок, в зависимости от того, над чем работает программист).


<P>
К репозиторию должен быть доступ (прямой или с помощью сетевой
файловой системы) со всех машин, которые будут использовать
CVS в серверном или локальном режиме; клиентские машины не
требуют никакого доступа к репозиторию кроме протокола CVS.
Использование CVS для доступа только для чтения все равно
требует прав на запись в репозиторий для создания файлов
блокировок (see section <A HREF="cvs-ru_10.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>).


<P>
<A NAME="IDX160"></A>
Чтобы создать репозиторий, выполните команду <CODE>cvs init</CODE>.
Она создаст пустой репозиторий в корневом каталоге CVS,
заданном обычным образом (see section <A HREF="cvs-ru_2.html#SEC9">Репозиторий</A>).  Например,



<PRE>
cvs -d /usr/local/cvsroot init
</PRE>

<P>
<CODE>cvs init</CODE> следит, чтобы не перезаписать уже существующие
файлы, поэтому никакого вреда от запуска <CODE>cvs init</CODE> по уже
настроенному репозиторию не произойдет.


<P>
<CODE>cvs init</CODE> включит журналирование истории; если вы не хотите
этого, удалите файл истории после выполнения <CODE>cvs init</CODE>.
See section <A HREF="cvs-ru_18.html#SEC172">Файл history</A>.




<H2><A NAME="SEC24" HREF="cvs-ru_toc.html#TOC24">Резервное копирование репозитория</A></H2>
<P>
<A NAME="IDX161"></A>
<A NAME="IDX162"></A>


<P>
Файлы в репозитории, в сущности, не обладают никакими особыми
свойствами, в большинстве случаев можно делать их резервные копии 
как обычно.  Есть, однако, несколько аспектов, которые необходимо 
учитывать.


<P>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>
Во-первых, с параноидальной точки зрения, следует либо не
использовать CVS во время резервного копирования, либо
сделать так, чтобы программа резервного копирования блокировала
репозиторий в процессе.  Чтобы не использовать CVS, вы
можете запретить логины на машины, которые могут иметь доступ к
репозиторию, отключить CVS-сервер или сделать что-либо
подобное.  Детали зависят от вашей операционной системы и от
настройки CVS.  Чтобы заблокировать CVS, создайте файлы 
блокировок (<TT>`#cvs.rfl'</TT>) в каждом каталоге репозитория.
См. section <A HREF="cvs-ru_10.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A> за дополнительной информацией о
блокировках CVS.  Даже учитывая вышесказанное, если вы
просто скопируете файлы, ничего особенно страшного не
произойдет.  Однако, при восстановлении из резервной копии
репозиторий может находиться в неустойчивом состоянии, что,
впрочем, нетрудно исправить вручную.


<P>
Когда вы восстанавливаете репозиторий из резервной копии,
предполагая, что репозиторий изменился с момента последнего
резервного копирования, рабочие каталоги, которые не пострадали,
могут ссылаться на ревизии, не существующие более в репозитории.
Попытка выполнения CVS в таких каталогах приведет к
сообщению об ошибке.  Один из способов вернуть все изменения в
репозиторий таков:



<UL>
<LI>

Получите новый рабочий каталог.

<LI>

Скопируйте файлы из рабочего каталога, сделанного перед аварией,
поверх файлов в новом рабочем каталоге (не копируйте содержимое
каталогов <TT>`CVS'</TT>). 

<LI>

Работая в новом рабочем каталоге, используйте команды типа
<CODE>cvs update</CODE> и <CODE>cvs diff</CODE>, чтобы выяснить, что
изменилось, а затем зафиксируйте изменения в репозиторий.
</UL>



<H2><A NAME="SEC25" HREF="cvs-ru_toc.html#TOC25">Перемещение репозитория</A></H2>
<P>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>


<P>
Точно так же, как и в случае с резервным копированием файлов,
перемещение репозитория с места на место сводится к перемещению
набора файлов.


<P>
Основная вещь, которую нужно учитывать -- это то, что рабочие
каталоги ссылаются на репозиторий.  Самый простой способ
справиться с этим -- получить свежий рабочий каталог после
перемещения.  Конечно, вам следует сначала убедиться, что старый
рабочий каталог был зафиксирован перед перемещением, или вы
уверены, что не потеряете своих изменений.  Если вы действительно
хотите использовать уже существующий рабочий каталог, то это
возможно с помощью хирургического вмешательства в файлы
<TT>`CVS/Repository'</TT>.  Смотрите section <A HREF="cvs-ru_2.html#SEC19">Как данные хранятся в рабочем каталоге</A> за дополнительной информацией о файлах
<TT>`CVS/Repository'</TT> и <TT>`CVS/Root'</TT>, но если вы не уверены,
то, наверное, лучше не пытаться.




<H2><A NAME="SEC26" HREF="cvs-ru_toc.html#TOC26">Сетевые репозитории</A></H2>
<P>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>
<A NAME="IDX172"></A>


<P>
Рабочая копия исходных текстов и репозиторий могут быть на разных
машинах.  Использование CVS таким образом известно как режим
<EM>клиент/сервер</EM>.  Вы выполняете CVS-<EM>клиент</EM> на
машине, на которой смонтирован ваш рабочий каталог, и говорите
ему общаться с машиной, на которой смонтирован репозиторий, с
CVS-<EM>сервером</EM>.  Вообще использование сетевого
репозитория похоже на использование локального, только формат
имени репозитория таков:



<PRE>
:<VAR>метод</VAR>:<VAR>пользователь</VAR>@<VAR>машина:/путь/к/репозиторию</VAR>
</PRE>

<P>
Детали зависят от того, как вы соединяетесь с сервером.


<P>
Если <VAR>метод</VAR> не указан, а имя репозитория содержит <SAMP>`:'</SAMP>,
то метод по умолчанию -- <CODE>ext</CODE> или <CODE>server</CODE>, в
зависимости от платформы; оба метода описаны в section <A HREF="cvs-ru_2.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>.




<H3><A NAME="SEC27" HREF="cvs-ru_toc.html#TOC27">Требования к серверу</A></H3>

<P>
Простой ответ: требования к серверу умеренны -- если дерево
каталогов не очень большое, и активность не слишком высока, то
подойдет машина с 32Mb памяти или даже меньше.


<P>
В реальной жизни, конечно, все сложнее.  Оценка пикового
использования памяти достаточна, чтобы оценить общие требования.
Здесь документированы две такие области максимального потребления
памяти; все остальные по сравнению с ними незначительны (если вы
обнаружите, что это не так, дайте нам знать, как описано в
section <A HREF="cvs-ru_23.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>, чтобы мы обновили документацию.


<P>
Первая область большого потребления памяти -- извлечения больших
рабочих каталогов.  Сервер состоит из двух процессов на каждого
обслуживаемого клиента.  Потребление памяти дочерним процессом
должно быть невелико.  Родительский процесс же, особенно когда
сетевые соединения медленны, может вырасти до размеров, чуть
больших размера исходных тестов, или до двух мегабайт, смотря что 
больше.


<P>
Умножая размер каждого CVS-сервера на количество клиентов,
которые вы ожидаете одновременно, вы оцените требуемый размер
памяти у сервера.  По большей части память, потребляемая
родительским процессом, будет находиться в файле подкачки, а не в 
физической памяти.


<P>
Вторая область большого потребления памяти -- <CODE>diff</CODE> при
фиксировании изменений в больших файлах.  Это требуется даже для
бинарных файлов.  Можно предусмотреть использование примерно
десятикратного размера самого большого файла, который только
будет фиксироваться, хотя пятикратный размер будет вполне
адекватен.  Например, если вы хотите фиксировать файл размером в
десять мегабайт, то в машине, на которой выполняется фиксирование
(сервер или локальная машина, на которой находится репозиторий),
должно быть сто мегабайт.  Скорее всего, это будет файл подкачки, 
а не физическая память.  Так как эта память требуется на
непродолжительное время, то особенной нужды выделять память под
несколько одновременных фиксирований нет.


<P>
Потребление ресурсов для клиентской машины еще более умеренны -- 
любая машина, способная выполнять соответствующую операционную
систему, будет пригодна.


<P>
Информация о требованиях к дисковому пространству находится в
section <A HREF="cvs-ru_2.html#SEC23">Создание репозитория</A>.




<H3><A NAME="SEC28" HREF="cvs-ru_toc.html#TOC28">Соединение с помощью <CODE>rsh</CODE></A></H3>

<P>
<A NAME="IDX173"></A>
CVS использует протокол <CODE>rsh</CODE> для работы с сетевым
репозиторием, поэтому на сетевой машине должен быть создан файл
<TT>`.rhosts'</TT>, позволяющий доступ данному пользователю.


<P>
Например, предположим, что вы пользователь <SAMP>`mozart'</SAMP> на
локальной машине <SAMP>`toe.example.com'</SAMP>, а сервер находится на
<SAMP>`faun.example.com'</SAMP>.  На машине <SAMP>`faun'</SAMP> поместите в файл
<TT>`.rhosts'</TT> в домашнем каталоге пользователя <SAMP>`bach'</SAMP>
следующее:



<PRE>
toe.example.com  mozart
</PRE>

<P>
Потом протестируйте, что <CODE>rsh</CODE> работает, запустив



<PRE>
rsh -l bach faun.example.org 'echo $PATH'
</PRE>

<P>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
Затем вам следует убедиться, что <CODE>rsh</CODE> найдет сервер.
Убедитесь, что путь, напечатанный в результате выполнения этого
примера содержит каталог, содержащий исполняемый файл <TT>`cvs'</TT>, 
который является серверной версией CVS.  Вы можете
установить путь в <TT>`.bashrc'</TT>, <TT>`.cshrc'</TT>, и т. п., но не
в файлах <TT>`.login'</TT> или <TT>`.profile'</TT>.  Можно также
установить переменную среды <CODE>CVS_SERVER</CODE> на клиентской
машине, чтобы указать, какой исполняемый файл вы хотите
использовать, например, <TT>`/usr/local/bin/cvs-1.6'</TT>.


<P>
Не требуется редактировать <TT>`inetd.conf'</TT>, чтобы запустить
CVS как демона.


<P>
<A NAME="IDX176"></A>
<A NAME="IDX177"></A>
<A NAME="IDX178"></A>
<A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<A NAME="IDX181"></A>
<A NAME="IDX182"></A>
Вы можете использовать в <CODE>CVSROOT</CODE> два метода доступа для
<CODE>rsh</CODE>.  <CODE>:server:</CODE> задает использование внутреннего
клиента <CODE>rsh</CODE>, который поддерживается только в некоторых
портах CVS.  <CODE>:ext:</CODE> указывает внешнюю программу
<CODE>rsh</CODE>.  По умолчанию это <CODE>rsh</CODE>, но вы можете установить
переменную среды <CODE>CVS_RSH</CODE>, чтобы выполнять другую
программу, которая может соединиться с сервером (например,
<CODE>remsh</CODE> на HP-UX 9, потому что <CODE>rsh</CODE> немного
отличается.  Эта программа должна уметь пересылать данные с
сервера и на сервер, не изменяя их; например, <CODE>rsh</CODE> из
Windows NT не подходит, потому что он транслирует CR-LF в LF.
Порт CVS для OS/2 содержит хэк, который передает <CODE>rsh</CODE>
параметр <SAMP>`-b'</SAMP>, чтобы обойти это,но так как это может
привести к проблемам с программами, не являющимися стандартным
<CODE>rsh</CODE>, это может быть изменено в будущем.  Если вы
устанавливаете <CODE>CVS_RSH</CODE> в <CODE>ssh</CODE> или какую-нибудь
другую замену <CODE>rsh</CODE>, то инструкции по настройке
<TT>`.rhosts'</TT>, скорее всего, неприменимы, поэтому обратитесь к
документации по соответствующей программе.


<P>
Продолжая наш пример, предположив, что вы хотите обратиться к
модулю <TT>`foo'</TT> в репозитории <TT>`/usr/local/cvsroot'</TT> на
машине <SAMP>`faun.example.org'</SAMP>, вы набираете:



<PRE>
cvs -d :ext:bach@faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
(Можно не писать <TT>`bach@'</TT>, если имена пользователей
совпадают на локальной и сетевой машинах.)




<H3><A NAME="SEC29" HREF="cvs-ru_toc.html#TOC29">Прямое соединение с парольной аутентификацией</A></H3>

<P>
Клиент CVS также может соединяться с сервером, используя
протокол с паролем.  Это особенно полезно, когда использование
<CODE>rsh</CODE> неосуществимо, (например, если сервер находится за
файерволлом), и Kerberos также недоступен.


<P>
Чтобы использовать этот метод, необходима некоторая настройка как 
сервера, так и клиентов.




<H4><A NAME="SEC30" HREF="cvs-ru_toc.html#TOC30">Настройка сервера для парольной аутентификации</A></H4>

<P>
Во-первых, вы, вероятно, хотите усилить права доступа к каталогам
<TT>`$CVSROOT'</TT> и <TT>`$CVSROOT/CVSROOT'</TT>.  См. section <A HREF="cvs-ru_2.html#SEC29">Прямое соединение с парольной аутентификацией</A> за дополнительными деталями.


<P>
<A NAME="IDX183"></A>
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
На стороне сервера следует редактировать файл
<TT>`/etc/inetd.conf'</TT>, чтобы <CODE>inetd</CODE> знал, что следует
выполнять команду <CODE>cvs pserver</CODE>, когда кто-либо пытается
соединиться с соответствующим портом.  По умолчанию номер порта
--- 2401; это значение можно изменить, если перед компиляцией
установить параметр <CODE>CVS_AUTH_PORT</CODE> в другое значение.


<P>
Если ваш <CODE>inetd</CODE> позволяет использование номеров портов в
<TT>`/etc/inetd.conf'</TT>, то можно использовать такую строку:



<PRE>
2401  stream  tcp  nowait  root  /usr/local/bin/cvs cvs --allow-root=/usr/cvsroot pserver
</PRE>

<P>
Вы можете также использовать ключ командной строки <SAMP>`-T'</SAMP>,
чтобы указать временный каталог.


<P>
Ключ командной строки <SAMP>`--allow-root'</SAMP> задает разрешенный
каталог CVSROOT.  Клиенты, пытающиеся использовать другой
каталог, не смогут соединиться.  Если вы хотите разрешить доступ
к нескольким каталогам CVSROOT, повторите эту опцию.


<P>
Если ваш <CODE>inetd</CODE> требует текстовых имен сервисов вместо
номеров портов, поместите эту строчку в <TT>`/etc/services'</TT>:



<PRE>
cvspserver      2401/tcp
</PRE>

<P>
и напишите <CODE>cvspserver</CODE> вместо <CODE>2401</CODE> в файле
<TT>`/etc/inetd.conf'</TT>. 


<P>
После всего этого перезапустите <CODE>inetd</CODE> или заставьте его
перечитать файлы конфигурации.  В случае проблем с настройкой
смотрите section <A HREF="cvs-ru_21.html#SEC179">Ошибки при установке соединения с CVS-сервером</A>.


<P>
<A NAME="IDX186"></A>
<A NAME="IDX187"></A>
Так как клиент хранит и пересылает пароли практически открытым
тестом (см. section <A HREF="cvs-ru_2.html#SEC29">Прямое соединение с парольной аутентификацией</A>), то может
использоваться отдельный файл паролей для CVS, чтобы
пользователи не раскрывали своих обычных паролей при доступе к
репозиторию.  Этот файл -- <TT>`$CVSROOT/CVSROOT/passwd'</TT>
(see section <A HREF="cvs-ru_2.html#SEC20">Административные файлы</A>).  Его формат похож на
<TT>`/etc/passwd'</TT>, но он имеет только два или три поля: имя
пользователя, пароль и необязательное имя пользователя для
использования сервером.  Например:



<PRE>
bach:ULtgRLXo7NRxs
cwang:1sOp854gDF3DY
</PRE>

<P>
Пароль шифруется стандартной функцией UNIX <CODE>crypt()</CODE>,
поэтому можно просто перенести пароль из обычного файла
<TT>`passwd'</TT>.


<P>
При парольной аутентификации сервер сначала проверяет, находится
ли пользователь в файле <TT>`CVSROOT/passwd'</TT>.  Если нет, или
файл <TT>`CVSROOT/passwd'</TT> не существует, то сервер пытается
проверить пароль, используя системную процедуру проверки
пользователя (это может быть запрещено, установив
<CODE>SystemAuth=no</CODE> в файле конфигурации, see section <A HREF="cvs-ru_18.html#SEC174">Файл конфигурации CVSROOT/config</A>).
При использовании файла <TT>`CVSROOT/passwd'</TT> сервер выполняется
с правами пользователя, указанного в третьем поле соответствующей
строки, или, если третьего поля нет, то в первом (таким образом
CVS позволяет использовать ненастоящие имена пользователей,
если в <TT>`CVSROOT/passwd'</TT> заданы соответствующие им настоящие
системные имена.  В любом случае, CVS не получит
дополнительных прав, кроме тех, что уже имеет пользователь.


<P>
<A NAME="IDX188"></A>
С помощью файла <TT>`CVSROOT/passwd'</TT> можно также отобразить
пользователей CVS в имена пользователей машины, добавив
двоеточие и системное имя пользователя после пароля.  Например:



<PRE>
cvs:ULtgRLXo7NRxs:kfogel
generic:1sOp854gDF3DY:spwang
anyone:1sOp854gDF3DY:spwang
</PRE>

<P>
Таким образом, пользователи, обращающиеся по сети к репозиторию
на <CODE>faun.example.org</CODE>, используя команду



<PRE>
cvs -d :pserver:cvs@faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
будут работать с сервером, который имеет права пользователя
<CODE>kfogel</CODE>, если, конечно, они успешно аутентифицировались.
При этом сетевые пользователи не знают системный пароль
пользователя <CODE>kfogel</CODE>, потому что файл <TT>`CVSROOT/passwd'</TT> 
может содержать другой пароль, используемый только
CVS-сервером.  Как показано в вышеприведенном примере, можно 
отображать разные имена пользователей CVS в единственного
системного пользователя.


<P>
Эта возможность создана, чтобы позволить доступ к репозиторию без
полного доступа к системе (в частности, см. section <A HREF="cvs-ru_2.html#SEC36">Доступ к репозиторию только для чтения</A>); однако, смотри также section <A HREF="cvs-ru_2.html#SEC29">Прямое соединение с парольной аутентификацией</A>.  Любой доступ к репозиторию, скорее всего,
подразумевает также некоторый доступ к системе вообще.


<P>
В настоящее время единственный способ поместить пароль в
<TT>`CVSROOT/passwd'</TT> -- это вырезать его откуда-нибудь еще.
Когда-нибудь появится команда <CODE>cvs passwd</CODE>.  В отличие от
других файлов в <TT>`$CVSROOT/CVSROOT'</TT>, вы редактируете файл
<TT>`CVSROOT/passwd'</TT> напрямую, а не с помощью CVS.




<H4><A NAME="SEC31" HREF="cvs-ru_toc.html#TOC31">Использование клиента с парольной аутентификацией</A></H4>
<P>
<A NAME="IDX189"></A>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>
Перед соединением с сервером клиент должен
<EM>зарегистрироваться</EM> с помощью команды <CODE>cvs login</CODE>.
При регистрации на сервере проверяется пароль, который затем
сохраняется для дальнейшего общения с сервером.  Команда
<CODE>cvs login</CODE> должна знать имя пользователя, имя машины с
сервером и полный путь к репозиторию.  Эту информацию CVS
получает из ключа командной строки <SAMP>`-d'</SAMP> и переменной
окружения <CODE>CVSROOT</CODE>.


<P>
<CODE>cvs login</CODE> -- это интерактивная команда, она спрашивает
пароль:



<PRE>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot login
CVS password:
</PRE>

<P>
Пароль проверяется на сервере, если он правильный, то команда
<CODE>login</CODE> завершается успешно, в противном случае она жалуется 
на неверный пароль и завершается с ошибкой.


<P>
После регистрации вы можете заставить CVS соединяться
напрямую с сервером, используя при этом сохраненный пароль.



<PRE>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
Обязательно надо указать <SAMP>`:pserver:'</SAMP>, в противном случае
CVS будет считать, что ему следует использовать <CODE>rsh</CODE>
для соединения с сервером (see section <A HREF="cvs-ru_2.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>).
(Когда вы получили рабочий каталог и выполняете команды CVS
внутри него, больше не требуется явно указывать репозиторий,
потому что CVS запоминает его в подкаталоге <TT>`CVS'</TT> в
рабочем каталоге.)


<P>
<A NAME="IDX193"></A>
Пароли обычно хранятся в файле <TT>`$HOME/.cvspass'</TT>.  У него
читабельный формат, но не следует редактировать его, если вы
не знаете точно, что вы делаете.  Пароли не хранятся открытым
текстом, а слегка шифруются, чтобы защититься от нечаянного
нарушения безопасности (например, системный администратор,
случайно заглянувший внутрь этого файла).


<P>
<A NAME="IDX194"></A>
Пароль  текущего сетевого репозитория удаляется из
<CODE>CVS_PASSFILE</CODE> при использовании команды <CODE>cvs logout</CODE>.


<P>
С помощью переменной окружения <CODE>CVS_PASSFILE</CODE> можно
переназначить файл, в котором хранятся пароли.  Если вы
используете эту переменную, убедитесь, что вы установили ее
<EM>перед</EM> использование <CODE>cvs login</CODE>.  Если вы установите
ее после выполнения <CODE>cvs login</CODE>, то последующие команды
CVS не смогут найти пароля для пересылки его на сервер.




<H4><A NAME="SEC32" HREF="cvs-ru_toc.html#TOC32">Вопросы безопасности при парольной аутентификации</A></H4>

<P>
<A NAME="IDX195"></A>
Пароли хранятся на стороне клиента тривиально зашифрованным
открытым текстом и передаются точно так же.  Такое шифрование
используется только для предотвращения нечаянного подсматривания
пароля (например, системный администратор, случайно заглянувший в 
файл) и не предотвращает даже самые тривиальные атаки.


<P>
Отдельный файл паролей CVS (see section <A HREF="cvs-ru_2.html#SEC30">Настройка сервера для парольной аутентификации</A>) позволяет использовать для доступа к репозиторию
пароль, отличающийся от пароля для доступа к машине.  С другой
стороны, если пользователь получил доступ к репозиторию для
чтения и записи, он может различными способами выполнять
программы на сервере.  Таким образом, доступ к репозиторию
означает также довольно широкий диапазон другого доступа к
системе.  Можно было бы модифицировать CVS, чтобы
предотвратить это, но до сих пор никто этого не сделал.
Более того, могут быть другие способы, которыми люди, имеющие
доступ к репозиторию, получат доступ к системе; никто не
производил тщательного аудита.


<P>
Заметьте, что из-за того, что каталог <TT>`$CVSROOT/CVSROOT'</TT>
содержит <TT>`passwd'</TT> и прочие файлы, использующиеся в целях
безопасности, нужно следить за правами доступа к этому каталогу
так же хорошо, как из правами доступа к <TT>`/etc'</TT>.  То же самое
применимо к самому каталогу <TT>`$CVSROOT'</TT> и любому каталогу,
находящему в нем.  Кто угодно, получив доступ для записи в этот
каталог, сможет стать любым пользователем в системе.  Заметьте,
что эти права доступа обычно строже при использовании pserver.


<P>
Вообще, любой, кто получает пароль, получает доступ к
репозиторию, и, до некоторой степени, доступ к самой системе.
Пароль доступен всем, кто может перехватить сетевые пакеты или
прочитать защищенный (принадлежащий пользователю) файл.  Если вы
хотите настоящей безопасности, используйте Kerberos.




<H3><A NAME="SEC33" HREF="cvs-ru_toc.html#TOC33">Прямое соединение с использованием GSSAPI</A></H3>

<P>
<A NAME="IDX196"></A>
<A NAME="IDX197"></A>
<A NAME="IDX198"></A>
<A NAME="IDX199"></A>
GSSAPI -- это общий интерфейс к системам сетевой безопасности,
таким как Kerberos 5.


<P>
Если у вас есть рабочая библиотека GSSAPI, то ваш CVS может
совершать TCP-соединения с сервером, аутентифицируясь с
помощью GSSAPI.  Для этого CVS нужно скомпилировать с
поддержкой GSSAPI; при конфигурировании CVS пытается
определить, наличествуют ли в системе библиотеки GSSAPI,
использующии Kerberos версии 5.  Вы также можете дать
<CODE>configure</CODE> флаг <CODE>--with-gssapi</CODE>.


<P>
Соединение аутентифицируется, используя GSSAPO, но сам поток
данных <EM>не</EM> аутентифицируется по умолчанию.  Вы должны
использовать глобальный ключ командной строки <CODE>-a</CODE>, чтобы
запросить аутентификацию потока.


<P>
Передаваемые данные по умолчанию <EM>не</EM> шифруются.  Как сервер, 
так и клиент могут быть скомпилированы с поддержкой шифрования;
используйте ключ командной строки <CODE>configure</CODE>
<CODE>--enable-encrypt</CODE>.  Для включения шифрования используйте
ключ командной строки <CODE>-x</CODE>.


<P>
Соединения GSSAPI обрабатываются на стороне сервера тем же
сервером, что производит парольную аутентификацию;  смотри
section <A HREF="cvs-ru_2.html#SEC30">Настройка сервера для парольной аутентификации</A>.  Если вы используете,
например, Kerberos, обеспечивающий хорошую аутентификацию, вы,
вероятно захочете также устранить возможность аутентифицироваться 
с использованием паролей открытым текстом.  Для этого создайте
пустой файл <TT>`CVSROOT/passwd'</TT> и поместите
<CODE>SystemAuth=no</CODE> в файл конфигурации <TT>`config'</TT>.


<P>
Сервер GSSAPI использует principal name cvs/<VAR>имя-машины</VAR>, где 
<VAR>имя-машины</VAR> -- это каноническое имя сервера.  Вам
потребуется настроить ваш механизм GSSAPI.


<P>
Для соединения с использованием GSSAPI, используйте
<SAMP>`:gserver:'</SAMP>.  Например,



<PRE>
cvs -d :gserver:faun.example.org:/usr/local/cvsroot checkout foo
</PRE>



<H3><A NAME="SEC34" HREF="cvs-ru_toc.html#TOC34">Прямое соединение с помощью Kerberos</A></H3>

<P>
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
<A NAME="IDX202"></A>
Самый простой способ использования Kerberos -- это kerberos
<CODE>rsh</CODE>, что описано в section <A HREF="cvs-ru_2.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>.
Основной недостаток использования rsh -- тот, что все данные
должны проходить сквозь дополнительные программы, что замедляет
работу.  Поэтому если у вас установлен Kerberos, вам следует
использовать прямые TCP-соединения, аутентифицируясь с
помощью Kerberos.


<P>
Эта глава относится к системе Kerberos версии 4. Kerberos версии
5 поддерживается посредством общего интерфейса сетевой
безопасности GSSAPI, как описано в предыдущей главе.


<P>
CVS должен быть скомпилирован с поддержкой kerberos; при
конфигурировании CVS пытается определить, какая версия
Kerberos присутствует на машине.  Вы можете также использовать
ключ командной строки <CODE>configure</CODE> <CODE>--with-krb4</CODE>.


<P>
Пересылаемые данные по умолчанию <EM>не</EM> шифруются.  Как
клиент, так и сервер должны быть скомпилированы с использованием
шифрования; используйте ключ командной строки <CODE>configure</CODE>
<CODE>--enable-encryption</CODE>.  Для включения шифрования используйте
глобальный ключ командной строки <CODE>-x</CODE>.


<P>
<A NAME="IDX203"></A>
На сервере требуется отредактировать <CODE>/etc/inetd.conf</CODE>,
чтобы запустить <CODE>cvs kserver</CODE>.  Клиент по умолчанию
использует порт 1999; если вы хотите использовать другой порт,
задайте его на клиентской машине в переменной окружения
<CODE>CVS_CLIENT_PORT</CODE>.


<P>
<A NAME="IDX204"></A>
Когда вы захотите использовать CVS, сначала, как обычно,
получите билет (<CODE>kinit</CODE>); этот билет должен позволять вам
зарегистрироваться на сервере.  Затем



<PRE>
cvs -d :kserver:faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
Предыдущие версии CVS могли в случае неудачи использовать
соединение с помощью <CODE>rsh</CODE>; текущие версии так не делают.




<H3><A NAME="SEC35" HREF="cvs-ru_toc.html#TOC35">Использование параллельного <CODE>cvs server</CODE> для соединения</A></H3>

<P>
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>
Этот метод доступа позволяет вам соединяться с репозиторием,
находящимся на локальном диске, используя сетевой протокол.
Другими словами, он делает то же самое, что и <CODE>:local:</CODE>, но
при этом с особенностями и ошибками, существующими у сетевого, а
нее локального CVS.


<P>
Для каждодневных операций вы, скорее всего, предпочтете
<CODE>:local:</CODE> или <CODE>:fork:</CODE>, в зависимости от ваших
предпочтений.  Конечно, <CODE>:fork:</CODE> особенно полезен при
тестировании и отладке <CODE>cvs</CODE> и сетевого протокола.  Точнее,
мы избавляемся от необходимости настройки сети, таймаутов,
проблем с аутентификацией, свойственных сетевому доступа, но при
этом пользуемся собственно сетевым протоколом.


<P>
Чтобы соединиться, используя метод доступа <CODE>:fork:</CODE>,
добавьте его к имени локального репозитория, например:



<PRE>
cvs -d :fork:/usr/local/cvsroot checkout foo
</PRE>

<P>
<A NAME="IDX207"></A>
Как и при использовании <CODE>:ext:</CODE>, сервер по умолчанию
называется <SAMP>`cvs'</SAMP>.  Если установлена переменная окружения
<CODE>CVS_SERVER</CODE>, используется ее значение.




<H2><A NAME="SEC36" HREF="cvs-ru_toc.html#TOC36">Доступ к репозиторию только для чтения</A></H2>
<P>
<A NAME="IDX208"></A>
<A NAME="IDX209"></A>
<A NAME="IDX210"></A>
<A NAME="IDX211"></A>


<P>
Существует возможность предоставить публичный доступ к
репозиторию только для чтения, используя сервер парольной
аутентификации (see section <A HREF="cvs-ru_2.html#SEC29">Прямое соединение с парольной аутентификацией</A>).  (Прочие
методы доступа не имеют явной поддержки для доступа только для
чтения, потому что все эти методы подразумевают регистрацию на
машине с репозиторием, и поэтому пользователь может делать все,
что позволяют ему права доступа к файлам.)


<P>
Пользователь, имеющий доступ к репозиторию только для чтения,
может выполнять все команды CVS, не изменяющие репозиторий,
за исключением определенных "административных" файлов (таких,
как файлы блокировок и файл истории).  Может потребоваться
использовать эту возможность совместно с возможностью
использования псевдонимов пользователей (see section <A HREF="cvs-ru_2.html#SEC30">Настройка сервера для парольной аутентификации</A>).


<P>
В отличие от предыдущих версий CVS, пользователи с доступом
только для чтения должны быть способны только читать репозиторий,
но не выполнять программы на сервере или другим способом получать
ненужные уровни доступа.  Говоря точнее, закрыты все <EM>ранее
известные</EM> дыры в безопасности.  Так как эта возможность
появилась недавно и не подвергалась исчерпывающему анализу
безопасности, вы должны действовать с максимально необходимой
осторожностью. 


<P>
Есть два способа указать доступ пользователя только для чтения:
включающий и исключающий.


<P>
<EM>Включающий</EM> способ означает, что пользователь явно
указывается в файле <TT>`$CVSROOT/CVSROOT/readers'</TT>, в котором
просто перечисляются "в столбик" пользователи.  Вот пример:



<PRE>
melissa
splotnik
jrandom
</PRE>

<P>
(Не забудьте символ новой строки в конце файла.)


<P>
<EM>Исключающий</EM> способ означает, что все, кто имеет доступ к
репозиторию <EM>для записи</EM>, перечисляются в файле
<TT>`$CVSROOT/CVSROOT/writers'</TT>.  Если этот файл существует, то
все пользователи, не упомянутые в нем, получают доступ только для
чтения (конечно, даже пользователи только для чтения должны быть
упомянуты в файле <TT>`CVSROOT/passwd'</TT>).  Файл <TT>`writers'</TT>
имеет тот же формат, что и файл <TT>`readers'</TT>.


<P>
Замечание: если ваш файл <TT>`CVSROOT/passwd'</TT> отображает
пользователей CVS в системных пользователей (see section <A HREF="cvs-ru_2.html#SEC30">Настройка сервера для парольной аутентификации</A>), убедитесь, что вы предоставляете или
не предоставляете доступ только для чтения пользователям
CVS, а не системным пользователям.  Это означает, что в
файлах <TT>`readers'</TT> и <TT>`writers'</TT> должны находиться
пользователи CVS, которые могут не совпадать с системными
пользователями.


<P>
Вот полное описание поведения сервера, принимающему решение,
какой тип доступа предоставить:


<P>
Если файл <TT>`readers'</TT> существует, и данный пользователь не
упомянут в нем, он получает доступ только для чтения.  Если
существует файл <TT>`writers'</TT>, и этот пользователь НЕ упомянут в
нем, то он также получает доступ только для чтения (это так даже
если файл <TT>`readers'</TT> существует, но пользователь не упомянут
в нем).  В противном случае пользователь получает полный доступ
для чтения и записи.


<P>
Конечно, возможен конфликт, если пользователь упомянут в обоих
файлах.  Такой конфликт разрешается консервативно и такой
пользователь получает доступ только для чтения.




<H2><A NAME="SEC37" HREF="cvs-ru_toc.html#TOC37">Временные каталоги на сервере</A></H2>
<P>
<A NAME="IDX212"></A>
<A NAME="IDX213"></A>


<P>
В процессе работы CVS-сервер создает временные каталоги.
Они называются



<PRE>
cvs-serv<VAR>pid</VAR>
</PRE>

<P>
где <VAR>pid</VAR> -- это номер процесса сервера.  Они находятся в
каталоге, указанном в переменной окружения <CODE>TMPDIR</CODE>
(see section <A HREF="cvs-ru_19.html#SEC175">Все переменные окружения, используемые в CVS</A>), ключом командной строки <SAMP>`-T'</SAMP> 
или в <TT>`/tmp'</TT> по умолчанию.


<P>
В большинстве случаев сервер сам удалит временный каталог в конце 
работы.  В некоторых случаях сервер может завершиться, не удалив
свой временный каталог, например:



<UL>
<LI>

если сервер аварийно завершается из-за внутренней ошибки, он
может оставить временный каталог, чтобы облегчить отладку;

<LI>

если сервер был убит так, что не смог убрать за собой (например,
<SAMP>`kill -KILL'</SAMP> под UNIX);

<LI>

система прекращает свою работу, не сообщив предварительно серверу
об этом факте.
</UL>

<P>
В таких случаях вы должны вручную удалить каталоги
<TT>`cvs-serv<VAR>pid</VAR>'</TT>.  Если нет сервера с номером процесса
<VAR>pid</VAR>, то сделать это можно совершенно безопасно.


<P><HR><P>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_1.html">previous</A>, <A HREF="cvs-ru_3.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
