<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Создание ветвей и слияние</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_4.html">previous</A>, <A HREF="cvs-ru_6.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC54" HREF="cvs-ru_toc.html#TOC54">Создание ветвей и слияние</A></H1>
<P>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
<A NAME="IDX271"></A>
<A NAME="IDX272"></A>
<A NAME="IDX273"></A>
<A NAME="IDX274"></A>
<A NAME="IDX275"></A>
<A NAME="IDX276"></A>


<P>
CVS позволяет изолировать изменения в отдельной линии
разработки, называемой <EM>веткой</EM>.  Когда вы изменяете файлы на 
ветке, эти изменения не появляются в основном стволе или на
других ветках.


<P>
Позже вы можете переместить изменения с одной ветки на другую или 
же с ветки в ствол, это называется <EM>слиянием</EM>.  Сначала
выполняется <CODE>cvs update -j</CODE>, чтобы  слить изменения в
рабочий каталог, а затем эти изменения фиксируются, что приводит
к копированию изменения в другую ветку.




<H2><A NAME="SEC55" HREF="cvs-ru_toc.html#TOC55">Для чего хороши ветви?</A></H2>
<P>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>


<P>
Предположим, был выпущен <TT>tc</TT> версии 1.0.  Вы продолжаете его
разработку, планируя выпустить версию 1.1 через пару месяцев.
Через некоторое время ваши пользователи начинают жаловаться на
серьезную ошибку.  Вы извлекаете версию 1.0 (see section <A HREF="cvs-ru_4.html#SEC48">Метки ревизий</A>) и
находите ошибку, для исправления которой требуется всего лишь
тривиальное изменение).  Однако же, текущая версия исходников
находится в крайне нестабильном состоянии и не стабилизируется по
крайней мере еще месяц.  Вы не можете выпустить исправленную
версию, основываясь на свежих исходниках. 


<P>
В подобной ситуации имеет смысл создать <EM>ветку</EM> в дереве
ревизий, содержащую файлы, из которых состояла версия 1.0.  Затем
вы вносите изменения в ветвь без вторжения в основной ствол.
Затем вы можете либо внести те же самые изменения в основной
ствол, либо оставить их только на ветви.




<H2><A NAME="SEC56" HREF="cvs-ru_toc.html#TOC56">Создание ветви</A></H2>
<P>
<A NAME="IDX280"></A>
<A NAME="IDX281"></A>
<A NAME="IDX282"></A>
<A NAME="IDX283"></A>
<A NAME="IDX284"></A>
<A NAME="IDX285"></A>


<P>
Вы можете создать ветвь, используя <CODE>tag -b</CODE>.  Например,
предполагая, что вы находитесь в каталоге с рабочей копией:



<PRE>
$ cvs tag -b rel-1-0-patches
</PRE>

<P>
Это отщепляет ветку, основанную на текущей ревизии рабочей копии, 
и присваивает этой ветке имя <SAMP>`rel-1-0-patches'</SAMP>.


<P>
Важно понимать, что ветки создаются в репозитории, а не в рабочей 
копии.  Создание ветки, основанной на текущей ревизии, как в
вышеприведенном примере, <EM>НЕ</EM> переключает рабочую копию на
использование ветки (как сделать это -- описано в section <A HREF="cvs-ru_5.html#SEC57">Доступ к веткам</A>).


<P>
Можно также создать ветку вообще без использования рабочей копии,
используя <CODE>rtag</CODE>.



<PRE>
$ cvs rtag -b -r rel-1-0 rel-1-0-patches tc
</PRE>

<P>
<SAMP>`-r rel-1-0'</SAMP> означает, что эта ветка имеет корневую ревизию, 
соответствующую метке <SAMP>`rel-1-0'</SAMP>.  Это не обязательно должна
быть самая последняя ревизия: довольно часто бывает полезно
отщепить ветку от старой ревизии (например, для исправления
ошибки в старой версии, которая в основном стабильна).


<P>
Как и в случае с <SAMP>`tag'</SAMP>, ключ командной строки <SAMP>`-b'</SAMP>
заставляет <CODE>rtag</CODE> создать ветку (а не алфавитное имя
ревизии).  Заметьте, что номера ревизий, соответствующих
<SAMP>`rel-1-0'</SAMP>, скорее всего, будут различаться от файла к
файлу. 


<P>
Таким образом, полный эффект этой команды -- создать новую ветку, 
которая называется <SAMP>`rel-1-0-patches'</SAMP>, в модуле <SAMP>`tc'</SAMP>,
которая растет в дереве ревизий из точки, помеченной как
<SAMP>`rel-1-0'</SAMP>. 




<H2><A NAME="SEC57" HREF="cvs-ru_toc.html#TOC57">Доступ к веткам</A></H2>
<P>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
<A NAME="IDX290"></A>
<A NAME="IDX291"></A>


<P>
Вы можете извлечь ветку двумя способами:  извлекая ее из
репозитория в чистом каталоге или переключая существующую рабочую 
копию на ветку. 


<P>
Для того, чтобы извлечь ветку из репозитория, выполните команду
<SAMP>`checkout'</SAMP> с ключом командной строки <SAMP>`-r'</SAMP>, с именем
метки в качестве параметра (see section <A HREF="cvs-ru_5.html#SEC56">Создание ветви</A>). 



<PRE>
$ cvs checkout -r rel-1-0-patches tc
</PRE>

<P>
Если у вас уже есть рабочая копия, вы можете переключить ее на
нужную ветку с помощью <SAMP>`update -r'</SAMP>:



<PRE>
$ cvs update -r rel-1-0-patches tc
</PRE>

<P>
или, что то же самое:



<PRE>
$ cd tc
$ cvs update -r rel-1-0-patches
</PRE>

<P>
Неважно, что рабочая копия была извлечена из основного ствола или 
какой-нибудь другой ветки: вышеприведенная команда переключит ее
на указанную ветку.  Подобно обычной команде <SAMP>`update'</SAMP>,
<SAMP>`update -r'</SAMP> сливает сделанные изменения, уведомляя вас о
произошедших конфликтах.


<P>
Когда у вы связываете рабочую копию с какой-либо веткой, она
будет находиться там, пока вы не укажете обратного.  Это
означает, что изменения, которые фиксируются из рабочей копии,
будут добавлять новые ревизии на ветку, оставляя без изменений
основной ствол и другие ветки. 


<P>
<A NAME="IDX292"></A>
Чтобы узнать, на какой ветви находится рабочая копия, можно
использовать команду <SAMP>`status'</SAMP>.  В том, что она вывела на
экран, обратите внимание на поле, которое называется <SAMP>`Sticky 
tag'</SAMP> (see section <A HREF="cvs-ru_4.html#SEC53">Липкие метки</A>) -- здесь CVS сообщает, на какой 
ветви находятся рабочие файлы:



<PRE>
$ cvs status -v driver.c backend.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7     Sat Dec  5 18:25:54 1992
    RCS Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.7.2)
        rel-1-0                     (revision: 1.7)

===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.4.2)
        rel-1-0                     (revision: 1.4)
        rel-0-4                     (revision: 1.4)

</PRE>

<P>
Не смущайтесь тем, что номера ветвей для каждого файла различны
(<SAMP>`1.7.2'</SAMP> и <SAMP>`1.4.2'</SAMP>, соответственно).  Метка ветви одна
и та же, <SAMP>`rel-1-0-patches'</SAMP>, и все файлы действительно
находятся на одной и той же ветке.  Номера лишь отражают точку в
истории файла, в которой появилась ветвь.  Из вышеприведенного
примера можно узнать, что <SAMP>`driver.c'</SAMP> претерпел больше
изменений, чем <SAMP>`backend.c'</SAMP>, перед тем, как была создана
ветка. 


<P>
Смотри section <A HREF="cvs-ru_5.html#SEC58">Ветки и ревизии</A> за деталями построения номеров
ветвей. 




<H2><A NAME="SEC58" HREF="cvs-ru_toc.html#TOC58">Ветки и ревизии</A></H2>
<P>
<A NAME="IDX293"></A>
<A NAME="IDX294"></A>
<A NAME="IDX295"></A>


<P>
Обычно история ревизий файла -- это линейная возрастающая
последовательность номеров (see section <A HREF="cvs-ru_4.html#SEC45">Номера ревизий</A>):



<PRE>
       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</PRE>

<P>
Однако же, CVS не ограничен линейной разработкой.
<EM>Дерево ревизий</EM> может быть расщеплено на <EM>ветви</EM>, где
каждая ветвь -- самостоятельная линия разработки.  Изменения,
сделанные на одной ветке, легко могут быть внесены также и в
основной ствол.


<P>
Каждая ветка имеет <EM>номер ветки</EM>, состоящий из нечетного
числа десятичных чисел, разделенных точками.  Номер ветки
создается путем добавления целого числа к номеру ревизии, от
которой была отщеплена ветка.  Номера веток позволяют отщеплять
от одной и той же ревизии несколько веток. 


<P>
Все ревизии на ветке имеют номера ревизий, образованные путем
добавления порядкового номера к номеру ветки.  Вот иллюстрация
создания веток.



<PRE>
                                                      +-------------+
                           Branch 1.2.2.3.2 -&#62;        ! 1.2.2.3.2.1 !
                                                    / +-------------+
                                                   /
                                                  /
                 +---------+    +---------+    +---------+
Branch 1.2.2 -&#62; _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
               / +---------+    +---------+    +---------+
              /
             /
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  &#60;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+    +---------+
Branch 1.2.4 -&#62; +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                    +---------+    +---------+    +---------+

</PRE>

<P>
Обычно не требуется задумываться о точных деталях того, как
строятся номера веток, но вот еще подробности: когда CVS
создает номер ветки, он берет первое неиспользованное четное
число, начиная с двойки.  Поэтому, если вы хотите создать ветку
от ревизии 6.4, она будет называться 6.4.2.  Номера веток,
заканчивающиеся на ноль (например, 6.4.0), используются для
внутренних нужд CVS (see section <A HREF="cvs-ru_5.html#SEC59">Волшебные номера веток</A>).  Ветка
1.1.1 имеет специальное значение.  See section <A HREF="cvs-ru_13.html#SEC103">Слежение за чужими исходными текстами</A>.




<H2><A NAME="SEC59" HREF="cvs-ru_toc.html#TOC59">Волшебные номера веток</A></H2>

<P>
<A NAME="IDX296"></A>
<A NAME="IDX297"></A>
В этой секции описана возможность CVS, называющаяся
<EM>волшебные ветки</EM>.  В большинстве случаев вам не потребуется
беспокоиться о волшебных ветках, так как CVS сам следит за
ними.  Однако, вы можете увидеть их при определенных условиях,
поэтому полезно было бы узнать, как они работают. 


<P>
Номера веток состоят из нечетного количества десятичных целых,
разделенных точками.  See section <A HREF="cvs-ru_4.html#SEC45">Номера ревизий</A>.  Однако же, это не
полная правда.  Из соображений эффективности CVS иногда
вставляет лишний ноль во вторую справа позицию (1.2.4 становится
1.2.0.4, а 8.9.10.11.12 становится 8.9.10.11.0.12 и так далее).


<P>
CVS довольно хорошо прячет такие "волшебные" ветки, но в
нескольких местах ему это не удается:



<UL>
<LI>

Номера волшебных веток появляются в выдаче <CODE>cvs log</CODE>. 

<LI>

Вы не можете указать символическое имя ветки в команде <CODE>cvs
admin</CODE>. 

</UL>

<P>
Можно использовать команду <CODE>admin</CODE>, чтобы переназначить
символическое имя ветки на то, которое ожидает увидеть CVS.
Например, если <CODE>R4patches</CODE> присвоено ветке 1.4.2 (волшебный
номер 1.4.0.2) в файле <TT>`numbers.c'</TT>, можно сделать так:



<PRE>
$ cvs admin -NR4patches:1.4.2 numbers.c
</PRE>

<P>
Это сработает, только если хотя бы одна ревизия уже была
зафиксирована на ветке.  Будьте очень осторожны, чтобы не
присвоить метку неправильному числу, так как нет способа узнать,
чему была присвоена эта метка вчера (за исключением ежедневного
резервного копирования). 




<H2><A NAME="SEC60" HREF="cvs-ru_toc.html#TOC60">Слияние веток</A></H2>
<P>
<A NAME="IDX298"></A>
<A NAME="IDX299"></A>


<P>
Вы можете объединить изменения, сделанные на ветке, с вашей
рабочей копией, добавив флаг <SAMP>`-j <VAR>ветка</VAR>'</SAMP> к команде
<CODE>update</CODE>.  В результате CVS внедряет в рабочую копию
изменения, сделанные между ревизией, где отщепилась ветка и
свежайшей ревизией на этой ветке.


<P>
<A NAME="IDX300"></A>
Ключ командной строки <SAMP>`-j'</SAMP> означает "объединить" (join).


<P>
<A NAME="IDX301"></A>
<A NAME="IDX302"></A>
<A NAME="IDX303"></A>
Представьте себе такое дерево ревизий:



<PRE>
+-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      &#60;- основной ствол
+-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+
 Ветвь R1fix -&#62; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</PRE>

<P>
Ветке 1.2.2 была назначена метка (символическое имя)
<SAMP>`R1fix'</SAMP>.  В нижеследующем примере предполагается, что модуль 
<SAMP>`mod'</SAMP> содержит единственный файл, <TT>`m.c'</TT>.



<PRE>
$ cvs checkout mod               # Извлчеь последнюю ревизию, 1.4

$ cvs update -j R1fix m.c        # Слить все изменения, сделанные на ветке,
                                 # т. е. изменения между ревизиями 1.2
                                 # и 1.2.2.2, в рабочую копию файла

$ cvs commit -m "Included R1fix" # создать ревизию 1.5.
</PRE>

<P>
В результате операции слияния может произойти конфликт.  В это
случае вам сначала надо справиться с ним перед фиксированием
изменений.  See section <A HREF="cvs-ru_10.html#SEC85">Пример конфликта</A>.


<P>
Команда <CODE>checkout</CODE> также поддерживает флаг <SAMP>`-j
<VAR>ветка</VAR>'</SAMP>.  Можно добиться эффекта, обсуждавшегося выше, с
помощью 



<PRE>
$ cvs checkout -j R1fix mod
$ cvs commit -m "Добавлен R1fix"
</PRE>



<H2><A NAME="SEC61" HREF="cvs-ru_toc.html#TOC61">Многократное слияние из ветки</A></H2>

<P>
Мы продолжаем обсуждение примера.  Теперь дерево ревизий выглядит 
так:



<PRE>
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &#60;- ствол
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+
 Ветвь R1fix -&#62; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</PRE>

<P>
Здесь линия из звездочек представляет собой слияние ветки
<SAMP>`R1fix'</SAMP> с основным стволом, обсуждавшееся только что. 


<P>
Предположим теперь, что разработка ветки <SAMP>`R1fix'</SAMP>
продолжается:



<PRE>
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &#60;- ствол
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+    +---------+
 Ветвь R1fix -&#62; +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    +---------+    +---------+    +---------+
</PRE>

<P>
и теперь вы опять хотите слить свежайшие изменения с основным
стволом.  Если бы вы просто использовали команду <CODE>cvs update
-j R1fix m.c</CODE>, то CVS попыталась бы опять слить уже слитые
изменения, что привело бы к нежелательным результатам. 


<P>
Вместо этого вам нужно указать, что вы хотите слить только
те изменения ветки, что еще не были объединены со стволом.  Для
этого вы указываете два ключа командной строки <SAMP>`-j'</SAMP>, и
CVS сливает изменения между первой и второй ревизиями.
Например, в этом случае самым простым способом будет 



<PRE>
cvs update -j 1.2.2.2 -j R1fix m.c    # Слить изменения между 1.2.2.2 и
                                      # головой ветки R1fix
</PRE>

<P>
Проблемой здесь является то, что вы должны вручную указать
ревизию 1.2.2.2.  Чуть лучшим подходом будет использование даты
совершения последнего слияния. 



<PRE>
cvs update -j R1fix:yesterday -j R1fix m.c
</PRE>

<P>
Еще лучше было бы помечать ветку <SAMP>`R1fix'</SAMP> после каждого
слияния со стволом, и использовать эту метку для дальнейших
слияний: 



<PRE>
cvs update -j merged_from_R1fix_to_trunk -j R1fix m.c
</PRE>



<H2><A NAME="SEC62" HREF="cvs-ru_toc.html#TOC62">Слияние изменений между двумя ревизиями</A></H2>
<P>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>
<A NAME="IDX306"></A>


<P>
С помощью двух флагов <SAMP>`-j <VAR>ревизия</VAR>'</SAMP>, команды <CODE>update</CODE> и
<CODE>checkout</CODE> могут сливать изменения между любыми двумя ревизиями в
ваш рабочий файл. 


<P>
Команда


<P>
<A NAME="IDX307"></A>
<A NAME="IDX308"></A>

<PRE>
$ cvs update -j 1.5 -j 1.3 backend.c
</PRE>

<P>
отменит изменения, сделанные между ревизиями 1.3 и 1.5.  Обратите
внимание на порядок указания ревизий!


<P>
Если вы попробуете использовать эту опцию при работе с несколькими
файлами, помните, что номера ревизий, вероятно, будут для разных файлов
сильно отличаться.  В таких случаях почти всегда следует использовать
алфавитные метки, а не номера ревизий.


<P>
<A NAME="IDX309"></A>
<A NAME="IDX310"></A>
Указав два ключа командной строки <SAMP>`-j'</SAMP>, можно также отменить
удаления и добавления файлов.  Например, предположим, у вас есть файл
<SAMP>`file1'</SAMP>, существовавший в ревизии 1.1.  Затем вы удалили его,
создав "мертвую" ревизию 1.2.  Теперь предположим, что вы хотите
добавить его опять, с тем же самым содержимым, что он имел ранее.  Вот
как сделать это: 



<PRE>
$ cvs update -j 1.2 -j 1.1 file1
U file1
$ cvs commit -m test
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  &#60;--  file1
new revision: 1.3; previous revision: 1.2
done
$
</PRE>



<H2><A NAME="SEC63" HREF="cvs-ru_toc.html#TOC63">При слиянии можно добавлять и удалять файлы</A></H2>

<P>
Если измененяи, которые вы сливаете, включают в себя удаление или
добавление каких-либо файлов, то команда <CODE>update -j</CODE> учтет такие
добавления и удаления. 


<P>
For example:

<PRE>
cvs update -A
touch a b c
cvs add a b c ; cvs ci -m "added" a b c
cvs tag -b branchtag
cvs update -r branchtag
touch d ; cvs add d
rm a ; cvs rm a
cvs ci -m "added d, removed a"
cvs update -A
cvs update -jbranchtag
</PRE>

<P>
После того, как эти команды выполнены, а также выполнена команда
<SAMP>`cvs commit'</SAMP>, файл <TT>`a'</TT> будет удален, а файл <TT>`d'</TT> будет
добавлен в основной ствол.


<P><HR><P>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_4.html">previous</A>, <A HREF="cvs-ru_6.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
