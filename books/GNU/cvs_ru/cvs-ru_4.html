<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Ревизии</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_3.html">previous</A>, <A HREF="cvs-ru_5.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC44" HREF="cvs-ru_toc.html#TOC44">Ревизии</A></H1>

<P>
В большинстве случаев использования CVS не требуется сильно
беспокоиться о номерах ревизий; CVS присваивает номера типа
<CODE>1.1</CODE>, <CODE>1.2</CODE> и т. д., и этого достаточно.  Некоторые,
однако, хотели бы иметь больше информации и лучше контролировать то, 
как CVS присваивает номера ревизий.


<P>
Если необходимо отслеживать набор ревизий, содержащих более
одного файла, например, ревизии, попавшие в конкретную версию
программы, используются <EM>метки</EM>, т. е. буквенные имена
ревизий, которые можно присвоить каждому номеру ревизии файла.




<H2><A NAME="SEC45" HREF="cvs-ru_toc.html#TOC45">Номера ревизий</A></H2>
<P>
<A NAME="IDX231"></A>
<A NAME="IDX232"></A>
<A NAME="IDX233"></A>
<A NAME="IDX234"></A>
<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
<A NAME="IDX237"></A>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
<A NAME="IDX240"></A>


<P>
Каждая ревизия файла имеет уникальный <EM>номер ревизии</EM>.
Номера ревизий выглядят как <SAMP>`1.1'</SAMP>, <SAMP>`1.2'</SAMP>,
<SAMP>`1.3.2.2'</SAMP> или даже <SAMP>`1.3.2.2.4.5'</SAMP>.  Номер ревизии всегда
содержит четное количество десятичных чисел, разделенных точкой.
По умолчанию ревизия 1.1 -- первая ревизия файла.  В номере
каждой следующей ревизии самая правая цифра увеличивается на
единицу.  Вот пример нескольких ревизий, новые версии находятся
правее старых:



<PRE>
       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</PRE>

<P>
Может также оказаться, что в номерах ревизий будет больше одной
точки, например, <SAMP>`1.3.2.2'</SAMP>.  Такие номера означают ревизии,
находящиеся на ветках (see section <A HREF="cvs-ru_5.html#SEC54">Создание ветвей и слияние</A>); эти
номера подробно описаны в section <A HREF="cvs-ru_5.html#SEC58">Ветки и ревизии</A>.




<H2><A NAME="SEC46" HREF="cvs-ru_toc.html#TOC46">Версии и ревизии</A></H2>
<P>
<A NAME="IDX241"></A>
<A NAME="IDX242"></A>


<P>
Как описано выше, у файла может быть несколько ревизий.  У
программного продукта может быть несколько версий.  Программным
продуктам обычно дают номера версий типа <SAMP>`4.1.1'</SAMP>.




<H2><A NAME="SEC47" HREF="cvs-ru_toc.html#TOC47">Назначение номеров ревизий</A></H2>

<P>
По умолчанию, CVS назначает номер ревизии, оставляя первую
цифру и увеличивая вторую.  Например, <CODE>1.1</CODE>, <CODE>1.2</CODE>,
<CODE>1.3</CODE>. 


<P>
При добавлении нового файла вторая цифра всегда будет единицей, а
первая цифра будет равняться самой большой первой цифре номера
ревизии какждого файла в каталоге.  Например, если в каталоге
находятся файлы с ревизиями <CODE>1.7</CODE>, <CODE>3.1</CODE>, <CODE>4.12</CODE>,
то добавленный файл получит номер ревизии <CODE>4.1</CODE>.


<P>
Обычно совершенно не требуется заботиться о номерах ревизий ---
проще думать о них, как о служебных номерах, за которыми следит
CVS, а также о метках, обеспечивающих хороший способ
различать, например, версию 1 вашего продукта от версии 2
(see section <A HREF="cvs-ru_4.html#SEC48">Метки ревизий</A>).  Однако, если вы хотите установить номер
ревизии, вам поможет ключ командной строки <SAMP>`-r'</SAMP> команды
<CODE>cvs commit</CODE>.  Ключ <SAMP>`-r'</SAMP> подразумевает использование
ключа <SAMP>`-f'</SAMP>, в том смысле, что он приводит к фиксированию
файлов, даже если он не были изменены.


<P>
Например, для того, что задать всем вашим файлам, включая те, что
не изменились, номер ревизии 3.0, выполните команду



<PRE>
$ cvs commit -r 3.0
</PRE>

<P>
Заметьте, что номер, который вы указываете вместе с ключом
<SAMP>`-r'</SAMP>, должен быть больше любого существующего номера
ревизии.  Скажем, если существует ревизия 3.0, вы не можете
сказать <SAMP>`cvs commit -r 1.3'</SAMP>.  Если вы хотите параллельно
отслеживать несколько версий программного продукта, вам нужно
создать ветку (see section <A HREF="cvs-ru_5.html#SEC54">Создание ветвей и слияние</A>).




<H2><A NAME="SEC48" HREF="cvs-ru_toc.html#TOC48">Метки ревизий</A></H2>
<P>
<A NAME="IDX243"></A>


<P>
Номера ревизий живут своей собственной жизнью.  Они могут
совершенно никак не соотноситься с номером версии вашего
программного продукта.  В зависимости от того, как вы
используете CVS, номера ревизий могут измениться несколько
раз между двумя выпусками продукта.  Например, файлы с исходными
текстами RCS 5.6 имеют такие номера ревизий:



<PRE>
ci.c            5.21
co.c            5.9
ident.c         5.3
rcs.c           5.12
rcsbase.h       5.11
rcsdiff.c       5.10
rcsedit.c       5.11
rcsfcmp.c       5.9
rcsgen.c        5.10
rcslex.c        5.11
rcsmap.c        5.2
rcsutil.c       5.10
</PRE>

<P>
<A NAME="IDX244"></A>
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>
<A NAME="IDX247"></A>
<A NAME="IDX248"></A>
<A NAME="IDX249"></A>
Вы можете использовать команду <CODE>tag</CODE>, чтобы задать буквенное 
имя определенной ревизии файла.  Вы можете использовать ключ
командной строки <SAMP>`-v'</SAMP> команды <CODE>status</CODE>, чтобы увидеть
все метки, которые имеет файл, а также какие номера ревизий они
представляют.  Имена меток должны начинаться с буквы и могут
содержать буквы, цифры и знаки <SAMP>`-'</SAMP> и <SAMP>`_'</SAMP>.  Два имени
меток <CODE>BASE</CODE> и <CODE>HEAD</CODE> зарезервированы для использования
в CVS.  Предполагается, что будущие зарезервированные имена
будут иметь специальный вид, например, начинаться с символа
<SAMP>`.'</SAMP>, чтобы избежать конфликтов с действительными именами
меток. 


<P>
Вы захотите выбрать какое-либо соглашение об именах меток,
основываясь, например, на имени программы и номере ее версии.
Например, можно взять имя программы, за которым следует номер
версии, в котором символ <SAMP>`.'</SAMP> заменен на <SAMP>`-'</SAMP>, так что
CVS 1.9 будет помечен как <CODE>cvs1-9</CODE>.  Если вы выберете
стабильные правила именования, вам не придется постоянно
угадывать, называется ли метка <CODE>cvs-1-9</CODE>, <CODE>cvs1_9</CODE> или
как-то еще.  Вы можете даже принудительно задать эти правила
именования в файле <TT>`taginfo'</TT> (see section <A HREF="cvs-ru_8.html#SEC77">Настройка журналирования</A>).


<P>
<A NAME="IDX250"></A>
<A NAME="IDX251"></A>
В нижеследующем примере показано, как добавить метку к файлу.
Команды должны выполняться внутри вашего рабочего каталога, то
есть там, где находится файл <TT>`backend.c'</TT>.



<PRE>
$ cvs tag rel-0-4 backend.c
T backend.c
$ cvs status -v backend.c
===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         (none)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-0-4                     (revision: 1.4)

</PRE>

<P>
Полный синтаксис команды <CODE>cvs tag</CODE>, включая разнообразные
ключи командной строки, описан в section <A HREF="cvs-ru_17.html#SEC152">Краткий справочник по командам CVS</A>.


<P>
Редко требуется помечать одиночные файлы.  Гораздо чаще нужно
пометить все файлы, составляющие модуль, в стратегической точке
цикла разработки, например, когда выпущена новая версия.



<PRE>
$ cvs tag rel-1-0 .
cvs tag: Tagging .
T Makefile
T backend.c
T driver.c
T frontend.c
T parser.c
</PRE>

<P>
(Если вы дадите CVS каталог в качестве параметра командной
строки, она обычно оперирует над всеми файлами в этом каталоге и, 
рекурсивно, ко всем подкаталогам, которые тот содержит.
See section <A HREF="cvs-ru_6.html#SEC64">Рекурсивное поведение</A>.)


<P>
<A NAME="IDX252"></A>
<A NAME="IDX253"></A>
Команда <CODE>checkout</CODE> имеет ключ командной строки <SAMP>`-r'</SAMP>,
позволяющий извлечь определенную ревизию модуля.  Этот флаг
упрощает извлечение исходного текста, из которого сделана версия
1.0 модуля <SAMP>`tc'</SAMP> в когда-нибудь в будущем.



<PRE>
$ cvs checkout -r rel-1-0 tc
</PRE>

<P>
Это полезно, например, если кто-то заявляет, что в той версии
была ошибка, но вы не можете найти ее в текущей рабочей копии.


<P>
Вы можете также извлечь модуль по состоянию на любую дату.
See section <A HREF="cvs-ru_16.html#SEC121">Ключи команды checkout</A>.  Задав команде <CODE>checkout</CODE>
ключ командной строки <SAMP>`-r'</SAMP>, следует остерегаться липких
меток; см. section <A HREF="cvs-ru_4.html#SEC53">Липкие метки</A>.


<P>
Когда вы помечаете более одного файла, вы можете думать о метке
как о кривой, проведенной по таблице имен файлов и их номеров
ревизий.  Скажем, у нас есть пять файлов со следующими ревизиями:



<PRE>
        file1   file2   file3   file4   file5

        1.1     1.1     1.1     1.1  /--1.1*      &#60;-*-  TAG
        1.2*-   1.2     1.2    -1.2*-
        1.3  \- 1.3*-   1.3   / 1.3
        1.4          \  1.4  /  1.4
                      \-1.5*-   1.5
                        1.6
</PRE>

<P>
Когда-то в прошлом, ревизии, отмеченные звездочками, были
помечены.  Вы можете думать о метке, как о ручке, приделанной к
кривой, нарисованной на помеченных ревизиях.  Когда вы тянете за
ручку, вы получаете все помеченные ревизии.  Еще одним способом
представления является прямая линия, вдоль которой вы смотрите на
набор файлов, и вдоль которой выровнены помеченные ревизии,
например:



<PRE>
        file1   file2   file3   file4   file5

                        1.1
                        1.2
                1.1     1.3                       _
        1.1     1.2     1.4     1.1              /
        1.2*----1.3*----1.5*----1.2*----1.1     (--- &#60;--- Look here
        1.3             1.6     1.3              \_
        1.4                     1.4
                                1.5
</PRE>



<H2><A NAME="SEC49" HREF="cvs-ru_toc.html#TOC49">Что пометить в рабочем каталоге</A></H2>

<P>
<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
Пример в предыдущей секции демонстирует один из самых
распространенных способов выбрать, какие ревизии пометить, а
именно: выполнение команды <CODE>cvs tag</CODE> без параметров
заставляет CVS выбрать ревизии, которые извлечены в текущем
рабочем каталоге.  Например, если копия файла <TT>`backend.c'</TT> в
рабочем каталоге была извлечена из ревизии 1.4, то CVS
пометит ревизию 1.4.  Заметьте, что метка прилагается
непосредственно к ревизии 1.4 в репозитории.  Пометка -- это не
изменение файла, и не какая-либо операция, при которой сначала
модифицируется рабочий каталог, а затем команда <CODE>cvs commit</CODE> 
переносит изменения в репозиторий.


<P>
Возможно, неожиданным обстоятельством того факта, что <CODE>cvs
tag</CODE> оперирует с репозиторием, является то, что вы помечаете
извлеченные ревизии, которые могут отличаться от файлов,
измененных в вашем рабочем каталоге.  Если вы хотите избежать
ошибочного выполнения этой операции, укажите команде <CODE>cvs
tag</CODE> ключ командной строки <SAMP>`-c'</SAMP>.  Если в рабочем каталоге
имеются измененные файлы, CVS завершится с сообщением об
ошибке, не пометив ни одного файла:



<PRE>
$ cvs tag -c rel-0-4
cvs tag: backend.c is locally modified
cvs [tag aborted]: correct the above errors first!
</PRE>



<H2><A NAME="SEC50" HREF="cvs-ru_toc.html#TOC50">Как помечать по дате или ревизии</A></H2>
<P>
<A NAME="IDX256"></A>


<P>
Команда <CODE>cvs rtag</CODE> помечает репозиторий по состоянию на
определенную дату и время (может использоваться для пометки
последней ревизии).  <CODE>rtag</CODE> работает прямо с содержимым
репозитория (не требуется сначала извлекать рабочий каталог).


<P>
Нижеследующие ключи командной строки указывают, по какой дате или
номеру ревизии помечать.  См. section <A HREF="cvs-ru_16.html#SEC117">Стандартные ключи командной строки</A> за полным
их описанием.


<DL COMPACT>

<DT><CODE>-D <VAR>дата</VAR></CODE>
<DD>
Помечает самую новую ревизию не позднее <VAR>даты</VAR>.

<DT><CODE>-f</CODE>
<DD>
Полезно только вместе с <SAMP>`-D <VAR>дата</VAR>'</SAMP> или <SAMP>`-r
<VAR>метка</VAR>'</SAMP>.  Если не обнаружено соответствующей ревизии, вместо
игнорирования файла используется самая новая ревизия.

<DT><CODE>-r <VAR>метка</VAR></CODE>
<DD>
Помечать только файлы, содержащие существующую метку
<VAR>метка</VAR>.
</DL>

<P>
Команда <CODE>cvs tag</CODE> также позволяет выбрать файлы по ревизии
или по дате, используя те же ключи командной строки <SAMP>`-D'</SAMP> и
<SAMP>`-f'</SAMP>.  Однако, это, скорее всего, вовсе не то, что вам
надо, потому что <CODE>cvs tag</CODE> выбирает, какие файлы помечать,
основываясь на файлах, существующих в рабочем каталоге, а не на
файлах, существовавших на заданную дату или в заданной ревизии.
Таким образом, обычно лучше использовать <CODE>cvs rtag</CODE>.
Исключением могут быть случаи типа:



<PRE>
cvs tag -r 1.4 backend.c
</PRE>



<H2><A NAME="SEC51" HREF="cvs-ru_toc.html#TOC51">Удаление, перемещение и удаление меток</A></H2>

<P>
Обычно метки не изменяются.  Они существуют, чтобы хранить
историю репозитория, поэтому изменять и удалять их обычно не
нужно.


<P>
Однако же, могут быть случая, в которых метки используются лишь
временно или случайно помечаются неверные ревизии.  Таким
образом, нужно удалить, переместить или переименовать метку.
Предупреждение: команды в этой секции опасны, они навсегда
уничтожают информацию об истории и восстановление после ошибок
может быть трудным или невозможным.  Если вы -- администратор
CVS, вы можете захотеть ограничить использование этих команд
с помощью файла <TT>`taginfo'</TT> (see section <A HREF="cvs-ru_8.html#SEC77">Настройка журналирования</A>).


<P>
<A NAME="IDX257"></A>
<A NAME="IDX258"></A>
Чтобы удалить метку, задайте ключ командной строки <SAMP>`-d'</SAMP>
команде <CODE>cvs tag</CODE> или <CODE>cvs rtag</CODE>.  Например:



<PRE>
cvs rtag -d rel-0-4 tc
</PRE>

<P>
удаляет метку <CODE>rel-0-4</CODE> из модуля <CODE>tc</CODE>.


<P>
<A NAME="IDX259"></A>
<A NAME="IDX260"></A>
Когда мы говорим <EM>перемещение</EM> метки, мы хотим, чтобы
существующее имя указывало на другие ревизии.  Например, метка
<CODE>stable</CODE> может указывать на ревизию 1.4 файла
<TT>`backend.c'</TT>, а мы хотим, чтобы она указывала на ревизию 1.6.
Чтобы переместить метку, задайте ключ командной строки <SAMP>`-F'</SAMP>
командам <CODE>cvs tag</CODE> или <CODE>cvs rtag</CODE>.  Например,
вышеупомянутая задача может быть решена так:



<PRE>
cvs tag -r 1.6 -F stable backend.c
</PRE>

<P>
<A NAME="IDX261"></A>
<A NAME="IDX262"></A>
Когда мы говорим <EM>переименовать</EM> метку, мы хотим, чтобы
другое имя указывало на те же ревизии, что и существующее.
Например, мы могли ошибиться в написании имени метки и хотим
исправить его, пока остальные не начали его использовать.  Чтобы
переименовать метку, сначала создайте новую метку, используя
ключ командной строки <SAMP>`-r'</SAMP> команды <CODE>cvs rtag</CODE>, затем
удалите старое имя.  После этого новая метка указывает на точно
те же самые файлы, что и старая.  Например:



<PRE>
cvs rtag -r old-name-0-4 rel-0-4 tc
cvs rtag -d old-name-0-4 tc
</PRE>



<H2><A NAME="SEC52" HREF="cvs-ru_toc.html#TOC52">Пометки при добавлении и удалении файлов</A></H2>

<P>
Пометки довольно запутанно взаимодействуют с операциями
добавления и удаления файлов; в основном CVS отслеживает,
существует файл или нет, не особенно беспокоясь о пустяках.  По
умолчанию, помечаются только файлы, которые имеют ревизии,
соответствующие тому, что помечается.  Файлы, которые еще не
существуют или которые уже были удалены, просто пропускаются при
пометке, при этом CVS знает, что отсутствие метки означает,
что файл не существует в помеченном месте.


<P>
Однако, при этом можно потерять небольшое количество информации.
Например, предположим, что файл был добавлен, а затем удален.
Затем, если для этого файла отсутствует метка, нет способа
сказать, потому ли это, что метка соответствует времени перед
тем, как файл был добавлен, или после того, как он был удален.
Если вы выполните <CODE>cvs rtag</CODE> с ключом командной строки
<SAMP>`-r'</SAMP>, то CVS помечает файлы, которые были удалены,
избегая таким образом проблемы.  Например, можно указать <SAMP>`-r
HEAD'</SAMP>, чтобы пометить головную ревизию.


<P>
Команда <CODE>cvs rtag</CODE> имеет ключ командной строки <SAMP>`-a'</SAMP>,
очищающий метку с удаленных файлов, которые в противном случае не
были бы помечены.  Например, можно указать этот ключ вместе с
<SAMP>`-F'</SAMP> при перемещении метки.  Если переместить метку без
<SAMP>`-a'</SAMP>, то метка на удаленных файлах все еще ссылалась бы на
старую ревизию и не отражала бы того факта, что файл был удален.
Я не считаю, что это обязательно, если указано <SAMP>`-r'</SAMP>, как
отмечено выше.




<H2><A NAME="SEC53" HREF="cvs-ru_toc.html#TOC53">Липкие метки</A></H2>
<P>
<A NAME="IDX263"></A>
<A NAME="IDX264"></A>


<P>
Иногда ревизия, находящаяся в рабочем каталоге, содержит также
дополнительную информацию о себе: например, она может находиться
на ветке (see section <A HREF="cvs-ru_5.html#SEC54">Создание ветвей и слияние</A>), или же может быть
ограничена с помощью <SAMP>`checkout -D'</SAMP> или <SAMP>`update -D'</SAMP>
версиями, созданными ранее указанной даты.  Так как эта
информация сохраняется долговременно, то есть действует на
последующие команды над рабочей копией, то мы называем ее
<EM>липкой</EM>.


<P>
В большинстве случаев липкость -- это запутанный аспект
CVS, о котором вам не следует думать.  Однако, даже если вы
не желаете использовать эту возможность, вы все же захотите
что-нибудь узнать о липких метках (например, как их избежать!).


<P>
Можно использовать команду <CODE>status</CODE>, чтобы посмотреть, какие
установлены липкие метки или даты:



<PRE>
$ cvs status driver.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
    RCS Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

</PRE>

<P>
<A NAME="IDX265"></A>
<A NAME="IDX266"></A>
<A NAME="IDX267"></A>
Липкие метки остаются на ваших рабочих файлах до тех пор, пока вы 
не удалите их с помощью <SAMP>`cvs update -A'</SAMP>.  Опция <SAMP>`-A'</SAMP>
извлекает версию файла из головной ревизии ствола и забывает обо
всех липких метках, датах и ключах командной строки.


<P>
<A NAME="IDX268"></A>
Самое распространенное использование липких меток -- указать,
над какой ветвью идет работа, что описано в section <A HREF="cvs-ru_5.html#SEC57">Доступ к веткам</A>.  Однако, липкие метки также используются и без веток.
Предположим, например, что вы хотите избежать обновления вашего
рабочего каталога, чтобы защититься от изменений, которые делают
ваши коллеги.  Вы, конечно, можете просто не выполнять команду
<CODE>cvs update</CODE>.  Если же вы хотите избежать обновления только
части большого дерева, то липкие метки могут помочь.  Если вы
извлечете определенную ревизию, скажем, 1.4, то она станет
липкой.  Последующие команды <CODE>cvs update</CODE> не станут
извлекать последнюю ревизию до тех пор, пока вы не очистите метку
с помощью <CODE>cvs update -A</CODE>.  Точно так же, использование
ключа командной строки <SAMP>`-D'</SAMP> команд <CODE>update</CODE> и
<CODE>checkout</CODE> задает <EM>липкую дату</EM>, которая используется
для будущих извлечений.


<P>
Люди часто хотят извлечь старую версию файла без установки липкой
метки.  Это можно сделать с помощью ключа командной строки
<SAMP>`-p'</SAMP> команд <CODE>checkout</CODE> или <CODE>update</CODE>, которая
посылает содержимое файла на стандартный вывод.  Например:



<PRE>
$ cvs update -p -r 1.1 file1 &#62;file1
===================================================================
Checking out file1
RCS:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
VERS: 1.1
***************
$
</PRE>

<P>
Однако, это не самый простой способ, если вы спрашиваете, как
отменить последнее фиксирование (в этом примере -- поместить
<TT>`file1'</TT> обратно в то состояние, в котором он был в ревизии
1.1). В этом случае лучше будет использовать ключ командной
строки <SAMP>`-j'</SAMP> команды <CODE>update</CODE>; дальнейшее обсуждение
находится в section <A HREF="cvs-ru_5.html#SEC62">Слияние изменений между двумя ревизиями</A>.


<P><HR><P>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_3.html">previous</A>, <A HREF="cvs-ru_5.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
