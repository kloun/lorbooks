<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 11 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями - Справочник по административным файлам</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_17.html">previous</A>, <A HREF="cvs-ru_19.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC153" HREF="cvs-ru_toc.html#TOC153">Справочник по административным файлам</A></H1>
<P>
<A NAME="IDX554"></A>
<A NAME="IDX555"></A>
<A NAME="IDX556"></A>
<A NAME="IDX557"></A>


<P>
В репозитории CVS в каталоге <TT>`$CVSROOT/CVSROOT/'</TT>
находится несколько вспомогательных файлов.  При работе с
CVS эти файлы можно и не использовать, но, будучи правильно
настроенными, они способны сильно облегчить вам жизнь.  Методика
редактирования таких файлов обсуждается в section <A HREF="cvs-ru_18.html#SEC153">Справочник по административным файлам</A>.


<P>
Самым важным таким файлом является <TT>`modules'</TT>, которые
описывает модули, находящиеся в репозитории.




<H2><A NAME="SEC154" HREF="cvs-ru_toc.html#TOC154">Файл <TT>`modules'</TT></A></H2>
<P>
<A NAME="IDX558"></A>
<A NAME="IDX559"></A>
<A NAME="IDX560"></A>


<P>
В файле <TT>`modules'</TT> находится описание модулей, то есть
коллекций исходных текстов.  Файл модулей можно редактировать
обычным для административных файлов способом.


<P>
Файл <TT>`modules'</TT> может содержать пустые строки и комментарии
(строки, начинающиеся с <SAMP>`#'</SAMP>), а также описания модулей.
Длинные описания можно разбивать на несколько строк, используя
обратную косую черту (<SAMP>`\'</SAMP>) в качестве последнего символа в
строке.


<P>
Существует три основных типа модулей: модули-синонимы, обычные
модули и амперсенд-модули.  Разница между ними заключается в
способе сопоставления файлов в репозитории файлам в рабочем
каталоге.  В нижеприведенных примерах в репозитории находится
каталог <TT>`first-dir/'</TT>, содержащий два файла, <TT>`file1'</TT> и
<TT>`file2'</TT>, а также каталог <TT>`sdir/'</TT>.
<TT>`first-dir/sdir/'</TT> содержит также файл <TT>`sfile'</TT>.




<H3><A NAME="SEC155" HREF="cvs-ru_toc.html#TOC155">Модули-синонимы</A></H3>
<P>
<A NAME="IDX561"></A>
<A NAME="IDX562"></A>
<A NAME="IDX563"></A>
<A NAME="IDX564"></A>


<P>
Модули синонимы -- это самый простой вид модулей:


<DL COMPACT>

<DT><CODE><VAR>mname</VAR> -a <VAR>aliases</VAR>...</CODE>
<DD>
Это -- простейший путь описания модуля <VAR>mname</VAR>.  Флаг
<SAMP>`-a'</SAMP> означает, что новый модуль будет лишь синонимом для
указанного списка модулей: CVS будет обращаться с
<VAR>mname</VAR>, указанным в командной строке, точно так же, как если 
бы вместо него был указан список <VAR>aliases</VAR>.  <VAR>aliases</VAR>
может содержать имена других модулей или имена каталогов.  При
использовании имен каталогов CVS создает промежуточные
каталоги в рабочем каталоге, как если бы путь был задан явно в
командной строке.
</DL>

<P>
Например, если файл <TT>`modules'</TT> содержит строку



<PRE>
amodule -a first-dir
</PRE>

<P>
то следующие две команды эквивалентны:



<PRE>
$ cvs co amodule
$ cvs co first-dir
</PRE>

<P>
и обе выдадут одинаковые сообщения:

<PRE>
cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
</PRE>



<H3><A NAME="SEC156" HREF="cvs-ru_toc.html#TOC156">Обычные модули</A></H3>
<P>
<A NAME="IDX565"></A>


<DL COMPACT>

<DT><CODE><VAR>mname</VAR> [ options ] <VAR>dir</VAR> [ <VAR>files</VAR>... ]</CODE>
<DD>
В простейшем случае эта форма описания модуля сокращается до
<SAMP>`<VAR>mname</VAR> <VAR>dir</VAR>'</SAMP>.  В этом случае файлы в каталоге
<VAR>dir</VAR> становятся модулем <VAR>mname</VAR>.  <VAR>dir</VAR> -- путь к
каталогу с исходными текстами, относительно <CODE>$CVSROOT</CODE>.  При
извлечении исходных текстов в рабочем каталоге создается каталог
<VAR>mname</VAR>; по умолчанию не используются промежуточные каталоги,
даже если <VAR>dir</VAR> состоит из нескольких уровней каталогов.
</DL>

<P>
Например, если модуль описан как



<PRE>
regmodule first-dir
</PRE>

<P>
то <VAR>regmodule</VAR> будет содержать файлы из <TT>`first-dir/'</TT>:



<PRE>
$ cvs co regmodule
cvs checkout: Updating regmodule
U regmodule/file1
U regmodule/file2
cvs checkout: Updating regmodule/sdir
U regmodule/sdir/sfile
$
</PRE>

<P>
Явно указывая в описании модуля после имени каталога имена
файлов, можно извлекать их из каталога по отдельности.  Вот
пример:



<PRE>
regfiles first-dir/sdir sfile
</PRE>

<P>
При таком описании извлечение модуля <VAR>regfiles</VAR> создает
единственный рабочий каталог <TT>`regfiles'</TT>, содержащий
указанный файл, который берется из каталога
<TT>`first-dir/sdir/'</TT>, находящегося в репозитории:



<PRE>
$ cvs co regfiles
U regfiles/sfile
$
</PRE>



<H3><A NAME="SEC157" HREF="cvs-ru_toc.html#TOC157">Амперсенд-модули</A></H3>
<P>
<A NAME="IDX566"></A>
<A NAME="IDX567"></A>


<P>
Описание модуля может ссылаться на другие модули, используя
запись <SAMP>`&#38;<VAR>module</VAR>'</SAMP>.

<PRE>
<VAR>mname</VAR> [ options ] <VAR>&#38;module</VAR>...
</PRE>

<P>
При извлечении такого модуля для каждого амперсенд-модуля
создается соответствующий подкаталог.  Например, если файл
<TT>`modules'</TT> содержит строчку



<PRE>
ampermod &#38;first-dir
</PRE>

<P>
то при извлечении будет создан каталог <TT>`ampermod/'</TT>,
содержащий каталог, который называется <TT>`first-dir/'</TT>,
который, в свою очередь, содержит все каталоги и файлы,
находящиеся в этом каталоге.  Например, команда



<PRE>
$ cvs co ampermod
</PRE>

<P>
создат следующие файлы:



<PRE>
ampermod/first-dir/file1
ampermod/first-dir/file2
ampermod/first-dir/sdir/sfile
</PRE>

<P>
В реализации CVS есть одна ошибка: сообщения, которые выдает 
CVS, не содержат упоминания <TT>`ampermod/'</TT>, и поэтому
неправильно сообщают о местонахождении извлеченных файлов:



<PRE>
$ cvs co ampermod
cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
$
</PRE>

<P>
Не полагайтесь на такое ошибочное поведение; в будущих версиях
CVS оно может быть исправлено.




<H3><A NAME="SEC158" HREF="cvs-ru_toc.html#TOC158">Исключение каталогов из списка</A></H3>
<P>
<A NAME="IDX568"></A>
<A NAME="IDX569"></A>


<P>
Модуль-синоним может исключить определенные каталоги из модулей,
используя восклицательный знак (<SAMP>`!'</SAMP>) перед именем каждого
исключенного каталога.


<P>
Например, если файл <TT>`modules'</TT> содержит



<PRE>
exmodule -a !first-dir/sdir first-dir
</PRE>

<P>
то при извлечении модуля <SAMP>`exmodule'</SAMP> будут извлечено все
содержимое <TT>`first-dir/'</TT>, кроме файлов из каталога
<SAMP>`first-dir/sdir'</SAMP>.




<H3><A NAME="SEC159" HREF="cvs-ru_toc.html#TOC159">Флаги модулей</A></H3>
<P>
<A NAME="IDX570"></A>


<P>
Описание обычных и амперсенд-модулей может содержать флаги,
предоставляющие дополнительную информацию о модуле.


<DL COMPACT>

<DT><CODE>-d <VAR>name</VAR></CODE>
<DD>
<A NAME="IDX571"></A>
 
Дать рабочему каталогу другое имя, отличающееся от имени модуля. 

<A NAME="IDX572"></A>
<A NAME="IDX573"></A>
<DT><CODE>-e <VAR>prog</VAR></CODE>
<DD>
Задает программу <VAR>prog</VAR>, которая выполняется при экспорте
модуля.  <VAR>prog</VAR> выполняется с единственным аргументом, именем 
модуля.

<A NAME="IDX574"></A>
<A NAME="IDX575"></A>
<DT><CODE>-i <VAR>prog</VAR></CODE>
<DD>
Задает программу <VAR>prog</VAR>, которая выполняется, когда изменения 
в файлах модуля помещаются в репозиторий.  <VAR>prog</VAR> выполняется 
с полным именем соответствующего каталога (??? а не файла?) в
репозитории.  Файлы <TT>`commitinfo'</TT>, <TT>`loginfo'</TT> и
<TT>`verifymsg'</TT> обеспечивают дополнительные способы выполнения
программ при фиксировании.

<A NAME="IDX576"></A>
<A NAME="IDX577"></A>
<DT><CODE>-o <VAR>prog</VAR></CODE>
<DD>
Задает программу <VAR>prog</VAR>, которая выполняется, когда файлы
модуля извлекаются в рабочий каталог.  <VAR>prog</VAR> выполняется с
единственным аргументом, именем модуля.

<A NAME="IDX578"></A>
<A NAME="IDX579"></A>
<A NAME="IDX580"></A>
<DT><CODE>-s <VAR>status</VAR></CODE>
<DD>
Задает статус модуля.  Когда файл модулей выдается на экран с
помощью <SAMP>`cvs checkout -s'</SAMP>, модули в нем отсортированы по
статусу, а затем по имени модуля.  Этот ключ не имеет какого-либо 
другого значения.  Этот ключ можно использовать для нескольких
вещей, помимо статуса модуля: например, перечислить людей,
ответственных за модуль.

<A NAME="IDX581"></A>
<A NAME="IDX582"></A>
<DT><CODE>-t <VAR>prog</VAR></CODE>
<DD>
Задает программу <VAR>prog</VAR>, которая выполняется, когда файлы в
модуле помечаются с помощью команды <CODE>rtag</CODE>.  <VAR>prog</VAR>
выполняется с двумя аргументами: именем модуля и именем метки,
указанной в команде <CODE>rtag</CODE>.  Эта программа <EM>не</EM>
выполняется, когда дается команда <CODE>tag</CODE>.  Обычно лучше
использовать файл <TT>`taginfo'</TT> (see section <A HREF="cvs-ru_8.html#SEC77">Настройка журналирования</A>).

<A NAME="IDX583"></A>
<A NAME="IDX584"></A>
<DT><CODE>-u <VAR>prog</VAR></CODE>
<DD>
Задает програму, которая выполняется, когда команда <SAMP>`cvs
update'</SAMP>, выполняется в основном каталоге извлеченного модуля.
<VAR>prog</VAR> выполняется с единственным аргументом, полным путем к
указанному модулю в репозитории.
</DL>



<H2><A NAME="SEC160" HREF="cvs-ru_toc.html#TOC160">Файл <TT>`cvswrappers'</TT></A></H2>
<P>
<A NAME="IDX585"></A>
<A NAME="IDX586"></A>
<A NAME="IDX587"></A>
<A NAME="IDX588"></A>
<A NAME="IDX589"></A>


<P>
<EM>Обертки</EM> -- это возможность CVS, позволяющая управлять 
определенными настройками, основываясь на имени обрабатываемого
файла.  В список таких настроке входят ключи <SAMP>`-k'</SAMP> для
двоичных файлов и <SAMP>`-m'</SAMP> для файлов, которые нельзя
автоматически объединять.


<P>
Ключ <SAMP>`-m'</SAMP> задает метод объединения, который нужно
использовать при обновлении не-двоичного файла.  <SAMP>`MERGE'</SAMP>
означает обычное поведение CVS: попробовать объединить
файлы.  <SAMP>`COPY'</SAMP> означает, что <CODE>cvs update</CODE> откажется
объединять файлы, точно так же, как это происходит с двоичными
файлами, описанными с помощью ключа <SAMP>`-kb'</SAMP> (если файл описан
как двоичный, то использовать <SAMP>`-m 'COPY''</SAMP> необязательно).
CVS предоставит пользователю две версии файлов, и потребует
вручную внести необходимые изменения, пользуясь внешними по
отношению к CVS инструментами.  <STRONG>Предупреждение:</STRONG> не
используйте <SAMP>`COPY'</SAMP> с CVS версии 1.9 и раньше -- они
просто перезапишут один файл поверх другого, уничтожая старое
содержимое. 
Ключ <SAMP>`-m'</SAMP> влияет только на поведение при обновлении, не
затрагивая способ хранения файла.  См. section <A HREF="cvs-ru_9.html#SEC79">Обработка двоичных файлов</A>, где
описана работа с ними.


<P>
В основном формат файла <TT>`cvswrappers'</TT> таков:



<PRE>
маска_файла     [ключ значение][ключ значение]...
</PRE>

<P>
где ключ -- это


<DL COMPACT>

<DT><CODE>-m</CODE>
<DD>
способ обновления (<SAMP>`MERGE'</SAMP> или <SAMP>`COPY'</SAMP>)

<DT><CODE>-k</CODE>
<DD>
способ подстановки ключевых слов (See section <A HREF="cvs-ru_12.html#SEC97">Подстановка ключевых слов</A>).
</DL>

<P>
а значение заключено в одиночные кавычки.


<P>
Например, нижеследующая команда импортирует каталог, считая
файлы, заканчивающиеся на <SAMP>`.exe'</SAMP>, двоичными:



<PRE>
cvs import -I ! -W "*.exe -k 'b'" first-dir vendortag reltag
</PRE>



<H2><A NAME="SEC161" HREF="cvs-ru_toc.html#TOC161">Выполнение программ на разных стадиях фиксирования</A></H2>
<P>
<A NAME="IDX590"></A>


<P>
Флаг <SAMP>`-i'</SAMP> в файле <TT>`modules'</TT> может использоваться для
выполнения определенной программы, когда соответствующие файлы
помещаются в репозиторий (see section <A HREF="cvs-ru_18.html#SEC154">Файл <TT>`modules'</TT></A>).  Файлы,
описанные в этой секции, обеспечивают другие, более гибкие
способы выполнения программ при фиксировании.


<P>
Есть три вида программ, которые можно выполнять при
фиксировании.  Они указываются в файлах в репозитории, как
описано ниже.  В этой таблице находится сводка таких файлов и
назначение соответствующих программ:


<DL COMPACT>

<DT><TT>`commitinfo'</TT>
<DD>
Программа, ответственная за проверку, разрешена ли команда
фиксирования изменений.  Если эта программа заканчивается с
ненулевым кодом завершения, фиксирование будет прервано.

<DT><TT>`verifymsg'</TT>
<DD>
Указанная программа используется для проверки журнального
сообщения, чтобы убедиться, что оно содержит все требуемые поля.
Полезно использовать этот файл в комбинации с <TT>`rcsinfo'</TT>,
который может содержать шаблон журнального сообщения (see section <A HREF="cvs-ru_18.html#SEC170">Файл rcsinfo</A>).

<DT><TT>`editinfo'</TT>
<DD>
Заданная программа используется для редактирования журнального
сообщения, и, возможно, проверки, что оно содержит все требуемые
поля.  Это особенно полезно в комбинации с файлом <TT>`rcsinfo'</TT>,
который может содержать шаблон журнального сообщения (see section <A HREF="cvs-ru_18.html#SEC170">Файл rcsinfo</A>).  Устарело.

<DT><TT>`loginfo'</TT>
<DD>
Указанная программа вызывается, когда завершено фиксирование.
Она получает журнальное сообщение и дополнительную информацию, и
может сохранить сообщение в файле, отправить его по почте
ответственному человеку, поместить в местной группе новостей,
или...  Пределом является только ваше воображение!
</DL>



<H3><A NAME="SEC162" HREF="cvs-ru_toc.html#TOC162">Обычный синтаксис</A></H3>
<P>
<A NAME="IDX591"></A>
<A NAME="IDX592"></A>
<A NAME="IDX593"></A>


<P>
Административные файлы, такие как <TT>`commitinfo'</TT>,
<TT>`loginfo'</TT>, <TT>`rcsinfo'</TT>, <TT>`verifymsg'</TT>, и т. д., все
имеют общий формат.  Назначение этих файлов описано позднее, а
здесь описан их общий синтаксис.


<P>
<A NAME="IDX594"></A>
Каждая строка содержит следующее:

<UL>
<LI>

Регулярное выражение: простое регулярное выражение, использующее
синтаксис GNU emacs.

<LI>

Разделитель -- один или больше пробелов или символов табуляции.

<LI>

Имя файла или шаблон командной строки.
</UL>

<P>
Пустые строки игнориуются.  Строки, которые начинаются с символа
<SAMP>`#'</SAMP>, считаются комментариями.  Длинные строки, к сожалению,
<EM>не</EM> могут быть разбиты на части.


<P>
Используется первое регулярное выражение, которое совпадает с
именем текущего каталога в репозитории.  Остаток строки
используется, соответственно, как имя файла или командная строка.




<H2><A NAME="SEC163" HREF="cvs-ru_toc.html#TOC163">Файл <TT>`commitinfo'</TT></A></H2>
<P>
<A NAME="IDX595"></A>
<A NAME="IDX596"></A>
<A NAME="IDX597"></A>
<A NAME="IDX598"></A>


<P>
Файл <TT>`commitinfo'</TT> описывает программы, которые выполняются
перед тем, как команда <SAMP>`cvs commit'</SAMP> выполняет свою работу.
Эти программы используются перед фиксированием изменений для
проверки, чтоы измененный, добавленные и удаленные файлы
действительно готовы к фиксированию.  Это можно использовать,
например, чтобы убедиться, что измененные файлы соответствуют
стандартам кодирования, принятым в вашей организации.


<P>
Как упоминалось ранее, каждая строка в файле <TT>`commitinfo'</TT>
состоит из регулярного выражения и шаблона командной строки.
Шаблон может включать имя программы и аргументы, которые вы
хотите передать этой программе.  К шаблону добалвяется полный
путь к текущему репозиторию, за которым следуют имена файлов,
участвующих в фиксировании (добавленные, удаленные и измененные).


<P>
<A NAME="IDX599"></A>
Используется первая строка с регулярным выражением,
соответствующим каталогу в репозитории.  Если команда возвращает
ненулевой код выхода, то фиксирование будет прервано.


<P>
<A NAME="IDX600"></A>
Если имя репозитория не соответствует ни одному регулярному
выражению в этом файле, то используется строка <SAMP>`DEFAULT'</SAMP>,
если она есть.


<P>
<A NAME="IDX601"></A>
Помимо совпадающих строк, используются также все строки,
начинающиеся с <SAMP>`ALL'</SAMP>.


<P>
Замечание: когда CVS обращается к сетевому репозиторию,
<TT>`commitinfo'</TT> будет выполняться на сервере, а не на клиенте
(see section <A HREF="cvs-ru_2.html#SEC26">Сетевые репозитории</A>).




<H2><A NAME="SEC164" HREF="cvs-ru_toc.html#TOC164">Проверка журнальных записей</A></H2>
<P>
<A NAME="IDX602"></A>
<A NAME="IDX603"></A>
<A NAME="IDX604"></A>


<P>
Когда вы ввели журнальное сообщение, вы можете проверить его,
чтобы убедиться, что в нем представлена вся необходимая
информация, такая, как номера исправленных ошибок и т. п.


<P>
Файл <TT>`verifymsg'</TT> полезнее всего использовать вместе с файлом 
<TT>`rcsinfo'</TT>, который используется в качестве шаблона
журнального сообщения.


<P>
Каждая строка в файле <TT>`verifymsg'</TT> состоит из регулярного
сообщения и шаблона команды.  В шаблоне должно присутствовать имя
программы и, возможно, несколько аргументов.  К шаблону
добавляется полный имя файла с шаблоном журнального сообщения.


<P>
Следует заметить, что ключевое слово <SAMP>`ALL'</SAMP> не
поддерживается.  Если найдено более одной совпадающей строки,
используется первая.  Это полезно для указания скрипта проверки,
используемого по умолчанию, а затем переопределения его в
подкаталоге.


<P>
<A NAME="IDX605"></A>
Если имя репозитория не совпадает ни с одним регулярным
выражением в этом файле, то используется строка <SAMP>`DEFAULT'</SAMP>,
если она есть.


<P>
<A NAME="IDX606"></A>
Если проверочный скрипт завершается с ненулевым кодом завершения, 
то процесс фиксирования завершается.


<P>
Заметьте, что скрипт верификации не может изменять журнальное
сообщение, но лишь принимать или отвергать его.


<P>
Вот простой пример файла <TT>`verifymsg'</TT>, использующегося вместе
с соответствующим шаблоном журнальной записи в файле
<TT>`rcsinfo'</TT> и скриптом проверки этой записи.  Сначала ---
шаблон журнальной записи.  Нам нужно, чтобы в первой строке этой
записи находился номер исправленной ошибки.  Остаток журнальной
записи -- в свободной форме.  Вот такой шаблон находится в файле 
<TT>`/usr/cvssupport/tc.template'</TT>:



<PRE>
BugId:
</PRE>

<P>
Скрипт <TT>`/usr/cvssupport/bugid.verify'</TT> используется для
проверки журнального сообщения.



<PRE>
#!/bin/sh
#
#       bugid.verify filename
#
#  Verify that the log message contains a valid bugid
#  on the first line.
#
if head -1 &#60; $1 | grep '^BugId:[ ]*[0-9][0-9]*$' &#62; /dev/null; then
    exit 0
else
    echo "No BugId found."
    exit 1
fi
</PRE>

<P>
Файл <TT>`verifymsg'</TT> содержит строку:



<PRE>
^tc     /usr/cvssupport/bugid.edit
</PRE>

<P>
Файл <TT>`rcsinfo'</TT> содержит такую строку:



<PRE>
^tc     /usr/cvssupport/tc.template
</PRE>



<H2><A NAME="SEC165" HREF="cvs-ru_toc.html#TOC165">Файл <TT>`editinfo'</TT></A></H2>
<P>
<A NAME="IDX607"></A>
<A NAME="IDX608"></A>
<A NAME="IDX609"></A>


<P>
<EM>ЗАМЕЧАНИЕ:</EM> использование <TT>`editinfo'</TT> устарело.  Для
задания редактора журнальных записей по умолчанию используйте
переменную окружения <CODE>EDITOR</CODE> (see section <A HREF="cvs-ru_19.html#SEC175">Все переменные окружения, используемые в CVS</A>)
или глобальный ключ <SAMP>`-e'</SAMP> (see section <A HREF="cvs-ru_16.html#SEC116">Глобальные ключи командной строки</A>)
См. section <A HREF="cvs-ru_18.html#SEC164">Проверка журнальных записей</A>, где описано, как использовать
<TT>`verifymsg'</TT>.


<P>
Если вы хотите убедиться, что все журнальные сообщения выглядят
одинаково, то можете использовать файл <TT>`editinfo'</TT>, чтобы
задать программу, используемую для редактирования этих сообщений.
Этой программой может быть текстовый редактор, настроенный
специальным образом, или небольшой скрипт, который вызывает
редактор и проверяет, что введенное сообщение содержит все
требуемые поля.


<P>
Если в файле <TT>`editinfo'</TT> не найдено совпадающей строки,
используется редактор, заданный переменной окружения
<CODE>$CVSEDITOR</CODE>.  Если эта переменная не установлена,
используется переменная окружения <CODE>$EDITOR</CODE>.  Если и эта
переменная не установлена, используется редактор по умолчанию
(См. section <A HREF="cvs-ru_1.html#SEC6">Фиксирование изменений</A>).


<P>
Файл <TT>`editinfo'</TT> наиболее полезно использовать вместе с
файлом <TT>`rcsinfo'</TT>, который используется в качестве шаблона
журнального сообщения.


<P>
Каждая строка в файле <TT>`editinfo'</TT> состоит из регулярного
выражения и шаблона команды, состоящего из имени программы и,
возможно, нескольких аргументов.  К шаблону программы добавляется
полное имя текущего шаблона журнального сообщения.


<P>
Следует заметить, что ключевое слово <SAMP>`ALL'</SAMP> не
поддерживается.  Если совпадает более одной строки, используется
первая.  Это полезно для задания скрипта редактирования по
умолчанию, а затем переопределения его в подкаталоге.


<P>
<A NAME="IDX610"></A>
Если имя каталога в репозитории не совпадает ни с одним
регулярным выражением в этом файле, то используется строка
<SAMP>`DEFAULT'</SAMP>, если она есть.


<P>
Если скрипт редактирования завершается с ненулевым кодом
завершения, то процесс фиксирования аварийно завершается.


<P>
Заметьте, что когда CVS обращается к сетевому репозиторию,
или когда используются ключи <SAMP>`-m'</SAMP> и <SAMP>`-F'</SAMP> команды
<CODE>cvs commit</CODE>, то файл <TT>`editinfo'</TT> не используется.
Вместо него можно использовать <TT>`verifymsg'</TT>.




<H3><A NAME="SEC166" HREF="cvs-ru_toc.html#TOC166">Пример использования Editinfo</A></H3>

<P>
Ниже следует небольшой глупый пример файла <TT>`editinfo'</TT>,
вместе с соответствующим шаблоном журнального сообщения в файле
<TT>`rcsinfo'</TT> и скрипт редактора.  Мы начнем с шаблона
журнального сообщения.  Предположим, мы хотим хранить номер
исправленной ошибки в первой строке журнального сообщения.
Остаток журнального сообщения содержит любой описательный текст.
В файле <TT>`/usr/cvssupport/tc.template'</TT> находится такой
шаблон:



<PRE>
BugId:
</PRE>

<P>
Скрипт <TT>`/usr/cvssupport/bugid.edit'</TT> используется для
редактирования журнального сообщения.



<PRE>
#!/bin/sh
#
#       bugid.edit filename
#
#  Call $EDITOR on FILENAME, and verify that the
#  resulting file contains a valid bugid on the first
#  line.
if [ "x$EDITOR" = "x" ]; then EDITOR=vi; fi
if [ "x$CVSEDITOR" = "x" ]; then CVSEDITOR=$EDITOR; fi
$CVSEDITOR $1
until head -1|grep '^BugId:[ ]*[0-9][0-9]*$' &#60; $1
do  echo -n  "No BugId found.  Edit again? ([y]/n)"
    read ans
    case ${ans} in
        n*) exit 1;;
    esac
    $CVSEDITOR $1
done
</PRE>

<P>
Файл <TT>`editinfo'</TT> содержит такую строчку:



<PRE>
^tc     /usr/cvssupport/bugid.edit
</PRE>

<P>
Файл <TT>`rcsinfo'</TT> содержит такую строчку:



<PRE>
^tc     /usr/cvssupport/tc.template
</PRE>



<H2><A NAME="SEC167" HREF="cvs-ru_toc.html#TOC167">Файл loginfo</A></H2>
<P>
<A NAME="IDX611"></A>
<A NAME="IDX612"></A>
<A NAME="IDX613"></A>
<A NAME="IDX614"></A>
<A NAME="IDX615"></A>


<P>
Файл <TT>`loginfo'</TT> используется для управления тем, куда
посылается журнальная информация при выполнении <SAMP>`cvs
commit'</SAMP>.  В левой части строки находится регулярное выражение, с
которым совпадает имя каталога, в котором производится изменение,
относительно <CODE>$CVSROOT</CODE>.  Остаток соответствующей строки --
это программа-фильтр, которая получает журнальное сообщение на
стандартный ввод.


<P>
Если имя в репозитории не совпадает ни с одним регулярным
выражением, используется строка <SAMP>`DEFAULT'</SAMP>, если она есть.


<P>
Все строки, начинающиеся с <SAMP>`ALL'</SAMP>, используются вдобавок к
обычным строкам с совпадающим регулярным выражением, и со строкой 
<SAMP>`DEFAULT'</SAMP>.


<P>
Используется первое совпадающее регулярное выражение.


<P>
See section <A HREF="cvs-ru_18.html#SEC161">Выполнение программ на разных стадиях фиксирования</A>, где описан синтаксис файла
<TT>`loginfo'</TT>.


<P>
Пользователь может использовать в имени команды форматные
строки.  Такие строки состоят из символа <SAMP>`%'</SAMP>, за которым
следует пробел, одиночный форматный символ или набор форматных
символов, заключенных в скобки <SAMP>`{'</SAMP> и <SAMP>`}'</SAMP>.  Форматные
символы таковы:


<DL COMPACT>

<DT><TT>s</TT>
<DD>
имя файла
<DT><TT>V</TT>
<DD>
старый номер ревизии (перед фиксированием)
<DT><TT>v</TT>
<DD>
новый номер ревизии (после фиксирования)
</DL>

<P>
Все прочие символы, появляющиеся в форматной строке, превращаются 
в пустые строки (запятые, разделяющие их, сохраняются).


<P>
Например, можно использовать форматные строки <SAMP>`%'</SAMP>,
<SAMP>`%s'</SAMP>, <SAMP>`%{s}'</SAMP> и <SAMP>`%{sVv}'</SAMP>.


<P>
На выходе образуется строка токенов, разделенных пробелами.  Для
обратной совместимости первый токен -- это имя репозитория,
остальные -- список запрошенных в форматной строке полей,
разделенных запятыми.  Например, если репозиторий находится в
<SAMP>`/u/src/master'</SAMP>, форматная строка <SAMP>`%{sVv}'</SAMP>, а были
изменены три файла, (<TT>`ChangeLog'</TT>, <TT>`Makefile'</TT> и
<TT>`foo.c'</TT>), то на выходе появится



<PRE>
/u/src/master ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13
</PRE>

<P>
В качестве другого примера:  <SAMP>`%{}'</SAMP> означает, что на выходе 
появится только имя репозитория.


<P>
Замечание: когда CVS обращается к сетевому репозиторию, то
<TT>`loginfo'</TT> будет исполнен на стороне сервера, а не на стороне 
клиента (see section <A HREF="cvs-ru_2.html#SEC26">Сетевые репозитории</A>).




<H3><A NAME="SEC168" HREF="cvs-ru_toc.html#TOC168">Пример использования loginfo</A></H3>

<P>
Нижеследующий файл <TT>`loginfo'</TT> с помощью крохотного скрипта
добавляет журнальные сообщения к файлу
<TT>`$CVSROOT/CVSROOT/commitlog'</TT>, а также журналирует в
<TT>`/usr/adm/cvsroot-log'</TT> фиксирование изменений в
административных файлах.  Журнальные записи, соответствующие
фиксированию изменений в каталоге <TT>`prog1/'</TT> отсылаются по
почте пользователю <SAMP>`ceder'</SAMP>.



<PRE>
ALL             /usr/local/bin/cvs-log $CVSROOT/CVSROOT/commitlog $USER
^CVSROOT        /usr/local/bin/cvs-log /usr/adm/cvsroot-log
^prog1          Mail -s %s ceder
</PRE>

<P>
Скрипт <TT>`/usr/local/bin/cvs-log'</TT> выглядит так:



<PRE>
#!/bin/sh
(echo "------------------------------------------------------";
 echo -n $2"  ";
 date;
 echo;
 cat) &#62;&#62; $1
</PRE>



<H3><A NAME="SEC169" HREF="cvs-ru_toc.html#TOC169">Обновление извлеченной копии</A></H3>

<P>
<A NAME="IDX616"></A>
<A NAME="IDX617"></A>
<A NAME="IDX618"></A>


<P>
Часто бывает полезно хранить дерево каталогов, содержащее файлы,
соответствующие последней версии из репозитория.  Например,
другие разработчики могут захотеть обращаться к последним версиям
исходных текстов без необходимости извлекать их, или же вы можете
обслуживать с помощью CVS web-сайт и хотели бы, чтобы каждое 
зафиксированное изменение приводило бы к обновлению файлов,
которые показываются web-сервером.


<P>
Можно настроить такое поведение с помощью <TT>`loginfo'</TT>, который 
будет вызывать <CODE>cvs update</CODE>.  Если сделать это напрямую, то
возникнет проблема с блокировками, поэтому <CODE>cvs update</CODE>
должен выполняться на фоне.
Вот пример для операционной системы UNIX (всё это должно
помещаться на одной строке):



<PRE>
^cyclic-pages		(date; cat; (sleep 2; cd /u/www/local-docs;
 cvs -q update -d) &#38;) &#62;&#62; $CVSROOT/CVSROOT/updatelog 2&#62;&#38;1
</PRE>

<P>
При такой конфигурации фиксироване изменений в каталогах
репозитория, которые начинаются с <SAMP>`cyclic-pages'</SAMP> приведет к
обновлению извлеченного дерева, находящегося в
<TT>`/u/www/local-docs'</TT>.




<H2><A NAME="SEC170" HREF="cvs-ru_toc.html#TOC170">Файл rcsinfo</A></H2>
<P>
<A NAME="IDX619"></A>
<A NAME="IDX620"></A>
<A NAME="IDX621"></A>
<A NAME="IDX622"></A>


<P>
Файл <TT>`rcsinfo'</TT> может использоваться, чтобы задать форму,
которая редактируется при заполнении журнала фиксирований.  Файл
<TT>`rcsinfo'</TT> имеет синтаксис, подобный синтаксису файлов
<TT>`verifymsg'</TT>, <TT>`commitinfo'</TT> и <TT>`loginfo'</TT>.
See section <A HREF="cvs-ru_18.html#SEC162">Обычный синтаксис</A>.  В отличие от остальных файлов, правая часть
строки является не шаблоном команды, но полным именем файла,
содержащего шаблон журнального сообщения.


<P>
Если имя в репозитории не соответствует ни одному регулярному
выражению в этом файле, используется строка <SAMP>`DEFAULT'</SAMP>, если
она есть.


<P>
Все строки, начинающиеся с <SAMP>`ALL'</SAMP>, используются вдобавок к
первому совпадающему регулярному выражению или строке
<SAMP>`DEFAULT'</SAMP>.


<P>
Шаблон журнального сообщения будет использоваться по умолчанию.
Если вы зададите журнальное сообщение с помощью <SAMP>`cvs commit
-m <VAR>message</VAR>'</SAMP> или <SAMP>`cvs commit -f <VAR>file</VAR>'</SAMP>, то вместо
шаблона будет использоватсья именно оно.


<P>
See section <A HREF="cvs-ru_18.html#SEC164">Проверка журнальных записей</A>, где приведен пример файла <TT>`rcsinfo'</TT>.


<P>
Когда CVS обращается к сетевому репозиторию, используется то
содержимое файла <TT>`rcsinfo'</TT>, которое было, когда каталог был
извлечен в последний раз.  Если вы редактируете <TT>`rcsinfo'</TT>
или шаблоны, которые используются в нем, вам потребуется заново
извлечь рабочий каталог.




<H2><A NAME="SEC171" HREF="cvs-ru_toc.html#TOC171">Игнорирование файлов с помощью cvsignore</A></H2>
<P>
<A NAME="IDX623"></A>
<A NAME="IDX624"></A>
<A NAME="IDX625"></A>
<A NAME="IDX626"></A>


<P>
Есть определенные имена файлов, которые постоянно находятся в
вашем рабочем каталоге, но которые вы не хотите помещать под
контроль версий.  Примерами являются объектные файлы,
получающиеся после компиляции.  Обычно когда вы выполняете
команду <SAMP>`cvs update'</SAMP>, она выдает по строке на каждый файл, о
котором не знает (see section <A HREF="cvs-ru_16.html#SEC151">Сообщения команды update</A>).


<P>
CVS использует список файлов (или шаблонов файлов в стиле
sh(1)), которые следует игнорировать при выполнении
<CODE>update</CODE>, <CODE>import</CODE> и <CODE>release</CODE>.
This list is constructed in the following way.



<UL>
<LI>

Список инициализируется определенными шаблонами имен файлов:
имена, служащие для служебных целей CVS и других
распространенных систем контроля версий; обычные имена файлов с
заплатами, объектных и архивных файлов, а также резервных копий
файлов, создаваемых текстовыми редакторами.  Остальные имена --
побочные продукты деятельности разнообразных утилит.  В настоящее 
время стандартный список шаблонов игнорируемых файлов таков: 

<A NAME="IDX627"></A>
<A NAME="IDX628"></A>

<PRE>
    RCS     SCCS    CVS     CVS.adm
    RCSLOG  cvslog.*
    tags    TAGS
    .make.state     .nse_depinfo
    *~      #*      .#*     ,*      _$*     *$
    *.old   *.bak   *.BAK   *.orig  *.rej   .del-*
    *.a     *.olb   *.o     *.obj   *.so    *.exe
    *.Z     *.elc   *.ln
    core
</PRE>

<LI>

Список игнорируемых файлов для каждого репозитория находится в
<TT>`$CVSROOT/CVSROOT/cvsignore'</TT> и добавляется к общему списку,
если этот файл существует.

<LI>

Список игнорируемых файлов для каждого пользователя находится в
домашнем каталоге пользователя в файле <TT>`~/.cvsignore'</TT> и
добавляется к общему списку, если этот файл существует.

<LI>

Содержимое переменной окружения <CODE>$CVSIGNORE</CODE> добавляется к
списку.

<LI>

Параметры ключей <SAMP>`-I'</SAMP> добавляются к списку.

<LI>

Когда CVS обходит дерево каталогов, к списку добавляется
содержимое файлов <TT>`.cvsignore'</TT>.  Шаблоны, находящиеся в
файле <TT>`.cvsignore'</TT>, используются только в соответствующем
каталоге, но не в его подкаталогах.
</UL>

<P>
Во всех перечисленных местах использование восклицательного знака
(<SAMP>`!'</SAMP>) очищает список.  Это можно использовать для хранения
файлов, которые обычно игнорируются CVS.


<P>
Задание команде <CODE>cvs import</CODE> ключа <SAMP>`-I !'</SAMP> приведет к
импорту всего, и обычно вы именно этого и хотите, когда
импортируете дистрибутив исходных текстов, не содержащий ничего
лишнего.  Однако, глядя на вышеприведенные правила, можно
заметить ложку дегтя в бочке меда: если в дистрибутиве находятся
файлы <TT>`.cvsignore'</TT>, то они будут обработаны, даже если в
командной строке был указан <SAMP>`-I !'</SAMP>.  Для того, чтобы
импортировать абсолютно все файлы, единственным обходным маневром
будет удалить файлы <TT>`.cvsignore'</TT>.  Это уродливо, поэтому в
будущем <SAMP>`-I !'</SAMP> может перестать обрабатывать файлы
<TT>`.cvsignore'</TT>.


<P>
Заметьте, что синтаксис файла со списком игнорируемых файлов
состоит из набора строк, каждая из которых содержит список
файлов, разделенных пробелами.  Таким образом, нет простого
способа задать имена файлов, содержащие пробелы, но можно
использовать шаблон <TT>`foo?bar'</TT>, чтобы игнорировать файл
<TT>`foo bar'</TT> (в этом случае, правда, будет также проигнорирован 
файл <TT>`fooxbar'</TT> и т. п._).  Заметьте, также, что сейчас не
существует способа поместить в этот файл комментарии.




<H2><A NAME="SEC172" HREF="cvs-ru_toc.html#TOC172">Файл history</A></H2>
<P>
<A NAME="IDX629"></A>
<A NAME="IDX630"></A>
<A NAME="IDX631"></A>


<P>
Файл <TT>`$CVSROOT/CVSROOT/history'</TT> используется для
журналирования информации для команды <CODE>history</CODE>
(see section <A HREF="cvs-ru_16.html#SEC133">Команда history: показать состояние файлов и пользователей</A>).  Для того, чтобы включить
журналирование, этот файл следует создать.  Это происходит
автоматически при выполнении команды <CODE>cvs init</CODE>, которая
используется для инициализации репозитория (see section <A HREF="cvs-ru_2.html#SEC23">Создание репозитория</A>).


<P>
Формат файла <TT>`history'</TT> документирован только в комментариях
в исходном тексте CVS, но, в любом случае, обычно программы
должны использовать команду <CODE>cvs history</CODE>, на тот случай,
если формат изменится в следующих версиях CVS.




<H2><A NAME="SEC173" HREF="cvs-ru_toc.html#TOC173">Подстановки в административных файлах</A></H2>

<P>
Иногда, при написании административного файлы вы хотели бы, чтобы 
в этом файле можно было бы использовать информацию о среде, в
которой выполняется CVS.  Есть несколько механизмов, с
помощью которых можно этого добиться.


<P>
Для того, чтобы узнать домашний каталог пользователя, который
запустил CVS (эта информация хранится в переменной окружения
<CODE>HOME</CODE>), используйте <SAMP>`~'</SAMP>, за которым следует <SAMP>`/'</SAMP>
или конец строки.  Точно так же, для получения домашнего каталога
пользователя используйте <SAMP>`~<VAR>user</VAR>'</SAMP>.  Подстановка этих
переменных происходит на серверной машине, и поэтому такая
подстановка не работает, если используется <CODE>pserver</CODE>
(see section <A HREF="cvs-ru_2.html#SEC29">Прямое соединение с парольной аутентификацией</A>).  Для того, чтобы изменить
поведение для каждого пользователя, лучше использовать
пользовательские переменные (см. ниже).


<P>
Иногда требуется узнать различную информацию, используемую
CVS.  Внутренняя переменная CVS имеет такой синтаксис:
<CODE>${<VAR>переменная</VAR>}</CODE>, где <VAR>переменная</VAR> начинается с
буквы и состоит из алфавитно-цифровых символов и символа подчерка 
(<SAMP>`_'</SAMP>).  Если символ, который следует за <VAR>variable</VAR>, не
является буквой, цифрой или знаком подчерка, то фигурные скобки
можно опустить.  Внутренние переменные CVS таковы:


<DL COMPACT>

<DT><CODE>CVSROOT</CODE>
<DD>
Здесь хранится корневой каталог используемого репозитория.
See section <A HREF="cvs-ru_2.html#SEC9">Репозиторий</A>, где описаны различные способы задания
корневого каталога.

<DT><CODE>RCSBIN</CODE>
<DD>
В CVS 1.9.18 и раньше в этой переменной находился каталог, в 
котором находились программы RCS.  Так как теперь CVS
более не запускает RCS, использование этой внутренней
переменной запрещено.

<DT><CODE>CVSEDITOR</CODE>
<DD>
<DT><CODE>VISUAL</CODE>
<DD>
<DT><CODE>EDITOR</CODE>
<DD>
Эти три переменных содержат одно и то же значение -- используемый 
текстовый редактор.  See section <A HREF="cvs-ru_16.html#SEC116">Глобальные ключи командной строки</A>, где описано, как
задать этот редактор.

<DT><CODE>USER</CODE>
<DD>
Имя пользователя, запустившего CVS (на серверной машине).
</DL>

<P>
Если вы хотите, чтобы пользователь мог задать какое-то значение,
передающееся в административный файл, используйте
пользовательскую переменную.  Для подстановки такой переменной в
административном файле написано <CODE>${=<VAR>variable</VAR>}</CODE>.  Для 
того, чтобы установить пользовательскую переменную, задайте
CVS глобальный флаг <SAMP>`-s'</SAMP> с аргументом
<CODE><VAR>переменная</VAR>=<VAR>значение</VAR></CODE>.  Особенно полезно будет
задать такой флаг в файле <TT>`~/.cvsrc'</TT> (see section <A HREF="cvs-ru_16.html#SEC115">Ключи по умолчанию и файл ~/.cvsrc</A>).


<P>
Например, если вы хотите, чтобы административный файл ссылался на 
тестовый каталог, вы можете создать пользовательскую переменную
<CODE>TESTDIR</CODE>.  Затем, если запустить CVS как



<PRE>
cvs -s TESTDIR=/work/local/tests
</PRE>

<P>
и при административном файле, содержащем <CODE>sh
${=TESTDIR}/runtests</CODE>, то эта строка преобразуется в <CODE>sh
/work/local/tests/runtests</CODE>.


<P>
Все другие строки, содержащие <SAMP>`$'</SAMP>, зарезервированы; нет
способа экранировать символ <SAMP>`$'</SAMP>, чтобы он обозначал сам
себя.




<H2><A NAME="SEC174" HREF="cvs-ru_toc.html#TOC174">Файл конфигурации CVSROOT/config</A></H2>

<P>
<A NAME="IDX632"></A>
<A NAME="IDX633"></A>


<P>
Административный файл <TT>`config'</TT> содержит различные настройки, 
влияющие на поведение CVS.  Синтаксис этого файла слегка
отличается от синтаксиса прочих файлов.  Переменные не
подстанавливаются.  Строки, начинающиеся с <SAMP>`#'</SAMP>, считаются
комментариями.


<P>
Все прочие строки состоят из ключевого слова, символа <SAMP>`='</SAMP> и
значения.  Заметьте, что этот синтаксис очень строг.
Дополнительные пробелы и символы табуляции не допускаются.


<P>
В настоящий момент определены следующие ключевые слова:


<DL COMPACT>

<DT><CODE>RCSBIN=<VAR>bindir</VAR></CODE>
<DD>
<A NAME="IDX634"></A>
 
Для CVS версий от 1.9.12 до 1.9.18, это ключевое слово
указывало, что следует искать программы RCS в каталоге
<VAR>bindir</VAR>.  Современные версии CVS не требуют программ
RCS; для совместимости эта установка допускается, но ничего
не делает.

<A NAME="IDX635"></A>
<DT><CODE>SystemAuth=<VAR>value</VAR></CODE>
<DD>
Если <VAR>value</VAR> равно <SAMP>`yes'</SAMP>, то pserver должен искать
пользователя в системной базе данных пользователей, если он не
найден в <TT>`CVSROOT/passwd'</TT>.  Если же значение равно
<SAMP>`no'</SAMP>, то все пользователи сервера с парольной
аутентификацией должны существовать в <TT>`CVSROOT/passwd'</TT>.  По
умолчанию значение равно <SAMP>`yes'</SAMP>.  Дополнительная информация о 
pserver находится в section <A HREF="cvs-ru_2.html#SEC29">Прямое соединение с парольной аутентификацией</A>.

<A NAME="IDX636"></A>
<DT><CODE>PreservePermissions=<VAR>value</VAR></CODE>
<DD>
Включить поддержку для хранения в репозитории специальных файлов
устройств, символических ссылок, прав доступа к файлами и
информации об их владельцах.  Значение по умолчанию: <SAMP>`no'</SAMP>.
See section <A HREF="cvs-ru_15.html#SEC111">Специальные файлы</A>, где описаны подробности использования
этого ключевого слова.

<A NAME="IDX637"></A>
<DT><CODE>TopLevelAdmin=<VAR>value</VAR></CODE>
<DD>
Изменить поведение команды <SAMP>`checkout'</SAMP> так, чтобы она
создавала каталог <SAMP>`CVS/'</SAMP> на уровень выше вашего рабочего
каталога, вдобавок к каталогам <SAMP>`CVS/'</SAMP>, которые создаются
внутри извлеченных каталогов.  Значение по умолчанию --
<SAMP>`no'</SAMP>.

Эта опция полезна, если вы обнаружите, что выполняете многие
команды в каталоге на уровень выше вашего рабочий каталога, а не
в одном из извлеченных подкаталогов.  Каталог <SAMP>`CVS/'</SAMP>,
созданный таким образом, позволяет не указывать <SAMP>`CVSROOT'</SAMP>
при каждой команде.  Обеспечивается также место для файла
<SAMP>`CVS/Template'</SAMP> (see section <A HREF="cvs-ru_2.html#SEC19">Как данные хранятся в рабочем каталоге</A>).

<A NAME="IDX638"></A>
<DT><CODE>LockDir=<VAR>directory</VAR></CODE>
<DD>
Создавать файлы блокировок CVS в каталоге <VAR>directory</VAR>, а 
не в репозитории.  Это полезно, если вы хотите разрешить
пользователям читать из репозитория, предоставив им доступ на
запись только в <VAR>directory</VAR>, а не в репозиторий.  Вам нужно
создать <VAR>directory</VAR>, а CVS сама создаст там требуемые
подкаталоги.  Информация о блокировках CVS находится в главе 
section <A HREF="cvs-ru_10.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>.

Перед включением опции <SAMP>`LockDir'</SAMP> убедитесь, что вы не
используете ни одной копии CVS версий 1.9 или раньше,
которые не поддерживают <SAMP>`LockDir'</SAMP>, и не дадут об этом
никакого предупреждения.  Если позволить такому случиться, то
некоторые пользователи CVS будут делать блокировки в одном
каталоге, а другие -- в другом, и репозиторий может быть
испорчен.  CVS 1.10 не поддерживает <SAMP>`LockDir'</SAMP>, но
выдаст предупреждение, если использовать его на репозитории с
включенным <SAMP>`LockDir'</SAMP>.
</DL>

<P><HR><P>
Go to the <A HREF="cvs-ru_1.html">first</A>, <A HREF="cvs-ru_17.html">previous</A>, <A HREF="cvs-ru_19.html">next</A>, <A HREF="cvs-ru_24.html">last</A> section, <A HREF="cvs-ru_toc.html">table of contents</A>.
</BODY>
</HTML>
