<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Печать в Linux HOWTO (Linux Printing HOWTO) : Как печатать на сетевой принтер</TITLE>
 <LINK HREF="Printing-HOWTO-12.html" REL=next>
 <LINK HREF="Printing-HOWTO-10.html" REL=previous>
 <LINK HREF="Printing-HOWTO.html#toc11" REL=contents>
</HEAD>
<BODY>
<A HREF="Printing-HOWTO-12.html">Следующий</A>
<A HREF="Printing-HOWTO-10.html">Предыдущий</A>
<A HREF="Printing-HOWTO.html#toc11">Содержание</A>
<HR>
<H2><A NAME="s11">11. Как печатать на сетевой принтер</A>      </H2>

<P>Одним из свойств pdq и lpd является то что они поддерживают печать
по сети на принтер, физически подключенный к другой машине. С помощью
правильной комбинации фильтров и разнообразных утилит, вы можете
печатать используя lpr на принтера во всех видах сетей.
<P>
<H2><A NAME="ss11.1">11.1 На машину с Unix/lpd</A>
        </H2>

<P>Для того чтобы разрешить удаленным машинам печатать на ваш
принтер используя протокол LPD, вы должны перечислить эти машины в
файле <EM>/etc/hosts.equiv</EM> или
<EM>/etc/hosts.lpd</EM>. (Заметим, что <EM>hosts.equiv</EM> имеет
список машин несколько с другим эффектом; будьте уверены что вы
знаете что вы делаете если перечисляете машины в этом файле). Вы
можете разрешить только определенным пользователям на других
машинах печатать на ваш принтер используя атрибут <EM>rs</EM>; читайте
справочную страницу <CODE>
<A HREF="http://www.picante.com/~gtaylor/pht/man/lpd.8.html">lpd</A></CODE> для
более детальной информации об этом.
<P>
<H3>Используя <CODE>pdq</CODE>          </H3>

<P>Используя PDQ, вы определяете принтер с типом интерфейса "bsd-lpd". 
Этот интерфейс берет в качестве аргумента имя удаленного сервера и имя 
очереди печати; помощник определения принтера запросит у вас эти
параметры.
<P>
<H3>С помощью <CODE>lpd</CODE>          </H3>

<P>Для того чтобы печатать на другую машину вы должны сделать
примерно такую запись в <EM>/etc/printcap</EM>: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Удаленный djet500
lp|dj|deskjet:\
        :sd=/var/spool/lpd/dj:\
        :rm=machine.out.there.com:\
        :rp=printername:\
        :lp=/dev/null:\
        :sh:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Заметим что все равно есть директория очереди на локальной
машине обслуживаемая <CODE>lpd</CODE>. Если удаленная машина занята или
отключена, то задание с локальной машины будет находиться в
очереди до тех пор пока оно не сможет быть послано.
<P>
<H3>С помощью <CODE>rlpr</CODE>          </H3>

<P>Вы также можете использовать <EM>rlpr</EM> для послания
задания печати прямо в очередь удаленной машины без мороки с
настройкой lpd для выполнения этой задачи. Это в большинстве
случаев полезно в ситуациях когда вы печатаете на множество
принтеров только время от времени. Из анонса <EM>rlpr</EM>:
<P>
<P>Rlpr использует TCP/IP для посылки заданий печати на сервера с
lpd, находящиеся где угодно в сети.
<P>
<P>В отличии от lpr, он <EM>не требует</EM> чтобы удаленный
принтер был явно известен машине с которой вы хотите печатать,
(например в <EM>/etc/printcap</EM>) и таким образом является
значительно белее гибким и требующим меньше администрирования.
<P>
<P>rlpr может использоваться везде где мог бы использоваться
традиционный lpr, и он является совместимым с традиционным BSD
lpr.
<P>
<P>Основная мощь rlpr заключается в удаленной печати <EM>откуда
угодно куда угодно</EM> без учета как система на которую вы
хотите печатать была настроена. Rlpr может работать как фильтр, как
и традиционный lpr, так что клиенты выполняемые на удаленной
машине такие как netscape, xemacs, и т.п., могут печатать на вашу 
локальную машину с небольшими усилиями.
<P>
<P>Rlpr доступен с <CODE>
<A HREF="ftp://metalab.unc.edu/pub/Linux/system/printing/">Metalab</A></CODE>.
<P>
<H2><A NAME="ss11.2">11.2 На принтер Win95, WinNT, LanManager, или Samba</A>
        </H2>

<P>Существует "Printing to Windows mini-HOWTO" в котором находится
больше информации чем в данном документе.
<P>
<H3>Используя PDQ          </H3>

<P>Нет предопределенного интерфейса smb, что я сознаю, но он может 
достаточно легко создан используя модель, заданную интерфейсом 
appletalk на базе пакета Netatalk. Некоторые люди создали его и
выслали его для включения в дистрибутив!
<P>
<P>Прочитайте раздел о Windows/LPD в следующих разделах данного 
документа для дополнительных советов как сделать данный драйвер.
<P>
<H3>From LPD          </H3>

<P>Возможно перенаправить очередь lpd через программу
<CODE>
<A HREF="http://www.picante.com/~gtaylor/pht/man/smbclient.1.html">smbclient</A></CODE>
(часть набора Samba) на основанный на TCP/IP сервис печати
SMB. Samba включает скрипт называемый <CODE>smbprint</CODE>. Вкратце, вы
помещаете конфигурационный файл для нужного принтера в его
директорию спула, и устанавливаете для него скрипт <CODE>smbprint</CODE>
как <EM>if</EM>-фильтр.
<P>
<P>Запись в <EM>/etc/printcap</EM> выглядит примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
lp|remote-smbprinter:\
    :lp=/dev/null:sh:\
    :sd=/var/spool/lpd/lp:\
    :if=/usr/local/sbin/smbprint:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Вы должны прочитать документацию внутри скрипта <CODE>smbprint</CODE>
для более детальной информации о настройке
<P>
<P>Вы также можете использовать программу <CODE>smbclient</CODE> для
посылки файла прямо на сервис печати SMB без вовлечения в этот
процесс <CODE>lpd</CODE>. Смотрите справочные страницы. 
<P>
<H2><A NAME="ss11.3">11.3 На принтер NetWare</A>
        </H2>

<P>Набор программ ncpfs включает утилиту названную <CODE>nprint</CODE>,
которая обеспечивает те же самые возможности как и <CODE>smbprint</CODE>,
но для NetWare. Вы можете получить ncpfs с 
<A HREF="ftp://metalab.unc.edu/pub/Linux/system/filesystems/ncpfs/">Metalab</A>. Информация
из записи в LSM для пакета версии 0.16:
<P>
<BLOCKQUOTE>
С помощью ncpfs вы можете монтировать тома вашего сервера netware под
Linux. Вы также можете печатать в очереди печати netware и перенаправлять
очереди печати netware на систему печати Linux. Вам необходимо ядро версии
1.2.x или 1.3.54 и выше. ncpfs НЕ работает с любыми ядрами 1.3.x ниже
1.3.54.
</BLOCKQUOTE>
<P>
<H3>From LPD          </H3>

<P>Для того чтобы заставить <CODE>nprint</CODE> работать через lpd, вам
нужно написать маленький скрипт для печати потока стандартного
ввода на принтер NetWare, и установить его как <EM>if</EM>-фильтр для
очереди печати lpd. Вы получите что-то подобное этому:
<P>
<BLOCKQUOTE><CODE>
<PRE>
sub2|remote-NWprinter:\
        :lp=/dev/null:sh:\
        :sd=/var/spool/lpd/sub2:\
        :if=/var/spool/lpd/nprint-script:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P><CODE>nprint-script</CODE> может выглядеть примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#! /bin/sh
# Вы должны сначала попробовать вход как guest без пароля!
/usr/local/bin/nprint -S net -U name -P passwd -q printq-name -
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss11.4">11.4 На принтер EtherTalk (Apple)</A>
        </H2>

<P>Пакет netatalk включает что-то подобное <CODE>nprint</CODE> и
<CODE>smbclient</CODE>. Другие имеют документированные процедуры для печати
на и с сетей Apple много лучше чем я представлял; Смотрите 
<A HREF="http://thehamptons.com/anders/netatalk/">Linux Netatalk-HOWTO</A>.
<P>
<H3>Используя PDQ          </H3>

<P>PDQ включает в поставку объявление интерфейса, который называется
"appletalk". Он использует пакет Netatalk для печати на подключенный к
сети принтер Apple. Просто выберите этот интерфейс при использовании 
помощника добавления принтера в xpdq.
<P>
<H2><A NAME="ss11.5">11.5 На HP или другой ethernet-принтер</A>
        </H2>

<P>Принтеры HP и некоторые другие принтера идут с интерфейсом на
который вы можете печатать прямо, используя протокол lpd. Вы должны
следовать инструкциям, которые идут с вашим принтером или его
сетевым адаптером, но в главном такие принтера являются
"работающим" lpd., и обеспечивают одну или более очередь на которые
вы можете печатать. Например HP может работать с printcap подобным:
<P>
<BLOCKQUOTE><CODE>
<PRE>
lj-5|remote-hplj:\
        :lp=/dev/null:sh:\
        :sd=/var/spool/lpd/lj-5:\
        :rm=printer.name.com:rp=raw:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>или используя аргументы REMOTE_HOST=printer.name.com и QUEUE=raw
для PDQ интерфейса bsd-lpd.
<P>Принтера HP Laserjet с интерфейсами Jet Direct iв общем
поддерживают две встроенных очереди lpd&nbsp;-- "raw", которая
принимает PCL (и возможно Postscript) и "text", которая принимает
чистый ascii (и автоматически справляется с лестничным
эффектом). Если у вас JetDirect Plus3 трех-портовый принтер, то
очереди называются "raw1", "text2", и так далее.
<P>
<P>Заметим, что компания ISS обнаружила набор атак denial of
service (DoS), которые могут завесить интерфейсы HP
Jetdirect. Большинство из них датируется началом осени 98.
<P>
<P>В средах большого масштаба, особенно в больших средах где
некоторые принтера не поддерживают PostScript, может быть полезно
создать выделенный сервер печати на который все машины будут
печатать и на котором все задания ghostscript будут запущены. Это
позволит вам приостанавливать очереди печати или переорганизовывать 
их используя команды topq и lprm.
<P>
<P>Это также позволяет вашей машине с Linux выступать как сервер
печати для принтера, так что ваши пользователи сети смогут
выполнять свои задания печати быстро и справляться с работой не
ожидая пока принтер печатает какое-то другое задание посланное
кем-то другим. Это также предполагается, если у вас есть старые HP
Jetdirects, которые невозможно исправить; это уменьшает вероятность 
заклинивания принтеров.
<P>
<P>Чтобы сделать это, установить очередь на вашей машине, которая
указывает на оборудованный ethernet принтер HP LJ (как показано
выше). Затем укажите для всех клиентов вашей LAN, чтобы они
печатали на очередь печати Linux (например lj-5 как в
вышеприведенном примере). 
<P>
<P>Некоторые сетевые принтера HP по всей видимости не нуждаются в
установке страницы заголовка (banner page) посылаемой клиентом; вы
можете отключить внутренне генерируемую страницу заголовка зайдя на
принтер с помощью telnet, нажав два раза return, набрав "banner: 0"
и затем "quit". Существуют другие настройки, которые вы можете
изменить тем же способом; наберите "?" для просмотра списка
установок.
<P>
<P>Полный набор установок принтера может контролироваться с помощью
программного обеспечения фирмы HP 
<A HREF="http://www.hp.com/go/webjetadmin">WebJet</A>. Этот пакет
запускается как демон и принимает http запросы на назначенном
порту. Он обслуживает формы и Java апплеты, которые могут
контролировать принтера HP, работающие в сети. Теоретически, он
также может контролировать очереди печати Unix, но он делает это
используя сервис rexec, который полностью незащищенным. Я не
советую вам использовать это свойство данного пакета.
<P>
<H3>На старые принтера HP          </H3>

<P>Некоторые принтера (и печатающие сетевые "черные ящики")
поддерживают только никуда не годные маленькие непротокольные
соединения включая чистые TCP соединения. Примечательными в этой
категории являются ранние модели карт JetDirect (включая
некоторые карты JetDirectEx). В основном для печати на принтер вы
должны открыть соединение TCP на принтер на указанный порт
(обычно 9100 или 9100, 9101 и 9102 для трех-портовых принтеров) и
запихнуть свое задание печати в принтер. LPRng имеет встроенную
поддержку для выдачи заданий печати на произвольные порты TCP, но
при использовании BSD lpd это не так легко. Это может быть
выполнено на Perl:
<P>Интерфейс PDQ использующий netcat должен выглядеть примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
interface tcp-port-0.1 {

   help "Это один из первых интерфейсов поддерживаемых стандартными
         сетевыми принтерами и серверами печати. Устройство просто ожидает 
                 TCP-соединения на определенном порту, и посылает данные с любого
                 соединения на принтер.\nЭтот интерфейс требует наличия программы 
                 netcat (\"nc\")."

   required_args "REMOTE_HOST"

   argument { 
      var = "REMOTE_HOST"
      desc = "Удаленная машина"
      help = "Имя или IP-адрес сервера печати."
   }

   argument { 
      var = "REMOTE_PORT"
      def_value = "9100"
      desc = "Удаленный порт"
      help = "Это номер порта TCP сервера печати, на который должно посылаться
                  задание. Большинство карт JetDirect, и их вариантов принимают
                          задания на порту 9100 (или 9101 для порта номер 2, и т.п.)."
   }

   requires "nc"

   # nc заканчивает работу после 45 секунд отсутствия сетевой активности: 
   # он не завершает работу после приема EOF как мы того желаем.
   send_exec { cat $OUTPUT | nc -w 45 $REMOTE_HOST $REMOTE_PORT }
 
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>В случае отсутствия этой программы, она может быть реализована 
другими способами, например на языке Perl, используя нижеприведенную
программу. Или для большей производительности используйте программу
netcat ("nc"), которая выполняет то же самое. Большинство
дистрибутивов должны иметь эту программу в своем составе.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/usr/bin/perl
# Спасибо Dan McLaughlin за написание оригинальной версии этого скрипта
# (А также Jim W. Jones за помощь мне при внесении исправлений ;)

$fileName = @ARGV[0];

open(IN,"$fileName") || die "Can't open file $fileName";

$dpi300     = "\x1B*t300R";
$dosCr      = "\x1B&amp;k3G";
$ends = "\x0A";

$port =  9100 unless $port;
$them = "bach.sr.hp.com" unless $them;

$AF_INET = 2;
$SOCK_STREAM = 1;
$SIG{'INT'} = 'dokill';
$sockaddr = 'S n a4 x8';

chop($hostname = `hostname`);
($name,$aliases,$proto) = getprotobyname('tcp');
($name,$aliases,$port) = getservbyname($port,'tcp')
    unless $port =~ /^\d+$/;;
($name,$aliases,$type,$len,$thisaddr) =
        gethostbyname($hostname);
($name,$aliases,$type,$len,$thataddr) = gethostbyname($them);
$this = pack($sockaddr, $AF_INET, 0, $thisaddr);
$that = pack($sockaddr, $AF_INET, $port, $thataddr);

if (socket(S, $AF_INET, $SOCK_STREAM, $proto)) {
#    print "socket ok\n";
}
else {
    die $!;
}
# Задать адрес сокету.
if (bind(S, $this)) {
#    print "bind ok\n";
}
else {
    die $!;
}

# Вызвать сервер.

if (connect(S,$that)) {
#    print "connect ok\n";
}
else {
    die $!;
}

# Установить буферизацию для сокета.

select(S); $| = 1; select(STDOUT);

#    print S "@PJL ECHO Hi $hostname! $ends";
#    print S "@PJL OPMSG DISPLAY=\"Job $whoami\" $ends";
#    print S $dpi300;

# Избежать блокировки при fork.

if($child = fork) {
    print S $dosCr;
    print S $TimesNewR;

    while (&lt;IN>) {
        print S;
    }
    sleep 3;
    do dokill();
} else {
    while(&lt;S>) {
        print;
    }
}

sub dokill {
    kill 9,$child if $child;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss11.6">11.6 Запуск <EM>if</EM> для удаленных принтеров со старыми LPD</A>
        </H2>

<P>Одна странность старых версий lpd в том что <EM>if</EM> не
запускается для удаленных принтеров. (Версии после 0.43 или примерно
такой имеют изменения внесенные на FreeBSD, так что они всегда работают).
Если вам нужно выполнить <EM>if</EM>, вы можете сделать это
установив двойную очередь и перенаправляя задание. Как пример
рассмотри такой <EM>printcap</EM>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
lj-5:remote-hplj:\
        :lp=/dev/null:sh:\
        :sd=/var/spool/lpd/lj-5:\
        :if=/usr/lib/lpd/filter-lj-5:
lj-5-remote:lp=/dev/null:sh:rm=printer.name.com:\
        :rp=raw:sd=/var/spool/lpd/lj-5-raw:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>в свете этого скрипт <CODE>filter-lj-5</CODE> будет выглядеть так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
gs &lt;options> -q -dSAFER -sOutputFile=- - | \
        lpr -Plj-5-remote -U$5
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Опция <EM>-U</EM> lpr работает только если lpr запущен как демон, и
она правильно устанавливает имя имя автора задания при его
перенаправлении. Вы должны вероятно использовать более надежный
метод получения имени пользователя, так как в некоторых случаях оно
не является пятым аргументом. Смотрите справочную станицу
<EM>
<A HREF="http://www.picante.com/~gtaylor/pht/man/printcap.5.html">printcap</A></EM>.
<P>
<H2><A NAME="ss11.7">11.7 Из Windows</A>
        </H2>

<P>Печать из под клиента Windows (или OS/2) на сервер Linux прямо
поддерживается через SMB используя пакет SAMBA, который также
поддерживает разделение вашей файловой системы Linux с клиентами
Windows.
<P>
<P>Samba включает в себя довольно полную документацию. Вы можете
либо настроить magic-фильтр на машине с Linux и печатать на нее в
формате PostScript или установить специфичные для принтера драйвера 
на всех машинах с Windows и обрабатывать очередь без
фильтрации. Полагаясь на драйвера Windows вы можете в некоторых
случаях получить более качественный вывод, но это дает больше
административной нервотрепки если у вас много машин с Windows. Так
что сначала попробуйте PostScript.
<P>
<P>Используя PDQ, вы должны настроить Samba для запуска команды pdq с 
соответствующими аргументами вместо команды lpr, которая выполняется по
умолчанию. Я верю, что Samba будет запускать pdq с правами
соответствующего пользователя, так что он должен работать нормально. 
Существует несколько настроек Samba, которые вы должны выставить для 
правильной работы:
<P>
<DL>
<DT><B>printcap</B><DD><P>этот параметр должен указывать на "фальшивый" файл, в 
котором вы должны перечислить доступные принтера. Все что нужно
указать, это короткие и длинные сервера для каждого из принтера, один
на каждую строку:
<P>
<BLOCKQUOTE><CODE>
<PRE>
lp1|Printer One
lp2|Printer Two
lp3|Printer Three
</PRE>
</CODE></BLOCKQUOTE>
<P>Короткое имя будет использоваться как имя принтера в команде печати:
<P>
<DT><B>print command</B><DD><P>Этот параметр должен быть установлен во что-нибудь
подобное следующему <CODE>pdq -P %p %s ; rm %s</CODE>.
<P>
<DT><B>lprm command</B><DD><P>Для этого параметра пока нет хорошего значения. 
Буферизованные задания PDQ будут сниматься после истечения времени,
так что если принтер не работает, то все нормально. Но если вы просто 
решили отменить свое намерение, то вы можете использовать программу 
xpdq для отмены заданий, но это неприменимо для Windows. Просто вствьте 
сюда ничего не делающую команду, такую как true. Если вы используете 
lpd или lprng в качестве основы, то соответствующая команда lprm должна 
нормально работать. Я не уверен, что Samba может идентифицировать
номер задания в очереди lpr для запущенных pdq заданий.
<P>
<DT><B>lpq command</B><DD><P>Также PDQ не предоставаляет хорошего значения,
которое можно поместить здесь. Распределенные системы не предлагают
нормального решения для того, чтобы видеть очередь печати, но
основанные на samba сервера должны иметь достойную схему. если вы 
используете lpd или lprng как основу, то соответствующая команда lpq c
должна работать; вы просто не сможете увидеть задания, до того, как
они будут отфильтрованы PDQ.
</DL>
<P>
<P>
<H2><A NAME="ss11.8">11.8 С Apple.</A>
        </H2>

<P>Netatalk поддерживает печать с клиентов Apple через
EtherTalk. Смотрите 
<A HREF="http://thehamptons.com/anders/netatalk/">Страницу Netatalk HOWTO</A> для более детальной
информации.
<P>
<H2><A NAME="ss11.9">11.9 Из под Netware</A>
        </H2>

<P>Пакет ncpfs включает демона называемого pserver, который может
быть использован для обеспечения сервиса очередей печати
NetWare. Как я понял эта система требует основанную на Bindery
систему NetWare, т.е. 2.x, 3.x, или 4.x с разрешенным доступом к
bindery.
<P>
<P>Для более детальной информации о ncpfs и ее программе pserver
смотрите 
<A HREF="ftp://ftp.gwdg.de/pub/linux/misc/ncpfs/">FTP сервер ncpfs FTP</A>.
<P>
<HR>
<A HREF="Printing-HOWTO-12.html">Следующий</A>
<A HREF="Printing-HOWTO-10.html">Предыдущий</A>
<A HREF="Printing-HOWTO.html#toc11">Содержание</A>
</BODY>
</HTML>
