<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux Kernel HOWTO: Важные вопросы и ответы на них</TITLE>
 <LINK HREF="Kernel-HOWTO-3.html" REL=next>
 <LINK HREF="Kernel-HOWTO-1.html" REL=previous>
 <LINK HREF="Kernel-HOWTO.html#toc2" REL=contents>
</HEAD>
<BODY>
<A HREF="Kernel-HOWTO-3.html">Следующий</A>
<A HREF="Kernel-HOWTO-1.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc2">Содержание</A>
<HR>
<H2><A NAME="s2">2. Важные вопросы и ответы на них</A></H2>

<H2><A NAME="ss2.1">2.1 Что вообще делает ядро?</A>
</H2>

<P>Ядро Unix выступает как посредник между вашей программой и вашим
оборудованием. Сначала оно делает (или подготавливается к)
обслуживанию/распределению памяти компьютера для всех запущенных программ
(процессов), и убеждается, что все они честно (или нечестно, если вы этого
желаете) разделяют время процессора. В добавление к этому оно обеспечивает
великолепный, довольно переносимый интерфейс для общения программ с
оборудованием.
<P>
<P>Конечно у ядро выполняет больше действий, чем мы здесь перечислили, но
эти основные функции необходимо знать.
<P>
<H2><A NAME="ss2.2">2.2 Почему я должен обновлять мое ядро? </A>
</H2>

<P>Более новые ядра в общем поддерживают большее количество типов
оборудования (они имеют больше драйверов устройств), они могут иметь
улучшенное управление процессами, они могут выполняться быстрее, чем более
старые версии, они могут быть более стабильными, чем старые версии, и они
исправляют глупые ошибки в более старых версиях. Большинство людей
обновляют ядро, потому-что они хотят использовать новые драйвера устройств
и исправить ошибки.
<P>
<H2><A NAME="ss2.3">2.3 Какие типы оборудования поддерживают новые ядра?</A>
</H2>

<P>Смотрите Hardware-HOWTO. В качестве альтернативы вы можете посмотреть
файл `<CODE>config.in</CODE>' в исходных текстах ядра linux source, или просто
найти нужное устройство запустив `<CODE>make config</CODE>'. Они показывают все 
оборудование поддерживаемое дистрибутивом ядра, но не все, которое
поддерживает linux; много драйверов общих устройств (таких как драйвера
PCMCIA и некоторые драйвера ленточных устройств) являются загружаемыми
модулями сопровождаются и распространяются отдельно.
<P>
<H2><A NAME="ss2.4">2.4 Какие версии gcc и libc мне нужны?</A>
</H2>

<P>Рекомендации Linus по версии gcc находятся в файле <CODE>README</CODE>,
включенном в исходные тексты linux. Если у вас нет этой версии, то
документация по рекомендуемой версии gcc должна сообщить вам все сведения,
если вам необходимо обновить вашу версию libc. Это не трудная процедура, но 
важно следовать инструкциям.
<P>
<H2><A NAME="ss2.5">2.5 Что такое загружаемый модуль?</A>
</H2>

<P>Это кусочки кода ядра, которые не включены прямо в
ядро. Они компилируются отдельно и затем могут вставлять и удалять их в
запущенное ядро почти в любое время. Вследствии их гибкости, сейчас это
предпочтительный способ кодирования некоторых средств ядра. Много
популярных драйверов устройств, таких как драйвера PCMCIA и драйвера
ленточных устройств QIC-80/40, являются загружаемыми модулями.
<P>
<H2><A NAME="ss2.6">2.6 Сколько места на диске мне надо?</A>
</H2>

<P>Это зависит от конфигурации вашей системы. Первое, это сжатые исходные
тексты ядра, примерно 6 мегабайт для версии 2.0.10. На многих машинах этот
файл хранят даже после распаковки. В расжатом виде исходные тексты занимают 
до 24 мегабайт. Но это не конец&nbsp;-- вам нужно больше для компиляции
ядра. Требуемый размер зависит от того, как вы настроили ваше
ядро. Например, на одной машине у меня настроена работа сети, драйвер 3Com
3C509, и три файловые системы, это все занимает примерно 30 мегабайт
дискового пространства. Добавив сжатые исходные тексты, вам понадобиться
около 26 Мб для такой конфигурации. На другой системе, без поддержки
драйвера сетевой карты (но все равно с поддержкой сети) и звуковой картой,
все занимает больше пространства. Также, более новые ядра имеют более
большое дерево исходных текстов, так что в общем, если если у вас довольно
много устройств, то убедитесь, что у вас достаточно большой жесткий диск
(при сегодняшних ценах, я не могу помочь вам, но я рекомендую взять другой
диск как ответ на вашу проблему отсутствия свободного пространства).
<P>
<H2><A NAME="ss2.7">2.7 Как долго этот процесс идет?</A>
</H2>

<P>Для большинства людей ответ будет такой: ``довольно долго''. Скорость
вашей машины и количество имеющейся памяти определяют это время, но
некоторая часть определяется, тем как вы включили в ядро. На машине
486DX4/100 с 16 МБ ОЗУ, на ядре версии 1.2 с пятью файловыми файловыми
системами, поддержкой сети и драйвером звуковой карты, компиляция займет
примерно 20 минут. На 386DX/40 (8 MБ ОЗУ) с примерно такой же
конфигурацией, компиляция продолжается около 1.5 часов. В общем рекомендуем 
выпить кофе, посмотреть телевизор, повязать или поделать что-нибудь
подобное пока ваша машина компилирует ядро. 
<P>
<HR>
<A HREF="Kernel-HOWTO-3.html">Следующий</A>
<A HREF="Kernel-HOWTO-1.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc2">Содержание</A>
</BODY>
</HTML>
