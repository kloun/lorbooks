<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Как сменить заголовок xterm</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Как сменить заголовок xterm</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Ric Lister</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>ric@giccs.georgetown.edu</P
></DIV
></DIV
><H3
CLASS="CORPAUTHOR"
>Перевод: <A
HREF="mailto:pax@asp-linux.com"
TARGET="_top"
>Павел Гашев</A
>,
<A
HREF="http://www.asplinux.com"
TARGET="_top"
>SWSoft Pte Ltd.</A
></H3
></DIV
><P
CLASS="PUBDATE"
>версия 2.0, 27 октябрь 1999<BR></P
><DIV
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN15"
></A
><P
></P
><P
>Этот документ описывает, как изменять заголовки окон и подписи иконок в xterm. Даны примеры для различных оболочек, а в приложении представлены escape-последовательности для различных типов терминалов.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Содержание</B
></DT
><DT
>1. <A
HREF="Xterm-Title.html#AEN17"
>Где можно найти этот документ</A
></DT
><DT
>2. <A
HREF="Xterm-Title.html#AEN25"
>Статические заголовки</A
></DT
><DT
>3. <A
HREF="Xterm-Title.html#AEN34"
>Динамические заголовки</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="Xterm-Title.html#AEN37"
>escape-последовательности XTerm</A
></DT
><DT
>3.2. <A
HREF="Xterm-Title.html#AEN64"
>Вывод escape-последовательностей</A
></DT
></DL
></DD
><DT
>4. <A
HREF="Xterm-Title.html#AEN73"
>Примеры для различных оболочек</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="Xterm-Title.html#AEN92"
>zsh</A
></DT
><DT
>4.2. <A
HREF="Xterm-Title.html#AEN106"
>tcsh</A
></DT
><DT
>4.3. <A
HREF="Xterm-Title.html#AEN122"
>bash</A
></DT
><DT
>4.4. <A
HREF="Xterm-Title.html#AEN148"
>ksh</A
></DT
><DT
>4.5. <A
HREF="Xterm-Title.html#AEN166"
>csh</A
></DT
></DL
></DD
><DT
>5. <A
HREF="Xterm-Title.html#AEN183"
>Вывод имени текущей задачи</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="Xterm-Title.html#AEN188"
>zsh</A
></DT
><DT
>5.2. <A
HREF="Xterm-Title.html#AEN196"
>Другие оболочки</A
></DT
></DL
></DD
><DT
>6. <A
HREF="Xterm-Title.html#AEN200"
>Приложение: escape-последовательности для других терминалов</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="Xterm-Title.html#AEN205"
>IBM <TT
CLASS="LITERAL"
>aixterm</TT
></A
></DT
><DT
>6.2. <A
HREF="Xterm-Title.html#AEN211"
>SGI <TT
CLASS="LITERAL"
>wsh</TT
>, <TT
CLASS="LITERAL"
>xwsh</TT
> и <TT
CLASS="LITERAL"
>winterm</TT
></A
></DT
><DT
>6.3. <A
HREF="Xterm-Title.html#AEN229"
>Sun <TT
CLASS="LITERAL"
>cmdtool</TT
> и <TT
CLASS="LITERAL"
>shelltool</TT
></A
></DT
><DT
>6.4. <A
HREF="Xterm-Title.html#AEN244"
>CDE <TT
CLASS="LITERAL"
>dtterm</TT
></A
></DT
><DT
>6.5. <A
HREF="Xterm-Title.html#AEN252"
>HPterm</A
></DT
></DL
></DD
><DT
>7. <A
HREF="Xterm-Title.html#AEN275"
>Приложение: примеры на других языках</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="Xterm-Title.html#AEN278"
>C</A
></DT
><DT
>7.2. <A
HREF="Xterm-Title.html#AEN282"
>Perl</A
></DT
></DL
></DD
><DT
>8. <A
HREF="Xterm-Title.html#AEN286"
>Благодарности</A
></DT
><DT
>9. <A
HREF="Xterm-Title.html#AEN333"
>Авторские права</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN17"
>1. Где можно найти этот документ</A
></H1
><P
>Этот документ является частью
<A
HREF="http://sunsite.unc.edu/LDP/HOWTO/"
TARGET="_top"
>Linux HOWTO</A
>
и находится по адресу 
<A
HREF="http://sunsite.unc.edu/LDP/HOWTO/mini/Xterm-Title.html"
TARGET="_top"
>http://sunsite.unc.edu/LDP/HOWTO/mini/Xterm-Title.html</A
>.</P
><P
>Последняя версия этого документа в различных форматах находится по адресу 
<A
HREF="http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/"
TARGET="_top"
>http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/</A
>.</P
><P
>Этот документ предшествует оригинальному HOWTO, который написал Winfried Tr&uuml;mper.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN25"
>2. Статические заголовки</A
></H1
><P
>Статический заголовок для <TT
CLASS="LITERAL"
>xterm</TT
>,
<TT
CLASS="LITERAL"
>color-xterm</TT
> или <TT
CLASS="LITERAL"
>rxvt</TT
>, может быть установлен при помощи ключей <TT
CLASS="LITERAL"
>-T</TT
> и
<TT
CLASS="LITERAL"
>-n</TT
>:

<PRE
CLASS="SCREEN"
>xterm -T "Мой заголовок XTerm" -n "Мой заголовок иконки XTerm"</PRE
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN34"
>3. Динамические заголовки</A
></H1
><P
>Для большинства людей более полезны заголовки, отражающие динамическую информацию, такую как имя пользователя или текущий каталог.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN37"
>3.1. escape-последовательности XTerm</A
></H2
><P
>Заголовок окна или имя иконки могут быть изменены при помощи escape-последовательностей:

<P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>ESC]0;строкаBEL</TT
> -- Устанавливает <I
CLASS="EMPHASIS"
>строку</I
> в качестве имени иконки и заголовка окна</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>ESC]1;строкаBEL</TT
> -- Устанавливает имя иконки</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>ESC]2;строкаBEL</TT
> -- Устанавливает текст заголовка окна</P
></LI
></UL
>

где <TT
CLASS="LITERAL"
>ESC</TT
> - это символ <I
CLASS="EMPHASIS"
>escape</I
> (\033), а <TT
CLASS="LITERAL"
>BEL</TT
> - это символ <I
CLASS="EMPHASIS"
>bell</I
> (\007).</P
><P
>Вывод этой последовательности на терминал xterm приведет к изменению заголовка окна или иконки.</P
><P
><I
CLASS="EMPHASIS"
>Примечание</I
>: эти последовательности относятся к терминалу xterm и его производным, таким как <TT
CLASS="LITERAL"
>nxterm</TT
>, <TT
CLASS="LITERAL"
>color-xterm</TT
> и <TT
CLASS="LITERAL"
>rxvt</TT
>. Другие типы терминалов часто используют другие последовательности; см. приложение. Полный список escape-последовательностей для xterm см. в файле
<A
HREF="http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/ctlseq2.txt"
TARGET="_top"
>ctlseq2.txt</A
>,
поставляемом вместе с дистрибутивом xterm; или в
<A
HREF="http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/xterm.seq"
TARGET="_top"
>xterm.seq</A
>, поставляемом с дистрибутивом
<A
HREF="http://www.rxvt.org/"
TARGET="_top"
>rxvt</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN64"
>3.2. Вывод escape-последовательностей</A
></H2
><P
>Для вывода информации, не меняющейся в течении всего сеанса работы - такой, как имя машины или имя пользователя, достаточно поместить в rc-файл следующую строчку:

<PRE
CLASS="SCREEN"
>echo -n "\033]0;${USER}@${HOST}\007"</PRE
>

которая установит заголовок окна в <TT
CLASS="LITERAL"
>имя_пользователя@имя_машины</TT
>, если переменные <TT
CLASS="LITERAL"
>$USER</TT
> и <TT
CLASS="LITERAL"
>$HOST</TT
> установлены правильно. Требуемые опции команды <TT
CLASS="LITERAL"
>echo</TT
> зависят от оболочки (см. примеры ниже).</P
><P
>Если в течении сеанса заголовок окна должен меняться (напр. текущий каталог), escape-последовательности должны выводиться каждый раз, когда изменяется приглашение оболочки. Некоторые оболочки позволяют вставлять такие последовательности прямо в строку приглашения. Это иллюстрируется в следующем разделе.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN73"
>4. Примеры для различных оболочек</A
></H1
><P
>Ниже представлены примеры для большинства оболочек - начиная с <TT
CLASS="LITERAL"
>zsh</TT
>, который предоставляет для этого специальные средства, и далее в порядке увеличения сложности.</P
><P
>Чтобы убедиться в том, что мы находимся в xterm, мы проверяем переменную <TT
CLASS="LITERAL"
>$TERM</TT
>
на предмет
<TT
CLASS="LITERAL"
>$TERM=xterm*</TT
>; шаблон необходим, потому что в некоторых случаях (например для rxvt) она может быть установлена <TT
CLASS="LITERAL"
>$TERM=xterm-color</TT
>.</P
><P
>Заметим также, что в производных C-shell, таких как
<TT
CLASS="LITERAL"
>tcsh</TT
> и <TT
CLASS="LITERAL"
>csh</TT
>, неопределенные переменные вызывают фатальную ошибку. Таким образом, перед тем как проверить содержимое переменной <TT
CLASS="LITERAL"
>$TERM</TT
>, мы должны проверить ее наличие. Чтобы добиться этого, мы должны использовать:

<PRE
CLASS="SCREEN"
>  if ($?TERM) then
      ...
  endif</PRE
>

(По нашему мнению, это одна из причин, почему не надо использовать C-shell. См.
<I
CLASS="EMPHASIS"
><A
HREF="http://language.perl.com/versus/csh.whynot"
TARGET="_top"
>Csh Programming Considered Harmful</A
></I
>).</P
><P
>Эти примеры можно использовать: просто вставьте их в соответствующий файл инициализации, выполняемый во время запуска интерактивной оболочки. В большинстве случаев он выглядит, примерно как
<TT
CLASS="LITERAL"
>.shellrc</TT
> (например <TT
CLASS="LITERAL"
>.zshrc</TT
>, <TT
CLASS="LITERAL"
>.tcshrc</TT
> и т.д.).</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN92"
>4.1. zsh</A
></H2
><P
><TT
CLASS="LITERAL"
>zsh</TT
> предоставляет несколько функций и расширений, которые мы будем использовать:

<PRE
CLASS="SCREEN"
>precmd ()   функция, выполняемая перед выводом каждого приглашения
chpwd ()    функция, выполняемая после смены текущего каталога
\e          escape-последовательность для символа ESC
\a          escape-последовательность для символа BEL
%n          $USERNAME
%m          имя машины до первой '.'
%~          путь к текущему каталогу, начиная с домашнего</PRE
>

Существует также много других расширений <TT
CLASS="LITERAL"
>man zshmisc</TT
>.</P
><P
>Таким образом, следующее меняет заголовок XTerm на
"<TT
CLASS="LITERAL"
>имя_пользователя@имя_машины: каталог</TT
>":

<PRE
CLASS="SCREEN"
>case $TERM in
    xterm*)
        precmd () {print -Pn "\e]0;%n@%m: %~\a"}
        ;;
esac</PRE
>

То же самое достигается использованием <TT
CLASS="LITERAL"
>chpwd()</TT
> вместо <TT
CLASS="LITERAL"
>precmd()</TT
>. Встроенная команда <TT
CLASS="LITERAL"
>print</TT
> работает так же, как и
<TT
CLASS="LITERAL"
>echo</TT
>, но обеспечивает доступ к <TT
CLASS="LITERAL"
>%</TT
>-командам.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN106"
>4.2. tcsh</A
></H2
><P
><TT
CLASS="LITERAL"
>tcsh</TT
> обладает похожими функциями:

<PRE
CLASS="SCREEN"
>precmd ()   функция, выполняемая перед выводом каждого приглашения
cwdcmd ()   функция, выполняемая после смены текущего каталога
%n          имя пользователя
%m          имя машины
%~          путь к текущему каталогу, начиная с домашнего
%#	    '%' для обычных пользователей, '#' для root'а
%{...%}     включает строчку как последовательность escape-сиволов</PRE
>&#13;</P
><P
>К сожалению, у tcsh нет аналога <TT
CLASS="LITERAL"
>zsh</TT
>-команды <TT
CLASS="LITERAL"
>print</TT
>,
так что нам придется пользоваться обычными переменными. Для <TT
CLASS="LITERAL"
>&tilde;/.tcshrc</TT
>):

<PRE
CLASS="SCREEN"
>switch ($TERM)
    case "xterm*":
        alias precmd 'echo -n "\033]0;${HOST}:$cwd\007"'
        breaksw
endsw</PRE
>

Тем не менее, это дает нам полный путь к текущему каталогу, а не через <TT
CLASS="LITERAL"
>&tilde;</TT
>.
Вместо этого в приглашение можно поместить свою строку:

<PRE
CLASS="SCREEN"
>switch ($TERM)
    case "xterm*":
        set prompt="%{\033]0;%n@%m:%~\007%}tcsh%# "
        breaksw
    default:
        set prompt="tcsh%# "
        breaksw
endsw</PRE
>

которая устанавливает приглашение "<TT
CLASS="LITERAL"
>tcsh% </TT
>", а в xterm устанавливает заголовок 
"<TT
CLASS="LITERAL"
>имя_пользователя@имя_машины: каталог</TT
>". Заметим, что вокруг escape-последовательности стоят символы "<TT
CLASS="LITERAL"
>%{...%}</TT
>" (приглашение не должно заканчиваться этим: <TT
CLASS="LITERAL"
>man tcsh</TT
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN122"
>4.3. bash</A
></H2
><P
><TT
CLASS="LITERAL"
>bash</TT
> поддерживает переменную <TT
CLASS="LITERAL"
>$PROMPT_COMMAND</TT
>, содержащую команду, запускаемую перед выводом приглашения. Этот пример устанавливает заголовок окна
<TT
CLASS="LITERAL"
>имя_пользователя@имя_машины: каталог</TT
>:

<PRE
CLASS="SCREEN"
>PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'</PRE
>

где <TT
CLASS="LITERAL"
>\033</TT
> - код символа <TT
CLASS="LITERAL"
>ESC</TT
>,
а <TT
CLASS="LITERAL"
>\007</TT
> - <TT
CLASS="LITERAL"
>BEL</TT
>.</P
><P
>Заметим, что кавычки здесь очень важны: значения переменных вставляются в
<TT
CLASS="LITERAL"
>"..."</TT
>, и не вставляются в <TT
CLASS="LITERAL"
>'...'</TT
>. Так что переменная
<TT
CLASS="LITERAL"
>$PROMPT_COMMAND</TT
> устанавливается без подстановки переменных, которая происходит во время выполнения <TT
CLASS="LITERAL"
>$PROMPT_COMMAND</TT
>.</P
><P
>Тем не менее, <TT
CLASS="LITERAL"
>$PWD</TT
> дает полный путь к каталогу. Если вы хотите, чтобы он начинался с <TT
CLASS="LITERAL"
>&tilde;</TT
>, можете воспользоваться следующими расширениями:

<PRE
CLASS="SCREEN"
>\u          $USERNAME
\h          имя машины до первой '.'
\w          каталог, начиная с '~'
\$	    '$' для обычных пользователей, '#' для root
\[...\]     вставляет последовательность непечатаемых символов</PRE
>&#13;</P
><P
>Таким образом, следующее устанавливает приглашение <TT
CLASS="LITERAL"
>bash$</TT
>, а в заголовке XTerm <TT
CLASS="LITERAL"
>имя_пользователя@имя_машины: каталог</TT
>:

<PRE
CLASS="SCREEN"
>case $TERM in
    xterm*)
        PS1="\[\033]0;\u@\h: \w\007\]bash\\$ "
        ;;
    *)
        PS1="bash\\$ "
        ;;
esac</PRE
>

Замечу, что используется последовательность <TT
CLASS="LITERAL"
>\[...\]</TT
>, которая говорит <TT
CLASS="LITERAL"
>bash</TT
>, во время вычисления ширины приглашения игнорировать символы, содержащиеся внутри. Иначе могут возникнуть проблемы с позиционированием курсора во время редактирования строки.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN148"
>4.4. ksh</A
></H2
><P
><TT
CLASS="LITERAL"
>ksh</TT
> дает не много возможностей для наших целей, так что нам придется вставить escape-последовательности прямо в приглашение. Следующий пример устанавливает заголовок окна
<TT
CLASS="LITERAL"
>имя_пользователя@имя_машины: каталог</TT
> и приглашение <TT
CLASS="LITERAL"
>ksh$</TT
>.

<PRE
CLASS="SCREEN"
>case $TERM in
    xterm*)
        HOST=`hostname`
        PS1='^[]0;${USER}@${HOST}: ${PWD}^Gksh$ '
        ;;
    *)
        PS1='ksh$ '
        ;;
esac</PRE
>

<TT
CLASS="LITERAL"
>$PWD</TT
> выдает полный путь к каталогу. При помощи <TT
CLASS="LITERAL"
>${...##...}</TT
> мы можем убрать префикс <TT
CLASS="LITERAL"
>$HOME/</TT
>
из каталога. Можно также укоротить имя машины через <TT
CLASS="LITERAL"
>${...%%...}</TT
>:

<PRE
CLASS="SCREEN"
>HOST=`hostname`
HOST=${HOST%%.*}
PS1='^[]0;${USER}@${HOST}: ${PWD##${HOME}/}^Gksh$ '</PRE
>

Заметим, что <TT
CLASS="LITERAL"
>&circ;[</TT
> и <TT
CLASS="LITERAL"
>&circ;G</TT
> в строке приглашения - это просто символы <TT
CLASS="LITERAL"
>ESC</TT
> и <TT
CLASS="LITERAL"
>BEL</TT
> (они могут быть введены в emacs при помощи <TT
CLASS="LITERAL"
>C-q ESC</TT
> и <TT
CLASS="LITERAL"
>C-q C-g</TT
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN166"
>4.5. csh</A
></H2
><P
>В <TT
CLASS="LITERAL"
>csh</TT
> это все достаточно сложно:

<PRE
CLASS="SCREEN"
>switch ($TERM)
    case "xterm*":
        set host=`hostname`
        alias cd 'cd \!*; echo -n "^[]0;${user}@${host}: ${cwd}^Gcsh% "'
        breaksw
    default:
        set prompt='csh% '
        breaksw
endsw</PRE
>

где мы переопределяем команду <TT
CLASS="LITERAL"
>cd</TT
> для того, чтобы она посылала escape-последовательности. Заметим, что <TT
CLASS="LITERAL"
>&circ;[</TT
> и <TT
CLASS="LITERAL"
>&circ;G</TT
> - символы <TT
CLASS="LITERAL"
>ESC</TT
> и <TT
CLASS="LITERAL"
>BEL</TT
>
(они могут быть введены в emacs при помощи <TT
CLASS="LITERAL"
>C-q ESC</TT
> и <TT
CLASS="LITERAL"
>C-q C-g</TT
>).</P
><P
>Заметим, что на некоторых системах команда <TT
CLASS="LITERAL"
>hostname -s</TT
> выдает короткое имя машины, вместо длинного, а некоторые пользователи могут использовать <TT
CLASS="LITERAL"
>`pwd`</TT
> (обратные кавычки запускают команду <TT
CLASS="LITERAL"
>pwd</TT
>), вместо <TT
CLASS="LITERAL"
>$cwd</TT
>, чтобы получить более точный путь.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN183"
>5. Вывод имени текущей задачи</A
></H1
><P
>Пользователь часто запускает "долгоиграющие" задачи, такие как <TT
CLASS="LITERAL"
>top</TT
>,
текстовый редактор, почтовый клиент и т.д., и хочет видеть название задачи в заголовке окна. Это более сложная задача, и она может быть легко решена только в <TT
CLASS="LITERAL"
>zsh</TT
>.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN188"
>5.1. zsh</A
></H2
><P
><TT
CLASS="LITERAL"
>zsh</TT
> предоставляет идеальную встроенную функцию для этих целей:

<PRE
CLASS="SCREEN"
>preexec()   функция, выполняемая прямо перед запуском команды
$*,$1,...   аргументы, передающиеся в preexec()</PRE
>

Таким образом, мы можем вставить в заголовок имя текущей задачи:

<PRE
CLASS="SCREEN"
>case $TERM in
    xterm*)
      preexec () {
        print -Pn "\e]0;$*\a"
      }
    ;;
esac</PRE
>

Заметим, что функуция <TT
CLASS="LITERAL"
>preexec()</TT
> появилась в <TT
CLASS="LITERAL"
>zsh</TT
> 3.1.2, так что, возможно, вам придется обновить версию.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN196"
>5.2. Другие оболочки</A
></H2
><P
>В других оболочках, не имеющих аналога функции
<TT
CLASS="LITERAL"
>preexec()</TT
>, это осуществить не просто. Если кто-то это сделал, пошлите пример автору этого текста.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN200"
>6. Приложение: escape-последовательности для других терминалов</A
></H1
><P
>Большинство современных терминалов являются производными <TT
CLASS="LITERAL"
>xterm</TT
> или <TT
CLASS="LITERAL"
>rxvt</TT
>
и поддерживают те же escape-последовательности, которыми мы пользовались раньше. Некоторые фирменные терминалы, идущие вместе с различными версиями Unix, имеют свои собственные escape-последовательности.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN205"
>6.1. IBM <TT
CLASS="LITERAL"
>aixterm</TT
></A
></H2
><P
><TT
CLASS="LITERAL"
>aixterm</TT
> понимает escape-последовательности <TT
CLASS="LITERAL"
>xterm</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN211"
>6.2. SGI <TT
CLASS="LITERAL"
>wsh</TT
>, <TT
CLASS="LITERAL"
>xwsh</TT
> и <TT
CLASS="LITERAL"
>winterm</TT
></A
></H2
><P
>Эти терминалы устанавливают <TT
CLASS="LITERAL"
>$TERM=iris-ansi</TT
> и используют escape-последовательности:

<P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>ESCP1.yстрокаESC\        Устанавливает заголовок окна</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>ESCP3.yстрокаESC\        Устанавливает имя иконки</TT
></P
></LI
></UL
>

Для полного списка escape-последовательностей <TT
CLASS="LITERAL"
>xwsh</TT
>: <TT
CLASS="LITERAL"
>man 1G xwsh</TT
>.</P
><P
>Терминалы Irix также поддерживают последовательности <TT
CLASS="LITERAL"
>xterm</TT
> для установки заголовка окна и имени иконки раздельно, но не для установки и того и другого вместе.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN229"
>6.3. Sun <TT
CLASS="LITERAL"
>cmdtool</TT
> и <TT
CLASS="LITERAL"
>shelltool</TT
></A
></H2
><P
><TT
CLASS="LITERAL"
>cmdtool</TT
> и <TT
CLASS="LITERAL"
>shelltool</TT
> устанавливают <TT
CLASS="LITERAL"
>$TERM=sun-cmd</TT
> 
и используют последовательности:

<P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>ESC]lстрокаESC\    Устанавливает заголовок окна</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>ESC]LстрокаESC\    Устанавливает имя иконки</TT
></P
></LI
></UL
>

Это ужасная программа - пользуйтесь чем-нибудь другим.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN244"
>6.4. CDE <TT
CLASS="LITERAL"
>dtterm</TT
></A
></H2
><P
><TT
CLASS="LITERAL"
>dtterm</TT
> устанавливает <TT
CLASS="LITERAL"
>$TERM=dtterm</TT
> и понимает как последовательности <TT
CLASS="LITERAL"
>xterm</TT
>, так и Sun <TT
CLASS="LITERAL"
>cmdtool</TT
>
(проверено на Solaris 2.5.1, Digital Unix 4.0, HP-UX 10.20).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN252"
>6.5. HPterm</A
></H2
><P
><TT
CLASS="LITERAL"
>hpterm</TT
> устанавливает <TT
CLASS="LITERAL"
>$TERM=hpterm</TT
> и использует последовательности:

<P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>ESC&amp;f0kдлинаDстрока   Устанавливает строку длиной в качестве заголовка окна</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>ESC&amp;f-1kдлинаDстрока  Устанавливает строку длиной в качестве имени иконки</TT
></P
></LI
></UL
>&#13;</P
><P
>Простая программа на C, вычисляющая длину строки и выводящая ее, выглядит примерно так:

<PRE
CLASS="SCREEN"
>#include &#60;string.h&#62;
int main(int argc, char *argv[])
{
    printf("\033&amp;f0k%dD%s", strlen(argv[1]), argv[1]);
    printf("\033&amp;f-1k%dD%s", strlen(argv[1]), argv[1]);
    return(0);
}</PRE
>&#13;</P
><P
>Можно написать простой скрипт, использующий <TT
CLASS="LITERAL"
>${#string}</TT
>
(<TT
CLASS="LITERAL"
>zsh</TT
>, <TT
CLASS="LITERAL"
>bash</TT
>, <TT
CLASS="LITERAL"
>ksh</TT
>) или <TT
CLASS="LITERAL"
>${%string}</TT
>
(<TT
CLASS="LITERAL"
>tcsh)</TT
> для вычисления длины строки. Для <TT
CLASS="LITERAL"
>zsh</TT
>:

<PRE
CLASS="SCREEN"
>case $TERM in
    hpterm)
        str="\e]0;%n@%m: %~\a"
	precmd () {print -Pn "\e&amp;f0k${#str}D${str}"}
   	precmd () {print -Pn "\e&amp;f-1k${#str}D${str}"}
	;;
esac</PRE
>&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN275"
>7. Приложение: примеры на других языках</A
></H1
><P
>Может быть полезно написать маленькую программу, вставляющую аргумент в заголовок. Ниже представлены несколько примеров.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN278"
>7.1. C</A
></H2
><P
>&#13;<PRE
CLASS="SCREEN"
>#include &#60;stdio.h&#62;

int main (int argc, char *argv[]) {
  printf("%c]0;%s%c", '\033', argv[1], '\007');
  return(0);
}</PRE
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN282"
>7.2. Perl</A
></H2
><P
>&#13;<PRE
CLASS="SCREEN"
>#!/usr/bin/perl
print "\033]0;@ARGV\007";</PRE
>&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN286"
>8. Благодарности</A
></H1
><P
>Хочу выразить благодарность следующим людям, давшим советы, нашедшим опечатки и предоставившим примеры для этого документа.</P
><P
>Paul D. Smith <TT
CLASS="LITERAL"
>&lt;psmith@BayNetworks.COM&gt;</TT
> и
Christophe Martin <TT
CLASS="LITERAL"
>&lt;cmartin@ipnl.in2p3.fr&gt;</TT
>
, отметившим неправильные кавычки вокруг <TT
CLASS="LITERAL"
>$PROMPT_COMMAND</TT
> в <TT
CLASS="LITERAL"
>bash</TT
>. Благодаря этому теперь переменные подставляются правильно.</P
><P
>Paul D. Smith <TT
CLASS="LITERAL"
>&lt;psmith@BayNetworks.COM&gt;</TT
>
, предложивший использовать <TT
CLASS="LITERAL"
>\[...\]</TT
> в приглашении <TT
CLASS="LITERAL"
>bash</TT
>
для непечатаемых символов.</P
><P
>Christophe Martin <TT
CLASS="LITERAL"
>&lt;cmartin@ipnl.in2p3.fr&gt;</TT
>
, предоставивший решение для <TT
CLASS="LITERAL"
>ksh</TT
>.</P
><P
>Keith Turner <TT
CLASS="LITERAL"
>&lt;keith@silvaco.com&gt;</TT
>
, предоставивший escape-последовательности для Sun <TT
CLASS="LITERAL"
>cmdtool</TT
> и
<TT
CLASS="LITERAL"
>shelltool</TT
>.</P
><P
>Jean-Albert Ferrez <TT
CLASS="LITERAL"
>&lt;ferrez@dma.epfl.ch&gt;</TT
>
, указавший на некоторые несовместимости в использовании "<TT
CLASS="LITERAL"
>PWD</TT
>"
и "<TT
CLASS="LITERAL"
>$PWD</TT
>", и использовании "<TT
CLASS="LITERAL"
>\</TT
>" с "<TT
CLASS="LITERAL"
>\\</TT
>".</P
><P
>Bob Ellison <TT
CLASS="LITERAL"
>&lt;papillo@hpellis.fc.hp.com&gt;</TT
> и
Jim Searle <TT
CLASS="LITERAL"
>&lt;jims@broadcom.com&gt;</TT
>, проверившие <TT
CLASS="LITERAL"
>dtterm</TT
>
на HP-UX.</P
><P
>Teng-Fong Seak <TT
CLASS="LITERAL"
>&lt;seak@drfc.cad.cea.fr&gt;</TT
>, предложивший опцию 
<TT
CLASS="LITERAL"
>-s</TT
> для <TT
CLASS="LITERAL"
>hostname</TT
>, использование <TT
CLASS="LITERAL"
>`pwd`</TT
>, и использование <TT
CLASS="LITERAL"
>echo</TT
> в <TT
CLASS="LITERAL"
>csh</TT
>.</P
><P
>Trilia <TT
CLASS="LITERAL"
>&lt;trilia@nmia.com&gt;</TT
>, предложивший примеры на других языках.</P
><P
>Brian Miller <TT
CLASS="LITERAL"
>&lt;bmiller@telstra.com.au&gt;</TT
>, предложивший escape-последовательности и примеры для <TT
CLASS="LITERAL"
>hpterm</TT
>.</P
><P
>Lenny Mastrototaro <TT
CLASS="LITERAL"
>&lt;lenny@click3x.com&gt;</TT
>, объяснивший, что терминалы Irix используют последовательности xterm.</P
><P
>Paolo Supino <TT
CLASS="LITERAL"
>&lt;paolo@init.co.il&gt;</TT
>, предложивший использовать <TT
CLASS="LITERAL"
>\\$</TT
> в приглашении <TT
CLASS="LITERAL"
>bash</TT
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN333"
>9. Авторские права</A
></H1
><P
>Авторские права на русский перевод этого текста принадлежат &copy; 2000 SWSoft Pte Ltd.
Все права зарезервированы.</P
><P
>Этот документ является частью проекта Linux HOWTO.</P
><P
>Авторские права на документы Linux HOWTO принадлежат их авторам, если явно
не указано иное. Документы Linux HOWTO, а также их переводы, могут
быть воспроизведены и распространены полностью или частично на любом
носителе, физическом или электронном, при условии сохранения этой заметки об
авторских правах на всех копиях. Коммерческое распространение разрешается и
поощряется; но, так или иначе, автор текста и автор перевода желали бы знать о
таких дистрибутивах.</P
><P
>Все переводы и производные работы, выполненные по документам Linux HOWTO,
должны сопровождаться этой заметкой об авторских правах. Это делается в
целях предотвращения случаев наложения дополнительных ограничений на
распространение документов HOWTO. Исключения могут составить случаи
получения специального разрешения у координатора Linux HOWTO, с которым
можно связаться по адресу приведенному ниже.</P
><P
>Мы бы хотели распространить эту информацию по всем возможным каналам. Но
при этом сохранить авторские права и быть уведомленными о всех планах
распространения HOWTO. Если у вас возникли вопросы, пожалуйста, обратитесь
к координатору проекта Linux HOWTO по электронной почте:
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@metalab.unc.edu"
>linux-howto@metalab.unc.edu</A
>&#62;</TT
> или к координатору русского
перевода Linux HOWTO компании SWSoft Pte Ltd. по адресу
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@asplinux.ru"
>linux-howto@asplinux.ru</A
>&#62;</TT
></P
></DIV
></DIV
></BODY
></HTML
>