<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Из  DOS/Windows в Linux HOWTO : Файлы и программы</TITLE>
 <LINK HREF="DOS-Win-to-Linux-HOWTO-6.html" REL=next>
 <LINK HREF="DOS-Win-to-Linux-HOWTO-4.html" REL=previous>
 <LINK HREF="DOS-Win-to-Linux-HOWTO.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="DOS-Win-to-Linux-HOWTO-6.html">Следующий</A>
<A HREF="DOS-Win-to-Linux-HOWTO-4.html">Предыдущий</A>
<A HREF="DOS-Win-to-Linux-HOWTO.html#toc5">Содержание</A>
<HR>
<H2><A NAME="s5">5. Файлы и программы</A></H2>

<H2><A NAME="ss5.1">5.1 Файлы: Предварительные замечания</A>
</H2>

<P>Структура каталогов и файлов в Linux очень сходна с той, которая
используется в DOSWin. Фалы имеют имена, которые подчиняются специальным
правилам и хранятся в каталогах, некоторые из файлов являются исполнимыми и
у некоторых из них существуют ключи командной строки. Более того, вы можете
использовать символы шаблонов, перенаправление и конвейеризацию. Есть
только несколько небольших отличий:
<P>
<UL>
<LI>в DOS, имена файлов хранятся в так называемом формате 8.3; например
<CODE>NOTENOUG.TXT</CODE>. В Linux мы можем делать лучше. Если вы установили
Linux, используя файловую систему, подобную ext2 или umsdos, то вы можете
использовать более длинные имена файлов (до 255 символов), и с более чем
одной точкой в имени: например, <CODE>This_is.a.VERY_long.filename</CODE>.
Пожалуйста заметьте, что я использовал символы и верхнего и нижнего
регистра: в действительности...
</LI>
<LI>символы верхнего и нижнего регистра в именах файлов отличаются друг
от друга. Поэтому <CODE>FILENAME.tar.gz</CODE> и <CODE>filename.tar.gz</CODE>
являются разными файлами. <CODE>ls</CODE> является командой, а <CODE>LS</CODE>
является ошибкой;
</LI>
<LI>пользователи Windows, будьте осторожны при использовании длинных имен в
Linux. Если имя файла содержит пробелы (не рекомендуется, но возможно), то
вы должны заключить имя файла в двойные кавычки при обращении к нему.
Например:

<BLOCKQUOTE><CODE>
<PRE>
$ # следующая команда создает каталог, названный "My old files"
$ mkdir "My old files"
$ ls
My old files    bin     tmp
</PRE>
</CODE></BLOCKQUOTE>


А Также некоторые символы не должны использоваться: это
<CODE>!*$&amp;#</CODE>.
</LI>
<LI>не существует обязательных расширений типа <CODE>.COM</CODE> и
<CODE>.EXE</CODE> для программ или <CODE>.BAT</CODE> для командных файлов.
Исполнимые файлы отмечаются символом звездочка `<CODE>*</CODE>' в конце их
имен, при использовании команды <CODE>ls -F</CODE>. Например:

<BLOCKQUOTE><CODE>
<PRE>
$ ls -F
I_am_a_dir/   cindy.jpg    cjpg*   letter_to_Joe    my_1st_script*  old~
</PRE>
</CODE></BLOCKQUOTE>


Файлы <CODE>cjpg*</CODE> и <CODE>my_1st_script*</CODE> являются исполнимыми, то
есть ``программами''. В DOS, файлы резервных копий заканчиваются на
<CODE>.BAK</CODE>, тогда как под Linux они заканчиваются на знак тильды
`<CODE>~</CODE>'.  Также файл, чье имя начинается со знака точки,
считается скрытым. Например: файл <CODE>.I.am.a.hidden.file</CODE> не будет
показан при выполнении команды <CODE>ls</CODE>;
</LI>
<LI>Ключи командной строки (switches) программ DOS задаются в виде
<CODE>/switch</CODE>, Linux использует ключи в виде <CODE>-switch</CODE> или
<CODE>--switch</CODE>. Пример: <CODE>dir /s</CODE> становится <CODE>ls -R</CODE>.
Заметим, что много программ DOS, такие как <CODE>PKZIP</CODE> или <CODE>ARJ</CODE>,
используют ключи в стиле UNIX.
</LI>
</UL>
<P>Вы можете теперь перепрыгнуть к разделу 
<A HREF="DOS-Win-to-Linux-HOWTO-5.html#Files">Перевод команд из DOS в Linux</A>, но я надеюсь, что вы будете читать дальше.
<P>
<H2><A NAME="ss5.2">5.2 Символьные ссылки</A>
</H2>

<P>В UNIX имеется тип файлов, которых нет в DOS: символьные ссылки.  Он
может быть описан как ссылка на файл или каталог и может быть использован
вместо файла или каталога, на который она указывает; они сходны с ярлыками
в Windows. Примером символьный ссылки может быть <CODE>/usr/X11</CODE>, которая
указывает на каталог <CODE>/usr/X11R6</CODE>, или <CODE>/dev/modem</CODE>, который
указывает либо на <CODE>/dev/ttyS0</CODE> либо на <CODE>/dev/ttyS1</CODE>.
<P>Для того, чтобы создать символьную ссылку, используется команда:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ln -s &lt;file_or_dir> &lt;linkname>
</PRE>
</CODE></BLOCKQUOTE>
<P>Пример:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</PRE>
</CODE></BLOCKQUOTE>
<P>Теперь вы можете ссылаться на <CODE>g77manual.txt</CODE> вместо
<CODE>/usr/doc/g77/DOC</CODE>. Ссылки показываются следующим образом в списке
файлов каталога:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls -F
g77manual.txt@
$ ls -l
(разные вещи...)           g77manual.txt -> /usr/doc/g77/DOC
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="Permissions"></A> <A NAME="ss5.3">5.3 Права доступа и владение</A>
</H2>

<P>Файлы и каталоги DOS имеют следующие атрибуты: A (архивный), H
(скрытый), R (только чтение) и S (системный). В Linux только H и R имеют
значение: скрытые файлы начинаются с точки, а для того чтобы задать атрибут
R, читайте дальше.
<P>В UNIX файл имеет ``права доступа'' и ``владельца'', который относится к
``группе''. Посмотрите пример:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</PRE>
</CODE></BLOCKQUOTE>
<P>Первое поле содержит права доступа к файлу  <CODE>/bin/ls</CODE>, который
принадлежит пользователю root, группы bin. Опуская другую информацию,
запомните, что означает <CODE>-rwxr-xr-x</CODE>, слева направо:
<P><CODE>-</CODE> это тип файла (<CODE>-</CODE> = обычный файл, <CODE>d</CODE> = каталог,
<CODE>l</CODE> = ссылка, и т.д.); <CODE>rwx</CODE> являются правами доступа для
владельца файла (чтение, запись, выполнение); <CODE>r-x</CODE> являются правами
доступа для группы, к которой относится владелец файла (чтение,
выполнение); (Я не хочу делать обозрение концепции групп, вы можете выжить
без нее, поскольку вы начинающий пользователь ;-) <CODE>r-x</CODE> являются
правами доступа для всех остальных пользователей (чтение, выполнение).
<P>Каталог <CODE>/bin</CODE> тоже имеет права доступа: смотрите раздел 
<@@ref>Права доступа к каталогамDirectories Permissions</A> для
дополнительной информации. Вот поэтому вы не можете удалить файл
<CODE>/bin/ls</CODE> до тех пор, пока не станете пользователемroot: вы просто
не имеете прав сделать это. Для изменения прав доступа к файлу используется
команда:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod &lt;whoXperm> &lt;file>
</PRE>
</CODE></BLOCKQUOTE>
<P>где who---это <CODE>u</CODE> (пользователь, который является владельцем),
<CODE>g</CODE> (группа), <CODE>o</CODE> (остальные), X---это либо <CODE>+</CODE>, либо
<CODE>-</CODE>, perm---это <CODE>r</CODE> (чтение), <CODE>w</CODE> (запись), или
<CODE>x</CODE> (выполнение).  Вот общие примеры использования команды
<CODE>chmod</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod +x file
</PRE>
</CODE></BLOCKQUOTE>
<P>устанавливает право на выполнения данного файла.
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod go-rw file
</PRE>
</CODE></BLOCKQUOTE>
<P>удаляет право на чтение и запись для всех, кроме владельца файла.
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod ugo+rwx file
</PRE>
</CODE></BLOCKQUOTE>
<P>дает всем права на чтение, запись и выполнение. 
<P>
<BLOCKQUOTE><CODE>
<PRE>
# chmod +s file
</PRE>
</CODE></BLOCKQUOTE>
<P>делает так называемый ``setuid'' или ``suid'' файл---файл, который любой
может выполнять с привилегиями владельца. Обычно, это применяется к файлам,
владельцем которых является  root; часто это важные системный файлы, такие
как X-сервер.
<P>Более коротким способом для ссылки на права доступа является использование
цифрового обозначения: <CODE>rwxr-xr-x</CODE> может быть выражен как 755
(каждый символ соответствует биту: <CODE>---</CODE> равен 0, <CODE>--x</CODE> равен
1, <CODE>-w-</CODE> равен 2, <CODE>-wx</CODE> равен 3...). Это выглядит трудным, но,
немного попрактиковавшись, вы поймете концепцию. root, будучи
администратором, может изменять права доступа на файлы любого пользователя.
RMP.
<P>
<P>
<H2><A NAME="Files"></A> <A NAME="ss5.4">5.4 Файлы: Перевод команд </A>
</H2>

<P>На левой стороне находятся команды DOS; справа их аналоги в Linux.
<P>
<BLOCKQUOTE><CODE>
<PRE>
ATTRIB:         chmod
COPY:           cp
DEL:            rm
MOVE:           mv
REN:            mv
TYPE:           more, less, cat
</PRE>
</CODE></BLOCKQUOTE>
<P>Операторы перенаправления и конвейеризации: <CODE> &lt; > >> |</CODE>
<P>Символы шаблонов: <CODE>* ?</CODE>
<P><CODE>устройство nul:        /dev/null</CODE>
<P><CODE>Устройства prn, lpt1:  /dev/lp0 or /dev/lp1; lpr</CODE>
<P>
<H3>Примеры</H3>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
DOS                                     Linux
---------------------------------------------------------------------

C:\\GUIDO>ATTRIB +R FILE.TXT             $ chmod 400 file.txt
C:\\GUIDO>COPY JOE.TXT JOE.DOC           $ cp joe.txt joe.doc
C:\\GUIDO>COPY *.* TOTAL                 $ cat * > total
C:\\GUIDO>COPY FRACTALS.DOC PRN          $ lpr fractals.doc
C:\\GUIDO>DEL TEMP                       $ rm temp
C:\\GUIDO>DEL *.BAK                      $ rm *~
C:\\GUIDO>MOVE PAPER.TXT TMP\\           $ mv paper.txt tmp/
C:\\GUIDO>REN PAPER.TXT PAPER.ASC        $ mv paper.txt paper.asc
C:\\GUIDO>PRINT LETTER.TXT               $ lpr letter.txt
C:\\GUIDO>TYPE LETTER.TXT                $ more letter.txt
C:\\GUIDO>TYPE LETTER.TXT                $ less letter.txt
C:\\GUIDO>TYPE LETTER.TXT > NUL          $ cat letter.txt > /dev/null
        n/a                              $ more *.txt *.asc
        n/a                              $ cat section*.txt | less
</PRE>
</CODE></BLOCKQUOTE>
<P>Примечания:
<P>
<UL>
<LI><CODE>*</CODE> намного  ``умнее '' в  Linux: <CODE>*</CODE> соответствует
всем файлам, за исключением скрытых; <CODE>.*</CODE> соответствует всем скрытым
файлам (но также текущему каталогу `<CODE>.</CODE>' и каталогу уровнем выше
`<CODE>..</CODE>': beware!); <CODE>*.*</CODE> соответствует только тем, которые
имеют `<CODE>.</CODE>' в середине имени, или оканчиваются на точку;
<CODE>p*r</CODE> соответствует и `peter' и `piper'; <CODE>*c*</CODE> соответствует
и `picked' и `peck';
</LI>
<LI>при использовании <CODE>more</CODE>, необходимо нажимать на клавишу
&lt;SPACE&gt; для того, чтобы продвигаться по файлу, и `q' для выхода.
<CODE>less</CODE> является более интуитивно понятной командой и позволяет вам
использовать клавиши управления курсором;
</LI>
<LI>нет команды <CODE>UNDELETE</CODE> (восстановления после удаления), так
что <EM>дважды подумайте</EM> до удаления чего-либо;
</LI>
<LI>в добавлении к используемым в  DOS' <CODE>&lt; &gt; &gt;&gt;</CODE>, в
Linux имеется <CODE>2&gt;</CODE> для перенаправления сообщений об ошибках
(stderr); более того, <CODE>2&gt;&amp;1</CODE> перенаправляет stderr в stdout,
в то время как <CODE>1&gt;&amp;2</CODE> перенаправляет stdout в stderr;
</LI>
<LI>Linux имеет дополнительный шаблон (wildcard): <CODE>[]</CODE>.
Использование: <CODE>[abc]*</CODE> соответствует файлам, начинающимся с  a, b,
c; <CODE>*[I-N1-3]</CODE> соответствует файлам, оканчивающимся на  I, J, K, L,
M, N, 1, 2, 3;
</LI>
<LI>команда <CODE>lpr</CODE> &lt;file&gt; печатает файл в фоновом режиме. Для
проверки состояния очереди печати используйте команду <CODE>lpq</CODE>; для
удаления файла из очереди печати используйте <CODE>lprm</CODE>;
</LI>
<LI>нет команды, похожей на команду <CODE>RENAME</CODE> в DOS; так что
команда <CODE>mv *.xxx *.yyy</CODE> не будет работать. команда, похожая на REN,
доступна с 
<A HREF="ftp://metalab.unc.edu/pub/Linux/utils/file">ftp://metalab.unc.edu/pub/Linux/utils/file</A>;
</LI>
<LI>используйте команды <CODE>cp -i</CODE> и <CODE>mv -i</CODE> для того, чтобы
вас предупредили, когда файл будет перезаписываться.
</LI>
</UL>
<P>
<H2><A NAME="ss5.5">5.5 Запуск программ: Многозадачность и сеансы работы</A>
</H2>

<P>Для запуска программы просто наберите ее имя, так как вы делали это в
DOS. Если каталог (Раздел 
<A HREF="DOS-Win-to-Linux-HOWTO-6.html#Directories">Использование каталогов</A>), где находится программа, находится в переменной среды PATH
(Раздел 
<A HREF="DOS-Win-to-Linux-HOWTO-9.html#System Initialisation">Файлы инициализации системы</A>), то программа будут запущена.  Исключение: в отличии от DOS, в
Linux программа, расположенная в текущем каталоге, не будет запускаться до
тех пор, пока вы не включите этот каталог в PATH. Предупреждение: если
<CODE>prog</CODE> это ваша программа, то наберите <CODE>./prog</CODE> для ее
запуска из текущего каталога.
<P>Типичная командная строка выглядит примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ command [-s1 [-s2] ... [-sn]] [par1 [par2] ... [parn]] [&lt; input] [> output]
</PRE>
</CODE></BLOCKQUOTE>
<P>где <CODE>-s1</CODE>, ..., <CODE>-sn</CODE> являются ключами программы, а
<CODE>par1</CODE>, ..., <CODE>parn</CODE> являются параметрами программы.  Вы
можете запустить несколько команд из одной командной строки:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ command1 ; command2 ; ... ; commandn
</PRE>
</CODE></BLOCKQUOTE>
<P>Это все о запуске программ, но теперь легко сделать следующий шаг.  Одна из
основных причин использования Linux---это то, что она является
многозадачной операционной системой---она может выполнять разные программы
(с этого места мы будем называть их процессами) одновременно. Вы можете
запускать процессы в фоновом режиме и продолжать работать. Более того,
Linux позволяет вам иметь несколько сеансов работы: Это подобно наличию
множества компьютеров на одном!
<P>
<UL>
<LI>Для того,чтобы переключится в сеанс 1..6 на виртуальных консолях,
нажмите &lt;ALT-F1&gt; ... &lt;ALT-F6&gt;
</LI>
<LI>Для запуска нового сеанса в той же самой виртуальной консоли без
выхода из нее, наберите <CODE>su - &lt;loginname&gt;</CODE>. Пример: <CODE>su -
root</CODE>. Это полезно, например, когда вам надо выполнить задачу, которую
может выполнить только root.
</LI>
<LI>Для окончания сеанса работы наберите <CODE>exit</CODE>. Если у вас есть
приостановленные задания (смотрите дальше), то вас предупредят.
</LI>
<LI>Для запуска процесса в фоновом режиме, добавьте знак амперсанда
'<CODE>&amp;</CODE>' в конец командной строки:

<BLOCKQUOTE><CODE>
<PRE>
$ progname [-switches] [parameters] [&lt; input] [> output] &amp;
[1] 123
</PRE>
</CODE></BLOCKQUOTE>


Командный процессор идентифицирует процессы по номеру задания  (например
<CODE>[1]</CODE>; смотрите ниже), и по PID (Идентификационный номер процесса;
123 в нашем примере).
</LI>
<LI>Для того, чтобы увидеть, сколько процессов запущено, наберите <CODE>ps
ax</CODE>. Эта команда выдаст список запущенных в настоящее время процессов. 
</LI>
<LI>Для того чтобы убить, (завершить) процесс, наберите команду <CODE>kill
&lt;PID&gt;</CODE>. Вам может понадобиться убить процесс в том случае, если вы
не знаете, как его правильно завершить... До тех пор, пока вы не станете
root, вы не сможете завершать процессы других людей.  Иногда процесс может
быть завершен только используя команду <CODE>kill -SIGKILL &lt;PID&gt;</CODE>.

В дополнение командный процессор позволяет вам остановить или временно
приостановить процесс, перевести процесс в фоновый режим, и перевести процесс
из фонового режима в интерактивный режим. В этом контексте процессы
называются ``заданиями''.
</LI>
<LI>Для того чтобы узнать, сколько заданий существует наберите
<CODE>jobs</CODE>. Здесь задания идентифицируются по номеру задания, а не по их
PID.
</LI>
<LI>Для того, чтобы остановить процесс, запущенный в интерактивном режиме,
нажмите &lt;CTRL-C&gt; (это не всегда работает).
</LI>
<LI>Для того, чтобы приостановить процесс, запущенный в интерактивном
режиме , нажмите &lt;CTRL-Z&gt; (то же самое).
</LI>
<LI>Для перевода приостановленного процесса в фоновый режим, наберите
<CODE>bg &lt;%job&gt;</CODE> (он станет заданием).
</LI>
<LI>Для перевода задания в интерактивный режим наберите <CODE>fg
&lt;%job&gt;</CODE>. Для перевода в интерактивный режим последнего задания,
запущенного в фоновом режиме, просто наберите <CODE>fg</CODE>.
</LI>
<LI>Для завершения задания наберите <CODE>kill &lt;%job&gt;</CODE>, где
&lt;job&gt; может быть 1, 2, 3,...  
</LI>
</UL>
<P>Используя эти команды вы можете форматировать диск, сжимать кучу файлов,
компилировать программу и разжимать архив в одно и тоже время и все равно
иметь командную строку для своих нужд. Попробуйте сделать это в Windows,
просто чтобы посмотреть разницу в производительности (конечно, если он не
рухнет).
<P>
<H2><A NAME="ss5.6">5.6 Запуск программ на удаленных компьютерах</A>
</H2>

<P>Для запуска программы на удаленной машине, чьим именем является
<CODE>remote.machine.edu</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ telnet remote.machine.edu
</PRE>
</CODE></BLOCKQUOTE>
<P>После входа в систему , запустите вашу любимую программу. Излишне говорить,
что вам необходимо быть зарегистрированным на удаленной машине и иметь
доступ к командному процессору.
<P>Если у вас есть X11, вы даже можете запустить приложение для X на удаленной
машине, отображая его на вашем экране X Windows. Допустим, что
<CODE>remote.machine.edu</CODE>>&nbsp;-- это удаленный компьютер с X и
допустим, что <CODE>local.linux.box</CODE>&nbsp;-- это ваша машина с Linux. Для
запуска с <CODE>local.linux.box</CODE> программы для X, которая расположена на
<CODE>remote.machine.edu</CODE>, выполните следующее:
<P>
<UL>
<LI>запустите X11, запустите <CODE>xterm</CODE> или подобный эмулятор
терминала, затем наберите:

<BLOCKQUOTE><CODE>
<PRE>
$ xhost +remote.machine.edu
$ telnet remote.machine.edu
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>После входа в систему наберите:

<BLOCKQUOTE><CODE>
<PRE>
remote:$ DISPLAY=local.linux.box:0.0
remote:$ progname &amp;
</PRE>
</CODE></BLOCKQUOTE>


(вместо <CODE>DISPLAY...</CODE>, вам может понадобиться написать: <CODE>setenv
DISPLAY local.linux.box:0.0</CODE>. Это зависит от командного процессора на
удаленной машине).
</LI>
</UL>
<P>И все! Теперь <CODE>progname</CODE> будет запущена на
<CODE>remote.machine.edu</CODE> и будет отображаться на вашей машине. Не
пытайтесь делать это через модем, это слишком медленно, чтобы можно было
пользоваться. Более того, это грубый и небезопасный метод: пожалуйста
прочитайте ``Remote X Apps mini-HOWTO'' по адресу 
<A HREF="http://www.linuxdoc.org/HOWTO/mini/Remote-X-Apps.html">http://www.linuxdoc.org/HOWTO/mini/Remote-X-Apps.html</A>.
<P>
<P>
<HR>
<A HREF="DOS-Win-to-Linux-HOWTO-6.html">Следующий</A>
<A HREF="DOS-Win-to-Linux-HOWTO-4.html">Предыдущий</A>
<A HREF="DOS-Win-to-Linux-HOWTO.html#toc5">Содержание</A>
</BODY>
</HTML>
