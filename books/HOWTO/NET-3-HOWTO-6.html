<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Сетевая поддержка в Линуксе, Linux NET-3-HOWTO.: Информация об IP- Ethernet-сетях.</TITLE>
 <LINK HREF="NET-3-HOWTO-7.html" REL=next>
 <LINK HREF="NET-3-HOWTO-5.html" REL=previous>
 <LINK HREF="NET-3-HOWTO.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="NET-3-HOWTO-7.html">Следующий</A>
<A HREF="NET-3-HOWTO-5.html">Предыдущий</A>
<A HREF="NET-3-HOWTO.html#toc6">Содержание</A>
<HR>
<H2><A NAME="s6">6. Информация об IP- Ethernet-сетях.</A></H2>

<P>В этом разделе рассматриваются вопросы работы ethernet и IP сетей.
Фактически здесь собраны наиболее интересные разделы из относящихся к
конкретным сетевым технологиям, и они будут полезны всем тем, что использует
Линукс в локальных сетях.
<H2><A NAME="ss6.1">6.1 Ethernet</A>
</H2>

<P>Ядро присваивает ethernet-устройствам имена`<CODE>eth0</CODE>', `<CODE>eth1</CODE>',
`<CODE>eth2</CODE>' и т.д. Первая обнаруженная карта получает имя `<CODE>eth0</CODE>',
а все остальные нумеруются по порядку обнаружения.
<P>По умолчанию ядро пытается обнаружить только одно ethernet-устройство,
если у Вас в машине несколько ethernet-карт, то Вам потребуется указать
в командной строке запуска ядра параметры для обнаружения оставшихся
карт.
<P>Подробно работа ethernet-карт под Линуксом описана в 
<A HREF="http://www.linux.org.ru/books/HOWTO/Ethernet-HOWTO.html">Ethernet-HOWTO</A>.
<P>После того как ядро будет скомпилировано с поддержкой Вашей ethernet-карты, Вам достаточно выполнить подобные следующим команды для ее
настойки:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up
        root# route add -net 192.168.0.0 netmask 255.255.255.0 eth0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Большинство драйверов ethernet-карт было написано Дональдом Беккером
(Donald Becker, <CODE>becker@CESDIS.gsfc.nasa.gov</CODE>).
<H2><A NAME="ss6.2">6.2 EQL -- балансировщик потока данных.</A>
</H2>

<P>Это устройство имеет имя `<CODE>eql</CODE>' (оно может быть только одно) и служит
для объединения нескольких соединений точка-точка, таких как PPP, slip
или plip в одно соединение, по которому передаются IP-пакеты. Иногда
оказывается дешевле использовать несколько низкоскоростных соединений,
чем одно высокоскоростное.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Network device support  --->
            [*] Network device support
            &lt;*> EQL (serial line load balancing) support
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Для работы такого соединения необходимо, чтобы машина на другой стороне
также поддерживала eql. Сейчас такая поддержка есть в Линуксе,
Livingstone Portmasters и некоторых современных dial-in серверах.
<P>Для настройки EQL вам понадобятся утилиты поддержки eql, которые можно
получит по адресу 
<A HREF="ftp://sunsite.unc.edu/pub/linux/system/Serial/eql-1.2.tar.gz">sunsite.unc.edu</A>.
<P>Настройка достаточно проста. Первым делом необходимо настроить eql-интерфейс. Он настраивается так же, как и любое другое сетевое
устройство. IP-адрес и mtu настраиваются программой <EM>ifconfig</EM>:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eql 192.168.10.1 mtu 1006
        
</PRE>
</CODE></BLOCKQUOTE>

<P>После этого Вы должны настроить все Ваши реальные соединения точка-точка. Способ настройки зависит от типа соединения -- обратитесь к
соответствующему разделу этого документа за подробностями.
<P>И наконец Вы должны связать все эти соединения с eql. Этот процесс
называют `подчинением' и выполняется с помощью программы <EM>eql_enslave</EM>:

<BLOCKQUOTE><CODE>
<PRE>
        root# eql_enslave eql sl0 28800
        root# eql_enslave eql ppp0 14400
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Параметр `<EM>ожидаемая скорость соединения</EM>' (последний параметр в
примере) оказывает косвенное влияние на работу eql. Он определяет долю
пакетов, передаваемых через соответствующее соединение, и Вы можете пытаться
повысить производительность eql, меняя этот параметр.
<P>Для отсоединения сетевого интерфейса от eql используйте программу
<EM>eql_emancipate</EM>:

<BLOCKQUOTE><CODE>
<PRE>
        root# eql_emancipate eql sl0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>При настройке маршрутизации замените в командах <EM>route</EM> все `подчиненные'
интерфейсы на eql. Обычно это выглядит так:

<BLOCKQUOTE><CODE>
<PRE>
        root# route add default eql
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Драйвер EQL был написан Саймоном Джейнсом (Simon Janes, <CODE>simon@ncm.com</CODE>).
<H2><A NAME="ss6.3">6.3 IP-учет (для версий ядра 2.0).</A>
</H2>

<P>Функция IP-учета позволяет ядру собирать и анализировать информацию об
использовании сети. Ядро собирает данные о количестве пакетов и
количестве байт, переданных по сети с момента последнего сброса этих
данных. Вы можете задать различные правила для того, чтобы
классифицировать эти данные. В ядре версии 2.1.102 эта возможность была
временно изъята, так как старая программа настройки файрволла ipfwadm,
которая используется и для настройки IP-учета, была заменена на
``ipfwchains''.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Networking options  --->
            [*] IP: accounting
        
</PRE>
</CODE></BLOCKQUOTE>

<P>После того, как Вы откомпилировали и установили ядро с поддержкой
IP-учета, используйте программу <EM>ipfwadm</EM> для его настройки. Вам может
потребоваться разбивать учетную информацию по многим признакам. Ниже
приведен простой, но достаточно полезный пример, за более детальной
информацией обратитесь к man-странице программы <EM>ipfwadm</EM>.
<P>Сценарий: У Вас есть ethernet-сеть, подключенная к интернету через
PPP-соединение. На одной из машин в сети запущено большое количество
сервисов и Вы хотели бы знать какой объем данных передается сервисами
telnet, rlogin, ftp и http.
<P>Вы можете использовать следующий скрипт:
<BLOCKQUOTE><CODE>
<PRE>

        #!/bin/sh
        #
        # Сброс правил учета
        ipfwadm -A -f
        #
        # Правила для локальной сети
        ipfwadm -A in -a -P tcp -D 44.136.8.96/29 20
        ipfwadm -A out -a -P tcp -S 44.136.8.96/29 20
        ipfwadm -A in -a -P tcp -D 44.136.8.96/29 23
        ipfwadm -A out -a -P tcp -S 44.136.8.96/29 23
        ipfwadm -A in -a -P tcp -D 44.136.8.96/29 80
        ipfwadm -A out -a -P tcp -S 44.136.8.96/29 80
        ipfwadm -A in -a -P tcp -D 44.136.8.96/29 513
        ipfwadm -A out -a -P tcp -S 44.136.8.96/29 513
        ipfwadm -A in -a -P tcp -D 44.136.8.96/29
        ipfwadm -A out -a -P tcp -D 44.136.8.96/29
        ipfwadm -A in -a -P udp -D 44.136.8.96/29
        ipfwadm -A out -a -P udp  -D 44.136.8.96/29
        ipfwadm -A in -a -P icmp -D 44.136.8.96/29
        ipfwadm -A out -a -P icmp -D 44.136.8.96/29
        #
        # Правила по умолчанию
        ipfwadm -A in -a -P tcp -D 0/0 20
        ipfwadm -A out -a -P tcp -S 0/0 20
        ipfwadm -A in -a -P tcp -D 0/0 23
        ipfwadm -A out -a -P tcp -S 0/0 23
        ipfwadm -A in -a -P tcp -D 0/0 80
        ipfwadm -A out -a -P tcp -S 0/0 80
        ipfwadm -A in -a -P tcp -D 0/0 513
        ipfwadm -A out -a -P tcp -S 0/0 513
        ipfwadm -A in -a -P tcp -D 0/0
        ipfwadm -A out -a -P tcp -D 0/0
        ipfwadm -A in -a -P udp -D 0/0
        ipfwadm -A out -a -P udp  -D 0/0
        ipfwadm -A in -a -P icmp -D 0/0
        ipfwadm -A out -a -P icmp -D 0/0
        #
        # Распечатать список правил
        ipfwadm -A -l -n
        #
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Имена ``ftp-data'' и ``www'' -- имена сервисов из файла
<CODE>/etc/services</CODE>. Последняя команда печатает список правил
и накопленные данные.
<P>Следует обратить внимание на то, что при обработке пакета <B>величины
накопленных данных во всех подходящих правилах будут увеличены</B>,
поэтому Вам потребуется произвести некоторые вычисления для того,
чтобы получить интересующие Вас данные. Например, для того, чтобы
узнать какое количество данных было передано "мимо" telnet, rlogin,
ftp или http, необходимо вычесть из их данные из данных правила,
которое описывает все порты.

<BLOCKQUOTE><CODE>
<PRE>
root# ipfwadm -A -l -n
IP accounting rules
 pkts bytes dir prot source               destination          ports
    0     0 in  tcp  0.0.0.0/0            44.136.8.96/29       * -> 20
    0     0 out tcp  44.136.8.96/29       0.0.0.0/0            20 -> *
   10  1166 in  tcp  0.0.0.0/0            44.136.8.96/29       * -> 80
   10   572 out tcp  44.136.8.96/29       0.0.0.0/0            80 -> *
  252 10943 in  tcp  0.0.0.0/0            44.136.8.96/29       * -> *
  231 18831 out tcp  44.136.8.96/29       0.0.0.0/0             * -> *
    0     0 in  udp  0.0.0.0/0            44.136.8.96/29       * -> *
    0     0 out udp  44.136.8.96/29       0.0.0.0/0            * -> *
    0     0 in  tcp  0.0.0.0/0            0.0.0.0/0            * -> 20
    0     0 out tcp  0.0.0.0/0            0.0.0.0/0            20 -> *
   10  1166 in  tcp  0.0.0.0/0            0.0.0.0/0            * -> 80
   10   572 out tcp  0.0.0.0/0            0.0.0.0/0            80 -> *
  253 10983 in  tcp  0.0.0.0/0            0.0.0.0/0            * -> *
  231 18831 out tcp  0.0.0.0/0            0.0.0.0/0            * -> *
    0     0 in  udp  0.0.0.0/0            0.0.0.0/0            * -> *
    0     0 out udp  0.0.0.0/0            0.0.0.0/0            * -> *
</PRE>
</CODE></BLOCKQUOTE>

<H2><A NAME="ss6.4">6.4 IP-учет (для версий ядра 2.2)</A>
</H2>

<P>Новая система учета использует систему ``IP Firewall Chains''.
Обратитесь к 
<A HREF="http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html">странице системы IP-цепочек</A> за более детальной информацией.
Среди прочего, Вы будете должны использовать программу <EM>ipchains</EM>
вместо программы <CODE>ipfwadm</CODE> для настройки IP-учета.
(Информация взята из файла <CODE>Documentation/Changes</CODE> последней
версии исходных текстов ядра).
<H2><A NAME="ss6.5">6.5 IP-псевдонимы.</A>
</H2>

<P>Иногда оказывается полезным, чтобы одному сетевому устройству
соответствовало несколько IP-адресов. Например, эта функция
используется интернет-провайдерами для создания www или ftp-сайтов
своих клиентов. Несколько более подробное описание IP-псевдонимов
дается в ``IP-Alias mini-HOWTO''.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Networking options  --->
            ....
            [*] Network aliasing
            ....
            &lt;*> IP: aliasing support
        
</PRE>
</CODE></BLOCKQUOTE>

<P>После того, как вы откомпилируете и установите ядро с поддержкой
IP-псевдонимов, дальнейшие настройки достаточно просты. IP-псевдонимы
присваиваются виртуальным устройствам, связанным с реальным устройством.
Имена этим устройствам присваиваются по правилу
<CODE>&lt;имя_устройсва>:&lt;номер_виртуального_устройства></CODE>, например
<CODE>eth0:0</CODE> или <CODE>ppp0:10</CODE>. Такое устройство нужно конфигурировать
<EM>после</EM> настройки основного интерфейса.
<P>Предположим, что у Вас есть ethernet-сеть с двумя существующими
одновременно IP-сетями, и Вы хотите, чтобы Ваша машина имела доступ к
обеим этим сетям. Для этого выполните следующие команды:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eth0:0 192.168.1.1 netmask 255.255.255.0 up
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0:0

        root# ifconfig eth0:1 192.168.10.1 netmask 255.255.255.0 up
        root# route add -net 192.168.10.0 netmask 255.255.255.0 eth0:0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Для удаления псевдонима просто добавьте символ `<CODE>-</CODE>' к имени устройства:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eth0:0- 0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Все данные о маршрутизации через этот псевдоним будут автоматически
удалены.
<H2><A NAME="ss6.6">6.6 IP файрволл (для версий ядра 2.0).</A>
</H2>

<P>Использование файрволлов подробно рассмотрено в 
<A HREF="http://www.linux.org.ru/books/HOWTO/Firewall-HOWTO.html">Firewall-HOWTO</A>. IP-файрволл позволяет вам предотвращать
несанкционированный доступ к Вашей машине путем отбрасывания IP-пакетов
по заданным правилам. Есть три типа правил -- входные фильтры, выходные
фильтры и фильтры передачи. Входные фильтры применяются к пакетам,
приходящим из сети. Выходные фильтры применяются к пакетам, предназначенным
к отправке в сеть. Фильтры передачи применяются к полученным пакетам,
которые не предназначены для данной машины и должны быть маршрутизированы.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Networking options  --->
            [*] Network firewalls
            ....
            [*] IP: forwarding/gatewaying
            ....
            [*] IP: firewalling
            [ ] IP: firewall packet logging
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Задание фильтров производится с помощью программы <EM>ipfwadm</EM>. Данный
документ не ставит своей задачей углубляться в тонкости сетевой
безопасности, поэтому, если Вы хотите надежно защитить свою сеть,
вам потребуется самостоятельно ознакомится с этим вопросом.
<P>По-видимому наиболее распространенный случай использования
IP-файрволла -- это когда Ваша машина является маршрутизатором,
через который локальная сеть подключена в интернету, и Вы хотите
предотвратить несанкционированный доступ к машинам Вашей локальной
сети с машин из внешних сетей.
<P>Данный пример был любезно предоставлен Арнтом Гюлбрандсеном
(Arnt Gulbrandsen, <CODE>&lt;agulbra@troll.no&gt;</CODE>).
<P>Данный пример иллюстрирует настройку фильтров для маршрутизатора,
изображенного на этом рисунке:

<BLOCKQUOTE><CODE>
<PRE>
     -                                   -
      \                                  | 172.16.37.0
       \                                 |   /255.255.255.0
        \                 ---------      |
         |  172.16.174.30 | Linux |      |
     NET =================|  f/w  |------|    ..37.19
         |    PPP         | router|      |  --------
        /                 ---------      |--| Mail |
       /                                 |  | /DNS |
      /                                  |  --------
     -                                   -
</PRE>
</CODE></BLOCKQUOTE>

<P>Приведенные ниже команды настройки файрволла следует поместить в один
из <CODE>rc</CODE>-файлов, так чтобы они автоматически выполнялись при запуске
системы. Для обеспечения максимальной безопасности их следует выполнять
после настройки сетевых интерфейсов, но до их активизации, чтобы
предотвратить возможность несанкционированного доступа в момент загрузки
системы.

<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/sh

        # Сбросить таблицу фильтров передачи
        # Установить правило по умолчанию в 'разрешить'
        #
        /sbin/ipfwadm -F -f
        /sbin/ipfwadm -F -p accept
        #
        # То же самое для входных фильтров
        #
        /sbin/ipfwadm -I -f
        /sbin/ipfwadm -I -p accept

        # Настроить интерфейс PPP
        # Можно было бы использовать опцию '-a deny' вместо '-a reject -y'
        # но тогда будет невозможно открывать исходящие соединения на этом
        # интерфейсе. Опция '-o' указывает, что отвергнутые пакеты следует
        # протоколировать. Тратя место на диске, вы получаете возможность
        # обнаруживать атаки и ошибки в конфигурации.
        #
        /sbin/ipfwadm -I -a reject -y -o -P tcp -S 0/0 -D 172.16.174.30

        # Отбрасывать очевидно неверные пакеты:
        # Информация не должна приходит с любых типов широковещательных адресов
        #
        /sbin/ipfwadm -F -a deny -o -S 224.0/3 -D 172.16.37.0/24
        #
        # Пакеты с кольцевого интерфейса не должны попадать на реальный
        #
        /sbin/ipfwadm -F -a deny -o -S 127.0/8 -D 172.16.37.0/24

        # разрешить входящие SMTP и DNS запросы, но только к выделенному для
        # этого серверу
        #
        /sbin/ipfwadm -F -a accept -P tcp -S 0/0 -D 172.16.37.19 25 53
        #
        # DNS использует протокол UDP наряду с TCP, его тоже следует разрешить
        #
        /sbin/ipfwadm -F -a accept -P udp -S 0/0 -D 172.16.37.19 53
        #
        # запретить "ответы" на опасные порты, такие как NFS или его расширений
        # (Larry McVoy's NFS extension). Если у Вас работает squid, добавьте и
        # его порты
        #
        /sbin/ipfwadm -F -a deny -o -P udp -S 0/0 53 \
                -D 172.16.37.0/24 2049 2050

        # ответы на другие порты разрешены
        #
        /sbin/ipfwadm -F -a accept -P udp -S 0/0 53 \
                -D 172.16.37.0/24 53 1024:65535

        # Запретить входящие соединения с демоном identd
        # Используйте параметр 'reject' чтобы машина, пытающаяся установить
        # соединение получала отказ немедленно
        #
        /sbin/ipfwadm -F -a reject -o -P tcp -S 0/0 -D 172.16.37.0/24 113

        # Разрешить соединения определенных типов из "дружественных" сетей
        # 192.168.64 и 192.168.65.
        #
        /sbin/ipfwadm -F -a accept -P tcp -S 192.168.64.0/23 \
                -D 172.16.37.0/24 20:23

        # Разрешить прохождение любых пакетов из локальной сети.
        #
        /sbin/ipfwadm -F -a accept -P tcp -S 172.16.37.0/24 -D 0/0

        # запретить остальные tcp-соединения и протоколировать их
        # (добавьте 1:1023 если у Вас перестанет работать ftp)
        #
        /sbin/ipfwadm -F -a deny -o -y -P tcp -S 0/0 -D 172.16.37.0/24

        # то же самое для udp-соединений
        #
        /sbin/ipfwadm -F -a deny -o -P udp -S 0/0 -D 172.16.37.0/24
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Правильная настройка файрволла -- нелегкая задача. Приведенный пример
может послужить хорошей отправной точкой. Некоторую информацию Вы можете
получить, воспользовавшись man-страницей программы <EM>ipfwadm</EM>. Обязательно
получите информацию из всех возможных надежных источников и попросите
кого-либо протестировать ваши настройки "снаружи".
<H2><A NAME="ss6.7">6.7 IP-файрволл (для версий ядра 2.2)</A>
</H2>

<P>Новый файрволл использует систему ``IP Firewall Chains''.
Обратитесь к 
<A HREF="http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html">странице системы IP-цепочек</A> за более детальной информацией.
Среди прочего, Вы будете должны использовать программу <EM>ipchains</EM>
вместо программы <CODE>ipfwadm</CODE> для настройки IP-файрволла.
(Информация взята из файла <CODE>Documentation/Changes</CODE> последней
версии исходных текстов ядра).

<H2><A NAME="ss6.8">6.8 IPIP-включение</A>
</H2>

<P>Зачем может понадобится передавать IP-пакеты внутри IP-пакетов? Если
Вы никогда не сталкивались с такой потребностью, подобная операция может
показаться странной. Два самых главных применения этой техники --
Мобильное IP и IP-рассылка. Еще одно применение -- Amateur Radio.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Networking options  --->
            [*] TCP/IP networking
            [*] IP: forwarding/gatewaying
            ....
            &lt;*> IP: tunneling
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Устройства "IP-тоннели" получают имена `<CODE>tunl0</CODE>', '<CODE>tunl1</CODE>' и т.д.
<P>Так все-таки, зачем это нужно? Обычные правила IP-маршрутизации
подразумевают, что IP-сеть имеет адрес и маску. Тем самым,
маршрутизация на блок последовательных адресов происходит с помощью
одной записи в таблице маршрутизации. Это означает, что при
подключении в конкретном месте сети Вы можете иметь конкретный
IP-адрес. Если Вы работаете с переносным компьютером, то место Вашего
подключения будет постоянно изменяться. Поэтому, если Вы собираетесь
временно работать в другом месте, Вы можете настроить машину на Вашем
обычном основном месте работы так, чтобы та перенаправляла приходящие
на Ваш адрес пакеты на Ваш новый адрес.
<H3>Настройка IP-туннеля сеть-сеть.</H3>

<P>Рассмотрим сеть следующей структуры:

<BLOCKQUOTE><CODE>
<PRE>

      192.168.1/24                          192.168.2/24

          -                                     -
          |      ppp0 =            ppp0 =       |
          |  aaa.bbb.ccc.ddd  fff.ggg.hhh.iii   |
          |                                     |
          |   /-----\                 /-----\   |
          |   |     |       //        |     |   |
          |---|  A  |------//---------|  B  |---|
          |   |     |     //          |     |   |
          |   \-----/                 \-----/   |
          |                                     |
          -                                     -
</PRE>
</CODE></BLOCKQUOTE>



Эта схема демонстрирует еще один пример использования IPIP-включения --
виртуальные частные сети. В этом примере предполагается, что у Вас есть
две машины с PPP-подключением к интернету. Каждой из них присвоен
IP-адрес. Эти машины подключены к локальным сетям, использующим адреса
из зарезервированного диапазона. Предположим, Вы хотите, чтобы машины из
одной локальной сети могли взаимодействовать с машинами из другой
сети, как будто они соединены непосредственно. Этого можно достичь
с помощью IPIP-включения. Это решение, правда, не позволит вашим
машинам из внутренних сетей обмениваться данными с другими машинами
в интернете -- для этого Вам потребуется использовать другие техники
вроде IP-маскарада. IPIP-включение производится на машинах A и B --
маршрутизаторах.
<P>На машине `<CODE>A</CODE>' выполните команды:

<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/sh
        PATH=/sbin:/usr/sbin
        mask=255.255.255.0
        remotegw=fff.ggg.hhh.iii
        #
        # Настройка Ethernet
        ifconfig eth0 192.168.1.1 netmask $mask up
        route add -net 192.168.1.0 netmask $mask eth0
        #
        # Настройка ppp0 (запуск ppp, установка маршрута по умолчанию)
        pppd
        route add default ppp0
        #
        # Настройка устройства-туннеля
        ifconfig tunl0 192.168.1.1 up
        route add -net 192.168.2.0 netmask $mask gw $remotegw tunl0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>А на машине `<CODE>B</CODE>' -- команды:

<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/sh
        PATH=/sbin:/usr/sbin
        mask=255.255.255.0
        remotegw=aaa.bbb.ccc.ddd
        #
        # Настройка Ethernet
        ifconfig eth0 192.168.2.1 netmask $mask up
        route add -net 192.168.2.0 netmask $mask eth0
        #
        # настройка ppp0 (запуск ppp, установка маршрута по умолчанию)
        pppd
        route add default ppp0
        #
        # Настройка устройства-туннеля
        ifconfig tunl0 192.168.2.1 up
        route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>
Команда

<BLOCKQUOTE><CODE>
<PRE>
        route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
        
</PRE>
</CODE></BLOCKQUOTE>


расшифровывается как `Посылать все пакеты для сети <CODE>192.168.1.0/24</CODE> внутри
пакетов, передаваемых на машину по адресу <CODE>aaa.bbb.ccc.ddd</CODE>'

Обратите внимание, что настройка туннеля требуется с обеих сторон.
Устройство-туннель использует параметр `<CODE>gw</CODE>' команды <EM>route</EM> для
определения адреса, на который следует передавать IP-пакеты, с
"завернутыми" в них пакетами, предназначенными для сети <CODE>192.168.1.0</CODE>.
<H3>Настройка IP-туннеля сеть-машина.</H3>

<P>Совсем не обязательно передавать через туннель данные между двумя
сетями. Иногда достаточно, чтобы на одном конце туннеля находилась
одна машина. В этом случае настройте устройство `<CODE>tunl</CODE>' на этой
машине на использование "домашнего" адреса, а на маршрутизаторе
A используйте маршрут на машину, а не на сеть (еще потребуется
использовать механизм кеширования аппаратного адреса (Proxy ARP)).
Рассмотрим этот случай. Цель -- добиться того, чтобы машина B вела
себя как машина, подключенная к интернету, и одновременно как
одна из машин сети `<CODE>A</CODE>.
<P>
<BLOCKQUOTE><CODE>
<PRE>

      192.168.1/24

          -
          |      ppp0 =                ppp0 =
          |  aaa.bbb.ccc.ddd      fff.ggg.hhh.iii
          |
          |   /-----\                 /-----\
          |   |     |       //        |     |
          |---|  A  |------//---------|  B  |
          |   |     |     //          |     |
          |   \-----/                 \-----/
          |                      also: 192.168.1.12
          -
</PRE>
</CODE></BLOCKQUOTE>
<P>На маршрутизаторе `<CODE>A</CODE>' выполните команды:

<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/sh
        PATH=/sbin:/usr/sbin
        mask=255.255.255.0
        remotegw=fff.ggg.hhh.iii
        #
        # Настройка Ethernet
        ifconfig eth0 192.168.1.1 netmask $mask up
        route add -net 192.168.1.0 netmask $mask eth0
        #
        # настройка ppp0 (запуск ppp, установка маршрута по умолчанию)
        pppd
        route add default ppp0
        #
        # Настройка туннеля
        ifconfig tunl0 192.168.1.1 up
        route add -host 192.168.1.12 gw $remotegw tunl0
        #
        # Кешировать аппаратный адрес удаленной машины
        arp -s 192.168.1.12 xx:xx:xx:xx:xx:xx pub
        
</PRE>
</CODE></BLOCKQUOTE>
<P>На машине `<CODE>B</CODE>' выполните команды:

<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/sh
        PATH=/sbin:/usr/sbin
        mask=255.255.255.0
        remotegw=aaa.bbb.ccc.ddd 
        #
        # Настройка ppp0 (запуск ppp, установка маршрута по умолчанию)
        pppd
        route add default ppp0
        #
        # Настройка туннеля
        ifconfig tunl0 192.168.1.12 up
        route add -net 192.168.1.0 netmask $mask gw $remotegwtunl0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Такая конфигурация характерна для так называемого "Мобильного IP".
Если Вы хотите перемещать одну машину по интернету, сохраняя неизменным
IP-адрес. За более подробной информацией о том, как это реализуется на
практике, обратитесь к разделу, посвященному мобильному IP.

<H2><A NAME="ss6.9">6.9 IP-маскарад (для версий ядра 2.0)</A>
</H2>

<P>Очень многие имеют обычное сеансовое подключение к интернет, при котором
интернет-провайдер выделяет только один IP-адрес. При этом в интернет можно
работать только с одной машины. IP-маскарад -- трюк, позволяющий нескольким
машинам одновременно использовать один IP-адрес, при этом с точки зрения
внешних машин выглядеть как одна машина. Правда такая конфигурация работает
только "в одну сторону" -- маскарадящиеся машины могут обращаться к любым
машинам в интернет, но сами при этом остаются недоступными для входящих
соединений. Это означает, что некоторые из сетевых сервисов просто не будут
работать (например <EM>talk</EM>), а некоторые (например <EM>ftp</EM>)должны быть
специально настроены на "пассивный" (PASV) режим работы. К счастью, наиболее
распространенные сервисы, такие как <EM>telnet</EM>, <EM>www</EM> и <EM>irc</EM> работают
нормально.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Code maturity level options  --->
            [*] Prompt for development and/or incomplete code/drivers
        Networking options  --->
            [*] Network firewalls
            ....
            [*] TCP/IP networking
            [*] IP: forwarding/gatewaying
            ....
            [*] IP: masquerading (EXPERIMENTAL)
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Настройте машину, поддерживающую PPP- или slip-соединение как обычную
(не маскарадящую) машину. Кроме того, на этой машине должно быть еще одно
сетевое устройство (как правило ethernet), через которое оно подключено к
внутренней сети. Настройте эту сеть с использованием адресов из одной из
зарезервированных сетей. На всех машинах укажите подключенную к интернет
машину в качестве маршрутизатора.
<P>Как правило, сеть имеет такую структуру:

<BLOCKQUOTE><CODE>
<PRE>
-                                   -
 \                                  | 192.168.1.0
  \                                 |   /255.255.255.0
   \                 ---------      |
    |                | Linux | .1.1 |
NET =================| masq  |------|
    |    PPP/slip    | router|      |  --------
   /                 ---------      |--| host |
  /                                 |  |      |
 /                                  |  --------
-                                   -
</PRE>
</CODE></BLOCKQUOTE>
<P>Маршрутизатор настраивается следующими командами:

<BLOCKQUOTE><CODE>
<PRE>
        # Маршрутизация для локальной сети
        route add -net 192.168.1.0 netmask 255.255.255.0 eth0
        #
        # Маршрут по умолчанию
        route add default ppp0
        #
        # Маскарадить все машины в сети 192.168.1/24
        ipfwadm -F -a m -S 192.168.1.0/24 -D 0.0.0.0/0 
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Для минималистов, или тех, кому лень набивать много команд предлагаем
следующую команду, которая будет работать для машины с двумя интерфейсами
(все проходящие пакеты должны маскарадится).

<BLOCKQUOTE><CODE>
<PRE>
        root# /sbin/ipfwadm -F -a accept -m
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Более подробную информацию об IP-маскараде вы можете получить на
<A HREF="http://www.hwy401.com/achau/ipmasq/">странице IP-маскарада</A>. <EM>Очень</EM> подробным документом
об IP-маскараде, в котором описано, как настраивать другие операционные
системы на работу с IP-маскарадом Линукса, является
``IP-Masquerade mini-HOWTO''.

<H2><A NAME="ss6.10">6.10 "Прозрачное" IP-кеширование.</A>
</H2>

<P>Прозрачное IP-кеширование -- возможность Линукса перенаправлять запросы
определенных сервисов на других машинах таким же сервисам на локальной
машине. Это может быть полезно, когда Ваша машина является маршрутизатором,
и одновременно кеширующим сервером. Вы сможете перенаправить все проходящие
через маршрутизатор запросы к удаленным машинам на локальный кеш-сервер.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Code maturity level options  --->
                [*] Prompt for development and/or incomplete code/drivers
        Networking options  --->
                [*] Network firewalls
                ....
                [*] TCP/IP networking
                ....
                [*] IP: firewalling
                ....
                [*] IP: transparent proxy support (EXPERIMENTAL)
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Настройка прозрачного кеширования производится с помощью программы
<EM>ipfwadm</EM>. Пример, который может быть Вам полезен:

<BLOCKQUOTE><CODE>
<PRE>
        root# ipfwadm -I -a accept -D 0/0 telnet -r 2323
        
</PRE>
</CODE></BLOCKQUOTE>

<P>В этом примере все попытки соединения с портом <CODE>telnet</CODE>
(23) на любой удаленной машине будут перенаправлены на локальный порт 2323.
На этом порту может работать демон, обрабатывающий telnet-соединения,
протоколирующий их и т.п.
<P>Более интересное применение прозрачного кеширования состоит в перенаправлении
<CODE>http</CODE> данных через локальный кеш. К сожалению, протокол, используемый
http-кешами отличается от обычного http: Если клиент соединяется с машиной
<CODE>www.server.com:80</CODE> и запрашивает страницу <CODE>/path/page</CODE>, то при
работе с локальным http-кешем он соединяется с машиной
<CODE>proxy.local.domain:8080</CODE> и запрашивает страницу
<CODE>www.server.com/path/page</CODE>.
<P>Для решения этой проблемы существует маленький сервер, называющийся
<CODE>transproxy</CODE>, который Вы можете найти в WWW. Если Вы запустите этот сервер
на порту 8081, выполните следующую команду:

<BLOCKQUOTE><CODE>
<PRE>
        root# ipfwadm -I -a accept -D 0/0 80 -r 8081
        
</PRE>
</CODE></BLOCKQUOTE>


Программа <CODE>transproxy</CODE> будет получать все запросы к удаленным http-серверам
и преобразовывать их в запросы к локальному кеш-серверу.

<H2><A NAME="ss6.11">6.11 IPv6</A>
</H2>

<P>Не успели Вы привыкнуть к правилам работы с протоколом IP, как все
изменилось! IPv6 -- сокращенное название шестой версии протокола IP.
IPv6 был разработан в первую очередь для преодоления проблемы нехватки
IP-адресов. Адреса в IPv6 имеют длину 16 байт (128 бит). Кроме того,
в IPv6 внесены еще несколько изменений, в основном упрощений, для того
чтобы сделать IP-сети более управляемыми.
<P>На данный момент в Линуксе есть работоспособная, хотя еще неполная
поддержка IPv6 в ядрах версий <CODE>2.1.*</CODE>.
<P>Если Вы хотите поэкспериментировать с этой технологией нового поколения,
или у Вас есть необходимость использовать ее, прочтите IPv6-FAQ,
доступный на 
<A HREF="http://www.terra.net/ipv6/">www.terra.net</A>.
<H2><A NAME="ss6.12">6.12 Мобильное IP</A>
</H2>

<P>Под "Мобильным IP" подразумевают способность машины подключаться к интернет
из разных мест без изменений в конфигурации. Как правило, при подключении в
новом месте Вы получите новый IP-адрес и Вам потребуется переконфигурировать
Вашу машину. Мобильное IP решает эту проблему путем выделения фиксированного
IP-адреса и создания туннеля с автоматической маршрутизацией, так чтобы все
пакеты, направленные на этот адрес перенаправлялись на реальный IP-адрес,
используемый в данный момент.
<P>Существует проект создания полного набора средств мобильного IP для Линукса.
Информацию о его текущем состоянии вы можете получить со
<A HREF="http://anchor.cs.binghamton.edu/~mobileip/">страницы мобильного IP в Линуксе</A>. Там же находится
последняя версия этого пакета.
<H2><A NAME="ss6.13">6.13 IP-рассылка (IP multicast)</A>
</H2>

<P>IP-рассылка -- механизм, позволяющий передавать IP-пакет на несколько машин
одновременно. Его используют для "широковещательных" приложений, таких как
передача видео- и аудио-информации.
<P><B>Опции компиляции ядра</B>:
<BLOCKQUOTE><CODE>
<PRE>
        Networking options  --->
                [*] TCP/IP networking
                ....
                [*] IP: multicasting
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Для использования IP-рассылки Вам потребуется набор утилит и небольшая
настройка сети. Более подробная информация о IP-рассылке содержится в
<A HREF="http://www.linux.org.ru/books/HOWTO/Multicast-HOWTO.html">Multicast-HOWTO</A>.
<H2><A NAME="ss6.14">6.14 Трансляция сетевых адресов (NAT, Network Address Translation)</A>
</H2>

<P>Механизм трансляции сетевых адресов -- гораздо более стандартизированный
"старший брат" IP-маскарада. Он подробно описан в RFC1631. Трансляция
адресов предоставляет возможности, которых у IP-маскарада нет и это
делает ее более пригодной для использования на маршрутизаторах и файрволлах
организаций и в более крупных сетях.
<P>Альфа-версия NAT для ядра версии 2.0.29 написана Михаэлем Хансенстайном
(Michael Hasenstein, <CODE>Michael.Hasenstein@informatik.tu-chemnitz.de</CODE>).
Она (вместе с документацией) доступна со 
<A HREF="http://www.csn.tu-chemnitz.de/HyperNews/get/linux-ip-nat.html">страницы трансляции IP-адресов</A>
<P>Последние версии ядра 2.1.* включают некоторые из возможностей трансляции
адресов в алгоритме маршрутизации.
<H2><A NAME="ss6.15">6.15 Ограничитель потока данных. (Traffic Shaper)</A>
</H2>

<P>Ограничитель потока данных создает специальные устройства, с ограничениями
на передачу данных. Эти устройства являются виртуальными и используют для
реальные сетевые устройства для фактической передачи данных. При этом все
исходящие IP-пакеты маршрутизируются через устройства-ограничители.
<P>Впервые ограничитель потока появился в ядре версии 2.1.15 и был затем
перенесен в ядро версии 2.0.36 (он появился в исправлении <CODE>2.0.36-pre-patch-2</CODE>,
распространяемом Аланом Коксом (Alan Cox), автором ограничителя потока и
сопровождающим версии ядра 2.0)
<P>На данный момент ограничитель потока может компилироваться в виде
модуля и настраивается с помощью программы <EM>shapecfg</EM> примерно следующим
образом:

<BLOCKQUOTE><CODE>
<PRE>
        shapecfg attach shaper0 eth1
        shapecfg speed shaper0 64000
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Ограничитель контролирует только исходящие IP-пакеты, так как пакеты
могут попадать на его интерфейс только в соответствии с таблицами маршрутизации,
если Вы хотите ограничивать и входящий поток данных, Вам потребуется
использовать функцию ``маршрутизации по адресу отправителя''.
<P>В версиях ядра 2.1 такая возможность уже есть, если Вы хотите внести ее
и в ядро версии 2.0.*, используйте исправление Майка МакЛагана (Mike McLagan),
доступное с <CODE>ftp.invlogic.com</CODE>. За дальнейшей информацией о работе
ограничителя потока данных обратитесь к файлу
<CODE>Documentation/networking/shaper.txt</CODE>, входящему в пакет исходных
текстов ядра.
<P>Если Вы хотите испытать тестовую версию ограничителя входящих пакетов,
получите пакет <CODE>rshaper-1.01</CODE> (или более свежую версию) с 
<A HREF="ftp://ftp.systemy.it/pub/develop">ftp.systemy.it</A>.
<H2><A NAME="ss6.16">6.16 Маршрутизация в ядрах версий 2.2.*</A>
</H2>

<P>В последних версиях ядра 2.1.* появилось множество нововведений в алгоритме
маршрутизации. К сожалению, Вам прийдется дождаться следующей версии этого
документа или обратится к исходным текстам ядра.

<HR>
<A HREF="NET-3-HOWTO-7.html">Следующий</A>
<A HREF="NET-3-HOWTO-5.html">Предыдущий</A>
<A HREF="NET-3-HOWTO.html#toc6">Содержание</A>
</BODY>
</HTML>
