<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r"><title>Глава 6. Локализация и Интернационализация</title><meta name="generator" content="DocBook XSL Stylesheets V1.59.1"><link rel="home" href="index.html" title="The Linux Cyrillic HOWTO (russian)"><link rel="up" href="index.html" title="The Linux Cyrillic HOWTO (russian)"><link rel="previous" href="ch05s05.html" title="Проверка правильности кириллизации X Window"><link rel="next" href="ch06s02.html" title="Интернационализация"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Глава 6. Локализация и Интернационализация</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s05.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch06s02.html">След.</a></td></tr></table><hr></div><div class="chapter" lang="ru"><div class="titlepage"><div><h2 class="title"><a name="l-n-i"></a>Глава 6. Локализация и Интернационализация</h2></div></div><div class="toc"><p><b>Содержание</b></p><dl><dt><a href="ch06.html#locale">Locale</a></dt><dd><dl><dt><a href="ch06.html#locale-use">Locale с точки зрения пользователя</a></dt><dt><a href="ch06.html#locale-programming">Locale зависимое программирование</a></dt></dl></dd><dt><a href="ch06s02.html">Интернационализация</a></dt><dd><dl><dt><a href="ch06s02.html#id2884654">Как принять участие в проекте перевода</a></dt><dt><a href="ch06s02.html#howtotranslate">Рекомендации по переводу сообщений программ</a></dt></dl></dd></dl></div><a class="indexterm" name="id2950862"></a><a class="indexterm" name="id2951019"></a><p>Основной объём этого документа занимают описания, как
заставить различные программы понять кириллицу.  Обычно каждая
программа требует, чтобы это был её собственный метод, как правило,
чрезвычайно отличный от других.  Кроме того, у некоторых программ
поддержка языков, отличных от английского далека от идеала, не говоря
уж об их неспособности взаимодействовать, используя родной язык
пользователя вместо английского.</p><p>Проблемы, перечисленные выше, сильно осложняют жизнь, так
как программное обеспечение редко создаётся только для местного рынка.
Переработка существенных частей программного обеспечения каждый раз
при входе на новый международному рынок очень
неэффективна. Интернациональная поддержка, осуществляемая собственными
средствами программы, уникальным и присущим только ей способом, в
терминах долгосрочного планирования далеко не блестящая идея.</p><p>Следовательно, возникает потребность в стандартизации.
<span class="emphasis"><em>И такой стандарт существует</em></span>.</p><p>Все связанное с вышеперечисленными проблемами разделено в
соответствии c двумя базисными концепциями:
<span class="emphasis"><em>localization</em></span> и
<span class="emphasis"><em>internationalization</em></span>. Под локализацией мы имеем в
виду создание программ, способных обрабатывать различные языковые
соглашения для различных стран.  Позвольте привести пример.  Формат
даты, принятый в Соединённых Штатах, имеет вид ММ/ДД/ГГ.  Однако в
России наиболее популярный формат &#8212; ДД.ММ.ГГ.  Другие проблемы
включают в себя представление времени, форматы числа и представления
валюты. Кроме этого, один из наиболее важных аспектов локализации
&#8212; это определение соответствующих классов символов, то есть
определение, какие символы в наборе символов являются
&quot;кирпичиками&quot;  языка (буквами) и как они упорядочиваются. С
другой стороны, локализация не работает со шрифтами.</p><p>Интернационализация (или <span class="emphasis"><em>i18n</em></span> для
краткости), как предполагается, решает проблемы, связанные со
способностью программы взаимодействовать с пользователем на его родном
языке.</p><p>Обе эти концепции должны быть стандартизованы, давая
программистам непротиворечивый путь создания программ, работающих в
национальной среде.</p><p>Хотя стандартизация ещё в процессе, много её частей уже
фактически являются стандартом, так что они могут использоваться без
особых проблем.</p><p>Я опишу общую схему создания программ, использующих описанные
выше возможности стандартным способом.  Так как это заслуживает
отдельного документа, я буду давать только очень общее описание и
указатели на более полные источники.</p><div class="sect1" lang="ru"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="locale"></a>Locale</h2></div></div><a class="indexterm" name="id2883144"></a><a class="indexterm" name="id2883155"></a><p>Одно из основных понятий локализации &#8212;
<span class="emphasis"><em>locale</em></span>.  Под locale подразумевается набор
соглашений, специфических для отдельно взятого языка в отдельно взятой
стране.  В общем случае говорить, что locale определяется только
страной, неправильно.  Например, в Канаде могут быть определены два
locale &#8212; язык &quot;Канада/Английский&quot;  и язык
&quot;Канада/Французский&quot;. Более того, язык &quot;Канада/Английский&quot;  не
является эквивалентом языку &quot;Великобритания/Английский&quot;  или
&quot;Американский/Английский&quot;, точно так же &quot;Канада/Французский&quot; 
язык &#8212; не эквивалент языку &quot;Франция/Французский&quot;  или языку
&quot;Швейцария / Французский&quot;  .</p><p>Более подробное описание проблем/возможностей/достоинств
локализации на русском языке можно найти на страничке <a href="http://www.sensi.org/~alec/locale/index.html" target="_top">Локализация, как
она есть</a>.</p><div class="sect2" lang="ru"><div class="titlepage"><div><h3 class="title"><a name="locale-use"></a>Locale с точки зрения пользователя</h3></div></div><a class="indexterm" name="id2883223"></a><p>Каждая locale &#8212; это специальная база данных,
определяющая, по крайней мере, следующие правила и соглашения:</p><div class="orderedlist"><ol type="1"><li><p>Классификация символов и преобразований,</p></li><li><p>Представление валюты, </p></li><li><p>Представление чисел (то есть Десятичные символы),
</p></li><li><p>Формат даты / времени.  </p></li></ol></div><div class="sect3" lang="ru"><div class="titlepage"><div><h4 class="title"><a name="LocaleUsage"></a>Настройка локали</h4></div></div><a class="indexterm" name="id2883293"></a><p>Прежде всего &#8212; подробная документация о локали
имеется на <a href="http://www.sensi.org/~alec/locale" target="_top">www.sensi.org/~alec/locale</a>
Обращайтесь туда, если вам нужны нестандартные варианты (например,
отключение русскоязычного интерфейса с сохранением правильной
сортировки и т.д.)</p><p>Документацию по локали X Window можно найти по адресу
<a href="http://www.tsu.ru/~pascal/x_locale/" target="_top">www.tsu.ru/~pascal/x_locale/</a></p><p>Вот инструкция для нетерпеливых (только для
	  glibc).</p><p>Вам нужно:</p><div class="itemizedlist"><ul type="disc"><li><p> Зайти в
<tt>/usr/share/locale</tt> и создать там симлинк
<span class="emphasis"><em>ru_RU.KOI8-R</em></span>, указывающий на
<span class="emphasis"><em>ru_SU</em></span>.  Эта операция необходима только для
<span class="emphasis"><em>glibc &lt; 2.1.2</em></span>.  </p></li><li><p> Как-либо прописать установку переменной
LANG в стартовых скриптах.  В RedHat-based дистрибутивах это делается
путём редактирования файла <tt>/etc/sysconfig/i18n</tt>,
где, кроме прочего, должна быть строчка
</p><pre class="screen">
LANG=ru_RU.KOI8-R
</pre><p>
В общем случае можно прописать в <tt>/etc/profile</tt>
</p><pre class="screen">
LANG=&lt;ваша кодировка&gt;   
export LANG
</pre></li><li><p> Проверить, что все работает, можно,
запустив <span class="emphasis"><em>locale</em></span> и посмотрев, что она выдаёт, а
также набрав <span class="emphasis"><em>cal</em></span>, <span class="emphasis"><em>date</em></span>
&#8212; названия месяцев и дней недели должны быть по-русски.
</p></li></ul></div><p>Гораздо же честнее сделать отдельный
<span class="emphasis"><em>настоящий</em></span> каталог:
<tt>/usr/share/locale/ru_RU.KOI8-R/</tt> (конечно,
если его нет в данном дистрибутиве).</p><p>Некоторые дистрибутивы
<span class="emphasis"><em>неправильно</em></span> включают</p><p>
</p><pre class="screen">
   LANG=ru
   LC_ALL=ru_RU.KOI8-R
</pre><p>
</p><p>Это <span class="emphasis"><em>НЕПРАВИЛЬНО</em></span>, почему так
делать нельзя &#8212; описано ниже.</p><p>А теперь поговорим о том же, но гораздо
	  подробнее. Итак:</p><p><span class="emphasis"><em>Как включить локализацию?</em></span></p><p>Если на UNIX машине (с POSIX:1996) средства locale
правильно установлены и программы правильно написаны, то локализация
включается путём задания строки окружения LANG:</p><p>
</p><pre class="screen">
$ export LANG={язык}
</pre><p>
</p><p>Если такой строки окружения нет, то работает значение
локализации по умолчанию: <tt>LANG=&quot;C&quot;</tt> или
<tt>LANG=&quot;POSIX&quot;</tt> (что то же самое) &#8212; минимальный
набор параметров, необходимый для функционирования программ на ANSI C
(ISO 9899:1990), в кодировке US-ASCII (7 bit) (<a href="ch03.html#CodePages" title="Символы и кодировки">&#8220;Символы и кодировки&#8221;</a>).</p><p>Если ваша система имеет полный набор утилит POSIX.2, то узнать
установленные в системе и допустимые значения для
<tt>LANG=</tt> можно командой
<tt>locale</tt>:</p><p>
</p><pre class="screen">
$ locale -a
</pre><p>
</p><p>По новому стандарту (POSIX.2 приложение E) значения локализации
записываются в форме:</p><p>
</p><pre class="screen">
        language_TERRITORY.Codeset
</pre><p>
</p><p>или формально:</p><p>
</p><pre class="screen">
        language[_TERRITORY[.Codeset[@modifier]]]
</pre><p>
</p><p>Стандарт <tt>ISO 639</tt> описывает &quot;language names&quot;,
<tt>ISO 3166</tt> &#8212; &quot;territory names&quot;. Территории
<span class="emphasis"><em>_SU</em></span> более не существует (вернее, теперь
она означает Судан), однако для совместимости некоторые системы
продолжают её поддерживать как alias: <tt>ru_SU
&#8212;&gt; ru_RU</tt>.</p><p>Для русского языка <tt>LANG</tt> устанавливается, как
правило, равным <tt>LANG=&quot;ru_RU.KOI8-R&quot;</tt> или
<tt>LANG=&quot;ru_RU.ISO_8859-5&quot;</tt>. То
есть:</p><p>
</p><pre class="screen">
$ export LANG=&quot;ru_RU.KOI8-R&quot;
</pre><p>
</p><p>Для установки украинской локали эта переменная должна быть равна
соответственно <tt>uk_UA.koi8-u</tt>.</p><p>Согласно стандарту допустимы также короткие именования значений
<tt>locale</tt>, которые часто оформляются как
<tt>aliases</tt> (псевдонимы) полного наименования.
Например <tt>&quot;C&quot; &#8212;&gt; &quot;POSIX&quot;</tt>.</p><p>
</p><pre class="screen">
$ export LANG=ru
$ export LANG=ru_RU
$ export LANG=ru_RU.KOI8-R
</pre><p>
</p><p>Однако, если вы указываете короткое имя, может оказаться, что
ваша кодировка оказывается вовсе не <span class="emphasis"><em>KOI8-R</em></span>
(почему следует использовать именно <span class="emphasis"><em>koi8-r</em></span>,
описано в разделе <a href="ch03.html#CodePages" title="Символы и кодировки">&#8220;Символы и кодировки&#8221;</a>).  Лучше не пользоваться
значениями по умолчанию, а указывать точное длинное имя.</p><p>Во FreeBSD 2.x так и есть. Для Linux &#8212; зависит от
дистрибутива.  В коммерческих реализациях (Solaris, SCO, AIX etc), как
правило, используется значение LANG=&quot;ru_RU&quot;, или укороченное
LANG=&quot;ru&quot;  (и, как правило, кодовая страница ISO8859-5 по
умолчанию).</p><p>Некоторые могут пожелать сделать себе локализацию в другом
наборе символов: <tt>ru_RU.X-CP-866</tt>
(<tt>ru_RU.IBM866</tt>),
<tt>ru_RU.x-mac-cyrillic</tt>,
<tt>ru_RU.ISO_8859-5</tt> или даже
<tt>ru_RU.CP1251</tt> &#8212; на это нет никаких
ограничений.  Все эти кодировки совершенно равноправны и
зарегистрированы (кроме <tt>x-mac-cyrillic</tt>) в IANA.
Только не забудьте, что локализация, ввод-вывод и отображение
национальных символов на терминале &#8212; это совершенно разные
вещи.</p><p>Если система локализована не полностью и использовать полное
переключение на другой язык (с помощью <tt>export
LANG={язык}</tt>) нельзя, можно включить
<span class="emphasis"><em>locale</em></span> только для функций <tt>locale
API</tt> библиотеки <tt>libc</tt>, задав значение
категорий локализации. Можно также присваивать разные значения разным
категориям, задавая их имена в строках окружения:</p><p>Если вас раздражают русские даты, сообщения и man-ы, но нужно
обрабатывать русские буквы и т.д., то сделайте:</p><p>
</p><pre class="screen">
$ export LANG=&quot;C&quot;
$ export LC_CTYPE=&quot;ru_RU.KOI8-R&quot;
$ export LC_COLLATE=&quot;ru_RU.KOI8-R&quot;
$ export LC_TIME=&quot;C&quot;
</pre><p>
</p><p>Ниже идёт описание различных опций
<span class="emphasis"><em>locale</em></span></p><div class="itemizedlist"><ul type="disc"><li><p><tt>LC_CTYPE</tt> &#8212; определяет
одиночные символы,</p></li><li><p><tt>LC_NUMERIC</tt> &#8212; формат
чисел,</p></li><li><p><tt>LC_TIME</tt> &#8212; формат
времени,</p></li><li><p><tt>LC_COLLATE</tt> &#8212;
используется для сравнения строк,</p></li><li><p><tt>LC_MONETARY</tt> &#8212;
валюта,</p></li><li><p><tt>LC_MESSAGES</tt> &#8212;
системные сообщения,</p></li><li><p><tt>LC_PAPER</tt> &#8212; формат
бумаги,</p></li><li><p><tt>LC_NAME</tt> &#8212; формат
имён,</p></li><li><p><tt>LC_ADDRESS</tt> &#8212; формат
адресов,</p></li><li><p><tt>LC_TELEPHONE</tt> &#8212; формат
телефонов.</p></li></ul></div><p>
</p><p><span class="emphasis"><em>Не рекомендуется использовать строку
окружения</em></span>:</p><p>
</p><pre class="screen">
$ export LC_ALL={язык}
</pre><p>
</p><p>поскольку формально такой категории локализации нет, она
&quot;виртуальная&quot;  и обозначает &quot;одновременно все категории&quot;. Из-за
этого во многих реализациях <tt>locale API</tt> возникают
проблемы.  Проблемы могут возникнуть также с программами, работающими
с <tt>PostScript</tt>: в категории
<tt>LC_NUMERIC</tt> локализации
<tt>ru_RU</tt> в соответствии со стандартом ГОСТ в
качестве десятичного разделителя используется символ 'запятая':
&quot;,&quot;  в то время, как в стандарте языка PostScript &#8212; точка
&quot;.&quot;  А категория <tt>LC_NUMERIC</tt> оказывает
влияние на <tt>printf(&quot;%f&quot;,float);</tt>. Используйте
значение <tt>C (POSIX)</tt> для
<tt>LC_NUMERIC</tt>, если вы работаете с
<tt>PostScript</tt>:</p><p>
</p><pre class="screen">
$ export LC_NUMERIC=&quot;POSIX&quot;
</pre><p>
</p><p>Посмотреть текущие значения категорий локализации можно все той
же утилитой locale (без параметров).</p><p>
</p><pre class="screen">
$ locale
</pre><p>
</p><p><span class="emphasis"><em>ПРИМЕЧАНИЕ:</em></span> В некоторых современных
системах начинает появляться локализация в UNICODE. Например, для
России эта локаль включается заданием строки окружения
LANG=&quot;ru_RU.UTF-8&quot;.</p></div></div><div class="sect2" lang="ru"><div class="titlepage"><div><h3 class="title"><a name="locale-programming"></a>Locale зависимое программирование</h3></div></div><a class="indexterm" name="id2884207"></a><p>С locale программа не должна знать о различных
символьных преобразованиях и правилах сравнения, описанных выше.
Вместо этого они используют специальный API, который действует по
правилам, определённым locale.  Кроме того, нет необходимости для
программы пользоваться только одной locale для соблюдения всех правил
&#8212; возможно пользоваться другими правилами, описанными в других
locale (хотя такой метод не очень хорош).</p><p>Из man <tt>setlocale(3)</tt>:</p><div class="blockquote"><blockquote class="blockquote"><p>Программа может быть сделана переносимой для всех locale,
вызывая <tt>setlocale(LC_ALL, &quot;&quot; )</tt> после
инициализации программы, используя значения, возвращённые из запроса
<tt>localeconv()</tt> для locale-зависимой информации, и
используя <tt>strcoll()</tt> или
<tt>strxfrm()</tt> для сравнения строк.</p></blockquote></div><p>Довольно легко определить четыре уровня программной
локализации:</p><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>Чисто 8ми
битное</em></span> программное обеспечение. То есть программа вызывает
<tt>setlocale()</tt>. Она не делает каких-либо предположений
относительно 8-ого бита каждого символа, используя пользовательские
функции из <tt>ctype.h</tt> и ограничения из
<tt>limits.h</tt>, а также заботится относительно
<tt>signed/unsigned</tt> результата.  Очень важно, чтобы
программа <span class="emphasis"><em>не</em></span> делала каких-либо предположений
относительно характера набора символов и их упорядочения. То есть
следует воздержаться от следующих конструкций при программировании:
</p><p>
</p><pre class="programlisting">
    if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
        ...
</pre><p>
</p><p>Подобные конструкции с точки зрения правильного
&quot;locale&quot;-программирования совершенно
<span class="emphasis"><em>недопустимы</em></span>. Взамен во всех таких случаях должны
использоваться, макрокоманды из locale зависимого файла заголовка
<tt>ctype.h</tt>.  Например:
</p><p>
</p><pre class="programlisting">
     if (isalpha(c) &amp;&amp; isupper(c)) { ... или
     if (isascii(c) &amp;&amp; isupper(c))
</pre><p>
</p><p>
Хорошо написанная программа должна быть полностью 8-бит
прозрачна. Например, отметка удалённого файла в MS-DOS кодом 0x0E5
&#8212; не очень хорошее решение. Ещё примеры плохих решений:
знаменитая русская буква &quot;Н&quot;  в редакторе GoldEd или русская
буква &quot;р&quot;  в Norton Commander...  </p></li><li><p>Форматы, методы сортировки, размеры листа бумаги.
Программа использует <tt>strcoll()</tt> и
<tt>strxfrm()</tt> вместо <tt>strcmp()</tt> для
строк, использует <tt>time()</tt>,
<tt>localtime()</tt>, и <tt>strftime()</tt> для
работы со временем, и в заключение, использует
<tt>localeconv()</tt> для правильного представления чисел и
валюты.  </p></li><li><p>Видимый текст складывается в каталоги сообщений/.
Программа должна локализовать весь видимый текст в специальных
<span class="emphasis"><em>каталогах сообщений</em></span>.  Они содержат соответствия
строк на английском и их переводы на другие языки.  Выбор сообщений,
соответствующих языку окружения, выполнен так, что полностью прозрачен
и для программы и для пользователя.  Чтобы использовать эти средства,
программа должна вызвать <tt>gettext()</tt> (Sun/POSIX
стандарт), или <tt>catgets()</tt> (X/Open
стандарт). Подробнее см. раздел <a href="ch06s02.html" title="Интернационализация">&#8220;Интернационализация&#8221;</a>.
</p></li><li><p>EUC/Unicode поддержка.  На этом уровне, программа не
использует тип <tt>char</tt>.  Взамен этого она использует
<tt>wchar_t</tt>, который определяет объекты,
достаточно большие, чтобы содержать символы Unicode. ANSI C определяет
этот тип данных и соответствующий API.
</p></li></ol></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s05.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Уровень выше</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06s02.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Проверка правильности кириллизации X Window </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Интернационализация</td></tr></table></div></body></html>
