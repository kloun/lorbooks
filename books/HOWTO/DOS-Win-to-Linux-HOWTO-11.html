<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Из  DOS/Windows в Linux HOWTO : Немного программирования</TITLE>
 <LINK HREF="DOS-Win-to-Linux-HOWTO-12.html" REL=next>
 <LINK HREF="DOS-Win-to-Linux-HOWTO-10.html" REL=previous>
 <LINK HREF="DOS-Win-to-Linux-HOWTO.html#toc11" REL=contents>
</HEAD>
<BODY>
<A HREF="DOS-Win-to-Linux-HOWTO-12.html">Следующий</A>
<A HREF="DOS-Win-to-Linux-HOWTO-10.html">Предыдущий</A>
<A HREF="DOS-Win-to-Linux-HOWTO.html#toc11">Содержание</A>
<HR>
<H2><A NAME="s11">11. Немного программирования</A></H2>

<H2><A NAME="Shell Scripts"></A> <A NAME="ss11.1">11.1 Скрипты командного процессора: Файлы .BAT на стероидах</A>
</H2>

<P>Если вы использовали .BAT-файлы для создания сокращений для длинных
командных строк (я сам так делал), то это может быть достигнуто вставкой
соответствующих алиасов (смотрите вышеприведенный пример) в файлы
<CODE>profile</CODE> или <CODE>.bash_profile</CODE>. Но если ваши .BAT-файлы были
более сложными, то вы полюбите язык, предоставляемый командным процессором:
он мощен, как старый QBasic, если не больше. Он имеет переменные,
управляющие структуры, подобные while, for, case, if... then... else, и
много других возможностей: он может быть хорошей альтернативой
``настоящим'' языкам программирования.
<P>Для написания скрипта---эквивалента .BAT-файла в DOS все, что надо
сделать---написать стандартный ASCII-файл, содержащий инструкции, сохранить
его и затем сделать его исполнимым с помощью команды <CODE>chmod +x
&lt;scriptfile></CODE>. Для выполнения скрипта наберите его имя.
<P>Предупреждение. Системный редактор называется <CODE>vi</CODE>, и по моему
мнению большинство новых пользователей найдет его трудным в использовании.
Я не буду объяснять, как его использовать;  пожалуйста посмотрите эту
информацию в книге Matt Welsh или найдите учебное руководство в сети. Здесь
достаточно сказать, что:
<P>
<UL>
<LI>для вставки некоторого текста нажмите <CODE>i</CODE>, и затем вводите
текст;
</LI>
<LI>для удаления символов наберите &lt;ESC&gt;, а затем <CODE>x</CODE>;
</LI>
<LI>для выхода из <CODE>vi</CODE> без сохранения изменений наберите
&lt;ESC&gt;, а затем <CODE>:q!</CODE>
</LI>
<LI>для сохранения и выхода наберите &lt;ESC&gt;, а затем  <CODE>:wq</CODE>.
</LI>
</UL>
<P>Примечание переводчика: На самом деле <CODE>vi</CODE>&nbsp;-- мощный
редактор. Для получения встроенного учебника наберите &lt;ESC&gt;, а затем
<CODE>:help tutor</CODE>, для получения справки по какому либо разделу наберите
&lt;ESC&gt;, а затем <CODE>:help имя_раздела или команды</CODE>. Этот перевод
был сделан используя вариант этого редактора под названием <CODE>Vim</CODE>,
дополнительную информацию смотрите на 
<A HREF="http://www.vim.org">http://www.vim.org</A>.
<P>Хорошим редактором для начинающих является <CODE>joe</CODE>: запустив его с
помощью команды <CODE>jstar</CODE>, вы получите те же самые сочетания клавиш,
как и в редакторе, используемом в DOSWin. <CODE>jed</CODE> в режиме WordStar
или IDE, даже еще лучше. Пожалуйста посмотрите раздел 
<A HREF="DOS-Win-to-Linux-HOWTO-12.html#Programs">Где найти приложения</A> для того чтобы узнать, где можно найти данные
редактора.
<P>Написание скриптов для <CODE>bash</CODE>&nbsp;-- это такой необъятный предмет,
что сам по себе заслуживает книги и я не буду углубляться в этот предмет. Я
просто дам вам пример скрипта командного процессора, из которого вы можете
вычленить некоторые базовые правила. Прочитайте справочную страницу
<CODE>bash</CODE>.
<P>
<HR>
<PRE>
#!/bin/sh
# sample.sh
# это комментарий
# не изменяйте первую строку, она должна быть такой
echo "Система называется: `uname -a`" # использовать вывод команды
echo "Мое имя $0" # Встроенные переменные
echo "Вы передали мне следующие $# параметров: "$*
echo "Первым параметром является: "$1
echo -n "Введите ваше имя? " ; read your_name
echo заметьте разницу: "hi $your_name" # использование кавычек вида "
echo заметьте разницу: 'hi $your_name' # использование кавычек вида '
DIRS=0 ; FILES=0
for file in `ls .` ; do
  if [ -d $\{file\} ] ; then # если файл является каталогом
    DIRS=`expr $DIRS + 1`  # DIRS = DIRS + 1
  elif [ -f $\{file\} ] ; then
    FILES=`expr $FILES + 1`
  fi
  case $\{file\} in
    *.gif|*jpg) echo "$\{file\}: графический файл" ;;
    *.txt|*.tex) echo "$\{file\}:  текстовый файл" ;;
    *.c|*.f|*.for) echo "$\{file\}: файл исходных текстов" ;;
    *) echo "$\{file\}: обычный файл" ;;
  esac
done
echo "обнаружено $\{DIRS\} каталогов и $\{FILES\} файлов"
ls | grep "ZxY--!!!WKW"
if [ $? != 0 ] ; then # код завершения последней команды
  echo "ZxY--!!!WKW не найден"
fi
echo "достаточно... наберите 'man bash' если вам нужна дополнительная информация."
</PRE>
<HR>
<P>
<H2><A NAME="ss11.2">11.2 C для вас</A>
</H2>

<P>В UNIX системным языком является C, любите его или ненавидьте.  Также
доступны другие языки программирования (Java, FORTRAN, Pascal, Lisp, Basic,
Perl, awk...).
<P>Считая, что вы знаете C, существует некоторое количество руководств для тех,
кто испорчен использованием Turbo C++ или его собратьев по DOS. Компилятор
С в Linux называется <CODE>gcc</CODE> и не содержит моргалки и дуделки, которые
обычно сопутствуют его аналогам в DOS: нет IDE (Интегрированная среда
разработки), оперативной подсказки, встроенного отладчика и т.п. Это просто
командно-строковый компилятор, очень мощный и эффективный. Для компиляции
стандартного <CODE>hello.c</CODE> вам необходимо выполнить команду:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc hello.c
</PRE>
</CODE></BLOCKQUOTE>
<P>которая создаст исполнимый файл, названный <CODE>a.out</CODE>. Для того, чтобы
дать исполнимому файлу другое название, выполните команду:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc -o hola hello.c
</PRE>
</CODE></BLOCKQUOTE>
<P>Для подключения к программе библиотеки функций добавьте к командной строке
ключ -l&lt;libname&gt;. Например, для подключения библиотеки математических
функций:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc -o mathprog mathprog.c -lm
</PRE>
</CODE></BLOCKQUOTE>
<P>(Ключ <CODE>-l&lt;libname&gt;</CODE> заставляет <CODE>gcc</CODE> подключить
библиотеку <CODE>/usr/lib/lib&lt;libname&gt;.so</CODE>; так что <CODE>-lm</CODE>
подключает библиотеку <CODE>/usr/lib/libm.so</CODE>).
<P>Чем дальше, тем лучше, но когда ваша программа состоит из нескольких файлов
исходных текстов, то вам понадобиться пользоваться утилитой <CODE>make</CODE>.
Предположим, что вы написали разбор выражений: его файл исходных текстов
называется: <CODE>parser.c</CODE> и подключает два заголовочных файла,
<CODE>parser.h</CODE> и <CODE>xy.h</CODE>. Затем вы хотите использовать
подпрограммы из <CODE>parser.c</CODE> в программе, допустим <CODE>calc.c</CODE>,
которая подключает файл <CODE>parser.h</CODE>.  Что за неразбериха! Что вам
надо сделать для компиляции <CODE>calc.c</CODE>?
<P>Вам необходимо написать так называемый <CODE>Makefile</CODE>, который сообщает
компилятору зависимости между файлами исходных текстов и объектными
файлами. В нашем примере:
<P>
<HR>
<PRE>
# Это Makefile, используемый для компиляции calc.c
# Нажмите клавишу &lt;TAB> где показано!

calc: calc.o parser.o
&lt;TAB>gcc -o calc calc.o parser.o -lm
# calc зависит от 2-х объектных файлов: calc.o и parser.o

calc.o: calc.c parser.h
&lt;TAB>gcc -c calc.c
# calc.o зависит от двух файлов исходных текстов

parser.o:  parser.c parser.h xy.h
&lt;TAB>gcc -c parser.c
# parser.o зависит от трех файлов исходных текстов

# конец Makefile.
</PRE>
<HR>
<P>Сохраните этот файл как <CODE>Makefile</CODE> и наберите <CODE>make</CODE> для
компиляции вашей программы; вы также можете сохранить его как
<CODE>calc.mak</CODE> и набрать <CODE>make -f calc.mak</CODE>, и конечно RMP. Вы
также можете получить некоторую помощь о функциях C, которые описаны в
справочных страницах, раздел 3; например,
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ man 3 printf
</PRE>
</CODE></BLOCKQUOTE>
<P>Для отладки ваших программ используйте программу <CODE>gdb</CODE>. Наберите
<CODE>info gdb</CODE> для того, чтобы узнать, как использовать отладчик.
<P>Существует большое количество библиотек; среди них первыми вы скорее всего
захотите использовать следующие: <CODE>ncurses</CODE> (для работы в текстовом
режиме), и <CODE>svgalib</CODE> (для графики в консоли).  Много редакторов
могут работать как IDE; например <CODE>emacs</CODE> и <CODE>jed</CODE>, также они
производят подсветку синтаксиса, автоматические отступы, и так далее.
Также вы можете взять пакет <CODE>rhide</CODE> с 
<A HREF="ftp://metalab.unc.edu:/pub/Linux/devel/debuggers/">ftp://metalab.unc.edu:/pub/Linux/devel/debuggers/</A>. Это клон Borland
IDE и есть шанс, что он вам понравится.
<P>
<P>
<H2><A NAME="ss11.3">11.3 Программирование для X11</A>
</H2>

<P>Если вы чувствуете себя достаточно образованным для программирования для
X11 (это не так трудно), то существует несколько библиотек, которые сделают
написание программ для X11 более легким. Основными серверами, которые вам
необходимо посетить, являются сервера GTK+, 
<A HREF="http://www.gtk.org">http://www.gtk.org</A>
и Qt, 
<A HREF="http://www.troll.no">http://www.troll.no</A>. Gtk+ является набором
элементов, написанных на языке С, в начале созданном для графического пакета
The GIMP (
<A HREF="http://www.gimp.org">http://www.gimp.org</A>), и используется средой Gnome. 
Kdeveloper основан на Qt, написанном на С++ и используемом средой
KDE. Вероятнее всего, вы будете использовать один из этих пакетов.
<P>Наилучшими пакетами для визуального программирования являются Kdevelop для
Qt, 
<A HREF="http://www.kdevelop.org">http://www.kdevelop.org</A>, и Glade для GTK+, 
<A HREF="http://glade.pn.org">http://glade.pn.org</A>. Эта страница имеет большее количество
информации: 
<A HREF="http://www.free-soft.org/guitool/">http://www.free-soft.org/guitool/</A>.
<P>
<P>
<H3>Многоплатформенной программирование</H3>

<P>Было бы хорошо, если бы вы могли писать код, который одинаково
компилируется и под <EM>и</EM> под Windows с помощью <CODE>gcc</CODE>? Во время
написания данного документа, существовало несколько наборов элементов,
которые позволяли (более или менее) программирование под разные
платформы. Из соображений достаточности и стабильности, может
использоваться только один: FLTK, Fast Light Tool Kit 
<A HREF="http://www.fltk.org">http://www.fltk.org</A>. Он достаточно небольшой, быстрый и
стабильный. В его составе также имеется полу-визуальный построитель
интерфейса под названием Fluid.
<P>
<HR>
<A HREF="DOS-Win-to-Linux-HOWTO-12.html">Следующий</A>
<A HREF="DOS-Win-to-Linux-HOWTO-10.html">Предыдущий</A>
<A HREF="DOS-Win-to-Linux-HOWTO.html#toc11">Содержание</A>
</BODY>
</HTML>
