<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The Software-RAID HOWTO: Установка RAID</TITLE>
 <LINK HREF="Software-RAID-HOWTO-2.4-5.html" REL=next>
 <LINK HREF="Software-RAID-HOWTO-2.4-3.html" REL=previous>
 <LINK HREF="Software-RAID-HOWTO-2.4.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="Software-RAID-HOWTO-2.4-5.html">Next</A>
<A HREF="Software-RAID-HOWTO-2.4-3.html">Previous</A>
<A HREF="Software-RAID-HOWTO-2.4.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4. Установка RAID</A></H2>

<P>
<H2><A NAME="ss4.1">4.1 Общие установки</A>
</H2>

<P>Вот что Вам нужно для любых уровней RAID:
<UL>
<LI>Ядро. Предпочтительно стабильной серии 2.2.X, или последнее 
2.0.X. (Если 2.4 уже вышло, в то время когда Вы это читаете, используйте его)</LI>
<LI>Патчи RAID.  Это обычно патч для последних ядер. (Если Вы найдете 2.4 
ядро, патчи уже в нем, и вы можете забыт о них)</LI>
<LI>RAID утилиты.</LI>
<LI>Терпение, пицца, и Ваш любимый кофейный напиток.</LI>
</UL>
<P>Все программы могут быть найдены на <CODE>ftp://ftp.fi.kernel.org/pub/linux</CODE> RAID
утилиты и патчи в <CODE>daemons/raid/alpha</CODE> подкаталоге. 
Ядра - в <CODE>kernel</CODE> подкаталоге.
<P>Пропатчите ядро, сконфигурируйте его для включения поддержки желаемого уровня 
RAID.  Скомпилируйте его и установите.
<P>Затем распакуйте, сконфигурируйте, скомпилируйте и установите утилиты RAID.
<P>Так, все хорошо. Если Вы сейчас перезагрузитесь, Вы должны получить файл 
называемый <CODE>/proc/mdstat</CODE>.  Запомните его, этот файл - Ваш друг. Сделав 
<CODE>cat </CODE><CODE>/proc/mdstat</CODE> посмотрите его содержимое. Это должно Вам сказать, что
у Вас зарегистрированы правильные свойства RAID (RAID режим), и
устройства RAID уже активны.
<P>Создайте разделы, которые хотите включить в RAID набор.
<P>Сейчас, рассмотрим специфику режимов.
<P>
<P>
<H2><A NAME="ss4.2">4.2 Линейный режим</A>
</H2>

<P>Итак, у вас есть два или более раздела, не обязательно одного размера
(но конечно могут быть), которые Вы хотите объединить вместе.
<P>Установите <CODE>/etc/raidtab</CODE> файл для описания вашей конфигурации. 
Я устанавливаю raidtab для двух дисков в линейный режим, и файл выглядит так:
<P>
<PRE>
raiddev /dev/md0
        raid-level      linear
        nr-raid-disks   2
        chunk-size      32
        persistent-superblock 1
        device          /dev/sdb6
        raid-disk       0
        device          /dev/sdc5
        raid-disk       1
</PRE>

Резервные диски тут не поддерживаются.  Если диск умрет, массив умрет вместе с
ним. Не существует информации для помещения на резервный диск.
<P>Вы, возможно удивлены тем, что мы указали здесь <CODE>chunk-size</CODE> (размер куска),
при том, что линейный режим просто объединяет два диска в один большой без 
параллелизма. Да, Вы полностью правы, это - лишнее. Просто поставьте какой-то
размер куска и не беспокойтесь об этом.
<P>Итак, создадим массив. Запускаем команду
<PRE>
  mkraid /dev/md0
</PRE>
<P>Это должно инициализировать ваш массив, записать отдельные суперблоки, и
запустить массив.
<P>Загляните в <CODE>/proc/mdstat</CODE>. Вы должны заметить, что массив уже запущен.
<P>Теперь, ВЫ можете создать файловую систему, просто как и на любом другом 
устройстве, смонтируйте ее, включите ее в Ваш fstab и тому подобное.
<P>
<P>
<H2><A NAME="ss4.3">4.3 RAID-0</A>
</H2>

<P>У вас должно быть два или более устройств, приблизительно одного размера, и Вы 
хотите объединить их емкость и также производительность путем параллельного 
доступа.
<P>Установите файл <CODE>/etc/raidtab</CODE> для описания Вашей конфигурации. Пример raidtab 
выглядит таким образом:
<PRE>
raiddev /dev/md0
        raid-level      0
        nr-raid-disks   2
        persistent-superblock 1
        chunk-size     4
        device          /dev/sdb6
        raid-disk       0
        device          /dev/sdc5
        raid-disk       1
</PRE>

В линейном режиме, резервные дики не поддерживаются. RAID-0
не имеет избыточности, так что если диск умрет, массив умрет вместе с ним.
<P>Еще раз, просто запустите 
<PRE>
  mkraid /dev/md0
</PRE>

для инициализации массива. Это должно инициализировать суперблок и
запустить устройство. Загляните в <CODE>/proc/mdstat</CODE> чтобы посмотреть, что произошло.
Вы должны увидеть, что Ваше устройство запущено.
<P>/dev/md0 теперь готов к форматированию, монтированию, использованию и 
издевательствам.
<P>
<P>
<H2><A NAME="ss4.4">4.4 RAID-1</A>
</H2>

<P>У вас есть два устройства приблизительно одного размера, и Вы хотите из 
зеркализировать. В конце концов, Вы можете использовать больше устройств, 
которые Вы можете держать как резервные диски, и которые автоматически станут
частью зеркала, если одно из из активных устройств сломается.
<P>Установите <CODE>/etc/raidtab</CODE> файл подобно этому:
<PRE>
raiddev /dev/md0
        raid-level      1
        nr-raid-disks   2
        nr-spare-disks  0
        chunk-size     4
        persistent-superblock 1
        device          /dev/sdb6
        raid-disk       0
        device          /dev/sdc5
        raid-disk       1
</PRE>

Если у Вас есть резервные диски, Вы можете добавить их в конец спецификации 
устройства 
<PRE>
        device          /dev/sdd5
        spare-disk      0
</PRE>

Не забудьте установить соответственно nr-spare-disks запись (количество 
резервных дисков).
<P>Итак, мы все установили для запуска инициализации RAID. Зеркало должно быть
сконструировано, содержимое ( сейчас это, однако, не важно, так как
устройство все еще не форматировано) двух дисков должно быть синхронизировано.
<P>Подаем команду
<PRE>
  mkraid /dev/md0
</PRE>

для начала инициализации зеркала.
<P>Проверьте  <CODE>/proc/mdstat</CODE> файл. Он должен сказать вам, что устройство /dev/md0
было запущено, зеркало начало реконструироваться, а
также оценочное время завершения реконструкции.
<P>Реконструкция делается в периоды отсутствия ввода-вывода. Так что, ваша система
должна быть еще достаточно отзывчива, хотя Ваш индикатор дисковой активности 
должен хорошо светиться.
<P>Процесс реконструкции прозрачен, так что Вы можете, фактически,  использовать
зеркало несмотря на реконструкцию.
<P>Попробуйте форматировать устройство, при запущенной реконструкции. Это
должно работать. Также Вы можете смонтировать его и использовать в процессе
реконструкции. Конечно, если неисправный диск разрушается при реконструкции, Вам
не повезло.
<P>
<P>
<H2><A NAME="ss4.5">4.5 RAID-4</A>
</H2>

<P><B>Заметьте!</B> Я сам не тестировал эту конфигурацию. Конфигурация ниже 
- моя догадка, а не что-то, фактически запущенное мною.
<P>У вас есть три или более приблизительно одного размера диска, один  
значительно быстрее других, и Вы хотите скомбинировать их все в одно большое
устройство, которое все еще содержит немного избыточной информации.
В конце концов у вас есть несколько устройств, которые Вы хотите использовать 
как резервные диски.
<P>Установите файл /etc/raidtab подобно этому:
<PRE>
raiddev /dev/md0
        raid-level      4
        nr-raid-disks   4
        nr-spare-disks  0
        persistent-superblock 1
        chunk-size      32
        device          /dev/sdb1
        raid-disk       0
        device          /dev/sdc1
        raid-disk       1
        device          /dev/sdd1
        raid-disk       2
        device          /dev/sde1
        raid-disk       3
</PRE>

Если у Вас резервные диски, они должны быть вставлены аналогичным образом,
следуя спецификациям raid-disk;
<PRE>
        device         /dev/sdf1
        spare-disk     0
</PRE>
<P>Как обычно, ваш массив может быть инициализирован командой
<PRE>
   mkraid /dev/md0
</PRE>
<P>Перед форматированием, Вы должны просмотреть секцию специальных опций mke2fs.
<P>
<P>
<P>
<H2><A NAME="ss4.6">4.6 RAID-5</A>
</H2>

<P>У Вас есть три или более дисков приблизительно одного размера, Вы хотите
скомбинировать их в  большое устройство, но еще содержащее некоторую 
степень избыточности. В конце концов у Вас есть несколько дисков для
использования как резервных, которые не будут частью массива до отказа 
другого устройства.
<P>Если Вы используете N дисков, где S - размер наименьшего, размер всего
массива будет  (N-1)*S. Это ``не включает'' пространство используемое для 
информации о четности (избыточности).  Итак, если любой диск отказывает,
все данные остаются целыми. Но, если два диска отказывают, все данные потеряны.
<P>Установите файл /etc/raidtab так:
<PRE>
raiddev /dev/md0
        raid-level      5
        nr-raid-disks   7
        nr-spare-disks  0
        persistent-superblock 1
        parity-algorithm        left-symmetric
        chunk-size      32
        device          /dev/sda3
        raid-disk       0
        device          /dev/sdb1
        raid-disk       1
        device          /dev/sdc1
        raid-disk       2
        device          /dev/sdd1
        raid-disk       3
        device          /dev/sde1
        raid-disk       4
        device          /dev/sdf1
        raid-disk       5
        device          /dev/sdg1
        raid-disk       6
</PRE>

Если у Вас есть резервные диски, они должны быть вставлены подобным образом,
следуя спецификациям raid-disk;
<PRE>
        device         /dev/sdh1
        spare-disk     0
</PRE>

И так далее.
<P>Размер куска в 32 KB хорошее начальное значение для многих общих применений
файловой системы. Массив, на котором используется вышеуказанный raidtab, -
устройство размером 7 раз по 6 GB = 36 GB  (запомните (n-1)*s = (7-1)*6 = 36)
Оно содержит файловую систему ext2 с размером блока 4 Кб.  Если Ваша файловая 
система намного больше или Вы храните очнь большие фалы, Вы должны установить
больший размер куска и размер блока файловой системы.
<P>Итак, хватит разговоров. Вы установили raidtab, так что посмотрим, работает ли 
он. Подаем команду
<PRE>
  mkraid /dev/md0
</PRE>

и смотрим, что получилось.  Надеюсь Ваши диски заработали как сумасшедшие,
так как начался процесс реконструкции Вашего массива. Загляните в 
<CODE>/proc/mdstat</CODE> чтобы посмотреть что происходит.
<P>Если устройство успешно создано, начался процесс реконструкции. Ваш массив
не устойчив, пока фаза реконструкции не завершена. Однако, массив полностью
функционален (кроме, конечно, обработки дисковых отказов), и Вы можете его
форматировать  и использовать, пока он реконструируется.
<P>Перед форматированием массива, посмотрите секцию специальных опций mke2fs.
<P>Итак, сейчас вы запустили свое RAID устройство, Вы можете всегда остановить его
или снова запустить используя
<PRE>
  raidstop /dev/md0
</PRE>

или
<PRE>
  raidstart /dev/md0
</PRE>

команды.
<P>Вместо помещения этого в init-файлы и многократных перезагрузок
чтобы заставить это работать, читайте далее, и запустите авто-детектирование.
<P>
<P>
<H2><A NAME="ss4.7">4.7 Отдельный суперблок</A>
</H2>

<P>Вернемся в ``Старые Добрые Времена'' (TM), raidtools читали Ваш read <CODE>/etc/raidtab</CODE> 
файл и затем инициализировали массив. Однако, это требовало 
наличия файловой системы та том, на чем был смонтирован <CODE>/etc/raidtab</CODE>. 
Это не подходило для загрузки с RAID.
<P>Также, старый подход приводил к сложностям при монтировании файловой системы
на RAID устройствах. Они не должны были, как обычно, вставляться в <CODE>/etc/fstab</CODE> 
файл, но должны были монтироваться из скриптов инициализации.
<P>Отдельный суперблок решил эти проблемы. Когда массив инициализируется 
с опцией <CODE>persistent-superblock</CODE> в файле <CODE>/etc/raidtab</CODE>, в начале всех
дисков массива записывается специальный суперблок. Это позволяет ядру читать
конфигурацию устройств RAID прямо с затрагиваемых дисков, вместо чтения 
конфигурационного файла, который может не всегда доступен.
<P>Однако Вы должны поддерживать целостность файла <CODE>/etc/raidtab</CODE>, так как Вам он может
понадобиться позже при реконструкции массива.
<P>Если вы хотите автоматического детектирования RAID устройств при загрузке - отдельный суперблок обязателен. Это описано в секции <B>Автоматическое детектирование</B>.
<P>
<P>
<H2><A NAME="ss4.8">4.8 Размер кусков</A>
</H2>

<P>Размер куска заслуживает обьяснения.  Вы можете никогда не писать 
полностью параллельно на дисковый набор. Если у Вас два диска и Вы хотите
записать байт, Вы должны, фактически, записать четыре бита на каждый диск,
каждый второй бит должен пойти на диск 0 а другие на диск 1. 
Аппаратно это не поддерживается.  Вместо этого, мы выбираем некоторый
размер куска, который мы определяем как наименьшую ``атомарную'' порцию данных,
которые могут быть записаны на диски.  Запись 16 Кб с размером куска 
в 4 Кб, приведет к записи первого и третьего 4 Кбайтных кусочков на первый диск,
а второго и четвертого на второй, в случае RAID-0 из двух дисков. Таким образом,
для длинных записей, вы можете увидеть меньшие накладные расходы 
при довольно больших размерах кусков, в то время как массивы, которые в основном
содержит небольшие файлы, имеют преимущество при небольших размерах куска.
<P>Размеры куска должны быть указаны для всех уровней RAID, включая линейный режим.
Однако, размер куска безразличен для линейного режима.
<P>Для оптимальной производительности, Вы должны поэкспериментировать с этим 
значением, также как и с размером блока файловой системы, которую вы создаете
в массиве.
<P>Аргумент опции chunk-size в <CODE>/etc/raidtab</CODE> указывает размер кусочка в килобайтах. 
Так ``4'' означает ``4 Кб''. 
<P>
<H3>RAID-0</H3>

<P>Данные записываются ``почти'' в параллельном режиме на диски массива. 
Фактически, <CODE>chunk-size</CODE> байт записываются на каждый диск 
последовательно.
<P>Если Вы указываете размер куска в 4 Кб, и пишете 16 Кб на массив из трех дисков,
RAID система будет писать 4 Кб на диски 0, 1 и 2, параллельно, а оставшиеся 4 Кб
на диск 0.
<P>Размер куска в 32 KB - разумное начальное значение для большинства массивов. Но
оптимальное занчение сильно зависит от количества в дисков, содержимого 
файловой системы на массиве, и многих других факторов. Поэкспериментируйте с
этим, для получения производительности.
<P>
<H3>RAID-1</H3>

<P>Для записи, размер куска не влияет, так как все данные, в любом случае, должны 
быть записаны на все диски.  Однако для чтения, размер куска указывает сколько
данных читаются последовательно с участвующих дисков.  Так как все диски
массива содержат одинаковую информацию, чтение может быть сделано параллельно,
подобным RAID-0 образом.
<P>
<H3>RAID-4</H3>

<P>Когда сделана запись на массив RAID-4, также должна быть обновлена информация о 
паритете на паритетном диске. Размер куска - размер паритетных блоков. 
Если байт записывается на массив RAID-4, потом <CODE>chunk-size</CODE> 
байт считываются с N-1 дисков, вычисляется информация о паритете, и 
<CODE>chunk-size</CODE> байт записываются на паритетный диск.
<P>Размер куска также влияет на производительность чтения также как и в RAID-0,
так как считывания с RAID-4 делаются аналогично.
<P>
<H3>RAID-5</H3>

<P>На RAID-5 размер куска имеет такое же занчение как и в RAID-4.
<P>Разумный размер куска для RAID-5 массива - 128 KB, но как обычно, Вы можете 
поэкспериментировать с ним.
<P>Посмотрите далее секцию специальных опций mke2fs. 
Это влияет на производительность RAID-5.
<P>
<P>
<H2><A NAME="ss4.9">4.9 Опции mke2fs</A>
</H2>

<P>Существует специальная опция форматирования RAID-4 ил -5 устройств с mke2fs. 
Опция <CODE>-R stride=nn</CODE> позволяет mke2fs лучше размещать различные ext2 
специфичные структуры данных разумным способом на устройство RAID.
<P>Если размер куска 32 Кб, это значит, что 32 Кб последовательных данных
будут лежать на одном диске. Если Вы хотите создать ext2 файловую систему 
с размером блока в 4 Кб, Вы сделаете так, что будет восемь блоков файловой
системы в одном куске. Мы можем указать эту информацию для утилиты mke2fs, 
при создании файловой системы:
<PRE>
  mke2fs -b 4096 -R stride=8 /dev/md0
</PRE>
<P>Производительность RAID-{4,5} строго зависит от этой опции. Я не уверен 
как опция stride будет воздействовать на другие уровни RAID. Если у кого-то
есть эта информация, пожалуйста пошлите ее мне.
<P>Размер блока ext2fs <I>строго</I> определяет производительность файловой
системы. Вы всегда должны использовать размер блока 4Кб на любой файловой
системе более чем нескольких сот мегабайт, если Вы не помещаете очень большое
число маленьких файлов на нее.
<P>
<P>
<H2><A NAME="ss4.10">4.10 Авто-детектирование</A>
</H2>

<P>Авто-детектирование позволяет ядру автоматически распознавать устройства RAID 
при загрузке, сразу после завершения обычного детектирования разделов. 
<P>Для этого требуется несколько вещей:
<OL>
<LI>Вам нужна поддержка авто-детектирования в ядре. Проверьте это.</LI>
<LI>Вы должны создать RAID устройства используя отдельный суперблок</LI>
<LI>Тип раздела устройств используемых в RAID должен быть установлен в
<B>0xFD</B>  (запустите fdisk и установите тип в ``fd'')</LI>
</OL>
<P>ЗАМЕТКА: Удостоверьтесь, что Ваш RAID НЕ ЗАПУЩЕН перед сменой типа раздела. 
Используйте <CODE>raidstop /dev/md0</CODE> для остановки устройства.
<P>Если Вы сделаете 1, 2 и 3 как указано выше, авто-детектирование должно 
быть установлено. Попробуйте перезагрузиться.  После загрузки системы, 
сделайте cat <CODE>/proc/mdstat</CODE> и это должно показать, что Ваш RAID запущен.
<P>При загрузке, Вы должны увидеть сообщения подобные этим:
<PRE>
 Oct 22 00:51:59 malthe kernel: SCSI device sdg: hdwr sector= 512
  bytes. Sectors= 12657717 [6180 MB] [6.2 GB]
 Oct 22 00:51:59 malthe kernel: Partition check:
 Oct 22 00:51:59 malthe kernel:  sda: sda1 sda2 sda3 sda4
 Oct 22 00:51:59 malthe kernel:  sdb: sdb1 sdb2
 Oct 22 00:51:59 malthe kernel:  sdc: sdc1 sdc2
 Oct 22 00:51:59 malthe kernel:  sdd: sdd1 sdd2
 Oct 22 00:51:59 malthe kernel:  sde: sde1 sde2
 Oct 22 00:51:59 malthe kernel:  sdf: sdf1 sdf2
 Oct 22 00:51:59 malthe kernel:  sdg: sdg1 sdg2
 Oct 22 00:51:59 malthe kernel: autodetecting RAID arrays
 Oct 22 00:51:59 malthe kernel: (read) sdb1's sb offset: 6199872
 Oct 22 00:51:59 malthe kernel: bind&lt;sdb1,1>
 Oct 22 00:51:59 malthe kernel: (read) sdc1's sb offset: 6199872
 Oct 22 00:51:59 malthe kernel: bind&lt;sdc1,2>
 Oct 22 00:51:59 malthe kernel: (read) sdd1's sb offset: 6199872
 Oct 22 00:51:59 malthe kernel: bind&lt;sdd1,3>
 Oct 22 00:51:59 malthe kernel: (read) sde1's sb offset: 6199872
 Oct 22 00:51:59 malthe kernel: bind&lt;sde1,4>
 Oct 22 00:51:59 malthe kernel: (read) sdf1's sb offset: 6205376
 Oct 22 00:51:59 malthe kernel: bind&lt;sdf1,5>
 Oct 22 00:51:59 malthe kernel: (read) sdg1's sb offset: 6205376
 Oct 22 00:51:59 malthe kernel: bind&lt;sdg1,6>
 Oct 22 00:51:59 malthe kernel: autorunning md0
 Oct 22 00:51:59 malthe kernel: running: &lt;sdg1>&lt;sdf1>&lt;sde1>&lt;sdd1>&lt;sdc1>&lt;sdb1>
 Oct 22 00:51:59 malthe kernel: now!
 Oct 22 00:51:59 malthe kernel: md: md0: raid array is not clean --
  starting background reconstruction 
</PRE>

Это отрывок при авто-детектировании массива RAID-5, который не был чисто
остановлен (например при крахе машины).  Была автоматически инициирована 
реконструкция.  Монтирование этого устройства вполне безопасно,
так как реконструкция прозрачна и все данные целы ( только 
паритетная информация противоречива - но она не нужна, пока диск не откажет).
<P>Автоматически стартующие устройства также автоматически останавливаются при 
выключении.  Не беспокойтесь о init скриптах.  Просто используйте устройства 
/dev/md как любые другие /dev/sd или /dev/hd устройства.
<P>Да, это в самом деле очень просто.
<P>Вы можете взглянуть в Ваш init-scripts для любых raidstart/raidstop
комманд. Они часто есть в стандартных RedHat init скриптах. 
Они используются для RAID старого стиля, и не используются в RAID нового стиля
с авто-детектированием. Посто удалите строки, и все будет очень просто.
<P>
<P>
<H2><A NAME="ss4.11">4.11 Загрузка с RAID</A>
</H2>

<P>Существует несколько путей для установки системы, которая монтирует
свою корневую файловую систему на устройство RAID. На текущий момент, только 
графический инсталлятор RedHat Linux 6.1 позволяет прямую установку на 
устройство RAID.  Так что вполне вероятно Вам прийдется немного повозиться, 
если это Вам нужно, но это вполне возможно.
<P>Последний официальный дистрибутив lilo (версия 21) не работает с устройствами
RAID, и, таким образом, ядро не может быть загружено с устройства RAID. Если Вы 
используете эту версию, Ваша файловая система <CODE>/boot</CODE> должна быть 
расположена на не-RAID устройстве.  Чтобы быть уверенным, что Ваша система 
загрузится в любом случае, создайте подобные <CODE>/boot</CODE> разделы на всех
дисках вашего RAID, таким образом BIOS всегда загрузит данные с первого
попавшегося диска.  Это требует, чтобы Вы не загружались с отказавшего диска.
<P>Для redhat 6.1 стал доступен патч к lilo 21, который способен найти 
<CODE>/boot</CODE> на RAID-1. Заметьте, что это не работает для любого другого 
уровня, RAID-1 (mirroring) - единственный поддерживаемый уровень RAID. Этот патч
(<CODE>lilo.raid1</CODE>) может быть найден в <CODE>dist/redhat-6.1/SRPMS/SRPMS/lilo-0.21-10.src.rpm</CODE> на любом зеркале redhat. 
Пропатченая версия LILO позволит <CODE>boot=/dev/md0</CODE> в <CODE>lilo.conf</CODE> и
сделает каждый диск зеркала загрузочным.
<P>Другой путь быть уверенным, что Ваша система сможет всегда загрузится - создать
загрузочную дискету после завершения всех установок. Если диск, на котором, 
расположена файловая система <CODE>/boot</CODE> умирает, Вы сможете всегда 
загрузиться с дискеты.
<P>
<P>
<H2><A NAME="ss4.12">4.12 Корневая файловая система на RAID</A>
</H2>

<P>В случае загрузки системы с RAID, корневая файловая система (/)
должна монтироваться на устройство RAID. Ниже предлагается два метода для 
достижения этого. Так как ни один из текущих дистрибутивов (по крайней мере
которые я знаю) не поддерживает инсталляцию на RAID устройство, методы предполагают, что Вы устанавливаете на обычный раздел, и затем, когда установка завершена,
перемещаете содержимое Вашей не-RAID корневой файловой системы на новое RAID 
устройство.
<P>
<H3>Метод 1</H3>

<P>Этот метод предполагает, что У вас есть резервный диск, который не входит в 
конфигурируемый RAID, и на который Вы можете инсталлировать систему.
<P>
<UL>
<LI>Сначала установите обычную систему на ваш дополнительный диск.</LI>
<LI>Запустите планируемое ядро, возьмите raid-патчи и утилиты и сделайте
загрузку Вашей системы с новым RAID-способным ядром. Убедитесь, что поддержка 
RAID <B>в</B> ядре, и не загружается как модуль.</LI>
<LI>Итак, сейчас Вы должны  сконфигурировать и создать планируемый к 
использованию RAID для корневой файловой системы. Эта стандартная процедура 
описана в этом документе.</LI>
<LI>Просто убедитесь, что все в порядке, попробуйте перезагрузить систему, 
чтобы посмотреть загрузится ли новый RAID. Должен загрузиться.</LI>
<LI>Поместите файловую систему на новый массив (используя
<CODE>mke2fs</CODE>), и смонтируйте его в /mnt/newroot</LI>
<LI>Сейчас, скопируйте содержимое Вашей текущей корневой файловой системы 
(с резервного диска) на новую корневую файловую систему (массив). Есть много
способов это сделать, один из них
<PRE>
 cd /
 find . -xdev | cpio -pm /mnt/newroot
</PRE>
</LI>
<LI>Вы должны модифицировать файл <CODE>/mnt/newroot/etc/fstab</CODE> для 
использования правильного устройства (корневого устройства <CODE>/dev/md?</CODE>) 
для корневой файловой системы.</LI>
<LI>Сейчас, размонтируйте текущуюt <CODE>/boot</CODE> файловую систему, и смонтируйте вместо нее загрузочное устройство указанное в  <CODE>/mnt/newroot/boot</CODE>. 
Это требуется для LILO для успешного запуска на следующем шаге.</LI>
<LI>Обновите <CODE>/mnt/newroot/etc/lilo.conf</CODE> для указания на правильные 
устройства. Загрузочное устройство должно все еще быть обычным диском (не-RAID
устройством), но root устройство должно указывать на Ваш новый RAID. Когда 
сделано, запустите 
<PRE>
 lilo -r /mnt/newroot
</PRE>
 
Этот запуск LILO дожен завершиться без ошибок.</LI>
<LI>Перезагрузите систему, и смотрите, чтобы все происходило как ожидается :)</LI>
</UL>
<P>Если Вы делаете это с IDE дисками, удостоверьтесь что установили в BIOS, что
все диски ``auto-detect'' типа, таким образом BIOS позволит Вашей машине
загружаться даже если диск отсутствует.
<P>
<H3>Метод 2</H3>

<P>Этот метод требует, чтобы Вы использовали raidtools/патч, которые включают 
директиву failed-disk. Это должны быть утилиты/патч для всех ядер
от 2.2.10 и выше.
<P>Вы можете использовать этот метод <B>только</B> на RAID уровня 1 и выше.  
Идея состоит в использовании установки системы на  диск специально отмеченный
как отказавший в RAID, тогда скопировав систему на RAID, запущенный в
деградированном режиме, и затем сделав доступным для RAID уже не нужный 
``инсталляционный диск'', уничтожаете старую установку, но запускаете RAID в не 
деградированном режиме.
<P>
<UL>
<LI>Сначала, установите обычную систему на один диск (который позже будет 
частью Вашего RAID). Важно, чтобы этот диск ( или раздел) не был наименьшим. 
Если это так, будет позже не возможно добавить его в массив RAID!</LI>
<LI>Теперь, возьмите ядро, патчи, утилиты и т.п. Вы уже заучили это. 
Сделайте Вашу систему загрузочной с Вашим новым ядром, который 
содержит необходимую поддержку RAID скопмилированой в ядре.</LI>
<LI>Сейчас, установите RAID с вашим текущим корневым устройством как 
<CODE>отказавшим диском</CODE> в фале <CODE>raidtab</CODE>. Не помещайте 
<CODE>отказавший диск</CODE> как первый диск в <CODE>raidtab</CODE>, это создаст 
проблемы с запуском. Создайте RAID, и поместите файловую систему на него.</LI>
<LI>Попробуйте перегрузиться и посмотреть, запустится ли RAID должным образом</LI>
<LI>Скопируйте системные файлы и ре-конфигурируйте систему для использования 
RAID в качестве корневого устройства, кaк описано в предыдущей секции.</LI>
<LI>Когда Ваша система успешно загрузиться с RAID, Вы можете модифицировать 
файл <CODE>raidtab</CODE> для включения предыдущего <CODE>отказавшего диска</CODE> как 
обычного <CODE>raid-диска</CODE>. Сейчас, <CODE>raidhotadd</CODE> диск ваш RAID.</LI>
<LI>Сейчас Вы должны получить систему, которая может загружаться с не
деградированного RAID.</LI>
</UL>
<P>
<P>
<H2><A NAME="ss4.13">4.13 Выполнение загрузки ситемы с RAID</A>
</H2>

<P>Чтобы ядро смогло смонтировать корневую файловую систему, вся поддержка
для устройства, на котором расположена корневая файловая система, должна 
быть в ядре. Таким образом, в случае монтирования файловой системы на RAID 
устройстве, ядро <EM>должно</EM> содержать  поддержку RAID.
<P>Обычный способ удостовериться, что ядро может видеть RAID устройство - 
просто скомпилировать ядро с вкомпилированой поддержкой RAID. Убедитесь, что
компилируете поддержку RAID <EM>в</EM> ядро, а <EM>не</EM> как модули. Ядро 
не может загружать модули (с корневой файловой системы) перед монтированием 
файловой системы.
<P>Однако, с RedHat-6.0 поставляется с ядром, которое содержит поддержку RAID
нового стиля в виде модулей, я здесь опишу как можно использовать стандартное 
ядро RedHat-6.0 и все еще загружать систему с RAID.
<P>
<H3>Загрузка с RAID в виде модуля</H3>

<P>Для достижения этого, Вы должны указать LILO использовать RAM-диск. 
Используйте команду <CODE>mkinitrd</CODE> для создания ramdisk, содержащего  
все модули ядра необходимые для загрузки корневого раздела. Это можно сделать
так:
<PRE>
 mkinitrd --with=&lt;module&gt; &lt;ramdisk name&gt; &lt;kernel&gt;
</PRE>

Например:
<PRE>
 mkinitrd --with=raid5 raid-ramdisk 2.2.5-22
</PRE>
<P>Это должно гарантировать, что ядро найдет указанный RAID модуль при 
монтировании устройства во время загрузки.
<P>
<P>
<H2><A NAME="ss4.14">4.14 Ловушки</A>
</H2>

<P>Никогда, НИКОГДА, <B>никогда</B> не пере-размечайте разделы дисков, которые 
являются частью рабочего RAID. Если Вы должны изменить таблицу разделов на диске,
который - часть RAID, сначала остановите массив, затем пере-размечайте.
<P>Поместить много дисков на одну шину очень просто. Обычная шина Fast-Wide SCSI
может выдерживать до 10 Мб/с, что меньше, чем могут дать многие современные 
диски. Размещение шести таких дисков на одной шине, конечно, не даст ожидаемого
прироста производительности.
<P>Многие SCSI контроллеры дадут Вам наивысшую производительность, если
SCSI шины почти маскимально забиты дисками на них.  Вы не увидите 
увеличения производительности от использования двух 2940s с двумя старыми SCSI
дисками, вместо простого подключения двух дисков к одному контролеру.
<P>Если Вы забудете опцию persistent-superblock, Ваш массив может сразу не 
запуститься после остановки.  Просто пере-создайте массив с установленной 
опцией в raidtab.
<P>Если RAID-5 отказывается реконструироваться после удаления и повторного 
добавления диска, это может быть из-за порядка устройств в raidtab. 
Попытайтесь переместить первую ``device ...'' и ``raid-disk ...'' пару 
в низ описания массива в фале raidtab.
<P>Большинство ``сообщений об ошибках'' , которые мы видим в linux-kernel, 
от людей, у которых как-то не работает правильный патч RAID с правильной версией
raidtools. Если Вы используете 0.90 RAID, убедитесь, что используете raidtools 
для этой версии.
<P>
<P>
<HR>
<A HREF="Software-RAID-HOWTO-2.4-5.html">Next</A>
<A HREF="Software-RAID-HOWTO-2.4-3.html">Previous</A>
<A HREF="Software-RAID-HOWTO-2.4.html#toc4">Contents</A>
</BODY>
</HTML>
