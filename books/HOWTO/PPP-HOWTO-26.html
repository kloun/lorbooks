<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>PPP HOWTO: Установка PPP сервера</TITLE>
 <LINK HREF="PPP-HOWTO-27.html" REL=next>
 <LINK HREF="PPP-HOWTO-25.html" REL=previous>
 <LINK HREF="PPP-HOWTO.html#toc26" REL=contents>
</HEAD>
<BODY>
<A HREF="PPP-HOWTO-27.html">Next</A>
<A HREF="PPP-HOWTO-25.html">Previous</A>
<A HREF="PPP-HOWTO.html#toc26">Contents</A>
<HR>
<H2><A NAME="s26">26. Установка PPP сервера</A></H2>

<P>Как уже упомянуто, имеется много способов это сделать. Как я говорил, имеется
способ, которым это делаю я (использование многопортовой платы Cyclades) и 
циклический пулл телефонных линий.
<P>Если вам не нравится способ, который я представляю здесь, пожалуйста, не 
стесняйтесь идти собственным путем. Мне бы хотелось включить дополнительные 
методы в будущие версии HOWTO. Так что, пожалуйста, вышлите мне ваши 
комментарии и способы!
<P>Пожалуйста, обратите внимание, что этот раздел касается только установки Linux 
в качестве PPP сервера. Я (даже) не предполагаю включать информацию о установке
специальных терминальных серверов итп.
<P>Также я все-таки экспериментирую с теневыми паролями (но сделаю так 
когда-нибудь).
<P>Информация в настоящее время не представлена, и следовательно никакие звоночки 
и свистки, которые требуются для shadow suite, не включаются.
<P>
<P>
<H2><A NAME="ss26.1">26.1 Компиляция ядра</A>
</H2>

<P>Примените все ранее высказанные комментарии о компиляции ядра и версиях ядра 
и соответствующих версий pppd. В этом разделе предполагается, что вы читали 
предыдущие разделы этого документа!
<P>Для PPP сервера, Вы ДОЛЖНЫ включить IP forwarding в вашем ядре. Вы можете также 
захотеть включить другие возможности (типа IP fire wall, учета пользователей 
и т.д и т.д).
<P>Если вы используете многопортовую последовательную плату, то вы очевидно также
включили необходимые драйверы в ваше ядро!
<P>
<P>
<H2><A NAME="ss26.2">26.2 Краткий обзор серверной системы </A>
</H2>

<P>Мы предлагаем аккаунты коммутируемого PPP (и SLIP) и shell, использующие одну и
ту же пару имени/пароля пользователя. Это имеет те преимущества (для нас), что 
для пользователя требуется только один аккаунт и можно использовать это для 
всех типов связей.
<P>Поскольку мы - образовательная организация, мы не надзираем за доступом нашего 
персонала и студентов, и также не должны волноваться за учет пользователей 
и проблемах поддержки.
<P>Мы эксплуатируем firewall между нашим сайтом и Интернетом, и это ограничивает 
некоторым пользователям доступ к телефонным линиям изнутри нашим
(Интернет) firewall'ом (по довольно очевидным причинам, подробности наших 
других firewall'ов не рассматриваются и несоответствуют в любом случае).
<P>Процесс, который пользователь проходит для установки PPP связи с нашим 
сайтом (конечно, если только ему разрешен доступ): 
<UL>
<LI>  Позвонить на наш циклический пулл (это единственный номер телефона, который 
соединяется с банком модемов - при звонке включается первый свободный модем).
</LI>
<LI> Вход в систему, если имя и пароль пользователя указаны правильно.
</LI>
<LI> В командной строке shell выдать команду ppp, чтобы запустить PPP на сервере.
</LI>
<LI> Запуск PPP на их PC (будь это Windows, DOS, Linux MAC OS или еще что) 
является проблемой пользователя).</LI>
</UL>

Сервер использует индивидуальные файлы /etc/ppp/options.ttyXX для каждого 
модемного порта, который устанавливает динамический удаленный IP адрес. 
Сервер использует proxyarp маршрутизацию для удаленных клиентов (установлено
соответствующей опцией pppd). Это устраняет потребность в routed или gated.
<P>Когда пользователь "бросает трубку" на своем конце, pppd обнаруживает это и 
заставляет модем тоже "положить трубку", одновременно закрывая связь PPP.
<P>
<P>
<H2><A NAME="ss26.3">26.3 Состав программного обеспечения</A>
</H2>

<P>Вы нужно будет следующее программное обеспечение:
<UL>
<LI> Linux, правильно скомпилированный, чтобы были включены необходимые опции.
</LI>
<LI> соответствующая версия pppd для вашего ядра.
</LI>
<LI> программа 'getty', которая интеллектуально обрабатывает модемную связь.
<P>Мы используем getty_ps2.0.7, но вроде mgetty лучше. Я понимаю, что mgetty может
обнаружить звонок, который использует pap/chap (pap - стандарт для Windows95) и
вызвать pppd автоматически, но однако я должен исследовать это.
</LI>
<LI> Функционирующий сервер доменных имен (DNS), который доступне вашим модемным
пользователям. </LI>
</UL>

Вы действительно должны запустить собственный DNS, если это возможно ...
<P>
<P>
<H2><A NAME="ss26.4">26.4 Установка стандартного (доступ через shell) коммутируемого доступа.</A>
</H2>

<P>Прежде, чем вы сможете установить ваш PPP сервер, ваш Linux box должен быть 
способен обрабатывать стандартный доступ по коммутируемым линиям.
<P>Этот howto не покрывает установку этой системы. Пожалуйста см. документацию по
выбранному вами getty и Serial-HOWTO для информации об этом.
<P>
<P>
<H2><A NAME="ss26.5">26.5 Установка файлов PPP опций</A>
</H2>

<P>Вам нужно будет установить полный /etc/ppp/options с общими опциями для всех
портов, принимающих внешние звонки. Опции, которые мы используем:
<PRE>
  ______________________________________________________________________
  asyncmap 0
  netmask 255.255.254.0
  proxyarp
  lock
  crtscts
  modem
  ______________________________________________________________________
</PRE>
<P>Примечание - мы НЕ используем (очевидную) маршрутизацию - и в частности, 
там нет опции defaultroute. Причина этого в том, что все, что вам (как PPP 
серверу) требуется сделать, это направить пакеты от внешнего ppp клиента
через ваш LAN/INTERNET и маршрутизации пакетов клиента вашей LAN наружу.
<P>Все, что для этого нужно - чтобы хост маршрутизировал клиентскую машину и 
использование опции pppd 'proxyarp'.
<P>Опция 'proxyarp' устанавливает (сюрприз) прокси ARP запись в ARP таблице PPP 
сервера, которая в основном говорит 'посылать все пакеты, предназначенные для
PPP клиента ко мне'. Это самый простой способ установить маршрутизацию 
одному PPP клиенту, но вы не сможете использовать его, если вы маршрутизируете
две LAN - вы должны добавить соответствующие сетевые маршруты, которые не могут
использовать прокси ARP.
<P>Вы наверняка пожелаете обеспечить динамическое распределение IP адресов для 
ваших модемных пользователей. Вы можете сделать это распределением IP адресов
для каждого порта входящего модемного соединения. Теперь, создайте 
/etc/ppp/options.ttyXX для каждого порта входящего модемного соединения.
<P>В них просто поместите локальный (серверный) IP адрес и IP адрес, который должен 
использоваться для этого порта. Например
<PRE>
______________________________________________________________________

kepler:slip01
______________________________________________________________________
</PRE>
<P>В частности, обратите внимание, что вы можете использовать допустимые главные 
имена машин в этом файле (я нахожу, что напрмер я помню IP адреса только 
критических машин и устройств в моих сетях - имена легче запомнить)!
<P>
<P>
<H2><A NAME="ss26.6">26.6 Настройка pppd, чтобы он был (успешно) доступен пользователям для запуска</A>
</H2>

<P>Так как запуск ppp связи подразумевает конфигурирование устройства ядра 
(сетевого интерфейса) и управление ядром, таблицы маршрутизации, требуются
специальные привилегии - фактически полные привилегии root.
<P>К счастью, pppd был разработан достаточно 'безопасным' для выполнения 
установки uid в root. Так что вам нужно будет сделать
<PRE>
______________________________________________________________________

chmod u+s /usr/sbin/pppd
______________________________________________________________________
</PRE>
<P>когда вы выведете список файлов, то должно появиться
<PRE>
______________________________________________________________________

-rwsr-xr-x   1 root     root        74224 Apr 28 07:17 /usr/sbin/pppd
______________________________________________________________________
</PRE>
<P>Если вы не сделаете это, то пользователи не смогут установить связь по ppp.
<P>
<P>
<H2><A NAME="ss26.7">26.7 Установка глобального псевдонима для pppd</A>
</H2>

<P>Для того, чтобы облегчить работу нашим модемным PPP пользователям, мы 
создадим глобальный псевдоним (в /etc/bashrc) так, чтобы одна простая команда 
запускала ppp на сервере, как только они регистрируются в системе.
<P>Это выглядит примерно так
<PRE>
______________________________________________________________________

alias ppp="exec /usr/sbin/pppd -detach"
______________________________________________________________________
</PRE>
<P>Что это значит
<UL>
<LI> exec : это означает заменить запущенную программу (в этом случае shell) 
программой, которая указана.
</LI>
<LI> pppd -detach : запустить pppd, и НЕ переводить в фоновый режим.</LI>
</UL>

Это гарантирует, что когда pppd завершит работу, то не останется никаких других 
процессов.
<P>Когда пользователь регистрируется по этому способу, при выполнении команды 'w' 
он появляется как
<PRE>
  ______________________________________________________________________
    6:24pm  up 3 days,  7:00,  4 users,  load average: 0.05, 0.03, 0.00
  User     tty       login@  idle   JCPU   PCPU  what
  hartr    ttyC0     3:05am  9:14                -
  ______________________________________________________________________
</PRE>

И это - все ... Я рассказал вам о простом, основном PPP сервере!
<HR>
<A HREF="PPP-HOWTO-27.html">Next</A>
<A HREF="PPP-HOWTO-25.html">Previous</A>
<A HREF="PPP-HOWTO.html#toc26">Contents</A>
</BODY>
</HTML>
