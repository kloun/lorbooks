<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Мини-HOWTO: Совместное использование мостов и Firewall в Linux</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Мини-HOWTO: Совместное использование мостов и Firewall в Linux</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Peter Breuer</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;    ptb@it.uc3m.es
    <br>
&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><H3
CLASS="CORPAUTHOR"
>  Перевод: <A
HREF="mailto:sam@asp-linux.com"
TARGET="_top"
>Станислав Рогин</A
>,
  <A
HREF="http://www.asplinux.com"
TARGET="_top"
>SWSoft Pte Ltd.</A
>
 </H3
></DIV
><P
CLASS="PUBDATE"
>версия 1.2.0, 19 декабря 1997<BR></P
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Содержание</B
></DT
><DT
>1. <A
HREF="Bridge+Firewall.html#INTRODUCTION"
>Введение</A
></DT
><DT
>2. <A
HREF="Bridge+Firewall.html#WHAT-AND-WHY-AND-HOW"
>Что и Зачем (и Как?)</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="Bridge+Firewall.html#WHAT"
>Что?</A
></DT
><DT
>2.2. <A
HREF="Bridge+Firewall.html#WHY"
>Почему?</A
></DT
><DT
>2.3. <A
HREF="Bridge+Firewall.html#HOW"
>Как?</A
></DT
></DL
></DD
><DT
>3. <A
HREF="Bridge+Firewall.html#BRIDGING"
>Мосты</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="Bridge+Firewall.html#SOFTWARE"
>Программы</A
></DT
><DT
>3.2. <A
HREF="Bridge+Firewall.html#PRIOR-READING"
>Литература для предварительного прочтения.</A
></DT
><DT
>3.3. <A
HREF="Bridge+Firewall.html#BOOT-CONFIGURATION"
>Конфигурация загрузки</A
></DT
><DT
>3.4. <A
HREF="Bridge+Firewall.html#KERNEL-CONFIGURATION"
>Конфигурация ядра</A
></DT
><DT
>3.5. <A
HREF="Bridge+Firewall.html#NETWORK-ADDRESSES"
>Сетевые адреса</A
></DT
><DT
>3.6. <A
HREF="Bridge+Firewall.html#NETWORK-ROUTING"
>Сетевая маршрутизация</A
></DT
><DT
>3.7. <A
HREF="Bridge+Firewall.html#CARD-CONFIGURATION"
>Настройка сетевых карт</A
></DT
><DT
>3.8. <A
HREF="Bridge+Firewall.html#ADDITIONAL-ROUTING"
>Дополнительная маршрутизация</A
></DT
><DT
>3.9. <A
HREF="Bridge+Firewall.html#BRIDGE-CONFIGURATION"
>Конфигурация моста</A
></DT
><DT
>3.10. <A
HREF="Bridge+Firewall.html#TRY-IT-OUT"
>Испытания</A
></DT
><DT
>3.11. <A
HREF="Bridge+Firewall.html#AEN186"
>Дополнительные проверки</A
></DT
></DL
></DD
><DT
>4. <A
HREF="Bridge+Firewall.html#FIREWALLING"
>FIREWALL</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="Bridge+Firewall.html#SOFTWARE-AND-READING"
>Программы и дополнительная литература</A
></DT
><DT
>4.2. <A
HREF="Bridge+Firewall.html#PRELIMINARY-CHECKS"
>Предварительные проверки</A
></DT
><DT
>4.3. <A
HREF="Bridge+Firewall.html#DEFAULT-RULE"
>Основное правило</A
></DT
><DT
>4.4. <A
HREF="Bridge+Firewall.html#HOLES-PER-ADDRESS"
>Исключения для адресов</A
></DT
><DT
>4.5. <A
HREF="Bridge+Firewall.html#HOLES-PER-PROTOCOL"
>Исключения для протоколов</A
></DT
><DT
>4.6. <A
HREF="Bridge+Firewall.html#AEN280"
>Проверка</A
></DT
></DL
></DD
><DT
>5. <A
HREF="Bridge+Firewall.html#AEN292"
>Авторские права</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTRODUCTION"
>1. Введение</A
></H1
><P
>Вам неплохо было бы посмотреть на
<A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/mini/Bridge"
TARGET="_top"
>"Мини-HOWTO: Мосты"</A
> автора Chris Cole, чтобы взглянуть на всю эту проблему по-другому.
Его адрес - <A
HREF="mailto:chris@polymer.uakron.edu"
TARGET="_top"
>chris@polymer.uakron.edu</A
>.  Мой документ основан на выдержках из этого документа версии 1.03 от 23 августа 1996.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="WHAT-AND-WHY-AND-HOW"
>2. Что и Зачем (и Как?)</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="WHAT"
>2.1. Что?</A
></H2
><P
>Мост - это интеллектуальное соединение между двумя сетевыми картами. Firewall - это интеллектуальный изолятор.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="WHY"
>2.2. Почему?</A
></H2
><P
>Мост вам может понадобиться, если у вас имеется несколько компьютеров, и вы хотите:</P
><P
>&#13;<P
></P
><OL
TYPE="1"
><LI
><P
> сэкономить на покупке хаба, если у вас есть еще одна запасная сетевая карта.&#13;</P
></LI
><LI
><P
> избавиться от проблем с изучением IP-переадресации и других хитростей, если у вас есть две сетевых карты в компьютере.&#13;</P
></LI
><LI
><P
> избежать проблем с поддержкой в будущем, когда все изменится!&#13;</P
></LI
></OL
>&#13;</P
><P
>"Несколько компьютеров" - это минимум 3 рабочих станции, которые занимаются
маршрутизацией, мостами, или просто часто переносятся из одной комнаты в
другую! Вам может также понадобиться мост, если вам просто интересно, что
же он на самом деле делает. Мне мост потребовался по 2-ой причине.</P
><P
>Если у вас действительно возникла 1-ая проблема, то вы один из немногих. Прочтите <A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/NET-2-HOWTO"
TARGET="_top"
>Howto: Сеть-2</A
> и <A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/Serial-HOWTO"
TARGET="_top"
>HOWTO: Последовательные порты</A
>, и вы, возможно, найдете там советы получше.</P
><P
>Firewall может вам понадобиться, если:</P
><P
>&#13;<P
></P
><OL
TYPE="1"
><LI
><P
> Вы пытаетесь защитить сеть от доступа извне, или&#13;</P
></LI
><LI
><P
> Вы хотите запретить доступ к внешнему миру изнутри.&#13;</P
></LI
></OL
>&#13;</P
><P
>Как ни странно, здесь меня также заинтересовал второй аспект.
В нашем университете существуют правила: мы не должны
быть провайдером интернета для студентов.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="HOW"
>2.3. Как?</A
></H2
><P
>Я начал с устройства мостов на сетевых картах в машине с firewall-ом и
затем выключил firewall, не отключая мост. Все работало вроде нормально и
оказалось более гибким, чем поодиночке. Я могу отключать firewall и
оставить мост или наоборот, по мере необходимости.</P
><P
>Я предполагаю, что код для мостов лежит чуть выше, чем уровень драйвера физического устройства, а код firewall-ов лежит еще выше, поэтому мосты и firewall-ы могут эффективно работать, потому что "соединены последовательно", а не "параллельно" (ох)!). Диаграмма: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>-&gt; Вход моста -&gt; Вход firewall -&gt; Ядро -&gt; Выход firewall -&gt; Выход моста -&gt;</PRE
>&#13;</P
><P
>Не существует другого приемлемого способа объяснить, как машина может быть
и "проводником" и "изолятором" одновременно. Существуют, однако, некоторые
хитрости, о которых я скажу немного позже. В общих словах - вы хотите
маршрутизировать пакеты, которые должны обрабатываться к тому же и
firewall-ом. В любом случае, у меня все это работало прекрасно. Вот, что вам
надо сделать...</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BRIDGING"
>3. Мосты</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SOFTWARE"
>3.1. Программы</A
></H2
><P
>Возьмите <A
HREF="ftp://shadow.cabi.net/pub/Linux/BRCFG.tgz"
TARGET="_top"
>утилиту
настройки мостов</A
> с домашних страниц Alan Cox. Это та же ссылка, что и в
документе Chris. Я просто не знал, что это ftp, а не http URL ...</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PRIOR-READING"
>3.2. Литература для предварительного прочтения.</A
></H2
><P
>Прочтите <A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/mini/Multiple-Ethernet"
TARGET="_top"
>HOWTO: Несколько Ethernet-карт</A
>, и вы найдете там несколько советов
о том, как заставить работать несколько сетевых карт одновременно.</P
><P
>Более подробные советы по "магии загрузки системы", которая может
понадобиться, вы найдете в <A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/BootPrompt-HOWTO"
TARGET="_top"
>HOWTO:
Приглашение системы при загрузке</A
>.</P
><P
>Конечно можно обойтись без чтения <A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/NET-2-HOWTO"
TARGET="_top"
>HOWTO: Сеть-2</A
>, хотя это очень хороший и объемный труд, и вы сможете почерпнуть из него все необходимые детали. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BOOT-CONFIGURATION"
>3.3. Конфигурация загрузки</A
></H2
><P
>В литературе, упомянутой выше, вы прочтете, что вам надо подготовить ядро к обнаружению второй сетевой карты в процессе загрузки, добавив в ваш файл <I
CLASS="EMPHASIS"
>/etc/lilo.conf</I
>, и затем перезапустив <I
CLASS="EMPHASIS"
>lilo</I
>: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>append = "ether=0,0,eth1" </PRE
>&#13;</P
><P
>Обратите внимание на "eth1". "eth0" - это первая карта. "eth1" - соответственно вторая. Вы всегда можете добавить эти параметры в строку, которую вам предлагает lilo в самом начале. Ниже приведен пример для трех карт: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>linux ether=0,0,eth1 ether=0,0,eth2 </PRE
>&#13;</P
><P
>Я лично использую <I
CLASS="EMPHASIS"
>loadlin</I
> для загрузки моего ядра из DOS: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>loadlin.exe c:\vmlinuz root=/dev/hda3 ro ether=0,0,eth1 ether=0,0,eth2 </PRE
>&#13;</P
><P
>Заметьте, что этот способ заставляет ядро автоматически определять
параметры карт при загрузке. Это не сработает, если драйвера сетевых карт
собраны у вас в виде <I
CLASS="EMPHASIS"
>modules</I
> (это сделано
из соображений устойчивости, так как в этом случае нельзя определить
порядок установки карт), поэтому, в случае использования модулей, вам
придется добавить соответствующие номера IRQ и портов в параметры драйвера
в файл <I
CLASS="EMPHASIS"
>/etc/conf.modules</I
>. У меня записано
следующее</P
><P
>&#13;<PRE
CLASS="SCREEN"
>alias eth0 3c509
alias eth1 de620
options 3c509 irq=5 io=0x210
options de620 irq=7 bnc=1 </PRE
>&#13;</P
><P
>Вы можете просто выяснить, используются ли в вашей системе модули, набрав "ps -aux", и поискать там <I
CLASS="EMPHASIS"
>kerneld </I
>, а также проверив подкаталоги каталога <I
CLASS="EMPHASIS"
>/lib/modules</I
> на предмет наличия в нем .o файлов. 
Вас интересует подкаталог, имя которого вам даст команда uname -r. Если у вас есть kerneld и/или foo.o, тогда исправьте файл <I
CLASS="EMPHASIS"
>/etc/conf.modules</I
> и внимательно прочитайте man depmod.</P
><P
>Заметьте, что до последней (2.0.25) версии ядра драйвер карты <I
CLASS="EMPHASIS"
>3c509</I
> не мог использоваться в виде модуля более одного раза. Я видел патч, который это исправлял. Возможно, когда вы это читаете, ядро уже исправлено. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="KERNEL-CONFIGURATION"
>3.4. Конфигурация ядра</A
></H2
><P
>Пересоберите ядро, разрешив  в нем опцию "мосты". </P
><P
>&#13;<PRE
CLASS="SCREEN"
>CONFIG_BRIDGE=y </PRE
>&#13;</P
><P
>Я лично пересобрал ядро также с поддержкой firewall и IP-переадресации, а также с маскарадингом и т.п. Это необходимо, если вам нужен и firewall тоже... </P
><P
>&#13;<PRE
CLASS="SCREEN"
>CONFIG_FIREWALL=y           
CONFIG_NET_ALIAS=y          
CONFIG_INET=y               
CONFIG_IP_FORWARD=y         
CONFIG_IP_MULTICAST=y       
CONFIG_IP_FIREWALL=y        
CONFIG_IP_FIREWALL_VERBOSE=y
CONFIG_IP_MASQUERADE=y      </PRE
>&#13;</P
><P
>Вам, вероятнее всего, нужно не все. Все что вам надо - это просто поддержка сети: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>CONFIG_NET=y </PRE
>&#13;</P
><P
>и я не думаю, что вам стоит беспокоиться о других сетевых опциях. У меня очень много не очень нужных функций собрано вне ядра, в виде модулей, чтобы я смог использовать их позже. </P
><P
>Установите новое ядро, перезапустите lilo и перезагрузитесь с новым ядром. К этому моменту ничего не должно измениться! </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NETWORK-ADDRESSES"
>3.5. Сетевые адреса</A
></H2
><P
>Chris говорит, что мост не должен иметь IP-адреса, но я опишу прямо противоположный вариант. </P
><P
>Если вы собираетесь использовать свою машину для подключения к сети, то вам
понадобится IP-адрес. Необходимо проверить, нормально ли настроено
устройство обратной петли, чтобы программы могли общаться с тем, с чем
они предполагают это общение возможным. Если устройство обратной петли
выключено, то DNSили другие сетевые сервисы могут отказать. Прочтите
"HOWTO: Сеть-2", но скорее всего, у вас эта часть стандартной конфигурации
должна уже присутствовать:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig lo 127.0.0.1 route add -net 127.0.0.0 </PRE
>&#13;</P
><P
>Вам также будет необходимо проставить адреса для сетевых карт. Я
исправил файл /etc/rc.d/rc.inet1 в моем дистрибутиве Slackware (3.x), чтобы
он работал с двумя сетевыми картами, и вам, скорее всего, также, как и мне,
придется просто найти файл конфигурации сети и удвоить или утроить
несколько команд, отвечающих за настройку сетевой карты. Предположим, что у
вас уже есть адрес</P
><P
>&#13;<PRE
CLASS="SCREEN"
>192.168.2.100 </PRE
>&#13;</P
><P
>(он входит в пространство адресов, зарезервированное для частных сетей, но не волнуйтесь - если вы используете этот адрес, то проблем ни у кого не возникнет), то у вас в скрипте уже есть примерно такая строка: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig eth0 192.168.2.100 netmask 255.255.255.0 metric 1 </PRE
>&#13;</P
><P
>Первое, что вам надо будет сделать - это, по-видимому, разделить адресное пространство, занимаемое этой картой пополам, чтобы затем настроить мост или firewall между этими двумя половинами. Для этого добавьте строку, сокращающую маску сети:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig eth0 netmask 255.255.255.128 </PRE
>&#13;</P
><P
>Испытайте такой режим. Эта строка ограничивает адресное пространство карты,
как минимум, от .0 до .127.</P
><P
>Теперь вы можете настроить вторую карту, выделив ей адрес из оставшейся половины адресного пространства. Убедитесь в том, что ни у кого этот адрес не используется. Для симметрии я использую 228=128+100. Подойдет любой адрес, не входящий в сеть первой карты (в принципе можно и входящий, но...). Избегайте специальных адресов типа .0, .1, .128 и т.п.., используйте их только в том случае, если точно знаете, что делаете. </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig eth1 192.168.2.228 netmask 255.255.255.128 metric 1 </PRE
>&#13;</P
><P
>Эта строка отводит к сети второй карты адреса от .128 до .255. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NETWORK-ROUTING"
>3.6. Сетевая маршрутизация</A
></H2
><P
>Вот здесь как раз и всплывает подводный камень схемы мост+firewall: нельзя
отфильтровывать пакеты, которые не прошли через маршрутизацию. Нет
маршрутизации - нет firewall. По крайней мере, это так в ядре версии 2.0.30
и более новых. Фильтры firewall очень близки и пересекаются с кодом
ip-переадресации.</P
><P
>Это, однако, не означает, что мост не будет работать. Вы можете устроить
мост между двумя картами и отфильтровывать потоки с третьей. Вы можете
иметь, например, две карты и включить фильтры firewall-а на обе,
обрабатывая пакеты с внешнего IP, например, ближайшего маршрутизатора, если
он направляет все пакеты только на одну вашу карту.</P
><P
>Другими словами, чтобы настроить firewall, необходимо точно знать и контролировать назначение конкретных пакетов. </P
><P
>У меня имеется небольшая сеть с машинами, подключенных к хабу, включенному в мой eth0, поэтому конфигурируем эту сеть: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>route add -net 192.168.2.128 netmask 255.255.255.128 dev eth0 </PRE
>&#13;</P
><P
>128 было бы заменено на 0, если бы у меня была полная сеть класса C. Но у меня ее нет, так как я ополовинил сеть ранее. Опции "dev eth0" в этом конкретном случае не обязательны, но они могут понадобиться для вас. Кто-то может захотеть иметь более одной карты, работающей с одной подсетью (127 компьютеров на одном сегменте - ничего себе), но эти карты будут соединены вместе с одной и той же маской сети, поэтому для кода маршрутизации они будут неразличимы.</P
><P
>Ко второй карте у меня подключена линия, идущая прямо к большому маршрутизатору, которому я полностью доверяю. </P
><PRE
CLASS="SCREEN"
>                                                  клиент 129
         __                                           |    __ 
клиент 1   \    .0                    .128            |   /   сеть 1
клиент 2 --- Хаб - eth0 -  Ядро  - eth1 - Хаб - Маршрутизатор --- сеть 2
клиент 3 __/       .100            .228            .2 |   \__ сеть 3
                                                      |
                                                  клиент 254 </PRE
><P
>Я добавил адрес маршрутизатора в таблицу переадресации этой карты в виде
фиксированного (статического) маршрута, иначе он может попасть в адресное
пространство первой карты, и ядро может ошибиться в выборе направления
посылки пакета к большому маршрутизатору. Вторая причина использования
статического маршрута - мне понадобиться фильтровать пакеты, идущие через
эту карту, при помощи firewall.</P
><P
>&#13;<PRE
CLASS="SCREEN"
>route add 192.168.2.2 dev eth1 </PRE
>&#13;</P
><P
>Я опишу сеть второй карты тоже, хотя у меня и нет в той половине адресов ни одной машины. Разделение адресных пространств карт позволяет мне настроить более "прочный" firewall, но вы можете справиться с этим и при помощи значительно более простой маршрутизации.</P
><P
>&#13;<PRE
CLASS="SCREEN"
>route add -net 192.168.2.128 netmask 255.255.255.128 dev eth1 </PRE
>&#13;</P
><P
>Мне также необходимо посылать все пакеты с нелокальным получателем во внешний мир, поэтому говорим ядру посылать их к большому маршрутизатору </P
><P
>&#13;<PRE
CLASS="SCREEN"
>route add default gw 192.168.2.2 </PRE
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CARD-CONFIGURATION"
>3.7. Настройка сетевых карт</A
></H2
><P
>Достаточно сетевых настроек, но, так как мы устроили мост, то
необходимо воспринимать на обеих картах пакеты, которые направлены не нам.
Следующие строки необходимо поместить в файл настройки сети.</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig promisc eth0 ifconfig promisc eth1 </PRE
>&#13;</P
><P
>В man написано использовать опцию allmulti=promisc, но у меня это не сработало. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ADDITIONAL-ROUTING"
>3.8. Дополнительная маршрутизация</A
></H2
><P
>Я еще выяснил, что мне пришлось переключить вторую карту в режим, в котором она смогла отвечать на запросы большого маршрутизатора, какие машины я прячу в моей локальной сети. </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig arp eth1 </PRE
>&#13;</P
><P
>На всякий случай, я проставил этот режим и другой карте. </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig arp eth0. </PRE
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BRIDGE-CONFIGURATION"
>3.9. Конфигурация моста</A
></H2
><P
>Вставьте в ваш конфигурационный скрипт строку, разрешающую работу моста: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>brcfg -enable </PRE
>&#13;</P
><P
>Наверное, вы уже пытались запустить эту строку! Конфигурация моста выдаст на экран несколько цифр. Вы можете поэкспериментировать, включая и выключая порты: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>brcfg -port 0 -disable/-enable
brcfg -port 1 -disable/-enable </PRE
>&#13;</P
><P
>Статус работы моста можно получить в любой момент простой командой: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>brcfg </PRE
>&#13;</P
><P
>без параметров. Вы увидите, что мост ждет пакетов, затем обрабатывает и
перенаправляет их. (Я не знаю почему, но программа выдавала одинаковые
аппаратные адреса на обеих моих картах, но не обращайте на это внимания...
В HOWTO Chris-а говорится, что это нормально)</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TRY-IT-OUT"
>3.10. Испытания</A
></H2
><P
>Если у вас до сих пор все работает и ничего не сломалось, испробуйте свой
конфигурационный скрипт - выключите обе карты и запустите скрипт:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ifconfig eth0 down ifconfig eth1 down /etc/rc.d/rc.inet1 </PRE
>&#13;</P
><P
>С достаточной долей везения различные сетевые подсистемы этого не заметят (<I
CLASS="EMPHASIS"
>nfs</I
>, <I
CLASS="EMPHASIS"
>ypbind</I
>, и т.п.).
 <I
CLASS="EMPHASIS"
>Не пытайтесь сделать это, если вы находитесь не за клавиатурой системной консоли!</I
></P
><P
>Если вы привыкли быть более аккуратным, чем в вышеприведенном примере,
тогда отключите максимально возможное количество демонов перед испытаниями,
и отключите сетевые каталоги NFS. Наихудшее, что может произойти - это то,
что вам придется перезагрузиться в однопользовательском режиме (параметр
"<I
CLASS="EMPHASIS"
>single</I
>" , переданный <I
CLASS="EMPHASIS"
>lilo </I
>или <I
CLASS="EMPHASIS"
>loadlin</I
>) и
внести требуемые изменения до перезагрузки.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN186"
>3.11. Дополнительные проверки</A
></H2
><P
>Проверьте, различается ли трафик на интерфейсах: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>tcpdump -i eth0 (в одном окне)
tcpdump -i eth1 (в другом окне)</PRE
>&#13;</P
><P
>Вы должны привыкнуть использовать <I
CLASS="EMPHASIS"
>tcpdump</I
>, чтобы искать то, чего не должно быть или искать отсутствие того, что быть должно. </P
><P
>Последите за пакетами, идущими, например, через мост на вторую карту из внутренней сети. Ниже я слежу за пакетами, идущими от машины с адресом .22: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>tcpdump -i eth1 -e host 192.168.2.22</PRE
>&#13;</P
><P
>Затем выполните команду ping от хоста .22 к маршрутизатору. Вы должны увидеть пакеты в окне tcpdump. </P
><P
>На этот момент у вас должен быть настроен и работать мост с двумя адресами. Проверьте возможность ping на них снаружи и изнутри сети, затем испробуйте telnet, ftp и т.п. с разных сторон.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FIREWALLING"
>4. FIREWALL</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SOFTWARE-AND-READING"
>4.1. Программы и дополнительная литература</A
></H2
><P
>Вы должны прочитать <A
HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/Firewall-HOWTO"
TARGET="_top"
>HOWTO: Firewall</A
>. </P
><P
>Там сказано, что вам понадобится утилита <I
CLASS="EMPHASIS"
>ipfwadm</I
>, если у вас ее еще нет. Существуют, правда, и другие, но как я начал использовать <I
CLASS="EMPHASIS"
>ipfwadm</I
>, так на нем и остановился. Он достаточно удобен и прост! Вы всегда знаете, что конкретно он делает. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PRELIMINARY-CHECKS"
>4.2. Предварительные проверки</A
></H2
><P
>Вы уже собрали IP-переадресацию и маскарадинг в ядро, поэтому проверьте,
находится ли firewall в его стандартном (разрешающем) состоянии
командой</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -l ipfwadm -O -l ipfwadm -F -l </PRE
>&#13;</P
><P
>Эти команды выдадут список правил соответственно для входного, выходного и переадресуемых потоков firewall. Опция "-l" означает "list" (список). </P
><P
>Возможно, вы собрали и систему учета IP-пакетов: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -A -l </PRE
>&#13;</P
><P
>Вы увидите, что ни одно правило не определено, и что, по умолчанию, firewall пропускает все пакеты. Вы всегда можете вернуться к этому состоянию командами </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -f
ipfwadm -O -f
ipfwadm -F -f </PRE
>&#13;</P
><P
>Опция "-f" означает "flush" (сбросить, очистить). Эта опция вам может понадобиться.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="DEFAULT-RULE"
>4.3. Основное правило</A
></H2
><P
>Я хочу отрезать внешний мир от моей сети и не более того, поэтому мое
последнее (воспринимаемое по умолчанию) правило будет следующим - firewall
должен игнорировать любые пакеты, идущие из внутренней сети во внешний мир.
Я поместил все правила в файл <I
CLASS="EMPHASIS"
>/etc/rc.d/rc.firewall</I
> и запускаю его из <I
CLASS="EMPHASIS"
>/etc/rc.d/rc.local</I
> в процессе загрузки.</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -a reject -S 192.168.2.0/255.255.255.128 -D 0.0.0.0/0.0.0.0 </PRE
>&#13;</P
><P
>Опция "-S" задает адрес источника и маску. "-D" - адрес и маску получателя. </P
><P
>Это - достаточно подробный формат. <I
CLASS="EMPHASIS"
>Ipfwadm</I
>
 понимает сетевые имена и некоторые сокращения (все это описано в man). </P
><P
>Наверно, более удобно поместить некоторые или все эти правила в выходной
поток firewall, используя "-O" вместо "-I", но я оставлю эти правила на
входящем потоке.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="HOLES-PER-ADDRESS"
>4.4. Исключения для адресов</A
></H2
><P
>Все исключения этому общему отрицанию я должен поместить до установки основного правила. </P
><P
>Машина, работающая в качестве firewall во внутренней сети, будет иметь некоторые привилегии. Без особого разрешения будет запрещено входить в машину, использующую firewall, но с этим разрешением им можно общаться с внешним миром. </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -i accept -S 192.168.2.100/255.255.255.255 \
 -D 0.0.0.0/0.0.0.0 </PRE
>&#13;</P
><P
>Я также разрешу клиентам внутренней сети общаться с firewall-машиной. Возможно, они попытаются таким образом постараться выбраться во внешний мир! </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -i accept -S 192.168.2.0/255.255.255.128 \
 -D 192.168.2.100/255.255.255.255 </PRE
>&#13;</P
><P
>На этом моменте вы можете попытаться добраться до клиентов снаружи firewall, при помощи <I
CLASS="EMPHASIS"
>telnet</I
>, но у вас ничего не получится. Это означает, что вы смогли увидеть их машины, но они не могут послать вам ничего. Вы сможете установить контакт с внутренними машинами, если firewall у вас играет роль простого аудитора. Испытайте <I
CLASS="EMPHASIS"
>rlogin</I
> и <I
CLASS="EMPHASIS"
>ping </I
>,
 а также <I
CLASS="EMPHASIS"
>tcpdump</I
> на первой или второй карте. Вы должны понять, что вы увидите. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="HOLES-PER-PROTOCOL"
>4.5. Исключения для протоколов</A
></H2
><P
>Я буду облегчать правила протокол за протоколом. Первое, что я хочу сделать - разрешить ping снаружи внутрь и получать ответ, поэтому я добавлю правило: </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -i accept -P icmp -S 192.168.2.0/255.255.255.128 \
 -D 0.0.0.0/0.0.0.0 </PRE
>&#13;</P
><P
>Опция "-P icmp" как раз отвечает за протокол.</P
><P
>Пока я не настроил должным образом <I
CLASS="EMPHASIS"
>ftp</I
>-proxy, я также разрешу вызовы ftp, используя конкретные порты - 20, 21 и 115 на внешние машины. </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -i accept -P tcp -S 192.168.2.0/255.255.255.128 \
 -D 0.0.0.0/0.0.0.0 20 21 115 </PRE
>&#13;</P
><P
>Я так и не смог заставить работать <I
CLASS="EMPHASIS"
>sendmail</I
> 
между внутренними машинами без DNS. Вместо настройки собственного DNS-сервера, я просто разрешил запросы с моей сети к внешнему серверу, поместив заодно его адрес в файлы <I
CLASS="EMPHASIS"
>/etc/resolv.conf</I
> на машинах моей сети
 ("<TT
CLASS="LITERAL"
>nameserver 123.456.789.31</TT
>" в отдельной строке). </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -i accept -P tcp -S 192.168.2.0/255.255.255.128 \
 -D 123.456.789.31/255.255.255.255 54 </PRE
>&#13;</P
><P
>Номер порта и протокол определенного сервиса вы можете узнать при помощи
<I
CLASS="EMPHASIS"
>tcpdump</I
>. Задействуйте этот сервис при
помощи <I
CLASS="EMPHASIS"
>ftp</I
> или <I
CLASS="EMPHASIS"
>telnet</I
> или чего-нибудь подобного с внутренней машины
или на нее, и затем проверяйте порты firewall при помощи <I
CLASS="EMPHASIS"
>tcpdump</I
>, например:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>tcpdump -i eth1 -e host client04 </PRE
>&#13;</P
><P
>В файле <I
CLASS="EMPHASIS"
>/etc/services </I
>
также есть много интересного. Чтобы разрешить <I
CLASS="EMPHASIS"
>telnet</I
> и <I
CLASS="EMPHASIS"
>ftp</I
> ВНУТРЬ сети ИЗВНЕ через firewall, вам придется разрешить локальным клиентам производить вызовы НАРУЖУ на определенных портах. С <I
CLASS="EMPHASIS"
>ftp</I
> все понятно - это сервер, организующий собственное соединение с получателем - но я не очень понимаю, зачем это необходимо для <I
CLASS="EMPHASIS"
>telnet</I
>. </P
><P
>&#13;<PRE
CLASS="SCREEN"
>ipfwadm -I -i accept -P tcp -S 192.168.2.0/255.255.255.128 ftp telnet \
 -D 0.0.0.0/0.0.0.0 </PRE
>&#13;</P
><P
>Иногда возникает проблема с некоторыми демонами, которые пытаются выяснить имя машины-firewall, чтобы узнать собственный сетевой адрес. У меня лично возникла проблема с <I
CLASS="EMPHASIS"
>Rpc.yppasswdd</I
>. Он настаивал на передаче информации наружу от firewall (через вторую карту). Это привело к тому, что клиенты изнутри его не видели. </P
><P
>Вместо запуска IP-алиасинга или правки кода демона, я просто переписал имя машины на адрес внутренней карты в клиентских файлах <I
CLASS="EMPHASIS"
>/etc/hosts</I
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN280"
>4.6. Проверка</A
></H2
><P
>Вам, наверное, надо будет проверить работу <I
CLASS="EMPHASIS"
>telnet</I
>, <I
CLASS="EMPHASIS"
>rlogin </I
>и
<I
CLASS="EMPHASIS"
>ping</I
> снаружи. Изнутри вы должны смочь
произвести <I
CLASS="EMPHASIS"
>ping</I
> наружу. Вы также должны
иметь возможность команды <I
CLASS="EMPHASIS"
>telnet</I
> на
firewall-машину изнутри сети, а на самой этой машине должно быть возможно
все.</P
><P
>Вот и все. Далее вам, наверно, стоит узнать подробнее про <I
CLASS="EMPHASIS"
>rpc</I
>/<I
CLASS="EMPHASIS"
>Y</I
>ellow <I
CLASS="EMPHASIS"
>P</I
>ages и работу с файлом паролей. Сеть с firewall
должна работать так, чтобы обычные пользователи не могли войти в firewall
(если они смогут зайти в него, они смогут выбраться наружу). Хороших вам
HOWTO!</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN292"
>5. Авторские права</A
></H1
><P
>Авторские права на русский перевод этого текста принадлежат &copy; 2000 SWSoft Pte Ltd.
Все права зарезервированы.</P
><P
>Этот документ является частью проекта Linux HOWTO.</P
><P
>Авторские права на документы Linux HOWTO принадлежат их авторам, если явно
не указано иное. Документы Linux HOWTO, а также их переводы, могут
быть воспроизведены и распространены полностью или частично на любом
носителе, физическом или электронном, при условии сохранения этой заметки об
авторских правах на всех копиях. Коммерческое распространение разрешается и
поощряется; но, так или иначе, автор текста и автор перевода желали бы знать о
таких дистрибутивах.</P
><P
>Все переводы и производные работы, выполненные по документам Linux HOWTO,
должны сопровождаться этой заметкой об авторских правах. Это делается в
целях предотвращения случаев наложения дополнительных ограничений на
распространение документов HOWTO. Исключения могут составить случаи
получения специального разрешения у координатора Linux HOWTO, с которым
можно связаться по адресу приведенному ниже.</P
><P
>Мы бы хотели распространить эту информацию по всем возможным каналам. Но
при этом сохранить авторские права и быть уведомленными о всех планах
распространения HOWTO. Если у вас возникли вопросы, пожалуйста, обратитесь
к координатору проекта Linux HOWTO по электронной почте:
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@metalab.unc.edu"
>linux-howto@metalab.unc.edu</A
>&#62;</TT
> или к координатору русского
перевода Linux HOWTO компании SWSoft Pte Ltd. по адресу
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@asplinux.ru"
>linux-howto@asplinux.ru</A
>&#62;</TT
></P
></DIV
></DIV
></BODY
></HTML
>