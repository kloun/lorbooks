<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Сетевая поддержка в Линуксе, Linux NET-3-HOWTO.: Общая информация по настройке сети.</TITLE>
 <LINK HREF="NET-3-HOWTO-6.html" REL=next>
 <LINK HREF="NET-3-HOWTO-4.html" REL=previous>
 <LINK HREF="NET-3-HOWTO.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="NET-3-HOWTO-6.html">Следующий</A>
<A HREF="NET-3-HOWTO-4.html">Предыдущий</A>
<A HREF="NET-3-HOWTO.html#toc5">Содержание</A>
<HR>
<H2><A NAME="s5">5. Общая информация по настройке сети.</A></H2>

<P>Понимание следующих подразделов необходимо для конфигурирования сети. Они
содержат информацию, необходимую Вам независимо от типа и структуры Вашей
сети.
<H2><A NAME="ss5.1">5.1 С чего начать?</A>
</H2>

<P>Для компиляции и настройки сетевой подсистемы Вам нужны несколько
вещей. Самые важные из них:
<H3>Исходный код текущего ядра.</H3>

<P>Поскольку ядро, используемое Вами сейчас, может не иметь встроенной
поддержки для тех типов сетевых карт и тех протоколов, которые Вы
захотите использовать, Вам может потребоваться перекомпилировать ядро
с соответствующими опциями.

<P>Вы всегда можете получит исходный код последних версий ядра по ftp с
<A HREF="ftp://ftp.kernel.org/pub/linux/kernel">основного сайта ftp.kernel.org</A>.
Следует отметить, однако, что этот сайт перегружен, поэтому старайтесь
получать исправления вместо файлов целиком, кроме того, рекомендуем Вам
воспользоваться "зеркалами", такими как 
<A HREF="ftp://ftp.funet.fi//mirrors/ftp.kernel.org/pub/linux/kernel">ftp.funet.fi</A>. Кроме того, свежие исходные тексты ядра обычно
есть на многих сайтах, посвященных Линуксу.
<P>Исходный код ядра обычно распаковывают в каталог <CODE>/usr/src/linux</CODE>
За информацией о том, как внести в ядро исправления и скомпилировать
его, обращайтесь к 
<A HREF="Kernel-HOWTO.html">Kernel-HOWTO</A>.
Информация о конфигурировании ядра содержится в ``Modules-mini-HOWTO''.
Еще одним полезным источником информации являются файл <CODE>README</CODE> и
каталог <CODE>Documentation</CODE>, входящие в состав исходных текстов ядра.
<P>Рекомендуем Вам пользоваться стандартным выпуском ядра (c четной второй
цифрой в номере версии), если в тексте явно не сказано обратное.
Выпуски ядра для разработчиков (с нечетной второй цифрой в номере версии)
обычно имеют серьезные структурные изменения и могут оказаться
несовместимыми с Вашими программами. Если вы не уверены в своей способности
(или желании) решить подобные проблемы, в дополнение к возможным ошибкам
в этих версиях ядра, не используйте их.
<P>С другой стороны, некоторые из описываемых возможностей были введены
в ядрах версий 2.1, поэтому у Вас есть выбор -- либо пользоваться версиями
2.0 и ждать версий 2.2 со всеми программами поддержки новых возможностей,
либо пользоваться версиями 2.1 и искать эти программы самостоятельно.
На момент написания этого абзаца (Август 1998) последней версией была
2.1.115 и появление версии 2.2 ожидалось в ближайшем будущем.
<H3>Сетевые утилиты.</H3>

<P>С помощью этих программ Вы можете конфигурировать сетевые устройства. Они,
например, позволяют Вам назначать сетевые адреса и настраивать маршрутизацию.
<P>Большинство современных дистрибутивов Линукса включают эти программы,
поэтому, если вы не установили их из вашего дистрибутива, самое время
сделать это.
<P>Если Вы устанавливали Линукс не из дистрибутива, Вам потребуется
скомпилировать эти программы из исходного кода. Это не слишком сложно.
<P>Набор сетевых утилит ведется сейчас Берндом Экенфельдсом
(Bernd Eckenfels) и может быть получен по ftp по адресу
<A HREF="ftp://ftp.inka.de/pub/comp/Linux/networking/NetTools/">ftp.inka.de</A>
или с "зеркала"
<A HREF="ftp://ftp.uk.linux.org/pub/linux/Networking/base/">ftp.uk.linux.org</A>.
<P>Убедитесь, что версия полученного Вами пакета совместима с Вашим ядром.
После этого следуйте содержащимся в пакете инструкциям по установке.
<P>Чтобы скомпилировать и установить этот пакет на момент написания этого
документа требовалось выполнить следующие команды:

<BLOCKQUOTE><CODE>
<PRE>
        user% tar xvfz net-tools-1.33.tar.gz
        user% cd net-tools-1.33
        user% make config
        user% make
        root# make install
        
</PRE>
</CODE></BLOCKQUOTE>



Если вы собираетесь установит файрволл или использовать средства
IP-маскарада Вам понадобится программа <EM>ipfwadm</EM>. Последнюю версию
этой программы Вы можете получить по ftp по адресу
<A HREF="ftp:/ftp.xos.nl/pub/linux/ipfwadm">ftp.xos.nl</A>.
Убедитесь, что полученная версия совместима в Вашим ядром. Так как работа
файрволла в версиях 2.1 изменилась, дальнейшее относится только к ядрам
версий 2.0.
<P>Для установки и настройки выполните следующие команды:

<BLOCKQUOTE><CODE>
<PRE>
        user% tar xvfz ipfwadm-2.3.0.tar.gz
        user% cd ipfwadm-2.3.0
        user% make
        root# make install
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Если Вы используете версии 2.2 или поздние версии 2.1, настройка файрволла
выполняется без программы <EM>ipfwadm</EM>. В данной версии этого документа новая
система настройки файрволла не рассматривается.
<H3>Сетевые приложения.</H3>

<P>К сетевым приложениям относятся, такие программы как <EM>telnet</EM> и
<EM>ftp</EM> и их демоны. Дистрибутивы основных программ этого типа ведутся
Дэвидом Холландом (David Holland). Пишите по адресу <CODE>netbug@ftp.uk.linux.org</CODE>.
Вы можете получить эти программы по адресу
<A HREF="ftp://ftp.uk.linux.org/pub/linux/Networking/base">ftp.uk.linux.org</A>.
<P>В марте 1997 года пакет сетевых приложений был разбит на несколько небольших
пакетов, а в мае 1997 основные программы были объединены в пакете
<CODE>netkit-base-0.10</CODE>. Вам может понадобится этот базовый пакет, и
некоторые из дополнительных.
<P>Для установки и настройки этих программ выполните следующие команды:

<BLOCKQUOTE><CODE>
<PRE>
        user% tar xvfz netkit-base-0.10
        user% cd netkit-base-0.10
        user% more README
        user% vi MCONFIG
        user% make
        root# make install
        
</PRE>
</CODE></BLOCKQUOTE>

<H3>Адреса.</H3>

<P>Адреса в протоколе IP состоят из четырех байт. Их принято записывать
в так называемой `dotted decimal notation' (десятичной нотации).
В ней каждый байт представляется десятичным числом (0-255), байты
разделены знаками '.' Каждому сетевому интерфейсу на компьютере или
маршрутизаторе присваивается IP-адрес. Возможно использование одного
адреса несколькими интерфейсами на одной машине, но как правило этого
не делают.
<P>IP-сетью называют непрерывную последовательность IP-адресов, такую, что
все адреса из последовательности имеют одинаковые старшие биты. Часть
адреса, присутствующая во всех адресах последовательности называется
сетевой частью' адреса. Оставшаяся часть называется `машинной частью'
Биты, соответствующие сетевой части называется `маской'. С помощью
маски определяют, какие адреса принадлежат сети, а какие -- нет.
В качестве примера рассмотрим следующую IP-сеть:
<BLOCKQUOTE><CODE>
<PRE>

        -----------------------  ---------------
        Адрес машины             192.168.110.23
        Маска                    255.255.255.0
        Сетевая часть            192.168.110.
        Машинная часть                      .23
        -----------------------  ---------------
        Адрес сети               192.168.110.0
        Широковещательный адрес  192.168.110.255
        -----------------------  ---------------
        
</PRE>
</CODE></BLOCKQUOTE>
<P>Применяя к адресу и маске операцию `побитовое И' получаем адрес сети.
Таким образом, адрес сети всегда является наименьшим в последовательности
и имеет нулевую машинную часть.
<P>`Широковещательный' адрес -- специальный адрес, который "слушают" все машины в
сети, кроме своего собственного. По этому адресу отправляются пакеты,
предназначенные всем машинам в сети. Таким образом передается информация о
маршрутизации или сетевые сообщения об ошибках. Есть два стандарта того, какой
адрес в сети использовать в качестве широковещательного. Наиболее
распространенный стандарт -- использовать для этого наибольший адрес в
IP-сети. В приведенном примере это <CODE>192.168.110.255</CODE>. Однако некоторые
сайты используют сетевой адрес в качестве широковещательного. На практике не
очень важно, какого стандарта придерживаться, однако всегда следует убедится,
что все машины в сети сконфигурированы на использование одного широковещательного
адреса.
<P>По административным причинам на ранних стадиях разработки протокола IP,
некоторые группы адресов были сгруппированы в сети и разбиты на классы.
Каждый класс состоит из сетей одинакового объема.

<BLOCKQUOTE><CODE>
<PRE>
  ----------------------------------------------------------
  | Сетевой |   Маска       | Сетевые Адреса               |
  |  Класс  |               |                              |
  ----------------------------------------------------------
  |    A    | 255.0.0.0     | 0.0.0.0    - 127.255.255.255 |
  |    B    | 255.255.0.0   | 128.0.0.0  - 191.255.255.255 |
  |    C    | 255.255.255.0 | 192.0.0.0  - 223.255.255.255 |
  |Multicast| 240.0.0.0     | 224.0.0.0  - 239.255.255.255 |
  ----------------------------------------------------------
  
</PRE>
</CODE></BLOCKQUOTE>

<P>Используемые Вами адреса зависят от контекста, в котором Вы их
используете. Вам может потребоваться произвести следующие действия:

<DL>
<P>
<DT><B> Установка компьютера в уже существующую сеть</B><DD><P>Если Вы собираетесь устанавливать машину с Линуксом в уже
существующую сеть, узнайте у Вашего сетевого администратора
следующие адреса:

<UL>
<LI>IP-адрес машины</LI>
<LI>IP-адрес сети</LI>
<LI>широковещательный IP-адрес</LI>
<LI>маску</LI>
<LI>IP-адрес маршрутизатора</LI>
<LI>IP-адрес сервера имен (DNS-server)</LI>
</UL>


После этого Вы должны сконфигурировать сетевое устройство на вашей
машине в на использование этих адресов.
<P>
<DT><B>Создание новой сети, которая не будет подключена к интернету.</B><DD><P>Если Вы создаете внутреннюю сеть, которую Вы не собираетесь в
будущем подключать к интернету, Вы можете выбрать любые адреса.
Однако, из соображений безопасности и единообразия, определенные
IP-адреса были специально зарезервированы для подобных целей.
Эти адреса описаны в RFC1597 следующим образом.

<BLOCKQUOTE><CODE>
<PRE>
        -----------------------------------------------------------
        |       АДРЕСА, ЗАРЕЗЕРВИРОВАННЫЕ ДЛЯ ВНУТРЕННИХ СЕТЕЙ     |
        -----------------------------------------------------------
        | Сетевой |    Маска      | Сетевые адреса                |
        |  Класс  |               |                               |
        -----------------------------------------------------------
        |    A    | 255.0.0.0     | 10.0.0.0    - 10.255.255.255  |
        |    B    | 255.255.0.0   | 172.16.0.0  - 172.31.255.255  |
        |    C    | 255.255.255.0 | 192.168.0.0 - 192.168.255.255 |
        -----------------------------------------------------------
        
</PRE>
</CODE></BLOCKQUOTE>


Все, что Вам нужно сделать -- это решить, сколько адресов Вам нужно,
и выбрать подходящий диапазон.
</DL>

<H2><A NAME="ss5.2">5.2 Где размещать команды конфигурации ?</A>
</H2>

<P>Есть несколько разных подходов к организации процесса загрузки Линукса.
После своей загрузки ядро всегда запускает программу, называющуюся `<EM>init</EM>'.
Эта программа читает файл <CODE>/etc/inittab</CODE> и выполняет процесс загрузки
системы. Есть несколько вариантов программы <EM>init</EM>, повсеместно
используется версия из System V, написанная Мигелем ван Смуренбургом
(Miguel van Smoorenburg.).
<P>В разных дистрибутивах процесс загрузки организован по-разному.
Обычно файл <CODE>/etc/inittab</CODE> содержит набор строчек типа

<BLOCKQUOTE><CODE>
<PRE>
        si::sysinit:/etc/init.d/boot
        
</PRE>
</CODE></BLOCKQUOTE>
<P>Эта строчка задает имя скрипта, который выполняет загрузку. Такой скрипт
играет роль, схожую с ролью файла <CODE>autoexec.bat</CODE> в МS-DOS.
<P>Обычно этот скрипт вызывает другие скрипты, и сеть конфигурируется в
одном из них.
<P>Следующую табличку можно использовать как руководство:
<BLOCKQUOTE><CODE>
<PRE>
-------------------------------------------------------------------------------
Дистриб. | Настройка интерфейса и маршрутизации       |Запуск демонов
-------------------------------------------------------------------------------
Debian   |/etc/init.d/network                         |/etc/init.d/netbase
         |                                            |/etc/init.d/netstd_init
         |                                            |/etc/init.d/netstd_nfs
         |                                            |/etc/init.d/netstd_misc
-------------------------------------------------------------------------------
Slackware|/etc/rc.d/rc.inet1                          |/etc/rc.d/rc.inet2
-------------------------------------------------------------------------------
RedHat   |/etc/sysconfig/network-scripts/ifup-&lt;ifname>|/etc/rc.d/init.d/network
-------------------------------------------------------------------------------
</PRE>
</CODE></BLOCKQUOTE>

<P>Обратите внимание, что дистрибутивы Debian и Red Hat содержат отдельный
каталог для скриптов для запуска системных сервисов (хотя сами файлы
настроек находятся в других местах, в дистрибутиве Red Hat они хранятся в
каталоге <CODE>/etc/sysconfig</CODE>). Для понимания процесса загрузки
ознакомьтесь с содержимым файла <EM>/etc/inittab</EM> и документацией
по процессу <EM>init</EM>. Готовится к публикации статья в Linux Journal,
как только она будет доступна на www, в этот документ будет включена
соответствующая ссылка.
<P>Большинство современных дистрибутивов включают программы для настройки
большинства типов сетевых интерфейсов. Если такая программа у вас есть,
попробуйте использовать ее, прежде чем вносить исправления вручную.

<BLOCKQUOTE><CODE>
<PRE>
       ----------------------------------------------
       Дистрибутив   | Программа конфигурирования сети
       ----------------------------------------------
       RedHat       | /sbin/netcfg
       Slackware    | /sbin/netconfig
       ----------------------------------------------
       
</PRE>
</CODE></BLOCKQUOTE>

<H2><A NAME="ss5.3">5.3 Создание сетевых интерфейсов.</A>
</H2>

<P>Во многих операционных системах из семейства Unix сетевые устройства
представлены в виде файлов в каталоге <EM>/dev</EM>
В Линуксе это не так. В Линуксе сетевые устройства создаются динамически,
и поэтому не требуют наличия соответствующих файлов в каталоге <EM>/dev</EM>
<P>В большинстве случаев сетевое устройство создается драйвером, после того
как тот проинициализируется и обнаружит сетевую карту. Например, драйвер
ethernet-карты создает интерфейсы с именами <CODE>eth[0..n]</CODE> по мере
обнаружения всех сетевых карт в Вашей машине. Первая сетевая карта
связывается с интерфейсом <CODE>eth0</CODE>, вторая -- <CODE>eth1</CODE> и т.д.
<P>Однако в некоторых случаях, в частности в случае интерфейсов <EM>slip</EM> и
<EM>ppp</EM>, интерфейсы создаются пользовательским программами. При этом
сохраняется принцип последовательной нумерации интерфейсов, однако
интерфейсы не создаются в момент загрузки. Причина этого состоит в том,
что количество работающих <EM>slip-</EM> и <EM>ppp-</EM>интерфейсов может меняться
в ходе работы машины, в отличие от количества ethernet-карт. Эти случаи
будут подробнее рассмотрены в следующих разделах.
<H2><A NAME="ss5.4">5.4 Настройка сетевого интерфейса.</A>
</H2>

<P>Итак, у Вас есть все необходимые программы, адреса и информация о сети.
Можно приступать к настройке сетевых интерфейсов. Настройка заключается
в присвоении соответствующих адресов сетевому устройству и установке
нужных значений для других параметров сетевого устройства. Наиболее
часто для этого используется программа <EM>ifconfig</EM>.
<P>Вы должны запустить ее примерно следующим образом:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up
        
</PRE>
</CODE></BLOCKQUOTE>

<P>В этом случае сетевому устройству <EM>eth0</EM> будет присвоен IP-адрес
`<CODE>192.168.0.1</CODE>' и маска `<CODE>255.255.255.0</CODE>'. Ключ `<EM>up</EM>' в конце
команды делает интерфейс активным. Это действие по умолчанию, поэтому Вы
можете опустить этот ключ. Для дезактивации интерфейса используйте команду
``<CODE>ifconfig eth0 down</CODE>''.
<P>Ядро при конфигурации интерфейса принимает некоторые значения по умолчанию.
Например, вы можете явно указать сетевой и широковещательный адрес для
интерфейса, однако если Вы этого не сделаете, как в примере выше, ядро
попытается "угадать" правильные значения на основе указанных адреса и
маски. Если Вы не укажете маску, она будет выбрана в соответствии с тем
классом адресов, в который попадет указанный адрес. В примере выше ядро
предположило бы, что машина находится в сети класса C, и установило бы
сетевой адрес в '<CODE>192.168.0.0</CODE>' а широковещательный в '<CODE>192.168.0.255</CODE>'.
<P>Программа <EM>ifconfig</EM> имеет множество опций, наиболее полезные из которых:

<DL>
<DT><B>up</B><DD><P>активирует интерфейс (это действие по умолчанию).
<DT><B>down</B><DD><P>дезактивирует интерфейс
<DT><B>[-]arp</B><DD><P>разрешает и запрещает использование протокола
преобразования адресов (arp) на данном интерфейсе.
<DT><B>[-]allmulti</B><DD><P>разрешает и запрещает прием аппаратных
пакетов с несколькими адресатами (multicast-пакетов). Такие пакеты
позволяют группе машин принимать пакеты, отправленные на специальный
адрес. Такая возможность используется в приложениях вроде
видеоконференцсвязи, но как правило не используется
<DT><B>mtu N</B><DD><P>позволяет установит MTU для интерфейса
<DT><B>netmask &lt;addr></B><DD><P>этот параметр позволяет задать маску сети,
в которой находится данный интерфейс
<DT><B>irq &lt;addr></B><DD><P>этот параметр работает только с определенными
типами сетевых карт и позволяет задать IRQ для соответствующей
интерфейсу карты
<DT><B>[-]broadcast [addr]</B><DD><P>этот параметр разрешает прием
широковещательных пакетов на заданный адрес либо запрещает прием
таких пакетов.
<DT><B>[-]pointopoint [addr]</B><DD><P>этот параметр позволяет
установить адрес машины на противоположном конце соединения
точка-точка (например <EM>slip</EM> или <EM>ppp</EM>)
<DT><B>hw &lt;type> &lt;addr></B><DD><P>этот параметр позволяет задать
аппаратный адрес некоторых типов сетевых устройств. Эта опция
редко используется в сетях ethernet, но очень полезна в сетях
других типов сетей, таких как AX.25
</DL>

<P>Вы можете использовать программу <EM>ifconfig</EM> для любого сетевого
интерфейса. Некоторые программы, такие как <EM>pppd</EM> и <EM>dip</EM>
автоматически конфигурируют сетевой интерфейс после создания и не
требуют дальнейшей ручной настройки.
<H2><A NAME="ss5.5">5.5 Настройка Системы Преобразования Имен (Name Resolver)</A>
</H2>

<P>Система преобразования имен -- часть стандартной библиотеки Линукса.
Ее основное назначение -- преобразовывать понятные пользователю имена
вроде `<CODE>ftp.funet.fi</CODE>' в понятные компьютеру IP-адреса, такие как
<CODE>128.214.248.6</CODE>.

<H3>Что такое "имя" ?</H3>

<P>Вы, по-видимому, знакомы с тем, как выглядят имена машин в интернете,
но можете не знать, как они конструируются. Система имен в интернет
является иерархической, организованной в виде дерева. <EM>Доменом</EM> называется
семейство имен. <EM>Домен</EM> может быть разбит на <EM>поддомены</EM>. Домены, которые не
являются поддоменами других доменов, называются <EM>доменами верхнего уровня</EM>.
Имена доменов верхнего уровня описаны в RFC920. В частности это следующие
домены:
<DL>
<DT><B>COM</B><DD><P>Коммерческие организации
<DT><B>EDU</B><DD><P>Учебные заведения
<DT><B>GOV</B><DD><P>Правительственные организации
<DT><B>MIL</B><DD><P>Военные организации
<DT><B>ORG</B><DD><P>Другие организации
<DT><B>NET</B><DD><P>Сетевые организации
<DT><B>Код страны</B><DD><P>Двухбуквенный код ISO, соответствующий
определенной стране
</DL>

<P>По историческим причинам большая часть доменов, не заканчивающихся
на код страны относится с США, хотя Соединенные Штаты имеют свой
код `<CODE>.us</CODE>'. В настоящее время, однако, домены <CODE>.com</CODE> and <CODE>.org</CODE>
широко используются и не-американскими организациями.
<P>Каждый из этих доменов имеет свои поддомены. Домены стран часто
разделяются на поддомены <CODE>com</CODE>, <CODE>edu</CODE>, <CODE>gov</CODE>, <CODE>mil</CODE> и <CODE>org</CODE>.
Например домены коммерческих и правительственных организаций в Австралии
заканчиваются на <CODE>com.au</CODE> и <CODE>gov.au</CODE> соответственно. Заметим, однако,
что это не всеобщая практика, в некоторых странах такого разбиения не
производится.
<P>Следующее слово в доменном имени обычно соответствует названию
организации. Дальнейшая детализация может быть разной, например
представлять структуру подразделений и отделов в организации, или
быть построенной по другому принципу, выбранному сетевым
администратором.
<P>Первое слово в имени -- уникальное (в рамках домена) `<EM>имя машины</EM>'.
Оставшаяся часть называется `<EM>именем домена</EM>', а в целом они составляют
`<EM>Полностью определенное доменное имя</EM>'.

Например в имени '<CODE>perf.no.itg.telstra.com.au</CODE>' именем машины является
`<CODE>perf</CODE>' а именем домена -- `<CODE>no.itg.telstra.com.au</CODE>'. Этот домен
принадлежит к домену страны Австралия, поддомену Австралийских коммерческих
организаций. Организация называется `<CODE>telstra</CODE>', а внутренняя структура
поддомена организации соответствует ее административной структуре -- в нашем
примере машина принадлежит отделу `Network Operations' (no) в подразделении
`Information Technology Group' (itg).
<P>Обычно имена получаются более короткими, например, интернет-провайдер
``<CODE>systemy.it</CODE>'' и организация ``<CODE>linux.it</CODE>'' без поддоменов
<CODE>com</CODE> и <CODE>org</CODE>. Машина имеет имя ``<CODE>morgana.systemy.it</CODE>'', а
e-mail адрес -- <CODE>rubini@linux.it</CODE>. Владелец домена имеет право
регистрировать и машины и поддомены в рамках своего домена, например,
группа пользователей Линукса имеет поддомен <CODE>pluto.linux.it</CODE>,
зарегистрированный у владельцев домена <CODE>linux.it</CODE>.
<H3>Что Вам нужно знать ?</H3>

<P>Вы должны знать, какому домену принадлежат Ваши машины. Программы
преобразования имен используют для работы `<EM>Сервер Преобразования Имен</EM>'
(Domain Name Server, DNS), поэтому Вы должны знать адрес этого сервера.
<P>После этого вы должны отредактировать следующие три файла:
<H3>/etc/resolv.conf</H3>

<P>Главный файл конфигурации системы преобразования имен --
<CODE>/etc/resolv.conf</CODE>. Он имеет весьма простой формат. Это текстовый файл,
каждая строка которого задает один из параметров системы преобразования имен.
Как правило, используются три ключевых слова-параметра:

<DL>
<DT><B>domain</B><DD><P>Задает имя локального домена.
<DT><B>search</B><DD><P>Задает список имен доменов, которые будут добавляться
к имени машины, если Вы не укажете явно имени домена для этой машины
<DT><B>nameserver</B><DD><P>Этот параметр, который вы можете указывать несколько
раз, задает IP-адрес сервера преобразования имен, на который ваша
машина будет посылать запросы. Повторяя этот параметр, Вы можете
задать несколько серверов.
</DL>

<P>Например, <CODE>/etc/resolv.conf</CODE> может выглядеть так:

<BLOCKQUOTE><CODE>
<PRE>
        domain maths.wu.edu.au
        search maths.wu.edu.au wu.edu.au
        nameserver 192.168.10.1
        nameserver 192.168.12.1
        
</PRE>
</CODE></BLOCKQUOTE>

<P>В этом примере машина находится в домене <CODE>maths.wu.edu.au</CODE>. Если Вы
зададите имя машины, не указывая домена, например `<CODE>boulder</CODE>', то система
преобразования имен попытается сначала найти машину
`<CODE>boulder.maths.wu.edu.au</CODE>', а в случае неудачи -- `<CODE>boulder.wu.edu.au</CODE>'.
Для преобразования имен Ваша машина будет обращаться к серверам по
адресам `<CODE>192.168.10.1</CODE>' и `<CODE>192.168.12.1</CODE>'.
<H3>/etc/host.conf</H3>

<P>В файле <CODE>/etc/host.conf</CODE> задаются параметры, влияющие на поведение
системы преобразования имен. Полностью формат этого файла описан на
man-странице `<CODE>resolv+</CODE>', но в большинстве случаев будет достаточно
такого файла:

<BLOCKQUOTE><CODE>
<PRE>
        order hosts,bind
        multi on
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Эти параметры указывают системе преобразования имен, что надо просмотреть
файл <CODE>/etc/hosts</CODE> перед тем, как посылать запрос к серверу, и что
следует возвращать все найденные в <CODE>/etc/hosts</CODE> адреса для данного
имени, а не только первый.
<H3>/etc/hosts</H3>

<P>В этом файле Вы можете указать имена и IP-адреса машин в локальном домене.
Для преобразования имен из этого файла Вашей машине не прийдется обращаться
к серверу. Недостаток такого подхода в том, что Вам надо самостоятельно
следить за всеми изменениями в структуре Вашей локальной сети и вносить
изменения в файл <CODE>/etc/hosts</CODE>, если IP-адрес какой-нибудь из машин
изменится. Как правило в этом файле указывают только 2 имени:

<BLOCKQUOTE><CODE>
<PRE>
        # /etc/hosts
        127.0.0.1      localhost loopback
        192.168.0.1    this.host.name
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Обратите внимание на первую строчку. Она демонстрирует, что Вы можете
указать более одного имени для IP-адреса. Адрес `<CODE>127.0.0.1</CODE>' всегда
используется для так называемого `<CODE>кольцевого интерфейса</CODE>'.
<H3>Настройка Сервера Преобразования Имен</H3>

<P>Вы можете запустить на своей машине локальный сервер имен. Это
несложно. Подробно этот процесс описан в 
<A HREF="DNS-HOWTO.html">DNS-HOWTO</A> или в любой документации по системе <EM>BIND</EM>
(Berkeley Internet Name Domain).
<H2><A NAME="ss5.6">5.6 Настройка кольцевого интерфейса.</A>
</H2>

<P>`<CODE>Кольцевой</CODE>' интерфейс -- специальный интерфейс, связывающий Вашу машину
саму с собой. Его можно использовать для разных целей. Например, Вы можете
захотеть протестировать какое-либо сетевое программное обеспечение, не
вмешиваясь в работу других машин в сети. Для этого интерфейса специально
зарезервирован адрес `<CODE>127.0.0.1</CODE>'. Поэтому, запустив telnet на адрес
<CODE>127.0.0.1</CODE> на любой машине, получите соединение с этой же машиной.
Настройка кольцевого интерфейса очень проста (Как правило эти действия
выполняет один из инициализационных скриптов).

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig lo 127.0.0.1
        root# route add -host 127.0.0.1 lo
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Команда <EM>route</EM> будет подробно рассмотрена в следующем разделе.
<H2><A NAME="ss5.7">5.7 Маршрутизация.</A>
</H2>

<P>Маршрутизация -- широкая тема, и о ней можно можно написать очень много.
Для большинства, однако, схема маршрутизации будет достаточно простой,
поэтому здесь будет рассмотрены только базовые вопросы, связанные с
маршрутизацией. Если Вы интересуетесь этой темой, то можете обратиться к
источникам, указанным в начале этого документа.
<P>Начнем с определения. Итак, что же такое IP-маршрутизация?
<P>
<BLOCKQUOTE>
IP-маршрутизацией называется процесс, при помощи которого машина
с несколькими сетевыми интерфейсами выбирает, через какой из
интерфейсов послать полученный IP-пакет.
</BLOCKQUOTE>

<P>Проиллюстрируем это определение на примере. Представьте себе обычный
офисный маршрутизатор, который имеет PPP-соединение с интернетом,
несколько подключенных сегментов локальной ethernet-сети и
PPP-соединение с другим офисом. Когда через один из интерфейсов на
маршрутизатор приходит IP-пакет, маршрутизатор должен решить, через
какой из интерфейсов отправлять этот пакет далее. Даже простым машинам
может потребоваться маршрутизировать пакеты, так как они имеют по меньшей
мере два интерфейса -- один кольцевой, описанный выше, и второй, через
который они подключены к реальной сети, например ethernet-интерфейс, или
интерфейс подключения по последовательным линиям PPP или SLIP.
<P>Как же происходит маршрутизация? На каждой машине хранится специальный
список правил маршрутизации, называемый таблицей маршрутизации. Любая строка
этой таблицы как правило содержит по меньшей мере три поля. Первое поле --
адрес назначения, второе -- имя интерфейса, через который следует
отправлять пакеты, и третье -- IP-адрес машины, через которую будут
передаваться пакеты. В Линуксе, Вы можете просмотреть таблицу
маршрутизации с помощью следующей команды:

<BLOCKQUOTE><CODE>
<PRE>
        user% cat /proc/net/route
        
</PRE>
</CODE></BLOCKQUOTE>

<P>или одной из команд:

<BLOCKQUOTE><CODE>
<PRE>
        user% /sbin/route -n
        user% netstat -r
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Процесс маршрутизации достаточно прост: когда машина получает IP-пакет,
его адрес назначения (адрес машины, на которую отправлен этот пакет)
сверяется с каждой строкой таблицы маршрутизации. Выбирается подходящая
строка и пакет передается через указанный в этой строке интерфейс.
Если поле адреса `машины-передатчика' заполнено, то пакет передается
на эту машину, иначе считается, что адресат пакета находится в сети, к
которой подключен данный интерфейс.
<P>Для управления таблицей маршрутизации используется программа `<EM>route</EM>'.
Эта программа преобразует свои аргументы в параметры вызова ядра,
и ядро добавляет, удаляет или изменяет строки в таблице маршрутизации.
<P>Простой пример. Представьте себе, что у вас есть ethernet-сеть. Она
организована как сеть класса C с адресом '<CODE>192.168.1.0</CODE>'. Вашей машине
был выделен адрес '<CODE>192.168.1.10</CODE>' и было сказано, что маршрутизатор,
через который Ваша сеть подключена к интернету находится по адресу
'<CODE>192.168.1.1</CODE>'.
<P>Первым делом Вы должны настроить сетевой интерфейс. Команда будет
выглядеть так:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up
        
</PRE>
</CODE></BLOCKQUOTE>

<P>После этого Вы должны добавить в таблицу маршрутизации на Вашей машине
строку, согласно которой пакеты на машины с адресами `<CODE>192.168.1.*</CODE>' ядро
должно отправлять через интерфейс eth0. Это делается с помощью следующей
команды:

<BLOCKQUOTE><CODE>
<PRE>
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Обратите внимание на использование опции `<CODE>-net</CODE>'. Эта опция указывает,
что адрес назначения в таблице маршрутизации будет адресом сети.
С помощью опции `<CODE>-host</CODE>' вы можете задать маршрут на конкретный IP-адрес.
<P>Этот маршрут позволит вам устанавливать IP-соединения со всеми машинами
в вашем локальном ethernet-сегменте. Но как быть со всеми остальными
машинами?
<P>Было бы очень сложно задавать маршруты для всех возможных IP-сетей явно,
поэтому используют следующий трюк -- <CODE>маршрут по умолчанию</CODE>. Маршрут по
умолчанию подходит для всех адресов назначения, не указанных в таблице
маршрутизации. С помощью маршрута по умолчанию Вы говорите ядру --
"а все остальное отправляй туда". В нашем примере маршрут по умолчанию
настраивается командой:

<BLOCKQUOTE><CODE>
<PRE>
        root# route add default gw 192.168.1.1 eth0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Опция `<CODE>gw</CODE>' указывает программе route что следующий аргумент --
IP-адрес или имя маршрутизатора, на который надо отправлять все пакеты,
соответствующие этой строке таблицы маршрутизации.
<P>Итак полностью настройка будет выглядеть так:

<BLOCKQUOTE><CODE>
<PRE>
        root# ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
        root# route add default gw 192.168.1.1 eth0
        
</PRE>
</CODE></BLOCKQUOTE>


<P>Если Вы внимательно просмотрите ваши `<CODE>rc</CODE>' файлы, настраивающие сеть,
Вы обнаружите, что по крайней мере один из них выглядит примерно так-же,
как и в нашем примере. Приведенная конфигурация -- одна из самых
распространенных.
<P>Рассмотрим теперь несколько более сложную конфигурацию маршрутизации в
сети. Представьте себе, что вы должны настроить маршрутизатор из
предыдущего примера. У этого маршрутизатора есть одно PPP-соединение
и три подключенных ethernet-сегмента. Настройка маршрутизации будет
выглядеть так:

<BLOCKQUOTE><CODE>
<PRE>
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
        root# route add -net 192.168.2.0 netmask 255.255.255.0 eth1
        root# route add -net 192.168.3.0 netmask 255.255.255.0 eth2
        root# route add default ppp0
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Во всей сети только маршрутизатор должен иметь в своей таблице
маршрутизации отдельные строки для каждой из подсетей. На остальных
машинах связь с другими сегментами локальной сети будет осуществляться
с помощью маршрута по умолчанию. Они будут отправлять пакеты на
маршрутизатор, о тот будет передавать их в нужный сегмент сети. Вас
может удивить, что маршрут по умолчанию на маршрутизаторе не использует
опции `<CODE>gw</CODE>'. Причина проста. Протоколы соединения по последовательным
линиям, такие как PPP и SLIP всегда имеют только две машины в сети --
(соединение точка-точка) поэтому указание адреса бессмысленно -- на том
конце соединения только одна машина. Таким образом, для подобных
соединений нет нужды указывать адрес маршрутизатора, на который надо
передавать пакеты. Для других типов сетей, таких как ethernet, arcnet
или token ring требуется указывать адрес маршрутизатора, так как эти
сети поддерживают подключение сразу многих машин к одному сегменту сети.
<H3>Что делает программа <EM>routed</EM> ?</H3>

<P>Настройка маршрутизации в приведенных примерах лучше всего подходит для
простых сетей, в которых между точками отправки и назначения существует
единственный маршрут. В более сложных сетях это не так, и маршрутизация
становится сложнее. К счастью, большинству из вас не прийдется
сталкиваться с таким сетями.
<P>Проблема со статической маршрутизацией, которую мы описали в примерах
состоит в том, что если сетевое соединение, через которое ваша машина
отправляла пакеты откажет, то единственным выходом для Вас будет
вручную изменить таблицу маршрутизации. Это медленно, непрактично и
чревато ошибками. Поэтому были разработаны методы, позволяющие
автоматически изменять таблицы маршрутизации в случае сбоев в сети.
Эти методы работают только в сетях, где между машиной-отправителем и
машиной адресатом есть несколько маршрутов. Все эти методы обычно
называют "Протоколами динамической маршрутизации".
<P>Вы возможно слышали о некоторых распространенных протоколах динамической
маршрутизации. Самые широко используемые протоколы -- RIP (Routing
Information Protocol) (Протокол информации о маршрутизации) и OSPF
(Open Shortest Path First Protocol) (Протокол кратчайшего открытого
пути). Протокол RIP используется в основном в небольших сетях, таких
как сеть небольшой или средней организации. Более современный протокол
OSPF обладает бОльшими возможностями для управления большими сетями в
которых существует много маршрутов между отправителем и адресатом.
Самые распространенные реализации этих протоколов -- программы
`<CODE>routed</CODE>' -- RIP и `<CODE>gated</CODE>' -- RIP, OSPF и другие. Программа
`<CODE>routed</CODE>' обычно включается в дистрибутивы Линукса и включена в
пакет `NetKit', упомянутый выше.
<P>Пример использования динамической маршрутизации может выглядеть примерно
так:

<BLOCKQUOTE><CODE>
<PRE>
      192.168.1.0 /                         192.168.2.0 /
         255.255.255.0                         255.255.255.0
       -                                     -
       |                                     |
       |   /-----\                 /-----\   |
       |   |     |ppp0   //    ppp0|     |   |
  eth0 |---|  A  |------//---------|  B  |---| eth0
       |   |     |     //          |     |   |
       |   \-----/                 \-----/   |
       |      \ ppp1             ppp1 /      |
       -       \                     /       -
                \                   /
                 \                 /
                  \               /
                   \             /
                    \           /
                     \         /
                      \       /
                       \     /
                    ppp0\   /ppp1
                       /-----\
                       |     |
                       |  C  |
                       |     |
                       \-----/
                          |eth0
                          |
                     |---------|
                     192.168.3.0 /
                        255.255.255.0
</PRE>
</CODE></BLOCKQUOTE>

<P>У Вас есть три маршрутизатора -- A, B и C. Каждый из них обслуживает
по одному ethernet-сегменту с IP-сетью класса C (маска 255.255.255.0).
Кроме того, каждый из них имеет PPP-соединения с двумя другими. Сеть
имеет форму треугольника.
<P>Таблица маршрутизации на маршрутизаторе A задается следующими командами:

<BLOCKQUOTE><CODE>
<PRE>
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
        root# route add -net 192.168.2.0 netmask 255.255.255.0 ppp0
        root# route add -net 192.168.3.0 netmask 255.255.255.0 ppp1
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Все будет нормально, пока не произойдет сбой на соединении между
маршрутизаторами A и B. В случае сбоя машины из сегмента A не смогут
установить соединения с машинами из сегмента В, так как маршрутизатор
A будет пытаться передать пакеты через интерфейс ppp0. В то же время
он смогут связываться с машинами из сегмента C, а машины из сегмента
C смогут связываться с машинами из сегмента В.
<P>Но раз сегмент A "видит" сегмент B, а тот, в свою очередь "видит"
сегмент C, то почему бы маршрутизатору A не передавать пакеты
для машин из сегмента B через маршрутизатор C ?  Именно это и помогает
осуществить динамическая маршрутизация. Если на каждом из маршрутизаторов
будет запущена демон динамической маршрутизации, то их таблицы
маршрутизации будут автоматически изменены, чтобы подстроиться под
изменения, произошедшие в структуре сети при сбое одного из соединений.
Для настройки динамической маршрутизации в нашем примере будет достаточно
выполнить на каждом из маршрутизаторов по две команды. Например, на
маршрутизаторе A:

<BLOCKQUOTE><CODE>
<PRE>
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
        root# /usr/sbin/routed
        
</PRE>
</CODE></BLOCKQUOTE>

<P>Демон `<CODE>routed</CODE>' при запуске автоматически найдет все активные сетевые
интерфейсы и начнет передавать и принимать специальные пакеты, с помощью
которых он будет постоянно иметь представление о текущей структуре сети,
и настраивать в соответствии с ней таблицу маршрутизации.
<P>Это очень краткое описание динамической маршрутизации и сетей, в которых
Вам следует ее использовать. Для получения более подробной информации
обратитесь к ссылкам, приведенным в начале этого документа.
<P>Резюмируя вышесказанное:

<OL>
<LI>Динамическая маршрутизация нужна лишь в тех случаях, когда на Вашей
машине есть выбор между маршрутами, по которым вы можете отправлять
пакеты.
</LI>
<LI>Демон динамической маршрутизации будет автоматически изменять таблицу
маршрутизации на Вашей машине при любых изменениях в структуре сети.
</LI>
<LI>Протокол RIP предназначен для небольших и средних сетей.</LI>
</OL>

<H2><A NAME="ss5.8">5.8 Настройка сетевых серверов и сервисов.</A>
</H2>

<P>Сетевые сервера и серверы -- это программы, позволяющие пользователям
на других машинах использовать Вашу машину. Сетевые серверы "слушают"
сетевые порты. Сетевые порты -- средство вызова нужного сервиса на
нужной машине. С их помощью машина отличает входящие telnet-соединения
от входящих ftp-соединений. Удаленный пользователь запрашивает сетевое
соединение с вашей машиной, а сервер на вашей машине, "слушающий"
запрашиваемый порт устанавливает и обслуживает соединение. Сервера
обычно работают в одном из двух режимов:

<DL>
<P>
<DT><B>самостоятельный</B><DD><P>сетевой сервер (демон) слушает один из сетевых портов, и при
запросе входящего соединения открывает и обслуживает его.
<P>
<DT><B>работающий под управлением демона <EM>inetd</EM></B><DD><P>демон <EM>inetd</EM> -- особый сетевой сервер, занимающийся
управлением входящими сетевыми соединениями. В его файле
конфигурации описано, какая программа должна быть запущена
при запросе на входящее соединение. Каждый из портов в этом
файле описывается как обслуживающий соединения по протоколу
tcp или протоколу udp, или обоим этим протоколам. Порты
описываются в другом файле, который будет вскоре рассмотрен.
</DL>

<P>Вам нужно настроить два важных файла -- <CODE>/etc/services</CODE>, в
котором числовым номерам портов присваиваются мнемонические имена и
<CODE>/etc/inetd.conf</CODE> -- конфигурационный файл для демона <EM>inetd</EM>.
<H3><CODE>/etc/services</CODE></H3>

<P>Файл <CODE>/etc/services</CODE> -- простая таблица, задающая соответствия между
числовыми номерами портов и читаемыми мнемоническими именами. Формат
этого файла очень прост. Это текстовый файл с тремя полями в каждой
строчке:

<PRE>
  имя           порт/протокол   псевдонимы      # комментарий
  
</PRE>


<DL>
<P>
<DT><B>имя</B><DD><P>слово, задающее имя сервиса.
<P>
<DT><B>порт/протокол</B><DD><P>это поле разбито на два подполя.

<DL>
<P>
<DT><B>порт</B><DD><P>число, задающее номер порта, на котором
находится данный сервис. Большинство основных сервисов имеют
зарезервированные номера портов. Эти номера описаны в
<CODE>RFC1340</CODE>.
<P>
<DT><B>протокол</B><DD><P>подполе, содержащее <CODE>tcp</CODE> или <CODE>udp</CODE>
</DL>


Очень важно понимать, что строки, содержащие поля <CODE>10/tcp</CODE>
и <CODE>10/udp</CODE> вообще говоря не связаны между собой, поэтому
сервис, привязанный к <CODE>10/tcp</CODE> совсем не обязан быть привязанным
к <CODE>10/udp</CODE>. Как правило, обе строки в таблице присутствуют
только для тех сервисов, которые реально обслуживают соединения
по обоим протоколам.
<P>
<DT><B>псевдонимы</B><DD><P>другие имена, которые можно использовать для задания данного сервиса.
</DL>

<P>Любой текст после символа `<CODE>#</CODE>' считается комментарием и игнорируется.

<H3>Пример файла <CODE>/etc/services</CODE>.</H3>

<P>Все современные дистрибутивы Линукса содержат весьма полный файл
`<CODE>/etc/services</CODE>'. На случай, если Вы устанавливаете систему не из
дистрибутива, приводим файл <CODE>/etc/services</CODE>, включенный в дистрибутив
<A HREF="http://www.debian.org/">Debian</A>.

<BLOCKQUOTE><CODE>
<PRE>

# /etc/services:
# $Id: NET-3-HOWTO-5.html,v 1.1.1.1 2001/06/15 14:14:59 maxcom Exp $
#
# Network services, Internet style
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, most entries here have two entries
# even if the protocol doesn't support UDP operations.
# Updated from RFC 1340, ``Assigned Numbers'' (July 1992).  Not all ports
# are included, only the more common ones.

tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
msp             18/tcp                          # message send protocol
msp             18/udp                          # message send protocol
chargen         19/tcp          ttytst source
chargen         19/udp          ttytst source
ftp-data        20/tcp
ftp             21/tcp
ssh             22/tcp                          # SSH Remote Login Protocol
ssh             22/udp                          # SSH Remote Login Protocol
telnet          23/tcp
# 24 - private
smtp            25/tcp          mail
# 26 - unassigned
time            37/tcp          timserver
time            37/udp          timserver
rlp             39/udp          resource        # resource location
nameserver      42/tcp          name            # IEN 116
whois           43/tcp          nicname
re-mail-ck      50/tcp                          # Remote Mail Checking Protocol
re-mail-ck      50/udp                          # Remote Mail Checking Protocol
domain          53/tcp          nameserver      # name-domain server
domain          53/udp          nameserver
mtp             57/tcp                          # deprecated
bootps          67/tcp                          # BOOTP server
bootps          67/udp
bootpc          68/tcp                          # BOOTP client
bootpc          68/udp
tftp            69/udp
gopher          70/tcp                          # Internet Gopher
gopher          70/udp
rje             77/tcp          netrjs
finger          79/tcp
www             80/tcp          http            # WorldWideWeb HTTP
www             80/udp                          # HyperText Transfer Protocol
link            87/tcp          ttylink
kerberos        88/tcp          kerberos5 krb5  # Kerberos v5
kerberos        88/udp          kerberos5 krb5  # Kerberos v5
supdup          95/tcp
# 100 - reserved
hostnames       101/tcp         hostname        # usually from sri-nic
iso-tsap        102/tcp         tsap            # part of ISODE.
csnet-ns        105/tcp         cso-ns          # also used by CSO name server
csnet-ns        105/udp         cso-ns
rtelnet         107/tcp                         # Remote Telnet
rtelnet         107/udp
pop-2           109/tcp         postoffice      # POP version 2
pop-2           109/udp
pop-3           110/tcp                         # POP version 3
pop-3           110/udp
sunrpc          111/tcp         portmapper      # RPC 4.0 portmapper TCP
sunrpc          111/udp         portmapper      # RPC 4.0 portmapper UDP
auth            113/tcp         authentication tap ident
sftp            115/tcp
uucp-path       117/tcp
nntp            119/tcp         readnews untp   # USENET News Transfer Protocol
ntp             123/tcp
ntp             123/udp                         # Network Time Protocol
netbios-ns      137/tcp                         # NETBIOS Name Service
netbios-ns      137/udp
netbios-dgm     138/tcp                         # NETBIOS Datagram Service
netbios-dgm     138/udp
netbios-ssn     139/tcp                         # NETBIOS session service
netbios-ssn     139/udp
imap2           143/tcp                         # Interim Mail Access Proto v2
imap2           143/udp
snmp            161/udp                         # Simple Net Mgmt Proto
snmp-trap       162/udp         snmptrap        # Traps for SNMP
cmip-man        163/tcp                         # ISO mgmt over IP (CMOT)
cmip-man        163/udp
cmip-agent      164/tcp
cmip-agent      164/udp
xdmcp           177/tcp                         # X Display Mgr. Control Proto
xdmcp           177/udp
nextstep        178/tcp         NeXTStep NextStep       # NeXTStep window
nextstep        178/udp         NeXTStep NextStep       # server
bgp             179/tcp                         # Border Gateway Proto.
bgp             179/udp
prospero        191/tcp                         # Cliff Neuman's Prospero
prospero        191/udp
irc             194/tcp                         # Internet Relay Chat
irc             194/udp
smux            199/tcp                         # SNMP Unix Multiplexer
smux            199/udp
at-rtmp         201/tcp                         # AppleTalk routing
at-rtmp         201/udp
at-nbp          202/tcp                         # AppleTalk name binding
at-nbp          202/udp
at-echo         204/tcp                         # AppleTalk echo
at-echo         204/udp
at-zis          206/tcp                         # AppleTalk zone information
at-zis          206/udp
z3950           210/tcp         wais            # NISO Z39.50 database
z3950           210/udp         wais
ipx             213/tcp                         # IPX
ipx             213/udp
imap3           220/tcp                         # Interactive Mail Access
imap3           220/udp                         # Protocol v3
ulistserv       372/tcp                         # UNIX Listserv
ulistserv       372/udp
#
# UNIX specific services
#
exec            512/tcp
biff            512/udp         comsat
login           513/tcp
who             513/udp         whod
shell           514/tcp         cmd             # no passwords used
syslog          514/udp
printer         515/tcp         spooler         # line printer spooler
talk            517/udp
ntalk           518/udp
route           520/udp         router routed   # RIP
timed           525/udp         timeserver
tempo           526/tcp         newdate
courier         530/tcp         rpc
conference      531/tcp         chat
netnews         532/tcp         readnews
netwall         533/udp                         # -for emergency broadcasts
uucp            540/tcp         uucpd           # uucp daemon
remotefs        556/tcp         rfs_server rfs  # Brunhoff remote filesystem
klogin          543/tcp                         # Kerberized `rlogin' (v5)
kshell          544/tcp         krcmd           # Kerberized `rsh' (v5)
kerberos-adm    749/tcp                         # Kerberos `kadmin' (v5)
#
webster         765/tcp                         # Network dictionary
webster         765/udp
#
# From ``Assigned Numbers'':
#
#> The Registered Ports are not controlled by the IANA and on most systems
#> can be used by ordinary user processes or programs executed by ordinary
#> users.
#
#> Ports are used in the TCP [45,106] to name the ends of logical
#> connections which carry long term conversations.  For the purpose of
#> providing services to unknown callers, a service contact port is
#> defined.  This list specifies the port used by the server process as its
#> contact port.  While the IANA can not control uses of these ports it
#> does register or list uses of these ports as a convienence to the
#> community.
#
ingreslock      1524/tcp
ingreslock      1524/udp
prospero-np     1525/tcp                # Prospero non-privileged
prospero-np     1525/udp
rfe             5002/tcp                # Radio Free Ethernet
rfe             5002/udp                # Actually uses UDP only
bbs             7000/tcp                # BBS service
#
#
# Kerberos (Project Athena/MIT) services
# Note that these are for Kerberos v4 and are unofficial.  Sites running
# v4 should uncomment these and comment out the v5 entries above.
#
kerberos4       750/udp         kdc     # Kerberos (server) udp
kerberos4       750/tcp         kdc     # Kerberos (server) tcp
kerberos_master 751/udp                 # Kerberos authentication
kerberos_master 751/tcp                 # Kerberos authentication
passwd_server   752/udp                 # Kerberos passwd server
krb_prop        754/tcp                 # Kerberos slave propagation
krbupdate       760/tcp         kreg    # Kerberos registration
kpasswd         761/tcp         kpwd    # Kerberos "passwd"
kpop            1109/tcp                # Pop with Kerberos
knetd           2053/tcp                # Kerberos de-multiplexor
zephyr-srv      2102/udp                # Zephyr server
zephyr-clt      2103/udp                # Zephyr serv-hm connection
zephyr-hm       2104/udp                # Zephyr hostmanager
eklogin         2105/tcp                # Kerberos encrypted rlogin
#
# Unofficial but necessary (for NetBSD) services
#
supfilesrv      871/tcp                 # SUP server
supfiledbg      1127/tcp                # SUP debugging
#
# Datagram Delivery Protocol services
#
rtmp            1/ddp                   # Routing Table Maintenance Protocol
nbp             2/ddp                   # Name Binding Protocol
echo            4/ddp                   # AppleTalk Echo Protocol
zip             6/ddp                   # Zone Information Protocol
#
# Debian GNU/Linux services
rmtcfg          1236/tcp                # Gracilis Packeten remote config server
xtel            1313/tcp                # french minitel
cfinger         2003/tcp                # GNU Finger
postgres        4321/tcp                # POSTGRES
mandelspawn     9359/udp        mandelbrot      # network mandelbrot

# Local services
</PRE>
</CODE></BLOCKQUOTE>

<P>В реальности этот файл постоянно растет по мере появления новых сервисов.
Если Вы опасаетесь, что Ваш экземпляр этого файла недостаточно полон, возьмите
его из одного из последних дистрибутивов.
<H3><CODE>/etc/inetd.conf</CODE></H3>

<P>Файл <CODE>/etc/inetd.conf</CODE> -- файл конфигурации для демона <EM>inetd</EM>.
Его назначение в том, чтобы описать, какие действия должен выполнить
<EM>inetd</EM> при получении входящего запроса. Для каждого из сервисов,
обслуживаемых демоном <EM>inetd</EM> Вы должны указать, какую программу
надо запустить для обслуживания этого соединения и как ее запускать.
<P>Формат этого файла также весьма прост. Это текстовый файл, в каждой
строке которого описывается один из сервисов. Любой текст после
символа `<CODE>#</CODE>' до конца строки считается комментарием и игнорируется.
Каждая строка содержит семь полей, разделенных произвольным
количеством пробелов или символов табуляции. Формат строки таков:

<BLOCKQUOTE><CODE>
<PRE>
  сервис тип_сокета протокол флаг имя_пользователя путь_к_серверу параметры_сервера
  
</PRE>
</CODE></BLOCKQUOTE>



<DL>
<P>
<DT><B>сервис</B><DD><P>имя сервиса из файла <CODE>/etc/services</CODE>
<P>
<DT><B>тип_сокета</B><DD><P>задает какого типа сокет следует создавать
для обслуживания соединения. Допустимыми значениями являются
<CODE>stream</CODE>, <CODE>dgram</CODE>, <CODE>raw</CODE>, <CODE>rdm</CODE>, <CODE>seqpacket</CODE>.
Не вдаваясь в технические подробности можете пользоваться
следующим правилом -- как правило соединения по  протоколу <CODE>tcp</CODE>
используют тип <CODE>stream</CODE>, а соединения по протоколу <CODE>udp</CODE> --
тип <CODE>dgram</CODE>. Только для нескольких специальных сетевых
серверов используются другие значения этого поля.
<P>
<DT><B>протокол</B><DD><P>протокол, считающийся допустимым для данного
сервиса. Это должен быть один из протоколов, описанных в файле
<CODE>/etc/services</CODE> для данного сервиса, и как правило имеет
значение <CODE>tcp</CODE> или <CODE>udp</CODE>. Серверы на базе протокола "Вызовов
удаленных процедур" (RPC, Remote Procedure Call) фирмы Sun имеют в
этом поле значения <CODE>rpc/tcp</CODE> или <CODE>rpc/udp</CODE>.
<P>
<DT><B>флаг</B><DD><P>это поле может иметь одно из двух значений --
<CODE>wait</CODE> и <CODE>nowait</CODE>. В зависимости от значения этого поля,
демон <EM>inetd</EM> будет запускать несколько экземпляров сервера,
обслуживающего данное соединение, или будет дожидаться завершения
работы сервера, предполагая, что сервер самостоятельно обслужит
все приходящие во время его работы запросы. Как правило, для
<CODE>tcp</CODE>-сервисов это поле имеет значение <CODE>nowait</CODE>, а для
<CODE>udp</CODE>-сервисов -- <CODE>wait</CODE>. Впрочем из этого правила есть
несколько важных исключений, так что будьте внимательны и
обратитесь к документации сервера, если не уверены.
<P>
<DT><B>имя_пользователя</B><DD><P>задает, с какими полномочиями будет работать запущенный сервер.
это имя из файла <CODE>/etc/passwd</CODE> используется из соображений
безопасности. Установив его в <CODE>nobody</CODE> Вы минимизируете риск и
возможный ущерб при "взломе" вашего сервера. Впрочем, многие из
важных серверов требуют привилегий пользователя "root" для того,
чтобы правильно функционировать.
<P>
<DT><B>путь_к_серверу</B><DD><P>путь для запуска программы-сервера
<P>
<DT><B>параметры_сервера</B><DD><P>это поле может быть опущено. В нем вы можете указать, какие параметры
следует передать в командной строке сервера при его запуске.
</DL>

<H3>Пример файла <CODE>/etc/inetd.conf</CODE></H3>

<P>Как и в случае с файлом <CODE>/etc/services</CODE>, большинство современных
дистрибутивов содержат достаточно полный файл <CODE>/etc/inetd.conf</CODE>
Приведем в качестве примера файл <CODE>/etc/inetd.conf</CODE> из дистрибутива
<A HREF="http://www.debian.org/">Debian</A>.

<BLOCKQUOTE><CODE>
<PRE>
# /etc/inetd.conf:  see inetd(8) for further informations.
#
# Internet server configuration database
#
#
# Modified for Debian by Peter Tobias &lt;tobias@et-inf.fho-emden.de>
#
# &lt;service_name> &lt;sock_type> &lt;proto> &lt;flags> &lt;user> &lt;server_path> &lt;args>
#
# Internal services
#
#echo           stream  tcp     nowait  root    internal
#echo           dgram   udp     wait    root    internal
discard         stream  tcp     nowait  root    internal
discard         dgram   udp     wait    root    internal
daytime         stream  tcp     nowait  root    internal
daytime         dgram   udp     wait    root    internal
#chargen        stream  tcp     nowait  root    internal
#chargen        dgram   udp     wait    root    internal
time            stream  tcp     nowait  root    internal
time            dgram   udp     wait    root    internal
#
# These are standard services.
#
telnet  stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.telnetd
ftp     stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.ftpd
#fsp    dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.fspd
#
# Shell, login, exec and talk are BSD protocols.
#
shell   stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rshd
login   stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rlogind
#exec   stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rexecd
talk    dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.talkd
ntalk   dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.ntalkd
#
# Mail, news and uucp services.
#
smtp    stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.smtpd
#nntp   stream  tcp     nowait  news    /usr/sbin/tcpd  /usr/sbin/in.nntpd
#uucp   stream  tcp     nowait  uucp    /usr/sbin/tcpd  /usr/lib/uucp/uucico
#comsat dgram   udp     wait    root    /usr/sbin/tcpd  /usr/sbin/in.comsat
#
# Pop et al
#
#pop-2  stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.pop2d
#pop-3  stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.pop3d
#
# `cfinger' is for the GNU finger server available for Debian.  (NOTE: The
# current implementation of the `finger' daemon allows it to be run as `root'.)
#
#cfinger stream tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.cfingerd
#finger stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.fingerd
#netstat        stream  tcp     nowait  nobody  /usr/sbin/tcpd  /bin/netstat
#systat stream  tcp     nowait  nobody  /usr/sbin/tcpd  /bin/ps -auwwx
#
# Tftp service is provided primarily for booting.  Most sites
# run this only on machines acting as "boot servers."
#
#tftp   dgram   udp     wait    nobody  /usr/sbin/tcpd  /usr/sbin/in.tftpd
#tftp   dgram   udp     wait    nobody  /usr/sbin/tcpd  /usr/sbin/in.tftpd /boot
#bootps dgram   udp     wait    root    /usr/sbin/bootpd        bootpd -i -t 120
#
# Kerberos authenticated services (these probably need to be corrected)
#
#klogin         stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rlogind -k
#eklogin        stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rlogind -k -x
#kshell         stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.rshd -k
#
# Services run ONLY on the Kerberos server (these probably need to be corrected)
#
#krbupdate      stream tcp      nowait  root    /usr/sbin/tcpd  /usr/sbin/registerd
#kpasswd        stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/kpasswdd
#
# RPC based services
#
#mountd/1       dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.mountd
#rstatd/1-3     dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.rstatd
#rusersd/2-3    dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.rusersd
#walld/1        dgram   rpc/udp wait    root    /usr/sbin/tcpd  /usr/sbin/rpc.rwalld
#
# End of inetd.conf.
ident           stream  tcp     nowait  nobody  /usr/sbin/identd        identd -i
</PRE>
</CODE></BLOCKQUOTE>

<H2><A NAME="ss5.9">5.9 Другие файлы, связанные с настройкой сети.</A>
</H2>

<P>Информация о настройке сети содержится еще в некотором количестве
файлов. Вам по-видимому не потребуется изменять их, но в любом случае
полезно представлять себе, как они устроены и для чего предназначены.
<H3><CODE>/etc/protocols</CODE></H3>

<P>
Файл <CODE>/etc/protocols</CODE> ставит в соответствие номера и имена протоколов.
Он позволяет программистам указывать в своих программах протоколы,
пользуясь легко запоминаемыми мнемоническими именами, а также
некоторыми программами, такими как <EM>tcpdump</EM>, для отображения
мнемонических имен протоколов. Формат этого файла таков:

<BLOCKQUOTE><CODE>
<PRE>
  имя_протокола  номер  псевдонимы
  
</PRE>
</CODE></BLOCKQUOTE>


Файл <CODE>/etc/protocols</CODE> из дистрибутива 
<A HREF="http://www.debian.org/">Debian</A>

<BLOCKQUOTE><CODE>
<PRE>
# /etc/protocols:
# $Id: NET-3-HOWTO-5.html,v 1.1.1.1 2001/06/15 14:14:59 maxcom Exp $
#
# Internet (IP) protocols
#
#       from: @(#)protocols     5.1 (Berkeley) 4/17/89
#
# Updated for NetBSD based on RFC 1340, Assigned Numbers (July 1992).

ip      0       IP              # internet protocol, pseudo protocol number
icmp    1       ICMP            # internet control message protocol
igmp    2       IGMP            # Internet Group Management
ggp     3       GGP             # gateway-gateway protocol
ipencap 4       IP-ENCAP        # IP encapsulated in IP (officially ``IP'')
st      5       ST              # ST datagram mode
tcp     6       TCP             # transmission control protocol
egp     8       EGP             # exterior gateway protocol
pup     12      PUP             # PARC universal packet protocol
udp     17      UDP             # user datagram protocol
hmp     20      HMP             # host monitoring protocol
xns-idp 22      XNS-IDP         # Xerox NS IDP
rdp     27      RDP             # "reliable datagram" protocol
iso-tp4 29      ISO-TP4         # ISO Transport Protocol class 4
xtp     36      XTP             # Xpress Tranfer Protocol
ddp     37      DDP             # Datagram Delivery Protocol
idpr-cmtp       39      IDPR-CMTP       # IDPR Control Message Transport
rspf    73      RSPF            # Radio Shortest Path First.
vmtp    81      VMTP            # Versatile Message Transport
ospf    89      OSPFIGP         # Open Shortest Path First IGP
ipip    94      IPIP            # Yet Another IP encapsulation
encap   98      ENCAP           # Yet Another IP encapsulation
</PRE>
</CODE></BLOCKQUOTE>

<H3><CODE>/etc/networks</CODE></H3>

<P>Файл <CODE>/etc/networks</CODE> имеет почти то же самое значение, что и файл
<CODE>/etc/hosts</CODE>. Он позволяет задавать имена для сетевых IP-адресов.
В отличие от <CODE>/etc/hosts</CODE>, в каждой строке этого файла задается два
поля:

<BLOCKQUOTE><CODE>
<PRE>
  имя_сети  адрес_сети
  
</PRE>
</CODE></BLOCKQUOTE>


Например:

<BLOCKQUOTE><CODE>
<PRE>
     loopnet    127.0.0.0
     localnet   192.168.0.0
     amprnet    44.0.0.0
     
</PRE>
</CODE></BLOCKQUOTE>

<P>При запуске программы <EM>route</EM>, если адрес назначения является сетевым,
Вы можете использовать имя из файла <CODE>/etc/networks</CODE> вместо IP-адреса.
<H2><A NAME="ss5.10">5.10 Безопасность и управление доступом.</A>
</H2>

<P>Хотелось бы начать этот раздел с предупреждения, что обеспечение
безопасности Вашей машины -- сложная вещь. Здесь описываются только
самые простые механизмы защиты машины в сети от несанкционированного
доступа. Если Вы желаете заняться этим вопросом более серьезно,
Вам прийдется ознакомится самостоятельно с информацией на эту тему,
доступной в интернете, в том числе 
<A HREF="Security-HOWTO.html">Security-HOWTO</A><P>Важное и простое правило обеспечения безопасности -- `<B>Не запускайте
ненужные сервера.</B>" Многие дистрибутивы устроены таким образом, что
стартуют после запуска все установленные сервера. Для обеспечения
минимального уровня безопасности просмотрите файл <CODE>/etc/inetd.conf</CODE>
и закомментарьте (поставьте символ `<CODE>#</CODE>' в начале строки) во всех
строчках с сервисами, которые Вы не собираетесь использовать. Хорошими
кандидатами для этого будут такие сервисы как <CODE>shell</CODE>, <CODE>login</CODE>, <CODE>exec</CODE>,
<CODE>uucp</CODE>, <CODE>ftp</CODE> и информационные сервисы -- <CODE>finger</CODE>, <CODE>netstat</CODE>, <CODE>systat</CODE>.
<P>Из всего многообразия механизмов обеспечения безопасности здесь
будут описаны самые простые.
<H3>/etc/ftpusers</H3>

<P>Файл <CODE>/etc/ftpusers</CODE> -- простейший механизм, позволяющий Вам запретить
некоторым пользователям получать доступ к Вашей машине по ftp.
Этот файл используется программой-сервером ftp (<EM>ftpd</EM>) при обработке
входящего соединения. Этот файл содержит список имен пользователей,
которые не имеют права работать с вашей машиной по ftp. Он может
выглядеть например так:

<BLOCKQUOTE><CODE>
<PRE>
        # /etc/ftpusers - пользователи, которым запрещен доступ по ftp
        root
        uucp
        bin
        mail
        
</PRE>
</CODE></BLOCKQUOTE>

<H3>/etc/securetty</H3>

<P>Файл <CODE>/etc/securetty</CODE> задает список устройств <CODE>tty</CODE>, с которых
в систему может входить пользователь `<CODE>root</CODE>'.  Этот файл используется
программой регистрации в системе (обычно <CODE>/bin/login</CODE>). Он содержит
список устройств, которыми можно пользоваться для работы в системе под
именем <CODE>root</CODE>, на всех остальных устройствах пользователь <CODE>root</CODE> не
сможет войти в систему.

<BLOCKQUOTE><CODE>
<PRE>
     # /etc/securetty - tty, с которых может работать пользователь root
     tty1
     tty2
     tty3
     tty4
     
</PRE>
</CODE></BLOCKQUOTE>

<H3>Механизм управления доступом с помощью программы <EM>tcpd</EM></H3>

<P>Вы уже встречали упоминание о программе <EM>tcpd</EM> в файле
<CODE>/etc/inetd.conf</CODE>. Эта программа обеспечивает протоколирование
и ограничение доступа к тем сервисам, которые она защищает. При запуске
из демона <EM>inetd</EM> она читает два файла, содержащие правила
разрешения или запрещения доступа, и действует в соответствии с этими
правилами. Эта программа будет искать файлы <CODE>/etc/hosts.allow</CODE> и
<CODE>/etc/hosts.deny</CODE>. Если оба эти файла отсутствуют, то доступ к
любому из сервисов разрешается. Структура этих файлов будет описана далее,
а за подробностями о работе программы <EM>tcpd</EM> обратитесь к
соответствующим man-страницам (советуем Вам начать со страницы
<CODE>hosts_access(5)</CODE>).
<H3>/etc/hosts.allow</H3>

<P>Файл <CODE>/etc/hosts.allow</CODE> -- один из конфигурационных файлов программы
<EM>/usr/sbin/tcpd</EM>. Этот файл содержит правила, описывающие машины, с
которых разрешен доступ к сервисам на Вашей машине.

Формат файла <CODE>/etc/hosts.allow</CODE> весьма прост:

<BLOCKQUOTE><CODE>
<PRE>
        # /etc/hosts.allow
        #
        # &lt;список_сервисов>: &lt;список_машин> [: команда]
        
</PRE>
</CODE></BLOCKQUOTE>


<DL>
<P>
<DT><B>список_сервисов</B><DD><P>список имен серверов, разделенных запятыми, к которым относится
данное правило. Например: <CODE>ftpd</CODE>, <CODE>telnetd</CODE>, <CODE>fingerd</CODE>.
<P>
<DT><B>список_машин</B><DD><P>список имен машин, разделенных запятыми. Можете вместо имен
использовать IP-адреса. Вы можете задавать группы имен. Например:
<CODE>gw.vk2ktj.ampr.org</CODE> -- описывает конкретную машину,
<CODE>.uts.edu.au</CODE> -- описывает все машины, чьи имена оканчиваются
на <CODE>.uts.edu.au</CODE>, <CODE>44.</CODE> -- описывают все машины, чьи
IP-адреса начинаются на 44.
Есть несколько специальных значений для этого поля -- например
<CODE>ALL</CODE> обозначает любую машину, <CODE>LOCAL</CODE> -- любую машину без
символов `<CODE>.</CODE>' в имени (машины из Вашего домена), <CODE>PARANOID</CODE> --
машину, чье имя не соответствует ее адресу (возможно в результате
подделки имени). Еще одно полезное значение -- <CODE>EXCEPT</CODE> --
позволяет Вам указывать исключения из списка. Все эти значения
будут проиллюстрированы на примере.
<P>
<DT><B>команда</B><DD><P>это поле можно опустить. оно задает полной путь к программе, которую
следует запустить, когда текущее правило подходит к обрабатываемому
запросу. Это может быть программа, которая будет пытаться определить,
кто пытается получить доступ, или отправит почтовое сообщение или
другое предупреждение системному администратору о том, что кто-то
пытается получить доступ. При запуске можно использовать переменные --
например переменная <CODE>%h</CODE> содержит имя (или адрес, если у машины
нет имени) машины, которая пытается получить доступ, <CODE>%d</CODE> содержит
имя запрашиваемого сервера.
</DL>

<P>Пример файла <CODE>/etc/hosts.allow</CODE>

<BLOCKQUOTE><CODE>
<PRE>
  # /etc/hosts.allow
  #
  # Разрешить всем доступ к почтовому серверу
  in.smtpd: ALL
  # Доступ по telnet и ftp - только из локального домена и с домашней машины
  telnetd, ftpd: LOCAL, myhost.athome.org.au
  # Разрешить всем доступ finger, но сообщать об этом.
  fingerd: ALL: (finger @%h | mail -s "finger from %h" root)
  
</PRE>
</CODE></BLOCKQUOTE>

<H3>/etc/hosts.deny</H3>

<P>Файл <CODE>/etc/hosts.deny</CODE> аналогичен файлу <CODE>/etc/hosts.allow</CODE> и
содержит правила, в соответствии с которыми программа <EM>tcpd</EM> отказывает
в соединении некоторым машинам.
<P>Пример файла <CODE>/etc/hosts.deny</CODE>

<BLOCKQUOTE><CODE>
<PRE>

     # /etc/hosts.deny
     #
     # Запретить доступ всем машинам с подозрительными именами
     ALL: PARANOID
     #
     # Запретить доступ всем
     ALL: ALL
  
</PRE>
</CODE></BLOCKQUOTE>

<P>Строка <CODE>ALL: PARANOID</CODE> в данном примере лишняя, так как поглощается
строкой <CODE>ALL: ALL</CODE>. Любая из этих строк вполне подойдет для конфигурации
Вашей машины по умолчанию.
<P>Самая безопасная конфигурация -- указать правило <CODE>ALL: ALL</CODE> в файле
<CODE>/etc/hosts.deny</CODE> и открыть доступ со всех нужных машин в файле
<CODE>/etc/hosts.allow</CODE>.
<H3>/etc/hosts.equiv</H3>

<P>Файл <CODE>/etc/hosts.equiv</CODE> используется для того, чтобы дать определенным
пользователям с определенных машин доступ к вашей машине без пароля.
Это может быть полезным в безопасной закрытой системе, в которой Вы
контролируете все машины, в противном случае -- это очень опасный
механизм с точки зрения безопасности. Ваша машина будет настолько же
в безопасности, насколько в безопасности наименее защищенная из машин,
перечисленных в файле <CODE>/etc/hosts.equiv</CODE>. Из соображений безопасности
не используйте этот механизм, и кроме того, советуем Вам и всем
пользователям Вашей машины отказаться от использования файла <CODE>.rhosts</CODE>
<H3>Правильная настройка демона <EM>ftp</EM>.</H3>

<P>На многих сайтах есть необходимость в запуске анонимного ftp-сервера,
который позволяет другим получать и загружать файлы без задания
имени пользователя. Если Вы планируете обеспечить такой режим доступа к
Вашей машине, убедитесь что вы правильно настроили демона <EM>ftp</EM> на
анонимный доступ. man-страницы демона <EM>ftpd</EM> описывают такую настройку.
Убедитесь, что Вы в точности следовали этим инструкциям. Важный момент,
например, состоит в том, что не следует копировать файл <CODE>/etc/passwd</CODE>
в директорию <CODE>/etc</CODE>, принадлежащую анонимному пользователю, убедитесь в
том что вы убрали из этого файла все строки, кроме необходимых, иначе
Вы подвергаете себя риску атаки с подбором пароля.
<H3>Сетевые файрволлы (брандмауэры).</H3>

<P>Отличным средством обеспечения безопасности является запрет передачи
некоторых типов пакетов с помощью файрволла, так что они не достигнут
Вашей машины. Эта тема подробно рассмотрена в 
<A HREF="http://www.linux.org.ru/books/HOWTO/Firewall-HOWTO.html">Firewall-HOWTO</A>, и (в общих чертах)
далее в этом документе.
<H3>Другие соображения.</H3>

<P>Предложим несколько других соображений (почти религиозного плана) на
Ваше рассмотрение:
<DL>
<P>
<DT><B>Программа sendmail</B><DD><P>несмотря на популярность программы <EM>sendmail</EM>, постоянно
появляются сообщения о проблемах с безопасностью этой программы.
<P>
<DT><B>Сетевая файловая система NFS и другие сервисы, основанные на протоколе
                RPC:</B><DD><P>Эти сервисы подвержены большому количеству возможных атак. Им трудно
найти замену, и если уж Вы установили их, убедитесь в правильности
назначения прав доступа.
</DL>


<HR>
<A HREF="NET-3-HOWTO-6.html">Следующий</A>
<A HREF="NET-3-HOWTO-4.html">Предыдущий</A>
<A HREF="NET-3-HOWTO.html#toc5">Содержание</A>
</BODY>
</HTML>
