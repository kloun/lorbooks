<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux 2.4 Packet Filtering HOWTO: Что такое - фильтр пакетов?</TITLE>
 <LINK HREF="packet-filtering-HOWTO-4.html" REL=next>
 <LINK HREF="packet-filtering-HOWTO-2.html" REL=previous>
 <LINK HREF="packet-filtering-HOWTO.html#toc3" REL=contents>
</HEAD>
<BODY>
<A HREF="packet-filtering-HOWTO-4.html">Next</A>
<A HREF="packet-filtering-HOWTO-2.html">Previous</A>
<A HREF="packet-filtering-HOWTO.html#toc3">Contents</A>
<HR>
<H2><A NAME="s3">3. Что такое - фильтр пакетов?</A></H2>

<P>Фильтр пакетов это программа которая просматривает 
<EM>заголовки</EM> пакетов по мере их прохождения, и решает дальнейшую судьбу
всего пакета.  Фильтр может сбросить <B>DROP</B> пакет
(т.е. как будто пакет и не приходил вовсе), принять 
<B>ACCEPT</B> пакет (т.е. пакет может пройти дальше), или
сделать с ним что-то еще более сложное.
<P>
<P>Под Linux, фильтр пакетов встроен в ядро (как модуль, или как неотъемлемая часть ядра), 
и мы можем делать с пакетами несколько хитроумных вещей, но основной принцип в
просмотре заголовков пакетов и решении их дальнейшей судьбы сохраняется.
<P>
<H2><A NAME="ss3.1">3.1 Почему я должен использовать фильтр пакетов?</A>
</H2>

<P>Управление.  Безопасность.  Бдительность.
<P>
<P>
<DL>
<DT><B>Управление:</B><DD><P>когда вы используете linux для соединения вашей внутренней
сети с другой сетью (скажем, с Интернетом) вы имеете возможность разрешать и запрещать 
отдельные типы траффика. Например, заголовок пакета содержит адрес назначения пакета, 
так что вы можете запретить пакеты идущие в определенные участки другой сети. Другой пример,
я использую Netscape для доступа к архивам Дилберта. Netscape постоянно загружает рекламу 
doubleclick.net баннеры которой находятся на страницах этих архивов, что отнимает мое время.
Запрет через фильтр пакетов на прохождение всех пакетов к doubleclick.net или обратно, решает
эту проблему (хотя есть другие более лучшие пути решения этой проблемы: ищи Junkbuster)
<P>
<DT><B>Безопасность:</B><DD><P>когда ваша linux машина, единственная преграда, между
хаосом Интернета и вашей классной и правильной сетью, было бы хорошо знать что вы можете
запретить то что ломиться к вам. Например, вы можете разрешить все что идет из вашей
сети, и позаботиться о всем известном 'Ping of Death' приходящего от злобных внешних пользователей.
Другой пример, вы не хотите чтобы внешние пользователи соединялись с вашей машиной по telnet
протоколу, даже несмотря на то что все аккаунты защищены паролями. Может быть вы хотите
(как большинство людей) быть наблюдателем в Интернете, а не сервером(желая того или нет). Просто
не позвольте никому соединяться с вашим компьютером, запретив в фильтре пакетов все входящие 
пакеты используемые при установке соединения.
<P>
<DT><B>Бдительность:</B><DD><P>временами плохо сконфигурированная машина в сети решает
извергнуть во внешний мир какие-либо пакеты. Есть отличная возможность указать фильтру пакетов 
то чтобы он давал вам знать если что-либо ненормальное случилось; возможно, вы что-то сможете сделать, 
или возможно вы просто любопытны по своей природе.
</DL>
<P>
<H2><A NAME="filter-linux"></A> <A NAME="ss3.2">3.2 Как я могу сделать фильтрование пакетов в Linux?</A>
</H2>

<P>Ядра Linux имеют способность отфильтровывать пакеты еще с 1.1 серий.
Первое поколение фильтров, основанное на ipfw от BSD, было спортированно Alan Cox 
в конце 1994г. Оно было улучшено Jos Vos и другими в Linux 2.0; пользовательская
утилита "ipfwadm" контролировала правила фильтра в ядре. В середине 1998, для 
Linux 2.2, я с помощью Michael Neuling, переработал ядро достаточно основательно, 
и представил новую утилиту для управления фильтром - "ipchains". Наконец, в середине
1999, код ядра был снова полностью преписан для 2.4 версии, появилась утилита четвертого
поколения "iptables". Это именна та утилита, которая послужила поводом для написания
этого HOWTO.
<P>
<P>Вам необходимо ядро, которое имеет netfilter-инфраструктуру:
netfilter - это основа внутри Linux ядра, в которую могут встраиваться
другие компоненты (такие как модуль iptables). Это означает что вам необходимо ядро
2.3.15 или выше, и вам необходимо ответить 'Y' на опцию CONFIG_NETFILTER при
конфигурировании ядра.
<P>
<P>Утилита <CODE>iptables</CODE> взаимодействует с ядром и указывает ему какие
пакеты фильтровать. Несмотря на то что вы программист или просто любопытный, но именно
с помощью этой программы вы будете управлять фильтром пакетов.
<P>
<H3>iptables</H3>

<P>Утилита <CODE>iptables</CODE> вставляет и удаляет правила из таблицы фильтра пакетов ядра. 
Это означает, что, чтобы вы не устанавливали или настраивали это будет потеряно при перезагрузке; смотри
<A HREF="packet-filtering-HOWTO-3.html#permanent">Делаем правила постоянными</A> для того чтобы гарантировать что правила восстановятся
после перезагрузки машины.
<P>
<P><CODE>iptables</CODE> это заменя для <CODE>ipfwadm</CODE> и
<CODE>ipchains</CODE>: смотри
<A HREF="packet-filtering-HOWTO-8.html#oldstyle">Применение ipchains и ipfwadm</A> для того чтобы избежать
использования iptables если вы используете одно из вышеуказанных.
<P>
<H3><A NAME="permanent"></A>Делаем правила постоянными</H3>

<P>Ваша текущая настройка firewall храниться в ядре, и соответственна будет потеряна
при перезагрузке системы. Написание iptables-save и iptables-restore уже естьв моем TODO списке.
Когда они будут созданы, они будут отличными инструментами - обещаю (на момент перевода эти утилиты 
уже созданы прим. перевод.).
<P>
<P>Пока, вставляйте необходимые команды нужные для настройки вашего firewall
в инициализирующий скрипт. Убедитесь, что вы создали нечно продвинутое.. такое - 
чтобы реагировало на ошибки при исполнении этого скрипта (обычно `exec /sbin/sulogin').
<P>
<HR>
<A HREF="packet-filtering-HOWTO-4.html">Next</A>
<A HREF="packet-filtering-HOWTO-2.html">Previous</A>
<A HREF="packet-filtering-HOWTO.html#toc3">Contents</A>
</BODY>
</HTML>
