<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux Kernel HOWTO: Советы и приемы</TITLE>
 <LINK HREF="Kernel-HOWTO-12.html" REL=next>
 <LINK HREF="Kernel-HOWTO-10.html" REL=previous>
 <LINK HREF="Kernel-HOWTO.html#toc11" REL=contents>
</HEAD>
<BODY>
<A HREF="Kernel-HOWTO-12.html">Следующий</A>
<A HREF="Kernel-HOWTO-10.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc11">Содержание</A>
<HR>
<H2><A NAME="s11">11. Советы и приемы</A></H2>

<H2><A NAME="ss11.1">11.1 Перенаправление вывода команд make или patch</A>
</H2>

<P>Если вы хотите протоколировать действия команд `<CODE>make</CODE>' или
`<CODE>patch</CODE>', то вы можете перенаправить вывод в файл. Сначала
определите какой интерпретатор команд вы используете выполнив команду:
`<CODE>grep root /etc/passwd</CODE>' и ищите строку, которая выглядит примерно
так `<CODE>/bin/csh</CODE>'.
<P>
<P>Если вы используете sh или bash, то команда
<P>
<PRE>
    (command) 2>&amp;1 | tee (output file)
</PRE>
<P>поместит копию вывода команды <CODE>(command)</CODE> в файл `<CODE>(output
file)</CODE>'. 
<P>
<P>Для csh или tcsh, используйте следующую последовательность
<P>
<PRE>
    (command) |&amp; tee (output file)
</PRE>
<P>
<P>Для rc (Замечание: вы скорее всего не используете rc) это выглядит так:
<P>
<PRE>
    (command) >[2=1] | tee (output file)
</PRE>
<P>
<H2><A NAME="ss11.2">11.2 Условная установка ядра</A>
</H2>

<P>Вместо использования гибкого диска существует другой метод тестирования
нового ядра без удаления старого. В отличии от многих других Unix-систем,
LILO имеет возможность загружать ядро с любого места на диске (если у вас
большой диск (500 MB или больше), то пожалуйста прочитайте документацию на
LILO о том как это может вызвать проблемы). Итак, если вы добавите что-то
похожее на следующие строки
<P>
<PRE>
    image = /usr/src/linux/arch/i386/boot/zImage
        label = new_kernel
</PRE>
<P>в конец вашего файла настроек LILO, то вы сможете выбрать запуск
свежескомпилированного ядра без удаления старого <CODE>/vmlinuz</CODE> (конечно 
после предварительного запуска <CODE>lilo</CODE>). Самый легкий способ
заставить LILO загрузить новое ядро - это нажать клавишу  shift во время
загрузки (когда на экран выводится сообщение <CODE>LILO</CODE>), это заставит
программу загрузки выдать приглашение. В этом месте вы можете ввести
название `<CODE>new_kernel</CODE>' для загрузки нового ядра.
<P>
<P>Если вы хотите хранить несколько исходных тексты разных ядер на своем
компьютере одновременно (это займет достаточно много места на диске, будьте 
осторожны) то наиболее удобный способ называть их
<CODE>/usr/src/linux-x.y.z</CODE>, где дерево исходных <CODE>x.y.z</CODE> это номер 
версии ядра. Вы можете ``выбирать'' дерево исходных текстов с помощью
символической ссылки. например, команда  `<CODE>ln -sf linux-1.2.2
/usr/src/linux</CODE>' должна сделать текущим дерево исходных текстов ядра
версии 1.2.2.  До создания символической ссылки убедитесь, что последний
аргумент команды <CODE>ln</CODE> не является настоящей директорией (старая
символическая ссылка это нормально); результат будут не такой какой вы
ожидали. 
<P>
<H2><A NAME="ss11.3">11.3 Обновления ядра</A>
</H2>

<P>Russell Nelson (<CODE>nelson@crynwr.com</CODE>) подводит итоги сделанных
изменений в новых выпусках ядер. Они являются короткими и вы можете
захотеть взглянуть на них до начала обновления ядра. Эти данные доступны
через анонимный ftp с <CODE>ftp.emlist.com</CODE> в директории
<CODE>pub/kchanges</CODE> или со следующего URL
<P>
<PRE>
    http://www.crynwr.com/kchanges
</PRE>
<P>
<HR>
<A HREF="Kernel-HOWTO-12.html">Следующий</A>
<A HREF="Kernel-HOWTO-10.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc11">Содержание</A>
</BODY>
</HTML>
