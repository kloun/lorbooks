<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>RPM HOWTO: Построение пакетов RPM</TITLE>
 <LINK HREF="RPM-HOWTO-7.html" REL=next>
 <LINK HREF="RPM-HOWTO-5.html" REL=previous>
 <LINK HREF="RPM-HOWTO.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="RPM-HOWTO-7.html">Следующий</A>
<A HREF="RPM-HOWTO-5.html">Предыдущий</A>
<A HREF="RPM-HOWTO.html#toc6">Содержание</A>
<HR>
<H2><A NAME="s6">6. Построение пакетов RPM</A></H2>

<P>Построить пакеты RPM довольно легко, особенно если вы
можете получить программное обеспечение, которые вы пытаетесь
упаковать чтобы построить для себя.
<P>Основные процедуры чтобы построить пакет RPM следующие:
<P>
<UL>
<LI>Убедитесь, что файл <CODE>/etc/rpmrc</CODE> установлен на вашей
системе. 
</LI>
<LI>Получите исходный код из которого вы хотите построить пакет
RPM на вашей системе.
</LI>
<LI>Сделайте заплатки к любым изменениям, которые вы сделали
чтобы исходный код построился правильно.
</LI>
<LI>Создайте spec-файл для пакета.
</LI>
<LI>Убедитесь, что все на нужном месте.
</LI>
<LI>Постройте пакет используя RPM.
</LI>
</UL>
<P>При нормальных условиях, RPM построит и двоичный пакет и пакет с
исходным кодом.
<P>
<H2><A NAME="ss6.1">6.1 Файл rpmrc</A>
</H2>

<P>Настройка RPM доступна через файл <CODE>/etc/rpmrc</CODE>. Пример
выглядит подобно:
<P>
<BLOCKQUOTE><CODE>
<PRE>
require_vendor: 1
distribution: I roll my own!
require_distribution: 1
topdir: /usr/src/me
vendor: Mickiesoft
packager:  Mickeysoft Packaging Account &lt;packages@mickiesoft.com>

optflags: i386 -O2 -m486 -fno-strength-reduce
optflags: alpha -O2
optflags: sparc -O2

signature: pgp
pgp_name: Mickeysoft Packaging Account
pgp_path: /home/packages/.pgp

tmppath: /usr/tmp
</PRE>
</CODE></BLOCKQUOTE>
<P>Строка <CODE>require_vendor</CODE> заставляет RPM найти строку
производителя. Она может быть из файла <CODE>/etc/rpmrc</CODE> или из
заголовка самого spec-файла. Что выключить эту опцию, смените число
на <CODE>0</CODE>. Тоже самое является правдой для строк
<CODE>require_distribution</CODE> и <CODE>require_group</CODE>.
<P>Следующая строка это строка <CODE>distribution</CODE>. Вы можете
определить ее здесь или позже в заголовке spec-файла. При
построении пакета для особого дистрибутива это хорошая идея
убедиться что строка правильна, даже хотя она требуется. 
Строка <CODE>vendor</CODE> обозначает тоже самое, но может быть чем
угодно (например, Joe's Software and Rock Music Emporium).
<P>RPM также сейчас поддержку для построения пакетов для множественных
архитектур. Файл <CODE>rpmrc</CODE> может содержать переменную ``optflags''
для построения вещей, которые требуют специфических для данной
архитектуры флагов для построения. Смотрите следующие разделы для
описания как использовать эту переменную.
<P>В добавление к вышеприведенным макросам, существует еще несколько.
Вы можете использовать:
<BLOCKQUOTE><CODE>
<PRE>
rpm --showrc
</PRE>
</CODE></BLOCKQUOTE>

чтобы увидеть какие значения установлены у вас и какие флаги
доступны. 
<P>
<H2><A NAME="ss6.2">6.2 Spec-файл</A>
</H2>

<P>Мы начнем с обсуждения spec-файла. Spec-файл требуется для
построения пакета. Spec-файл это описание программного обеспечения
вместе с инструкциями как построить пакет и списком файлов для всех
устанавливаемых файлов.
<P>
<P>Вы можете захотеть назвать ваш spec-файл согласно стандартному
соглашению. Имя должно быть следующим: имя пакета-тире-номер
версии-тире-номер выпуска (релиз)-точка-spec.
<P>
<P>Здесь приведен маленький spec-файл (vim-3.0-1.spec):
<P>
<BLOCKQUOTE><CODE>
<PRE>
Summary: ejects ejectable media and controls auto ejection
Name: eject
Version: 1.4
Release: 3
Copyright: GPL
Group: Utilities/System
Source: sunsite.unc.edu:/pub/Linux/utils/disk-management/eject-1.4.tar.gz
Patch: eject-1.4-make.patch
Patch1: eject-1.4-jaz.patch
%description
This program allows the user to eject media that is autoejecting like
CD-ROMs, Jaz and Zip drives, and floppy drives on SPARC machines.

%prep
%setup
%patch -p1
%patch1 -p1

%build
make RPM_OPT_FLAGS="$RPM_OPT_FLAGS"

%install
install -s -m 755 -o 0 -g 0 eject /usr/bin/eject
install -m 644 -o 0 -g 0 eject.1 /usr/man/man1

%files
%doc README COPYING ChangeLog

/usr/bin/eject
/usr/man/man1/eject.1
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.3">6.3 Заголовок</A>
</H2>

<P>Заголовок имеет несколько стандартных полей, которые вам
необходимо заполнить. Также существует несколько предостережений. Поля 
должны быть заполнены как показано:
<P>
<UL>
<LI><CODE>Summary:</CODE> Это однострочное описание пакета.
</LI>
<LI><CODE>Name:</CODE> Это должна быт строка имени из имени файла rpm,
котрое вы планируете использовать.
</LI>
<LI><CODE>Version:</CODE> Это должна быть строка версии из имени файла
rpm, которое вы планируете использовать.
</LI>
<LI><CODE>Release:</CODE> Это номер выпуска для пакета с той же самой
версией (например, если мы сделали пакет и обнаружили, что он
незначительно неисправный и нам необходимо сделать его заново, то
следующий пакет будет номер выпуска 2).
</LI>
<LI><CODE>Icon:</CODE> Это имя файла иконки, которое будет использоваться
другими высокоуровневыми утилитами установки (подобными ``glint''
из Red Hat). Она должна быть в формате gif и располагаться в
директории SOURCES. 
</LI>
<LI><CODE>Source:</CODE> Эта строка указывает на расположение "ДОМА"
файла исходных текстов. Она используется если вы хотите получить
исходные тексты снова и проверить новые версии. Предостережение: Имя
файла в этой строке ДОЛЖНО соответствовать имени файла который вы
имеете на своей собственной системе (например не изменяйте имя
загруженного файла исходных текстов). Вы можете также указать
больше чем один файл исходных текстов используя следующие строки: 

<BLOCKQUOTE><CODE>
<PRE>
Source0: blah-0.tar.gz
Source1: blah-1.tar.gz
Source2: fooblah.tar.gz
</PRE>
</CODE></BLOCKQUOTE>


Эти файлы должны находиться в директории <CODE>SOURCES</CODE>. (Структура
директорий обсуждается далее в разделе "Дерево директорий исходных
текстов"). 
</LI>
<LI><CODE>Patch:</CODE> Это место где вы можете найти заплатки, если вы
захотите загрузить их снова. Предостережение: Имя файла должно
соответствовать имени файла которое вы использовали когда делали
вашу заплатку. Вы можете также заметить, что вы можете иметь много
файлов заплаток также как вы можете иметь много файлов исходных
текстов. У вас должно быть что-то подобное:

<BLOCKQUOTE><CODE>
<PRE>
Patch0: blah-0.patch
Patch1: blah-1.patch
Patch2: fooblah.patch
</PRE>
</CODE></BLOCKQUOTE>


Эти файлы должны быть в директории <CODE>SOURCES</CODE>.
</LI>
<LI><CODE>Copyright:</CODE> Эта строка говорит с какими авторскими
правами идет пакет. Вы можете использовать что-то подобное GPL,
BSD, MIT, public domain, distributable, или commercial.
</LI>
<LI><CODE>BuildRoot:</CODE> Эта строка позволяет вам указать директорию
как ``корневую'' для построения и установки нового пакета. Вы
можете использовать это для тестирования вашего пакета до установки
его на вашей машине.
</LI>
<LI><CODE>Group:</CODE> Эта строка используется чтобы указать
высокоуровневым программам установки (таким как ``glint'' Red Hat)
где разместить эту отдельную программу в их иерархических
структурах. Дерево груп в настоящее время выглядит примерно так:

<BLOCKQUOTE><CODE>
<PRE>
Applications
    Communications
    Editors
        Emacs
    Engineering
    Spreadsheets
    Databases
    Graphics
    Networking
    Mail
    Math
    News
    Publishing
        TeX
Base
    Kernel
Utilities
    Archiving
    Console
    File
    System
    Terminal
    Text
Daemons
Documentation
X11
    XFree86
        Servers
    Applications
        Graphics
        Networking
    Games
        Strategy
        Video
    Amusements
    Utilities
    Libraries
    Window Managers
Libraries
Networking
    Admin
    Daemons
    News
    Utilities
Development
    Debuggers
    Libraries
        Libc
    Languages
        Fortran
        Tcl
    Building
    Version Control
    Tools
Shells
Games
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI><CODE>%description</CODE> В действительности это не часть заголовка,
но этот раздел должен быть описан вместе с остальными частями
заголовка. Вам нужен один таг описания на один пакет и/или
подпакет. Это многостроковое поле, которое должно использоваться
чтобы дать достаточно полное описание пакета.
</LI>
</UL>
<P>
<H2><A NAME="ss6.4">6.4 Раздел Prep</A>
</H2>

<P>Это второй раздел в spec-файле. Он используется чтобы сделать
исходные тексты готовыми к построению. Здесь вам необходимо сделать
все что угодно чтобы сделать исправления в исходных текстах и
сделать настройку подобную той, которую необходимо сделать чтобы
выполнить <CODE>make</CODE>.
<P>
<P>Одно замечание: Каждый из этих разделов в действительности
просто место для выполнения скриптов оболочки. Вы должны просто
сделать <CODE>sh</CODE>-скрипт и поместить его после тага <CODE>%prep</CODE>
для распаковки и исправления ваших исходных текстов. Однако мы
добавили макросы чтобы помочь вам сделать это.
<P>
<P>Первый из этих макросов это макрос <CODE>%setup</CODE>. В своей
простейшей форме (без командной строки), он просто распаковывает
исходные тексты и делает <CODE>cd</CODE> в директорию исходных текстов. Он
также принимает следующие опции:
<P>
<UL>
<LI><CODE>-n name</CODE> установит имя директории где будет производиться
построение пакета в <CODE>name</CODE>. Значение по умолчанию равно 
<CODE>$NAME-$VERSION</CODE>. Другие возможные значения
включают <CODE>$NAME</CODE>, <CODE>${NAME}${VERSION}</CODE>, 
или что использует главный файл архива. (Заметим, что эти
переменные с ``$'' <EM>не</EM> являются настоящими переменными
доступными внутри spec-файла. Они просто используются здесь вместо
имен примеров. Вам необходимо использовать настоящие имена и версии
в вашем пакете, а не эти переменные).
</LI>
<LI><CODE>-c</CODE> создаст указанную директорию <EM>до</EM> выполнения
распаковки архивов.
</LI>
<LI><CODE>-b #</CODE> будет выполнять распаковку Source# <EM>до</EM>
выполнения cd в директорию (и это делает нечувствительной к опции
<CODE>-c</CODE> так что не делайте ее). Это полезно только в случае
множества файлов исходных текстов.
</LI>
<LI><CODE>-a #</CODE> будет выполнять распаковку Source#
<EM>после</EM> перехода в директорию.
</LI>
<LI><CODE>-T</CODE> Эта опция отменяет действия по умолчанию при
распаковке исходных текстов и требует опций <CODE>-b 0</CODE> или <CODE>-a 0</CODE>
чтобы произвести разархивацию главного файла исходных текстов. Вам
нужно это в случае наличия дополнительных файлов исходных текстов.
</LI>
<LI><CODE>-D</CODE> <EM>Не</EM> удалять директорию до распаковки. Это полезно
только когда вы имеете больше одного макроса setup. Эта опция
должна использоваться <EM>только</EM> в макросах setup <EM>после</EM>
первого (но никогда не быть в первом макросе).
</LI>
</UL>
<P>
<P>Следующий из имеющихся макросов это макрос <CODE>%patch</CODE>. Этот
макрос помогает автоматизировать процесс наложения заплаток на
исходные тексты. Макрос имеет несколько опций, перечисленных ниже: 
<P>
<UL>
<LI><CODE>#</CODE> будет прикладывать Patch# как файл заплатки.
</LI>
<LI><CODE>-p #</CODE> указывает количество отбрасываемых директорий
для команды patch(1).
</LI>
<LI><CODE>-P</CODE> Действие по умолчанию&nbsp;-- наложение <CODE>Patch</CODE> (или
<CODE>Patch0</CODE>). Этот флаг запрещает действие по умолчанию и будет
требовать <CODE>0</CODE> чтобы распаковать главный файл с исходными
текстами. Эта опция полезна во второй (и последующих) макросах
<CODE>%patch</CODE>, которые требуют номера отличного от номера в
первом макросе. 
</LI>
<LI>Вы также можете выполнять <CODE>%patch#</CODE> вместо
выполнения команды: <CODE>%patch # -P</CODE>
</LI>
</UL>
<P>
<P>Это все макросы которые вам необходимы. После того как вы все
сделаете правильно, вы также можете сделать любую другую настройку,
которая необходима, используя скрипты на <CODE>sh</CODE>. Все что вы
включите до макроса <CODE>%build</CODE> (обсуждаемого в следующем
разделе) выполняется через <CODE>sh</CODE>. Посмотрите в вышеприведенном
разделе для того чтобы увидеть какие вещи вы можете сделать если
захотите. 
<P>
<H2><A NAME="ss6.5">6.5 Раздел Build</A>
</H2>

<P>Для этого раздела нет никаких макросов. Вы должны просто
поместить здесь любые команды которые вам необходимо выполнить для
построения программного обеспечения после того как вы распаковали
исходные тексты, изменили их с помощью заплаток и вошли в
директорию. Это просто другой набор команд передаваемых <CODE>sh</CODE>,
так что любые команды <CODE>sh</CODE> могут быть здесь (включая
комментарии) <B>Ваша текущая директория устанавливается в каждом
из этих разделов в корневую директорию для исходных текстов</B>, так
что помните это. Вы можете переходить в поддиректории если это
необходимо. 
<P>
<H2><A NAME="ss6.6">6.6 Раздел Install</A>
</H2>

<P>В этом разделе также нет никаких макросов. Вам просто необходимо
поместить команды необходимые для установки. Если для вашего пакета
существует команда <CODE>make install</CODE>, то просто поместите ее здесь.
Если ее нет, то вы можете сделать заплатку для makefile, чтобы
выполнялась команда <CODE>make install</CODE> и просто делать здесь
<CODE>make install</CODE>, или вы можете вручную устанавливать пакет с
помощью команд <CODE>sh</CODE>. Вы можете считать свою текущую директорию
как корневую директорию для исходных текстов пакета.
<P>
<H2><A NAME="ss6.7">6.7 Опциональные скрипты выполняемые до и после</A>
установки/удаления пакета</H2>

<P>Вы можете поместить скрипты которые запустятся до и после
инсталляции и деинсталляции двоичного пакета. Основная причина для
этого&nbsp;-- это выполнение вещей подобных запуску <CODE>ldconfig</CODE>
после установки или удаления пакета, который содержит разделяемые
библиотеки. Макросы для каждого из скриптов приведены как показано:
<P>
<UL>
<LI><CODE>%pre</CODE> макрос для выполнения предустановочного
скрипта. 
</LI>
<LI><CODE>%post</CODE> макрос для выполнения послеустановочного
скрипта. 
</LI>
<LI><CODE>%preun</CODE> макрос для выполнения скрипта перед
удалением пакета.
</LI>
<LI><CODE>%postun</CODE> макрос для скрипта выполняемого после
удаления пакета.</LI>
</UL>
<P>
<P>Содержимым разделов должны быть любые <CODE>sh</CODE> скрипты, хотя вам 
<EM>не</EM> нужно определять строку <CODE>#!/bin/sh</CODE>.
<P>
<H2><A NAME="ss6.8">6.8 Раздел Files</A>
</H2>

<P>Это раздел где вы <EM>должны</EM> перечислить файлы для двоичного
пакета. У RPM нет способа узнать какие двоичные файлы установлены
как результат выполнения <CODE>make install</CODE>. <EM>НЕ</EM> существует
способа сделать это. Некоторые предлагают выполнить команду
<CODE>find</CODE> до и после установки пакета. На многопользовательской
системе это неприемлемо так как другие файлы могут быть созданы в
течении процесса построения пакета, которые не имеют ничего общего
с самим пакетом.
<P>
<P>Есть несколько доступных макросов для выполнения специальных
действий. Они перечислены и описаны здесь:
<P>
<UL>
<LI><CODE>%doc</CODE> используется для обозначения документации в
исходных текстах пакета, которую вы хотите установить при
установке. Документы будут установлены в директорию 
<CODE>/usr/doc/$NAME-$VERSION-$RELEASE</CODE>. Вы
можете перечислить много документов в командной строке этого
макроса или вы можете перечислить все отдельно, используя этот
макрос для каждого документа.
</LI>
<LI><CODE>%config</CODE> используется для обозначения
конфигурационных файлов в пакете. Этот список включает файлы
подобные sendmail.cf, passwd, и т.п. Если вы позже удаляете пакет
содержащий конфигурационные файлы, все неизмененные файлы будут
удалены и все измененные будут переименованы со старыми названиями с
добавлением <CODE>.rpmsave</CODE> к имени файла. Вы можете перечислять
много файлов в этом макросе.
</LI>
<LI><CODE>%dir</CODE> обозначает единичную директорию в списке
файлов включенную как директория которой владеет пакет. По
умолчанию, если вы укажете имя директории <EM>БЕЗ</EM> макроса
<CODE>%dir</CODE>, то <EM>ВСЕ</EM> в этой директории будет включено в
список файлов и позже установлено как часть пакета.
</LI>
<LI><CODE>%files -f &lt;filename&gt;</CODE> позволит вам
перечислить ваши файлы в некотором файле внутри директории
построения исходных текстов. Это просто великолепно в случае когда
у вас пакет, который может построить свой собственный список
файлов. Затем вы просто включаете этот список файлов здесь и вы не
должны специально перечислять файлы.</LI>
</UL>
<P>
<P>Наибольшое предостережение в списке файлов это перечисление
директорий. Если вы случайно укажете <CODE>/usr/bin</CODE>, то ваш
двоичный пакет будет содержать <EM>все</EM> файлы в директории 
<CODE>/usr/bin</CODE> на вашей системе.
<P>
<H2><A NAME="ss6.9">6.9 Построение пакета</A>
</H2>

<H3>Дерево директорий исходных текстов</H3>

<P>Первая вещь которая вам необходима&nbsp;-- это правильно настроенное
дерево построения. Это настраивается используя файл
<CODE>/etc/rpmrc</CODE>. Большинство людей просто используют директорию
<CODE>/usr/src</CODE>. 
<P>
<P>Вам надо создать следующие директории чтобы создать дерево
построения: 
<P>
<UL>
<LI><CODE>BUILD</CODE> это директория где происходят все построения с
помощью RPM. Вы не должны проводить ваше тестовое построение где то
в особом месте, но это место где RPM будет проводить построение
пакета. 
</LI>
<LI><CODE>SOURCES</CODE> это директория где вы должны поместить ваши
оригинальные архивные файлы и ваши заплатки. Это место где RPM
будет искать их по умолчанию.
</LI>
<LI><CODE>SPECS</CODE> это директория где должны находиться все spec-файлы.
</LI>
<LI><CODE>RPMS</CODE> это место где RPM поместит все двоичные пакеты RPM
после их построения.
</LI>
<LI><CODE>SRPMS</CODE> место где будут помещены пакеты RPM с исходными текстами.</LI>
</UL>
<P>
<H3>Тестовое построение пакета</H3>

<P>Первая вещь которую вы вероятно захотите сделать&nbsp;-- это
построить исходные тексты без использования RPM. Чтобы сделать это
распакуйте исходные тексты и измените имя директории на
$NAME.orig. Затем еще раз распакуйте исходные тексты.
Используйте эти исходные тексты для построения. Перейдите в
директорию исходных текстов и следуйте инструкциям по их
построению. Если вы что-то редактировали вам необходимо сделать
заплатку. После того как вы построили исходные тексты, очистите
директорию исходных текстов. Убедитесь что вы удалили все файлы
созданные скриптом <CODE>configure</CODE>. Затем перейдите из директории
исходных текстов в директорию являющуюся для них родительской.
Затем сделайте что-то подобное:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        diff -uNr dirname.orig dirname > ../SOURCES/dirname-linux.patch
</PRE>
</CODE></BLOCKQUOTE>
<P>Это создаст для вас заплатку, которую вы сможете использовать в
вашем spec-файле. Заметим что ``linux'', который вы видите в имени
заплатки это просто идентификатор. Вы можете захотеть использовать
что-нибудь более описательное как ``config'' или ``bugs'' для
описания <EM>почему</EM> вы сделали эту заплатку. Также хорошая идея
посмотреть в файл заплатки, который вы создали, до его
использования чтобы убедиться что бинарные файлы случайно не включены.
<P>
<H3>Создание списка файлов</H3>

<P>Сейчас у вас есть исходные тексты, которые будут строиться и вы
знаете как построить и установить их. Посмотрите в вывод
установочной последовательности и постройте на его основе список
ваших файлов для использования в spec-файле. Мы обычно создаем
spec-файл параллельно со всеми описанными шагами. Вы можете сначала
создать его и заполнить самые легкие его части, а затем затем
заполнять его по мере прохождения всех этапов.
<P>
<H3>Построение пакета с помощью RPM</H3>

<P>Когда вы имеете spec-файл, вы готовы попытаться и построить ваш
пакет. Наиболее полезный способ сделать это&nbsp;-- использовать команду
похожую на следующую:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        rpm -ba foobar-1.0.spec
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Также существуют другие опции полезные с переключателем <CODE>-b</CODE>:
<P>
<UL>
<LI><CODE>p</CODE> обозначает просто запуск раздела <CODE>prep</CODE> spec-файла.
</LI>
<LI><CODE>l</CODE> это проверка списка, который делает некоторые проверки
раздела <CODE>%files</CODE>.
</LI>
<LI><CODE>c</CODE> выполняет раздел prep и компиляцию. Это полезно в
случае, когда вы не уверены будут ли ваши исходные тексты
построены. Это выглядит бесполезно, потому-что вы можете захотеть
просто самому поиграть с исходными текстами до их построения и
затем начать использовать RPM, но когда вы привыкнете использовать
RPM вы найдете случаи когда этот ключ используется.
</LI>
<LI><CODE>i</CODE> выполняет prep, компиляцию и установку.
</LI>
<LI><CODE>b</CODE> выполняет prep, компиляцию, установку, и построения
двоичного пакета.
</LI>
<LI><CODE>a</CODE> строит все (и двоичный пакет и пакет с исходными текстами).</LI>
</UL>
<P>Существует несколько модификаторов к переключателю <CODE>-b</CODE>. Это:
<P>
<UL>
<LI><CODE>--short-circuit</CODE> будет пропускать действия до указанной
стадии (может использоваться с ключами c и i).
</LI>
<LI><CODE>--clean</CODE> удаляет дерево построения когда все сделано.
</LI>
<LI><CODE>--keep-temps</CODE> будет сохранять все временные файлы и
скрипты которые созданы в /tmp. Вы можете в действительности
посмотреть какие файлы созданы в директории /tmp используя опцию
<CODE>-v</CODE>. 
</LI>
<LI><CODE>--test</CODE> не выполняет никакую реальную стадию, но делает keep-temp.</LI>
</UL>
<P>
<H2><A NAME="ss6.10">6.10 Тестирование пакета</A>
</H2>

<P>После того как вы построили двоичный пакет и пакет с исходным
кодом, вам необходимо проверить их. Самый легкий и наилучший способ
--- это использовать для тестирования использовать другою машину, а
не ту на которой вы создавали пакет. После всего вам только лишь
надо выполнить несколько команд <CODE>make install</CODE> на вашей машине,
так что все должно быть установлено.
<P>
<P>Вы можете выполнить <CODE>rpm -u packagename</CODE> для тестирования
пакета, но это может быть обманывающим потому-что в процессе
построения пакета вы делали <CODE>make install</CODE>. Если вы пропустите
что-нибудь в своем списке файлов, это не будет удалено при
инсталляции. Если вы затем будете переставлять двоичный пакет, то
все на вашей системе будет в норме, но сам пакет не будет полным.
Будьте уверенными и помните, что если вы делали <CODE>rpm -ba
package</CODE>, то большинство людей будут устанавливать ваш пакет
выполняя лишь команду <CODE>rpm -i package</CODE>.  Будьте уверены, что вы
не делаете ничего в разделах <CODE>build</CODE> или <CODE>install</CODE>, что
должно будет быть сделано при установке только двоичного пакета. 
<P>
<H2><A NAME="ss6.11">6.11 Что делать с вашим новым пакетом RPMs</A>
</H2>

<P>После того как вы сделали свой собственный пакет RPM из
чего-либо (предполагая что этого еще нет в виде RPM) вы можете
предлагать свою работу другим людям (также предполагая, что ваш
RPM свободно распространяемый). Чтобы сделать это вы можете
захотеть загрузить пакет на сервер 
<A HREF="ftp://ftp.redhat.com">ftp.redhat.com</A>.
<P>
<H2><A NAME="ss6.12">6.12 Что теперь?</A>
</H2>

<P>Пожалуйста смотрите выше разделы "Тестирование пакета" и "Что
делать с вашим новым пакетом RPM". Мы хотим сделать доступными все
пакеты RPM которые мы можем получить и хотим чтобы это были хорошо
сделанные пакеты. Пожалуйста найдите время для хорошего
тестирования пакетов и найдите время для их загрузки для общей
выгоды. Также <EM>пожалуйста</EM> будьте уверены, что вы загружаете
только <EM>свободно распространяемое программное обеспечение</EM>.
Коммерческое программное обеспечение и shareware <EM>не</EM> должны
быть загружены до тех пор пока не будут иметь авторские права,
которые определенно констатируют что это разрешено. Это включает
программное обеспечение Netscape, ssh, pgp, и т.п.
<P>
<HR>
<A HREF="RPM-HOWTO-7.html">Следующий</A>
<A HREF="RPM-HOWTO-5.html">Предыдущий</A>
<A HREF="RPM-HOWTO.html#toc6">Содержание</A>
</BODY>
</HTML>
