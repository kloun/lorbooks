<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Печать в Linux HOWTO (Linux Printing HOWTO) : Как настроить -  основы</TITLE>
 <LINK HREF="Printing-HOWTO-8.html" REL=next>
 <LINK HREF="Printing-HOWTO-6.html" REL=previous>
 <LINK HREF="Printing-HOWTO.html#toc7" REL=contents>
</HEAD>
<BODY>
<A HREF="Printing-HOWTO-8.html">Следующий</A>
<A HREF="Printing-HOWTO-6.html">Предыдущий</A>
<A HREF="Printing-HOWTO.html#toc7">Содержание</A>
<HR>
<H2><A NAME="s7">7. Как настроить -  основы</A>      </H2>

<P>Для общих конфигураций вам вероятно захочется проигнорировать
этот раздел, вместо этого вы должны перейти к разделу о Решениях
Производителей, или еще лучше к документации вашего
поставщика. Большинство дистрибутивов Linux поставляет одну или
несколько дуракоустойчивых утилит для того, чтобы делать все
описанное здесь для основных типов принтеров.
<P>
<P>Если предоставленные вам утилиты не подходят вам, или вы хотите
контролировать настройки печати, то вы должны использовать PDQ; Я
рекомендую использование PDQ в большинстве случаев.
<P>
<H2><A NAME="ss7.1">7.1 Настройка PDQ</A>
        </H2>

<P>PDQ может быть настроен либо администратором, либо обычным
пользователем. Изменения внесенные администратором делаются в файле
<EM>/etc/printrc</EM>, и применяются ко всем пользователям, в то
время как обычный пользователь может изменять только свой
персональный файл <EM>.printrc</EM>. Все описанное применяется к
обоим типам настройки.
<P>
<P>Если PDQ не доступен в вашем дистрибутиве, то вы должны взять
исходные тексты со 
<A HREF="http://feynman.tam.uiuc.edu/pdq/">страницы PDQ</A> и скомпилировать его сами. Он легко
компилируется, но вы сначала должны убедиться, что установили
разные библиотеки для разработки с применением GTK, пакет для
разработки программ на языке C, компилятор gcc, программу make, и
возможно еще несколько других пакетов для разработки.
<P>
<H3>Драйвера и интерфейсы          </H3>

<P>PDQ позволяет пользователям выбрать принтер на который будет
производится печать. Принтер в PDQ определяется как комбинация
"драйвера" и "интерфейса".  И драйвер и интерфейс являются
текстовыми описаниями в файле настройки PDQ.
<P>
<P>Интерфейс PDQ описывает то, как данные посылаются на
принтер. Наиболее общими интерфейсами, которые поставляются
вместе с дистрибутивом PDQ в качестве примера файла printrc,
являются:
<P>
<DL>
<DT><B>local-port</B><DD><P>Интерфейс локального порта работает с
параллельным или последовательным портом на той машине, на
которой запущен PDQ. Используя этот интерфейс PDQ может печать
прямо в параллельный порт. Заметьть, что если вы работаете в
многопользовательской системе, то это может вызвать
неразбериху, и если вы имеете сеть, то интерфейс local-port
будет применим только для одной системы. В этих случаях вы
можете определить очередь печати lpd без фильтра и без проблем печатать на
в эту очередь одинаковым способом со всех систем и
пользователей. Интерфейс имеет аргумент -- имя устройства;
обычным значением является /dev/lp0.
<P>
<DT><B>bsd-lpd</B><DD><P>Интерфейс bsd lpd общается по сети с демоном LPD
или с работающим по протоколу LPD сетевым принтером. PDQ
поддерживает постановку, отмену заданий и запросы к интерфейсу
LPD. Этот интерфейс имеет параметры: имя сервера и название
очереди.
<P>
<DT><B>appletalk</B><DD><P>Интерфейс appletalk позволяет вам печатать на
принтера в сети Appletalk; если у вас есть принтер подключенный 
к компьютеру Mac, то необходимо использовать этот
интерфейс. Этому интерфейсу для работы нужен пакет Netatalk.
<P>
</DL>
<P>
<P>Драйвер PDQ описывает как перевести печатаемые данные в
формат, который понимает данные принтер. Для принтеров понимающих
Postscript, он будет включать преобразования из ascii в
Postscript; для не-Postscript принтеров он будет описывать
преобразования из Postscript в язык принтер, используя
Ghostscript.
<P>
<P>Если ни одна из включенных в поставку PDQ спецификаций
драйвера не подходит к вашему принтеру, то читайте дальнейшие
разделы и пишите свой драйвер.
<P>
<H3>Определение принтеров          </H3>

<P>Для того чтобы определить принтер в PDQ:
<P>
<UL>
<LI>Сначала проверьте, что вы получили правильные определения
драйвера и интерфейса в системном или в персональном файле
printrc.
</LI>
<LI>IЕсли вы хотите определить драйвер принтера в файле
/etc/printrc (для всех пользователей), то делайте это как
администратор. 
</LI>
<LI>Запустите xpdq, и выберите пункт меню Printer-&gt;Add
printer. Этот мастер настройки проведет вас через выбор нужного 
драйвера и интерфейса.</LI>
</UL>
<P>
<P>Это все что надо сделать; большинство работы приходится на
нахождение или создание подходящей спецификации драйвера, если вы 
не можете найти уже сделанную.
<P>
<H3>Создание определения драйвера PDQ          </H3>

<P>Здесь я проведу вас по примеру создания объявления драйвера
PDQ. До того, как вы начнете этот процесс, загляните в несколько
мест, чтобы найти существующие объявления драйверов:
<P>
<UL>
<LI>С PDQ поставляется небольшая коллекция файлов с
драйверами.
</LI>
<LI>В  
<A HREF="http://www.picante.com/~gtaylor/pht/">базу данных</A>
этого документа включена программа, названная "PDQ-O-Matic",
которая сгенерирует спецификацию PDQ из информации в базе
данных. При небольших усилиях это может подойти. Это легкий
способ если у вас не-Postscript принтер.
</LI>
<LI>Я написал утилиту, которая называется <CODE>ppdtopdq</CODE>,
и которая берет файл Postscript Printer Definition (определения 
принтера Postscript) и преобразует его в спецификацию драйвера
PDQ. Это правильны способ если у вас принтер понимающий
Postscript. Напишите мне, чтобы получить копию.
</LI>
</UL>
<P>
<P>Вам необходимо заглянуть в несколько мест для того, чтобы
найти информацию необходимую для написания вашего драйвера
PDQ:
<P>
<UL>
<LI>Синтаксис спецификации драйвера PDQ достаточно богат и
полностью документирован в справочной странице 
<A HREF="http://feynman.tam.uiuc.edu/pdq/man/printrc.5.html">printrc(5)</A>.
</LI>
<LI>Дистрибутив PDQ включает несколько
файлов-примеров. Посмотрите в файл, описывающий Epson Stylus,
который демонстрирует структуру определения для принтера,
управляемого Ghostscript. 
</LI>
<LI>
<A HREF="http://www.picante.com/~gtaylor/pht/">База данных Printing HOWTO</A> включает данные примерно о
400 принтерах. Она выдаст информацию о том, какие ключи
необходимы для Ghostscript, или какие программы надо запустить
для обработки вывода Ghostscript.
</LI>
</UL>
<P>
<P>Если вы создали свой собственную спецификацию драйвера, или
или вы расширили спецификацию из дистрибутива PDQ или
сгенерированную вышеупомянутой программой, то пожалуйста
поделитесь вашим трудом со всем миром!Пошлите его мне на адрес 
(<CODE>gtaylor+pht@picante.com</CODE>), и его смогут найти будущие
пользователи PDQ, у которых принтер такого же как у вас типа.
<P>
<P>Теперь давайте пройдем сквозь этапы написания спецификации
драйвера для принтера, который в базе данных Printing HOWTO
отмечен как работающий, но для которого вы не можете найти
спецификацию драйвера PDQ. Я буду использовать принтер Canon
BJC-210 в качестве примера
<P>
<P>Давайте сначала заглянем в   
<A HREF="http://www.picante.com/~gtaylor/pht/show_printer.cgi?recnum=58752">информацию</A> об этом принтере. Заметьте, что он
поддерживается "великолепно", так что мы можем получить
результат, который сравним (или лучше) с результатами,
получаемыми пользователями Windows. Важной информацией являются
три места в полученной информации:
<P>
<DL>
<DT><B>Драйвер</B><DD><P>Последняя строка в колонке Works?/Language/Driver
сообщает нам, что есть драйвер работающий с этим
принтером. Более того, это имя является ссылкой на домашнюю
страницу с драйвером.
<P>
<DT><B>Заметки</B><DD><P>Заметки понятные для людей часто содержат полезную
информацию. Для некоторых принтеров существует ссылка "More
Info (Больше информаци)", которая обычно ссылается на страницу
пользователя, который работает с этим принтером или на странцу
драйвера данного принтера.
<P>
<DT><B>Список драйверов</B><DD><P>Большинство принтеров имеют список команд 
драйвера. Это наиболее важная часть.
<P>
</DL>
<P>
<P>Спецификация драйвера PDQ имеет две логических функции:
взаимодействие с пользователем и обработка задания. Это
представляется в файле в трех местах:
<P>
<DL>
<DT><B>Объявление ключей (опций)</B><DD><P>Этот раздел определяет какие
ключи могут быть установлены пользователем, и определяют
переменные PDQ для дальнейшего использования драйвером.
<P>
<DT><B>Языковые фильтры</B><DD><P>Этот раздел описывает процесс
преобразования заданий печати из формата в котором они пришли
(обычно это Postscript или ASCII) в формат, который понимает
принтер (например PCL). Значения ключей доступны в этом
разделе, так же как и в фильтре вывода.
<P>
<DT><B>Выходной фильтр</B><DD><P>Этот последний фильтр связывает данные
принтера независимо от типа входных данных; часто ключи
принтера устанавливаются в этом месте.
<P>
</DL>
<P>
<P>Давайте продемонстрируем все это для Canon BJC-210:
<P>
<H3>Ключи            </H3>

<P>Список драйверов для данного принтера выглядит следующим образом:
<P>
<BLOCKQUOTE><CODE>
<PRE>
Driver: Ghostscript: -sDEVICE=bj200 -r360x360   # (360x360 BW)
Driver: Ghostscript: -sDEVICE=bjc600 -r360x360  # (360x360 Color)
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Документация в базе данных сообщает нам, что тип драйвера
"Ghostscript", который является набором ключей для Ghostscript,
без "обычных" ключей, таких как <CODE>-q</CODE> или файлом,
указывающим эти ключи.
<P>
<P>BJC-210 поддерживает одну полезную опцию: пользователь
должен выбрать в каком режиме будет печатать: в цветном или
черно-белом. Давайте объявим это как опцию выбора, названную
"MODE":
<P>
<BLOCKQUOTE><CODE>
<PRE>
option {
  var = "MODE"
  desc = "Print Mode"
  # default_choice "Color"    # раскомментируйте для установки значения по умолчанию
  choice "BW" {
    # Часть value назначает переменной MODE все что вы захотите.
    # Мы будем назначать текст, который отличается для разных наборов
    # ключей Ghostscript для каждого из режимов
    value = "bj200"
    help = "Fast black printing with the black cartridge."
    desc = "Black-only"
  }
  choice "Color" {
    value = "bjc600"
    help = "Full-color printing."
    desc = "Color"
  }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>При описанном выше объявлении пользователь будет видеть
выбор только из значений Color или BW, в диалоге драйвера
принтера при печати через xpdq. В командно-строковой утилите
pdq, пользователь может указать ключи <CODE>-oBW</CODE> или
<CODE>-oColor</CODE>. Значение по умолчанию может быть установлено
с помощью xpdq, или объявлено с помощью ключевого слова
<CODE>default_choice</CODE>.
<H3>Обработка типов данных            </H3>

<P>Обычно PDQ определяет тип входных данных с помощью команды
file(1). Для каждого типа, возвращенного командой file, и
который вы хотите обрабатывать, вам необходимо определить
предложение <CODE>language_driver</CODE>. Это предложение состоит в 
основном из скрипта для обработки задания печати, на любом (!)
языке скриптов, который вы захотите использовать (языком по
умолчанию является язык Bourne shell).  
<P>
<P>В нашем случае мы хотим печатать Postscript и ASCII на нашем 
принтере BJC-210. Поэтому нам необходимо два драйвера для типов 
файлов: один для запуска Ghostscript для заданий в формате
Postscript, и один для добавления команд возврата каретки к
заданиям в ASCII: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Первый language_driver в этом файле, который соответствует результату
# выполнения  file(1) сообщает, что будет использовано
language_driver ps {
  # file(1) возвращает строку "PostScript document text conforming at..."
  filetype_regx = "postscript"
  convert_exec = { 
    gs -sDEVICE=$MODE -r360x360 \     # ключи gs из базы данных
       -q -dNOPAUSE -dBATCH -dSAFER \ # "обычные" ключи Ghostscript
       -sOutputFile=$OUTPUT $INPUT    # обработка INPUT в файл OUTPUT

    # Последние две строки часто одинаковы для всех поддерживаемых gs
    # принтеров. Однако строка gs..., будет разная для каждого из
    # принтеров. 
  }
}

# Мы объявили тип text после postscript, потому-что команда "file" часто
# описывает файл postscript как текстовый (чем он и является).
language_driver text {
  # Нет filetype_regx; мы ищем соответствие имени драйвера: "text"
  convert_exec = {#!/usr/bin/perl
     # Программа на Perl, просто потому-что мы можем писать на нем!
     my ($in, $out) = ($ENV{'INPUT'}, $ENV{'OUTPUT'});
     open INPUT, "$in";
     open OUTPUT, ">$out";
     while(&lt;INPUT>) {
        chomp;
        print OUTPUT, "$_\r\n";
     }
  }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Это все! В то время как другие принтера нуждаются в фильтрации
выходных данных (как описано в следующем разделе), вышеприведенное
предложение подходит для BJC-210. Мы просто передадим их указанному
предложению <CODE>driver</CODE>: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
driver canon-bjc210-0.1 {
  option {
    var = "MODE"
    desc = "Print Mode"
    # default_choice "Color"    # раскомментируйте для установки значения по
                                                                # умолчанию
    choice "BW" {
      # Часть value назначает переменной MODE все что вы захотите.
      # Мы будем назначать текст, который отличается для разных наборов
      # ключей Ghostscript для каждого из режимов
      value = "bj200"
      help = "Fast black printing with the black cartridge."
      desc = "Black-only"
    }
    choice "Color" {
      value = "bjc600"
      help = "Full-color printing."
      desc = "Color"
    }
  }

  # Первый language_driver в этом файле, который соответствует результату
  # выполнения  file(1) сообщает, что будет использовано
  language_driver ps {
    # file(1) возвращает строку "PostScript document text conforming at..."
    filetype_regx = "postscript"
    convert_exec = { 
      gs -sDEVICE=$MODE -r360x360 \     # gs options from the database
         -q -dNOPAUSE -dBATCH -dSAFER \ # the "usual" Ghostscript options
         -sOutputFile=$OUTPUT $INPUT    # process INPUT into file OUTPUT

      # Последние две строки часто одинаковы для всех поддерживаемых gs
      # принтеров. Однако строка gs..., будет разная для каждого из
      # принтеров. 
    }
  }

  # Мы объявили тип text после postscript, потому-что команда "file" часто
  # описывает файл postscript как текстовый (чем он и является).
  language_driver text {
    # Нет filetype_regx; мы ищем соответствие имени драйвера: "text"
    convert_exec = {#!/usr/bin/perl
       # Программа на Perl, просто потому-что мы можем писать на нем!
       my ($in, $out) = ($ENV{'INPUT'}, $ENV{'OUTPUT'});
       open INPUT, "$in";
       open OUTPUT, ">$out";
       while(&lt;INPUT>) {
          chomp;
          print OUTPUT, "$_\r\n";
       }
    }
  }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Если вы хотите добавит что-нибудь в начало или конец всех заданий 
печати, или выполнить какое-нибудь преобразование любых данных любых 
типов, то воспользуйтесь предложением <CODE>filter_exec</CODE>. Наш 
принтер Canon не нуждается в таком предложении, но просто для
примера, мы приведем простую иллюстрацию, показывающую как сделать
поддержку двухсторонней печати и выбора разрешения на принтерах 
Laserjet или других моделях, поддерживающих PJL:
<P>
<BLOCKQUOTE><CODE>
<PRE>
driver generic-ljet4-with-duplex-0.1 {
  # Сначала два предложения option для обеспечения выбора пользователя:
  option {
    var = "DUPLEX_MODE"
    desc = "Duplex Mode"
    default_choice = "SIMPLEX"
    choice "SIMPLEX" {
      value = "OFF"
      desc = "Односторонняя печать"
    }
    choice "DUPLEX" {
      value = "ON"
      desc = "Двухсторонняя печать"
    }
  }

  option { 
    var = "GS_RES"
    desc = "Resolution"
    default_choice = "DPI600"
    choice "DPI300" {
      value = "-r300x300"
      desc = "300 dpi" 
    }
    choice "DPI600" {
      value = "-r600x600"
      desc = "600 dpi" 
    }
  }

  # Теперь мы обрабатываем Postscript используя драйвер Ghostscript для ljet4:
  language_driver ps {
    filetype_regx = "postscript"
    convert_exec = { 
       gs -sDEVICE=ljet4 $GS_RES \
          -q -dNOPAUSE -dBATCH -dSAFER \
          -sOutputFile=$OUTPUT $INPUT
    }
  }

  # В заключение мы обернем задание в команды PJL:
  filter_exec {
    # требуется наличие команды echo с возможностями выдачи кода escape...
    echo -ne '\33%-12345X' > $OUTPUT

    echo "@PJL SET DUPLEX=$DUPLEX_MODE"    >> $OUTPUT
    # Вы можете вставить дополнительные команды @PJL, подобные приведенным выше.
    # Убедитесь, что вы всегда дополняете (>>) к выходному файлу!

    cat $INPUT >> $OUTPUT
    echo -ne '\33%-12345X' >> $OUTPUT
  }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss7.2">7.2 Настройка LPD</A>
      </H2>

<H3>Традиционная настройка lpd        </H3>

<P>Традиционная настройка lpd заканчивается тем, что можно
создавать очереди файлов и печатать их. Она не обращает никакого
внимания на то понимает ли принтер эти файлы или нет, и скорее
всего не позволит производить привлекательный вывод. Тем не менее,
это первый шаг к пониманию, так что читайте!
<P>
<P>Для добавления очереди печати к lpd, вы должны добавить запись в
файл <EM>/etc/printcap</EM>, и создать новую буферную директорию в
каталоге<EM>/var/spool/lpd</EM>.
<P>
<P>Запись в файле <EM>/etc/printcap</EM> выглядит примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ЛОКАЛЬНЫЙ djet500
lp|dj|deskjet:\
        :sd=/var/spool/lpd/dj:\
        :mx#0:\
        :lp=/dev/lp0:\
        :sh:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Это определяет принтер называемый <EM>lp</EM>, <EM>dj</EM>, или
<EM>deskjet</EM>, его спул размещается в директории
<EM>/var/spool/lpd/dj</EM>, без ограничения максимального размера
задания, который печатает на устройство <EM>/dev/lp0</EM>, и
который не имеет страницу с заголовком (с именем человека, который
печатает и т.п. информацией) добавленную в начало задания печати.
<P>
<P>Теперь прочитайте справочную страницу для <EM>
<A HREF="http://www.picante.com/~gtaylor/pht/man/printcap.5.html">printcap</A></EM>.  
<P>
<P>Вышеприведенный пример выглядит очень простым, но он имеет
ловушку&nbsp;-- хотя я посылаю файлы, которые DeskJet 500 может
понимать, этот DeskJet будет печатать странные вещи. Например посыл 
обычного текстового файла Unix приведет к тому, что deskjet будет
интерпретировать символы новой строки как символы, и выдаст мне: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
This is line one.
                 This is line two.
                                  This is line three.
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Печать файла PostScript на этот принтер выдаст великолепный
листинг команд PostScript, напечатанных с этим "лестничным
эффектом", а не полезный вывод. 
<P>
<P>Очевидно требуется что-то сделать, и это является назначением
фильтрации. Более наблюдательные из тех кто читал справочную
страницу printcap должны были заметить атрибуты принтера <EM>if</EM> и
<EM>of</EM>.  Хорошо, <EM>if</EM>, или входной фильтр&nbsp;-- это все что
нам нужно здесь.
<P>
<P>Если мы напишем маленький скрипт, названный <EM>filter</EM>, который 
добавляет возврат каретки до символа новой строки, то лестничный
эффект будет ликвидирован. Так что мы добавим строку <EM>if</EM> в
нашу, вышеприведенную запись в printcap: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
lp|dj|deskjet:\
        :sd=/var/spool/lpd/dj:\
        :mx#0:\
        :lp=/dev/lp0:\
        :if=/var/spool/lpd/dj/filter:\
        :sh:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Простой скрипт может выглядеть так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!perl
# Предыдущая строка должна содержать полный путь к perl
# Скрипт должен быть исполнимым: chmod 755 filter
while(&lt;STDIN>){chop $_; print "$_\r\n";};
# Вы можете также добавить в конец прогон страницы: print "\f";
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Если мы сделаем как приведено выше, мы будем иметь принтер на
котором мы сможем печатать обычные текстовые файлы Unix и получать
осмысленные результаты. (Конечно мы можем написать этот фильтр
четырьмя миллионами лучших способов, но этот более
иллюстративный. Вы можете попытаться сделать это более
эффективно). 
<P>
<P>Оставшаяся проблема в том что печать простого текста не является 
злободневной&nbsp;-- наверняка будет лучше если мы сможем печатать 
PostScript и другие типы форматированого и графического вывода. Да 
и это легко сделать. Метод является просто расширением
вышеприведенного фильтра для исправления перевода строки. Если вы
напишите фильтр, который может воспринимать произвольные типы
файлов как ввод и производить вывод для DeskJet для каждого случая, 
тогда мы безусловно получим "умный" спулер принтера. 
<P>
<P>Такой фильтр называется <EM>magic</EM>-фильтр. Не беспокойте себя
написанием фильтра, до тех пора пока они не будут печатать странные 
вещи&nbsp;-- в сети уже существует много хорошо написанных
фильтров. APS Filter это лучший среди всех, или ваш дистрибутив
Linux может иметь утилиту настройки принтера, которая сделает всю
настройку очень простой.
<P>
<P>Есть правда ловушка для таких фильтров: некоторые старые версии
lpd не  запускают фильтр <EM>if</EM> для удаленных принтеров, а
некоторые запускают. Версии lpd используемые в современных
дистрибутивах Linux и FreeBSD запускают указанный фильтр;
большинство коммерческих юниксов до сих пор поставляются с lpd,
которые не запускают фильтр для удаленных принтеров. Смотрите
раздел о сетевой печати для более детальной информации.
<P>
<H3>Учет ресурсов          </H3>

<P>Для некоторых систем необходимо хранить информацию о том, кто
и как много печатал; этот раздел описывает разные методы
выполнения данной работы.
<P>
<P>Обычный LPD предоставляет очень небольшую помощь в выполнение
учета ресурсов. Вы можете указать имя файла для учета ресурсов
используя атрибут af= в printcap, но только передается как
параметр вашему фильтру, указанному в if=. Возможно сделать так,
что ваш if= фильтр будет писать данные в файл учета ресурсов, и
вы будете обрабатывать этот файл позже (традиционный формат в
основном полезен для строчных принтеров, и нетривиален для
разбора с помощью Perl, так что нет причин сохранять его).
<P>
<P>Ghostscript предоставляет оператор PageCount, который вы
можете использовать для подсчета страниц в каждом из заданий;
обычно вам необходимо добавить несколько строк на postscript в
конец задания для того, чтобы дописать запись в файл учета;
лучшим примером этого является файл unix-lpr.sh в поставке
исходного кода Ghostscript.
<P>
<P>Заметьте, что реализация учета ресурсов использованная в
unix-lpr пишет в файл из Ghostscript и таким образом несовместима 
с рекомендованным ключом -dSAFER. Лучшим решением мог бы быть
опрос принтера с помощью команды PJL после каждого из заданий,
или написать программу на postscript, которая будет выдавать
число страниц на стандартный вывод, где данные могут быть
захвачены другой программой.
<P>
<P>Система буферизации LPRng включает простую реализацию учета
ресурсов для HP; я думаю, что она опрашивает принтер используя PJL.
<P>
<H3>Большие системы          </H3>

<P>Большие системы, под которыми я подразумеваю сети, включающие
более двух принтеров или серверов, имеют специальные
требования. Вот описание одной из возможных спецификаций.
<P>
<UL>
<LI>Каждый принтер должен иметь одну точку контроля, откуда
администратор может приостановить, переупорядочить или
переназначить задания в очереди. Для реализации этого каждый
должен печатать на локальный сервер, который будет выполнять
буферизацию заданий и направлять их на соответствующий принтер.
</LI>
<LI>Используйте LPRng, по крайней мере на серверах; BSD LPD
является имеет слишком много недостатков для "нормального"
использования. 
</LI>
<LI>Клиентские системы не должны иметь уникальные настройки
печати. Для реализации этого используйте расширенный синтаксис
printcap в LPRng, так что вы сможете везде использовать один и
тот же файл printcap.
</LI>
<LI>Очереди печати не должны называться по названию
производителя или модели; очереди печати лучше именовать лучше
по расположению (floor2_nw) или по возможностям
(color_transparency). Три года спустя, если сломается принтер,
то вы сможете сменить его другой моделью без введения в
заблуждение. 
</LI>
<LI>Разработайте страницу web, которая показывает детальную
информацию о каждом из принтеров, включая расположение,
возможности и т.п. Рассмотрите возможность показа
очереди. Сложные сетевые среды неуправляемы без соответствующей
документации. 
</LI>
<LI>На машинах с Unix, используйте PDQ для того, чтобы
предоставить выбор параметров печати, таких как двухстороннюю
печать или размер бумаги, и заставить пользователей запускать
все задания Ghostscript под правильным идентификатором
пользователя.
</LI>
<LI>На машинах с  Windows и Apple, либо используйте <B>везде</B>
поставляемые драйвера (Samba поддерживает механизм
автоматической загрузки драйверов) или <B>везде</B>
используйте драйвера Postscript. Не смешивайте разные
драйвера; примитивные текстовые процессора часто производят
разный код при изменении драйвера принтера; пользователи не
могут связать изменения в виде с отдельной парой
клиент/принтер.
</LI>
<LI>Если возможно, то покупайте принтер с большими ресурсами для 
печати в больших объемах. Если возможно по бюджету, то используйте
свойство LPRng печати на много принтеров через одну очередь и
назначьте "приходящую няню"; принтера являются сложными механическими 
устройствами, которые будет часто зажимать бумагу или работать без нее
в таких конфигурациях.
</LI>
<LI>Не переживайте, что принтера должны быть подключены к рабочим
станциям; сейчас Ethernet "сервера печати" стоят в районе $100.
Возможность размещать принтера где есть сеть является большим
удобством по сравнению с расположением принтеров около машин; 
располагайте принтера в разумных, центральных точках.</LI>
</UL>
<P>
<P>
<H3>Права доступа на файлы        </H3>

<P>По популярному требованию, я включил ниже список прав доступа на 
интересующие нас файлы на моей системе. Существует несколько более
лучших способов сделать это, в идеале использовать только
выполнимые файлы со SGID и не делать все подряд SUID root, но это
как пришло в моей системе, и это работает для меня. (Довольно
откровенно, если ваш производитель даже не может сделать работающий 
lpd, то вы в опасной поездке).
<P>
<BLOCKQUOTE><CODE>
<PRE>
-r-sr-sr-x   1 root     lp    /usr/bin/lpr*
-r-sr-sr-x   1 root     lp    /usr/bin/lprm*
-rwxr--r--   1 root     root  /usr/sbin/lpd*
-r-xr-sr-x   1 root     lp    /usr/sbin/lpc*
drwxrwxr-x   4 root     lp    /var/spool/lpd/
drwxr-xr-x   2 root     lp    /var/spool/lpd/lp/
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>В настоящее время lpd должен быть запущен под правами
администратора, так что он может быть связан с сервисным портом
lp с низким номером. Он должен вероятно быть с UID lp.lp или
каким-то после связывания, но я не знаю с каким.
<P>
<P>PDQ  использует отличную от других схему, не ориентированную на 
демонов, и поэтому у него другие программы. Только несколько программ 
имеют установленный бит SUID и владельца администратора, эта программы 
являются интерфейсом к lpd и называются <CODE>lpd_cancel</CODE>, 
<CODE>lpd_print</CODE> и <CODE>lpd_status</CODE>; эти программы имеют SUID,
потому-что сервера печати Unix требуют отправки запросов с
привилегированного порта. Если вам необходимо применять интерфейс
bsd-lpd из поставки PDQ только для сетевых принтеров печати таких
как адаптеры HP JetDirect или  Lexmark MarkNet), то вам не нужно 
устанавливать бит suid на эти программы. 
<P>
<P>
<HR>
<A HREF="Printing-HOWTO-8.html">Следующий</A>
<A HREF="Printing-HOWTO-6.html">Предыдущий</A>
<A HREF="Printing-HOWTO.html#toc7">Содержание</A>
</BODY>
</HTML>
