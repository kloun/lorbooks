<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux IPCHAINS-HOWTO: Основы фильтрации пакетов</TITLE>
 <LINK HREF="Ipchains-HOWTO-3.html" REL=next>
 <LINK HREF="Ipchains-HOWTO-1.html" REL=previous>
 <LINK HREF="Ipchains-HOWTO.html#toc2" REL=contents>
</HEAD>
<BODY>
<A HREF="Ipchains-HOWTO-3.html">Next</A>
<A HREF="Ipchains-HOWTO-1.html">Previous</A>
<A HREF="Ipchains-HOWTO.html#toc2">Contents</A>
<HR>
<H2><A NAME="s2">2. Основы фильтрации пакетов</A></H2>

<H2><A NAME="ss2.1">2.1 Что?</A>
</H2>

<P>Весь трафик в сети производится в виде пакетов. Например, при скачивании этого 
пакета (примерно 50КБ) вы, возможно, приняли 36 или около этого пакетов длиной
1460 байт каждый.
<P>Начало каждого пакета сообщает, куда он направляется, откуда он исходит, тип 
пакета и другие административные подробности. Это начало пакета называется 
заголовком. Остальная часть пакета, содержащая фактически передаваемые данные,
обычно называется телом.
<P>Некоторые протоколы, такие как TCP, которые используются для web, электронной
почты и удаленных регистраций в системах, используют понятие "соединения" - 
перед посылкой любых пакетов с данными производится обмен различными 
настроечными пакетами (со специальными заголовками), говорящими "Я хочу 
соединиться", "Хорошо, соединяйся" и "Спасибо". Затем идут обычные пакеты.
<P>Пакетный фильтр - кусок программного обеспечения, которое рассматривает 
заголовок курсирующих пакетов и решает что делать со всем пакетом. Оно может 
отвергнуть пакет (то есть отбросить пакет, как будто никогда не получало его),
принять пакет (то есть позволить пакету пройти) или отклонить пакет (не только
отвергнуть, но и сообщить об этом отправителю пакета).
<P>Под Linux, фильтрация пакетов встроена в ядро, и хотя есть способы, которыми
мы можем как-то оперировать пакетами, но общий принцип просмотра заголовков и 
решения судьбы пакета остается в коде ядра.
<P>
<P>
<H2><A NAME="ss2.2">2.2 Почему?</A>
</H2>

<P><B>Управление. Защита. Осторожность.</B>
<P>
<DL>
<P>
<DT><B>Управление:</B><DD><P>когда вы используете Linux-машину для подключения вашей внутренней сети к 
другой сети (скажем, к Internet), то вы имеете возможность разрешить какой-то
тип трафика и запретить какой-то другой тип. Например, заголовок пакета 
содержит адрес назначения пакета, так что вы можете предотвратить выход 
некоторых пакетов во внешнюю сеть. Еще пример: я использую <CODE>Netscape</CODE>, чтобы 
обратиться к архивам <CODE>Dilbert</CODE>. На странице размещены баннеры от 
<CODE>doubleclick.net</CODE>, и <CODE>Netscape</CODE> будет тратить мое время на их скачивание. Эту 
проблему можно решить сообщив пакетному фильтру, чтобы он не пропускал любые 
пакеты в или из адресов, принадлежащих <CODE>doubleclick.net</CODE> (хотя для этого есть 
лучшие способы).
<P>
<DT><B>Защита:</B><DD><P>когда ваша Linux-машина - единственый заслон между хаосом Internet и вашей 
красивой, организованной сетью, хорошо знать, что вы можете ограничить то, что 
пытается пройти в вашу дверь. Например, вы могли бы позволить чему-нибудь 
выйти из вашей сети, но вас может беспокоить известный "Пинг Смерти", 
посылаемый подлыми злоумышленниками. Вот другой пример: вы не хотите пускать
посторонних на telnet-порт вашей Linux-машины, даже если все ваши аккаунты 
имеют пароли; возможно вы хотите (как большинство людей) только просматривать
ресурсы Internet, а не предоставлять сервис (так или иначе) - просто не 
позволяйте никому подсоединяться к порту; при наличии пакетного фильтра 
входящие пакеты, используемые для установки соединения, будут отклоняться.
<P>
<DT><B>Осторожность:</B><DD><P>иногда неправильно настроенная машина в локальной сети может отправлять
пакеты во внешний мир. Хорошо если бы фильтр пакетов дал вам знать, что
происходит нечто аварийное; возможно вы захотите принять какие-то меры или 
только поинтересуетесь природой событий.
</DL>
<P>
<H2><A NAME="ss2.3">2.3 Как?</A>
</H2>

<P>
<H3>Ядро с фильтрацией пакетов</H3>

<P>Вам нужно ядро, в которое встроен новый код IP firewall chains (цепочки). Вы 
можете проверить, если этот код в ядре, поискав файл "/proc/net/ip_fwchains'. 
Если он существует, то все в порядке.
<P>Если нет, то вы должны сделать ядро, в котором есть IP firewall цепочки. 
Сначала, скачайте исходники ядра. Если у вас есть ядро 2.1.102 или выше, то
вам не надо будет это патчить (сейчас этот код встроен в ядро основной ветки).
Иначе, вам придется найти в web патч, указанный выше, и установить 
конфигурацию как разъяснено ниже. Если вы не знаете, как это сделать, не 
паникуйте - прочтите Kernel-HOWTO.
<P>Опции настроек, которые вы должны будете установить для ядер 2.0:
<P>
<PRE>
CONFIG_EXPERIMENTAL=y
CONFIG_FIREWALL=y
CONFIG_IP_FIREWALL=y
CONFIG_IP_FIREWALL_CHAINS=y
</PRE>
<P>Для ядер 2.1 или 2.2 :
<P>
<PRE>
CONFIG_FIREWALL=y
CONFIG_IP_FIREWALL=y
</PRE>
<P>
<P>ipchains общается с ядром и сообщает ему какие пакеты фильтровать. Если вы не 
программист, или очень любопытный человек, это как вы будете управлять 
пакетной фильтрацией.
<P>
<P>
<H3>ipchains</H3>

<P>Ipchains вставляет и удаляет правила из раздела пакетной фильтрации ядра.
Это означает, что все, что вы устанавливаете будет потеряно после 
перезагрузки; как этого избежать написано в ``Создание постоянных правил" .
<P>Ipchains заменяет ipfwadm, который использовался в старом коде IP Firewall. 
Есть набор полезных скриптов, доступных на ftp-сайте ipchains:
<PRE>
        ftp://ftp.rustcorp.com/ipchains/ipchains-scripts-1.1.2.tar.gz 
</PRE>

Это скрипт shell, называемый ipfwadm-wrapper, который позволяет вам сделать 
такую же пакетную фильтрацию, как это было выполнено прежде. Вам не стоит
использовать этот скрипт, если вы не хотите быстро перейти на новую систему 
со старого ipfwadm (это медленнее, отсутствует настройка параметров и т.д).
<P>В этом случае, вам также не нужен этот HOWTO.
<P>Подробности о проблемах ipfwadm см. в приложениях ``Различия между ipchains и ipfwadm" и ``Использование 
скрипта ipfwadm-wrapper'.
<P>
<P>
<H3>Создание постоянных правил</H3>

<P>Ваша текущая настройка firewall хранится в ядре, и таким образом 
будет потеряна на перезагрузке. Я рекомендую использовать скрипты 
`ipchains-save' и `ipchainsrestore', чтобы ваши правила действовали постоянные. 
Чтобы сделать это, настройте ваши правила, затем выполните (от root):
<PRE>
       # ipchains-save > /etc/ipchains.rules
       #
</PRE>

Создайте примерно такой скрипт:
<PRE>
#! /bin/sh
# Скрипт управления пакетной фильтрацией.

# Если правил нет, то ничего не делать.
[ -f /etc/ipchains.rules ] || exit 0

case "$1" in

  start)
    echo -n "Включение пакетной фильтрации:" 
    /sbin/ipchains-restore &lt; /etc/ipchains.rules || exit 1 
    echo 1 > /proc/sys/net/ipv4/ip_forward 
    echo "." ;;

  stop)
    echo -n "Отключение пакетной фильтрации:" 
    echo 0 > /proc/sys/net/ipv4/ip_forward 
    /sbin/ipchains -X 
    /sbin/ipchains -F 
    /sbin/ipchains -P input ACCEPT 
    /sbin/ipchains -P output ACCEPT 
    /sbin/ipchains -P forward ACCEPT 
    echo "." ;;

  *)
    echo "Использование: /etc/init.d/packetfilter {start|stop}" 
    exit 1 ;;

esac

exit 0
</PRE>
<P>Убедитесь, что этот скрипт запускается при загрузке. В моем случае
( Debian 2.1), я делаю символическую связь с именем "S39packetfilter" в
каталоге "/etc/rcS.d' (он будет выполняться перед S40network).
<P>
<HR>
<A HREF="Ipchains-HOWTO-3.html">Next</A>
<A HREF="Ipchains-HOWTO-1.html">Previous</A>
<A HREF="Ipchains-HOWTO.html#toc2">Contents</A>
</BODY>
</HTML>
