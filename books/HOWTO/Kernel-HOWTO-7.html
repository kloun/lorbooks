<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux Kernel HOWTO: Некоторые ловушки</TITLE>
 <LINK HREF="Kernel-HOWTO-8.html" REL=next>
 <LINK HREF="Kernel-HOWTO-6.html" REL=previous>
 <LINK HREF="Kernel-HOWTO.html#toc7" REL=contents>
</HEAD>
<BODY>
<A HREF="Kernel-HOWTO-8.html">Следующий</A>
<A HREF="Kernel-HOWTO-6.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc7">Содержание</A>
<HR>
<H2><A NAME="s7">7. Некоторые ловушки</A></H2>

<H2><A NAME="ss7.1">7.1 make clean</A>
</H2>

<P>Если новое ядро делает какие-то странные вещи после текущего его
обновления, то есть большая вероятность, что вы забыли выполнить <CODE>make
clean</CODE> до компиляции нового ядра. Симптомы могут быть любыми от полного 
краха вашей системы, странных проблем с вводом/выводом до малой
производительности. Убедитесь также, что вы сделали <CODE>make dep</CODE>.
<P>
<H2><A NAME="ss7.2">7.2 Большие или медленные ядра</A>
</H2>

<P>Если ваше ядро поглощает достаточное количество памяти, слишком большое
и/или просто долго компилирует, даже когда вы заставили ваш новый
786DX6/440 работать с ним, то вы вероятно получили набор ненужных вам вещей
(драйверов устройств, файловых систем и т.п.). Если вы не используете их,
то не настраивайте их, потому, что это занимает память машины. Наиболее
очевидный симптом раздутия ядра, это интенсивное свапирование памяти на
диск и с диска; если ваш диск создает шум и он не один из старых
винчестеров Fujitsu Eagles, чей звук напоминал звук выключаемого двигателя
реактивного самолета, то посмотрите в конфигурацию ядра.
<P>
<P>Вы можете узнать сколько оперативной памяти занимает ядро взяв общее
количество памяти на машине и вычтя из него количество ``общей памяти'' в
файле <CODE>/proc/meminfo</CODE> или вывод команды `<CODE>free</CODE>'. Вы можете
также определить это выполнив команду `<CODE>dmesg</CODE>' (или посмотрев в
файл протокола ядра, если он есть в вашей системе). Там будет строка,
которая выглядит примерно так:
<P>
<P><CODE>Memory: 15124k/16384k available (552k kernel code, 384k reserved, 324k data)</CODE>
<P>
<P>Моя машина с процессором 386 (которая была настроена с меньшим
количество опций) выдает следующее:
<P>
<P><CODE>Memory: 7000k/8192k available (496k kernel code, 384k reserved, 312k data)</CODE>
<P>
<P>Если у вас просто получается большое ядро, но система не позволяет вам
это, то вы можете попытаться выполнить `<CODE>make bzimage</CODE>'. Вам также
может понадобиться установить новую версию LILO чтобы сделать это.
<P>
<H2><A NAME="ss7.3">7.3 Ядро не компилируется</A>
</H2>

<P>Если ядро не компилируется, то скорее всего произошел сбой при
накладывании заплатки или ваши исходные тексты были повреждены каким-либо
образом. У вас также может быть неправильная версия gcc или также может
быть повреждена (например включаемые файлы могут быть с
ошибками). Убедитесь, что символические ссылки, которые описывает Linus в
файле <CODE>README</CODE> установлены правильно. В общем, если стандартное ядро 
не компилируется, то у час что-то серьезное с системой и вероятно
необходима переустановка некоторых утилит.
<P>
<P>или возможно вы компилируете ядро 1.2.x при помощи ELF компилятора (gcc
2.6.3 и выше). Если вы получили набор ошибок типа <CODE>so-and-so
undefined</CODE> в течении компиляции, то скорее всего у вас такая
проблема. Исправление в большинстве случаев очень просто. Добавьте эти
строки в начало файла <CODE>arch/i386/Makefile</CODE>:
<P>
<PRE>
AS=/usr/i486-linuxaout/bin/as
LD=/usr/i486-linuxaout/bin/ld -m i386linux
CC=gcc -b i486-linuxaout -D__KERNEL__ -I$(TOPDIR)/include
</PRE>
<P>Затем заново выполните <CODE>make dep</CODE> и <CODE>zImage</CODE>.
<P>
<P>В редких случаях gcc может не работать из-за аппаратных проблем. Сообщение 
об ошибке будет примерно такое ``xxx exited with signal 15'' и это в общем
будет выглядеть очень загадочно. Я вероятно не должен был здесь это
упоминать, за исключением того что это со мной однажды случилось -- у меня
была испорченная кэш-память  и компилятор время от времени не
работал. Попробуйте сначала переставить gcc, если у вас есть такая
проблема. ВЫ должны стать подозрительным только если ваше ядро нормально
компилируется с отключенным внешним кэшем, с уменьшенным количество
оперативной памяти и т.п.
<P>
<P>Это имеет склонность беспокоить людей, когда они предполагают, что их
оборудование не в порядке. Хорошо, я не буду делать это. Об этом существует
FAQ -- он находится на <CODE>http://www.bitwizard.nl/sig11/</CODE>.
<P>
<H2><A NAME="ss7.4">7.4 Не видно чтобы новая версия ядра грузилась </A>
</H2>

<P>Вы не запустили LILO, или он не настроен правильно. Одна вещь которая
случилось однажды со мной это была проблема в файле конфигурации; там
говорилось  `<CODE>boot=/dev/hda1</CODE>' вместо `<CODE>boot=/dev/hda</CODE>' (Это
может быть раздражающим в начале, но когда вы сделаете рабочий файл
конфигурации, то вам не нужно будет его больше изменять).
<P>
<H2><A NAME="ss7.5">7.5 Вы забыли запустить LILO, или система просто не грузится</A>
</H2>

<P>Оххх! Лучшая вещь, которую вы можете сделать в этом случае это
загрузиться с дискеты подготовить другой загрузочный диск (такой какой
должна сделать команда `<CODE>make zdisk</CODE>'). Вам необходимо знать где
находится ваша корневая файловая система (<CODE>/</CODE>) и какой тип она имеет
(например second extended, minix). В нижеприведенном примере, вам также
необходимо знать на какой файловой системе находится дерево исходных
текстов <CODE>/usr/src/linux</CODE>, ее тип и где она обычно монтируется. 
<P>
<P>В следующем примере, <CODE>/</CODE> находится на <CODE>/dev/hda1</CODE>, а
файловая система, которая содержит <CODE>/usr/src/linux</CODE> находится на
<CODE>/dev/hda3</CODE>, обычно смонтированной как <CODE>/usr</CODE>. Обе относятся
к типу second extended файловых систем. Рабочее ядро находится в директории 
<CODE>/usr/src/linux/arch/i386/boot</CODE> и называется <CODE>zImage</CODE>.
<P>
<P>Идея заключается в том, что если есть работающее ядро, то можно
использовать его для создания нового загрузочного гибкого диска. Другой
вариант, который может работать лучше (а может и не работать, это зависит
от конкретного метода которым вы сломали свою систему) обсуждается
дальше после примера. 
<P>
<P>С начала загрузимся с комбинации загрузочного/корневого дисков или
спасательного (rescue) диска, и смонтируем файловую систему, которая
содержит работающее ядро:
<P>
<PRE>
    mkdir /mnt
    mount -t ext2 /dev/hda3 /mnt
</PRE>
<P>
<P>Если <CODE>mkdir</CODE> сообщает вам, что директория уже существует, то
просто проигнорируйте это сообщение. Затем перейдите в ту директорию, где
находится работающее ядро. Заметим, что 
<P>
<PRE>
/mnt + /usr/src/linux/arch/i386/boot - /usr = /mnt/src/linux/arch/i386/boot
</PRE>
<P>
<P>Поместите отформатированную дискету в привод ``A:'' (только не
загрузочную дискету и не дискету с корневой файловой системой!), и
перебросьте ядро на дискету и настройте его на вашу корневую файловую
систему:
<P>
<PRE>
    cd /mnt/src/linux/arch/i386/boot
    dd if=zImage of=/dev/fd0
    rdev /dev/fd0 /dev/hda1
</PRE>
<P>перейдите в <CODE>/</CODE> и отмонтируйте обычную файловую систему <CODE>/usr</CODE>:
<P>
<PRE>
    cd /
    umount /mnt
</PRE>
<P>Теперь вы должны иметь возможность перезагрузить ваш компьютер как обычно с 
созданной дискеты. Не забудьте перезапустить lilo (или выполнить то, что вы 
сделали не правильно) после перезагрузки!
<P>
<P>Как было упомянуто выше, существует другая общая альтернатива. Если у вас 
к счастью имеется рабочее ядро находящееся на разделе <CODE>/</CODE> (например
<CODE>/vmlinuz</CODE>), то вы можете использовать его для загрузочной
дискеты. Предполагая все вышеприведенные условия, и что наше ядро находится 
в <CODE>/vmlinuz</CODE>, то просто сделайте изменения в вышеприведенном
примере: измените <CODE>/dev/hda3</CODE> на <CODE>/dev/hda1</CODE> (корневая
файловая система), <CODE>/mnt/src/linux</CODE> на <CODE>/mnt</CODE>, и
<CODE>if=zImage</CODE> на <CODE>if=vmlinuz</CODE>. Замечание о том как получить
доступ к <CODE>/mnt/src/linux</CODE> может быть проигнорировано.
<P>
<P>Используя LILO с большими дисками (больше чем 1024 цилиндра) может
вызвать проблемы. Смотрите LILO mini-HOWTO или документацию для помощи в
этом случае.
<P>
<H2><A NAME="ss7.6">7.6 Ядро сообщает `warning: bdflush not running (предупреждение bdflush не запущен)'</A>
</H2>

<P>Это может быть серьезной проблемой. Начиная с ядер после 1.0 (примерно
20 апреля 1994), программа названная  `<CODE>update</CODE>', которая
периодически сохраняла буфера файловой системы была
изменена/заменена. Возьмите исходные тексты программы  `<CODE>bdflush</CODE>'
(вы должны найти их там где вы брали исходные тексты ядра), и установите
эту программу (вы вероятно захотите запустить старое ядро пока вы делаете
это). Эта программа сама установится как `<CODE>update</CODE>' и после
перезагрузки, новое ядро не будет больше выражать недовольство ее
отсутствием. 
<P>
<H2><A NAME="ss7.7">7.7 Выводятся сообщения о неопределенных символах и не компилируется</A>
</H2>

<P>У вас вероятнее всего ELF компилятор (gcc 2.6.3 и выше) и исходные
тексты ядра 1.2.x (или более раннего). Обычное исправление заключается в
добавлении этих трех строк в начало файла <CODE>arch/i386/Makefile</CODE>:
<PRE>
AS=/usr/i486-linuxaout/bin/as
LD=/usr/i486-linuxaout/bin/ld -m i386linux
CC=gcc -b i486-linuxaout -D__KERNEL__ -I$(TOPDIR)/include
</PRE>
<P>
<P>Это заставит выполнять компиляцию ядра 1.2.x с библиотеками a.out.
<P>
<H2><A NAME="ss7.8">7.8 Я не могу заставить работать мой привод IDE/ATAPI CD-ROM</A>
</H2>

<P>Достаточно странно, но много людей не могут заставить работать свои
устройства ATAPI, потому что существуют некоторые вещи, который могут быть
сделаны неправильно. 
<P>
<P>Если ваш CD-ROM единственное устройство на отдельном интерфейсе IDE, то
оно должно быть выставлено как ``master'' или ``single''. Предположительно
это наиболее общая ошибка.
<P>
<P>Creative Labs (для некоторых) поместил интерфейс IDE на свои звуковые
карты. Однако это приводит к интересной проблеме, заключающейся в том, что
некоторые люди имеют только один интерфейс, много имеют два IDE интерфейса, 
встроенных в материнские платы (обычно на IRQ15), так что общая практика в
том, чтобы сделать интерфейс на soundblaster третим IDE портом (IRQ11).
<P>
<P>Это вызывает проблему с linux в том, что в версиях 1.2.x не
поддерживается третий IDE интерфейс (эта поддержка началась где-то в серии
1.3.x, но это было для разработчиков, помните об этом, и не был
автоматической пробы). Для того чтобы заставить это работать у вас есть
несколько возможностей.
<P>
<P>Если вы уже имеете второй IDE порт, то существует вероятность, что вы не 
используете его или у вас не два устройства на нем. Уберите привод ATAPI со 
звуковой карты и поместите его на второй интерфейс. Затем вы можете
запретить интерфейс на звуковой карте, что сохранит вам IRQ.
<P>
<P>Если у вас нет второго интерфейса, то переключите интерфейс на звуковой
карте (только не часть работающую со звуком) на использование IRQ15, как
второй интерфейс. Это должно работать.
<P>
<P>Если по некоторым причинам ваше устройство должно быть на так называемом 
``третьем'' интерфейсе, или в случае других проблем возьмите ядро версии
1.3.x (например ядро 1.3.57 имеет такую поддержку), и прочитайте файл
<CODE>drivers/block/README.ide</CODE>. Там существует гораздо больше
информации.
<P>
<H2><A NAME="ss7.9">7.9 Ядро сообщает странные вещи об устаревших запросах маршрутизации</A>
</H2>

<P>Возьмите новую версию программы <CODE>route</CODE> и любую другую программу, 
которая выполняет манипуляцию маршрутизацией. 
<CODE>/usr/include/linux/route.h</CODE>  (который является файлом в
<CODE>/usr/src/linux</CODE>) был изменен.
<P>
<H2><A NAME="ss7.10">7.10 Firewalling не работает в 1.2.0</A>
</H2>

<P>Обновите ядро по крайней мере до версии 1.2.1.
<P>
<H2><A NAME="ss7.11">7.11 ``Not a compressed kernel Image file (Не является файлом сжатого</A>
образа ядра)''</H2>

<P>Не используйте файл <CODE>vmlinux</CODE>, созданный в
<CODE>/usr/src/linux</CODE> как образ загрузки; Правильным образом загрузки
является <CODE>[..]/arch/i386/boot/zImage</CODE>.
<P>
<H2><A NAME="ss7.12">7.12 Проблемы с консолью после обновления до 1.3.x</A>
</H2>

<P>Измените слово <CODE>dumb</CODE> на <CODE>linux</CODE> в записи для консоли в
файле <CODE>/etc/termcap</CODE>. Вам также может понадобиться создать запись в
terminfo. 
<P>
<H2><A NAME="ss7.13">7.13 Не могу скомпилировать некоторые вещи после обновления ядра</A>
</H2>

<P>Исходные тексты ядра linux включают некоторое количество заголовочных
файлов (файлов, чьи имена заканчиваются на <CODE>.h</CODE>), на которые
ссылаются стандартные заголовочные файлы в <CODE>/usr/include</CODE>. На них
обычно ссылаются примерно так (где <CODE>xyzzy.h</CODE> должен быть чем-то в
<CODE>/usr/include/linux</CODE>):
<P>
<PRE>
    #include &lt;linux/xyzzy.h>
</PRE>
<P>Обычно существует ссылка, названная <CODE>linux</CODE> в <CODE>/usr/include</CODE>
на директорию <CODE>include/linux</CODE> в исходных текстах вашего ядра
(<CODE>/usr/src/linux/include/linux</CODE> в обычной системе). Если эта ссылка
находится не там, или указывает на неправильное место, то некоторые вещи
вообще не будут компилироваться. Если вы посчитали, что исходные тексты ядра 
занимают слишком много места на диске и удалили их, то это скорее всего
вызовет проблему. Другая проблема может возникнуть при неправильных правах
доступа на файлы; если ваш администратор установил umask в такое значение,
которое не позволяет другим пользователям видеть его файлы по умолчанию, и
вы разархивировали исходные тексты без опции <CODE>p</CODE> (сохранение прав
доступа), то эти пользователи не смогут пользоваться компилятором C. Хотя
вы могли бы воспользоваться командой <CODE>chmod</CODE> для исправления этого,
но вероятно более легко заново разархивировать заголовочные файлы. Вы
можете сделать это также, как и со всеми исходными текстами, но только с
дополнительным аргументом:
<P>
<PRE>
    blah# tar zxvpf linux.x.y.z.tar.gz linux/include
</PRE>
<P>Замечание: ``<CODE>make config</CODE>'' заново создаст ссылки в
<CODE>/usr/src/linux</CODE>, если они отсутствуют.
<P>
<H2><A NAME="ss7.14">7.14 Увеличение предельных значений</A>
</H2>

<P>Следующие несколько показательных команд могут быть полезны для тех кто
не знает как увеличить некоторые программные предельные значения 
The following few <I>example</I> commands may be helpful to those
wondering how to increase certain soft limits imposed by the kernel:
<P>
<PRE>
echo 4096 > /proc/sys/kernel/file-max
echo 12288 > /proc/sys/kernel/inode-max
echo 300 400 500 > /proc/sys/vm/freepages
</PRE>
<P>
<HR>
<A HREF="Kernel-HOWTO-8.html">Следующий</A>
<A HREF="Kernel-HOWTO-6.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc7">Содержание</A>
</BODY>
</HTML>
