<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Software-RAID HOWTO: Список пожеланий для MD и сопутствующего ПО</TITLE>
 <LINK HREF="Software-RAID-HOWTO-2.2-10.html" REL=previous>
 <LINK HREF="Software-RAID-HOWTO-2.2.html#toc11" REL=contents>
</HEAD>
<BODY>
Next
<A HREF="Software-RAID-HOWTO-2.2-10.html">Previous</A>
<A HREF="Software-RAID-HOWTO-2.2.html#toc11">Contents</A>
<HR>
<H2><A NAME="s11">11. Список пожеланий для MD и сопутствующего ПО</A></H2>

<P>Bradley Ward Allen
&lt;
<A HREF="mailto:ulmo@Q.Net">ulmo@Q.Net</A>&gt;
написал:
<BLOCKQUOTE>
Идеи включают:
<UL>
<LI>Параметры загрузки для указания ядру какие устройства -
MD устройства (без ``<CODE>mdadd</CODE>'')</LI>
<LI>Сделать MD прозрачным для ``<CODE>mount</CODE>''/``<CODE>umount</CODE>''
без использования ``<CODE>mdrun</CODE>'' и ``<CODE>mdstop</CODE>''</LI>
<LI>Интегрировать ``<CODE>ckraid</CODE>'' в ядро,
и запускать его при необходимости</LI>
</UL>

(Итак в общем, все, что я могу предложить - избавиться от утилит и поместить 
их в ядро; так я это вижу, это - файловая система, а не игрушка.)
<UL>
<LI>Работа с массивами, которые могут свободно пережить одновременный, 
или в разное время, отказ N дисков,
где N - целое &gt; 0 устанавливаемое администратором</LI>
<LI>Лучшая обработка застывания ядра, отключения питания,
и других внезапных завершений </LI>
<LI>Не отключать целый диск, если только часть его отказала,
если ошибки секторов занимают менее 50% 
доступа при 20 попытках различных обращений,
то просто продолжаем игнорируя эти сектора этого отдельного диска.</LI>
<LI>Плохие сектора:
<UL>
<LI>Механизм для сохранения плохих секторов в другом месте диска.</LI>
<LI>Если существует обобщенный механизм для маркировки 
деградировавших плохих блоков, которые вышестоящие уровни 
файловой системы могут распознать, использовать его. 
Программный он или нет.</LI>
<LI>Возможен альтернативный механизм извещения вышестоящего 
уровня, что размер диска более маленький,
прямо выравнивая для вышестоящего уровня сдвигать части
исключенных областей диска.
Это может помочь с деградированными блоками.</LI>
<LI>Недостаток вышеуказанных идей, сохранять маленькое 
(устанавливаемое администратором) количество пространства для 
резервирования плохих блоков (равномерно распределенное по 
диску?), и использовать его (как можно более близко) вместо 
плохих блоков, при их появлении.
Конечно, это не эффективно.
Более того, ядро должно вести log каждый раз при нахождении 
RAID массивом плохого сектора и делать это с
``<CODE>crit</CODE>'' уровнем предупреждения, просто дать понять 
администратору, что его диск содержит пылинку
в себе (или соприкосновение головки с пластиной).</LI>
</UL>
</LI>
<LI>Программно-переключаемые диски:
<DL>
<DT><B>``запретить этот диск''</B><DD><P>должно блокировать, пока ядро не завершит проверки наличия
данных для сбрасывания на диск при завершении (таких как 
завершение XOR/ECC/других коррекций ошибок), затем освободить 
диск от использования
(чтобы его можно было вынуть и т.п.);
<DT><B>``разрешить этот диск''</B><DD><P>должно, при соответствии, <CODE>mkraid</CODE> новый диск 
и затем запустить его для использования для ECC или любых 
операций, расширяя RAID5 массив;
<DT><B>``изменить размер массива''</B><DD><P>должно переопределять общее чило дисков и чило избыточных 
дисков, и результатом должно быть изменение размера массива;
без потери данных, хорошо было бы сделать это должным образом,
но я потратил много времени пытаясь описать, как это должно 
делаться; в любом случае, необходим режим, где массив будет 
блокироваться ( возможно, на несколько часов (ядро должно 
заносить что-то в log каждые десять секунд));
<DT><B>``разрешение диска при сохранении данных''</B><DD><P>это должно сохранить данные на диске как есть и перемещать их,
как положено, на систему RAID5, так что ужасающее сохранение 
и восстановление не должно происходить каждый раз когда
кто-то ``поднимает''систему RAID5 (вместо этого, может быть 
проще сохранять только один раздел вместо двух,
он может поместится на первый как сжатый gzip-ом файл);
<DT><B>``пере-разрешение диска''</B><DD><P>должно быть операторской подсказкой операционной системе 
попробовать ранее отказавший диск 
(это должен быть, как я думаю, просто вызов запрещения, а
потом разрешения).
</DL>
</LI>
</UL>
</BLOCKQUOTE>
<P>Прочие идеи не из сети:
<BLOCKQUOTE>
<UL>
<LI>finalrd аналог для initrd, для упрощения raid на корневой файловой системе.</LI>
<LI>режим только-чтение для raid, чтобы упростить вышесказанное  </LI>
<LI>Помечать RAID том как чистый всякий раз когда не сделано  
"частичной записи". -- То есть, всякий раз нет транзакций записи, 
котрые были зафиксированы на одном диске, но все еще не завершены 
на другом диске.

Добавить период "неактивности записи" (для избежания частого 
позиционирования головок на суперблок RAID при относительной 
занятости RAID тома).
</LI>
</UL>
</BLOCKQUOTE>
<P>
<HR>
Next
<A HREF="Software-RAID-HOWTO-2.2-10.html">Previous</A>
<A HREF="Software-RAID-HOWTO-2.2.html#toc11">Contents</A>
</BODY>
</HTML>
