<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Мини-HOWTO: Восстановление удаленных файлов с файловой системы Ext2fs в Linux</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Мини-HOWTO: Восстановление удаленных файлов с файловой системы Ext2fs в Linux</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Aaron Crane</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>aaronc@pobox.com</P
></DIV
></DIV
><H3
CLASS="CORPAUTHOR"
>  Перевод: <A
HREF="mailto:denm@asp-linux.com"
TARGET="_top"
>Денис Дементьев</A
>,
  <A
HREF="http://www.asplinux.com"
TARGET="_top"
>SWSoft Pte Ltd.</A
>
 </H3
></DIV
><P
CLASS="PUBDATE"
>Версия 1.3, 2 Февраля 1999 года<BR></P
><DIV
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN15"
></A
><P
></P
><P
>Представьте себе следующую картину. Последние три дня вы не ели, не спали,
даже не принимали душ. И, наконец, ваши усилия вознаграждены: вы закончили
программу, которая принесет вам всемирную известность и славу. Все, что вам
осталось сделать - это запаковать ее архиватором tar и поместить на Metalab.
Да... и удалить все копии старых файлов, созданные Emacs. Итак, вы
набиваете на клавиатуре <TT
CLASS="LITERAL"
>rm * ~</TT
>. Лишний пробел
в вашей команде вы замечаете слишком поздно. Вы только что удалили вашу
супер программу! Но помощь у вас под рукой. Этот документ
рассказывает, как можно восстановить удаленные файлы с файловой системы
ext2 (Second Extended File System). Может быть, несмотря ни на что, вам
удастся выпустить вашу программу...</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Содержание</B
></DT
><DT
>1. <A
HREF="Ext2fs-Undeletion.html#AEN18"
>Введение</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="Ext2fs-Undeletion.html#AEN33"
>Версии документа</A
></DT
><DD
><DL
><DT
>1.1.1. <A
HREF="Ext2fs-Undeletion.html#SEC-V1.1"
>Изменения в версии 1.1</A
></DT
><DT
>1.1.2. <A
HREF="Ext2fs-Undeletion.html#SEC-V1.2"
>Изменения в версии 1.2</A
></DT
><DT
>1.1.3. <A
HREF="Ext2fs-Undeletion.html#SEC-V1.3"
>Изменения в версии 1.3</A
></DT
></DL
></DD
><DT
>1.2. <A
HREF="Ext2fs-Undeletion.html#AEN76"
>Где можно найти этот документ</A
></DT
></DL
></DD
><DT
>2. <A
HREF="Ext2fs-Undeletion.html#AEN93"
>Несколько советов</A
></DT
><DT
>3. <A
HREF="Ext2fs-Undeletion.html#AEN139"
>Сколько процентов данных я смогу восстановить?</A
></DT
><DT
>4. <A
HREF="Ext2fs-Undeletion.html#AEN144"
>Итак, как мне восстановить файл?</A
></DT
><DT
>5. <A
HREF="Ext2fs-Undeletion.html#SEC-UMOUNT"
>Отключение файловой системы</A
></DT
><DT
>6. <A
HREF="Ext2fs-Undeletion.html#SEC-PREP-CHG"
>Подготовка к непосредственному изменению inode</A
></DT
><DT
>7. <A
HREF="Ext2fs-Undeletion.html#SEC-PREP-WRT"
>Подготовка к записи данных в другое место</A
></DT
><DT
>8. <A
HREF="Ext2fs-Undeletion.html#SEC-FINDING"
>Поиск удаленных inodes</A
></DT
><DT
>9. <A
HREF="Ext2fs-Undeletion.html#SEC-OBTAIN"
>Получение подробной информации об удаленных inode</A
></DT
><DT
>10. <A
HREF="Ext2fs-Undeletion.html#SEC-RECOVER"
>Восстановление блоков данных</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="Ext2fs-Undeletion.html#AEN286"
>Короткие файлы</A
></DT
><DT
>10.2. <A
HREF="Ext2fs-Undeletion.html#AEN312"
>Длинные файлы</A
></DT
></DL
></DD
><DT
>11. <A
HREF="Ext2fs-Undeletion.html#SEC-MODIFY"
>Прямое редактирование inodes</A
></DT
><DT
>12. <A
HREF="Ext2fs-Undeletion.html#SEC-EASIER"
>Станет ли легче в будущем?</A
></DT
><DT
>13. <A
HREF="Ext2fs-Undeletion.html#AEN415"
>Есть ли какие-нибудь утилиты для автоматизации процесса?</A
></DT
><DT
>14. <A
HREF="Ext2fs-Undeletion.html#AEN441"
>Отзывы и предложения</A
></DT
><DT
>15. <A
HREF="Ext2fs-Undeletion.html#SEC-CREDITS"
>Ссылки и благодарности</A
></DT
><DT
>16. <A
HREF="Ext2fs-Undeletion.html#AEN482"
>Права</A
></DT
><DT
>17. <A
HREF="Ext2fs-Undeletion.html#AEN506"
>Авторские права</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN18"
>1. Введение</A
></H1
><P
>Этот мини-Howto предоставляет вам возможность восстановить удаленные с файловой системы ext2 файлы. В нем также содержатся некоторые советы о том, как можно избежать удаления файлов.</P
><P
>В первую очередь,  этот документ предназначался для людей, случайно, если так можно выразиться, пострадавших от <TT
CLASS="LITERAL"
>rm</TT
>. Впрочем,  надеемся, что остальные пользователи также прочитают его. Никогда нельзя быть уверенным во всем - может быть однажды информация из этого документа вам очень пригодится.</P
><P
>Мы предполагаем, что вы знакомы с файловыми системами UNIX. Впрочем, мы надеемся, что он вполне доступен большинству пользователей Linux. Если вы начинающий пользователь, учтите, что восстановление удаленных файлов под Linux все же требует некоторых технических знаний и упорства.</P
><P
>Вы не сможете восстановить удаленные файлы с файловой системы ext2, как минимум, без прав доступа для чтения к непосредственно к устройству (device), на котором хранился файл. Подразумевается, что вы должны иметь права root, хотя некоторые дистрибутивы (например 
<A
HREF="http://www.debian.org/"
TARGET="_top"
>Debian GNU/Linux</A
>) имеют группу
<TT
CLASS="LITERAL"
>disk</TT
>, члены которой имеют доступ к этим устройствам. Также вам потребуется утилита
<TT
CLASS="LITERAL"
>debugfs</TT
> из пакета <TT
CLASS="LITERAL"
>e2fsprogs</TT
>, который должен быть установлен.</P
><P
>Почему мы написали этот документ? Потому, что имеем большой опыт случайного и непоправимого использования  команды <TT
CLASS="LITERAL"
>rm -r</TT
> с правами root. Ваш покорный слуга однажды удалил около 97 необходимых JPEG файлов, которые невозможно было найти в других источников. Но, при помощи некоторых полезных подсказок (см. раздел 
<A
HREF="Ext2fs-Undeletion.html#SEC-CREDITS"
>Разд. 15</A
>) и большого терпения, я восстановил 91 файл в первозданном виде. Пять из оставшихся мне удалось восстановить частично (по крайней мере было понятно, что это за картинки). Лишь один файл невозможно было просмотреть, но,  я уверен, что потерял не более 1024 байт информации (это очевидно из заголовка файла).</P
><P
>Ниже будет объяснено, какой процент восстановления удаленных файлов, вы можете ожидать, в зависимости от обстоятельств.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN33"
>1.1. Версии документа</A
></H2
><P
>Предыдущие опубликованные версии документа:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>версия 1.0, 18 января 1997&#13;</P
></LI
><LI
><P
>версия 1.1, 23 июля 1997 (см. раздел 
<A
HREF="Ext2fs-Undeletion.html#SEC-V1.1"
>Разд. 1.1.1</A
>)&#13;</P
></LI
><LI
><P
>версия 1.2, 4 августа 1997 (см. раздел 
<A
HREF="Ext2fs-Undeletion.html#SEC-V1.2"
>Разд. 1.1.2</A
>)&#13;</P
></LI
><LI
><P
>версия 1.3, 2 февраля 1999 (см. раздел 
<A
HREF="Ext2fs-Undeletion.html#SEC-V1.3"
>Разд. 1.1.3</A
>)&#13;</P
></LI
></UL
>&#13;</P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="SEC-V1.1"
>1.1.1. Изменения в версии 1.1</A
></H3
><P
>Какие изменения были внесены в эту версию? Во-первых, кое-что было изменено в самом примере, на котором показано восстановление файла. Спасибо всем, кто указал на ошибку. Надеюсь, я стал внимательнее при создании интерактивных программ.</P
><P
>Во-вторых, с целью облегчения понимания, описание файловой системы UNIX было переписано . Первоначальный вариант документа был не совсем удачен, но при помощи советов, присланных мне, я смог его подкорректировать.</P
><P
>В-третьих, в середине документа был убран огромный кусок закодированной uuencode программы <TT
CLASS="LITERAL"
>fsgrab</TT
>. Программу теперь можно найти на
<A
HREF="http://pobox.com/~aaronc/tech/fsgrab-1.2.tar.gz"
TARGET="_top"
>моем сайте</A
>
и на сайте
<A
HREF="http://metalab.unc.edu/pub/Linux/utils/file/"
TARGET="_top"
>Metalab</A
>(и зеркалах).</P
><P
>В-четвертых, документ был переведен в LDP SGML. Этот язык (SGML) может быть легко преобразован в другие языки (включая HTML и LaTeX) для просмотра и печати. Одно из преимуществ - красивый вид в печатных изданиях, другое - наличие перекрестных ссылок при просмотре через WWW.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="SEC-V1.2"
>1.1.2. Изменения в версии 1.2</A
></H3
><P
>Эта версия является просто очередным выпуском. В основном, она была выпущена для внесения изменений, предложенных читателями, одно из которых очень важно.</P
><P
>Первое изменение было предложено Egil Kvaleberg
<TT
CLASS="LITERAL"
><A
HREF="mailto:egil@kvaleberg.no"
TARGET="_top"
>egil@kvaleberg.no</A
></TT
>,
и оно касалось  команды <TT
CLASS="LITERAL"
>dump</TT
> в <TT
CLASS="LITERAL"
>debugfs</TT
>.  Спасибо еще раз Egil.</P
><P
>Второе касается использования <TT
CLASS="LITERAL"
>chattr</TT
>, чтобы избежать удаления важных файлов. Спасибо Herman Suijs
<TT
CLASS="LITERAL"
><A
HREF="mailto:H.P.M.Suijs@kub.nl"
TARGET="_top"
>H.P.M.Suijs@kub.nl</A
></TT
>
за упоминание об этом.</P
><P
>Абстрактная часть была пересмотрена. Были добавлены URL для организаций и программного обеспечения. Также были внесены некоторые другие незначительные изменения (исправлен typos и т.п.).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="SEC-V1.3"
>1.1.3. Изменения в версии 1.3</A
></H3
><P
>Хотя это первое обновление за 17 месяцев, мало что нового появилось в документе. В этой версии исправлены незначительные ошибки (typos, неправильные URL) и изменены некоторые части текста, к сожалению, устаревшие, например, данные о версиях ядра и <TT
CLASS="LITERAL"
>lde</TT
>.  И еще, 'Sunsite' везде  заменен на 'Metalab'.</P
><P
>Эта версия, скорее всего, будет последней перед версией 2.0, которая, как я надеюсь, будет полным Howto. Ведутся работы, результатом которых станут существенные изменения, они и приведут к увеличению первой цифры версии документа.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN76"
>1.2. Где можно найти этот документ</A
></H2
><P
>Последнюю версию этого документа всегда можно найти на
<A
HREF="http://metalab.unc.edu/LDP/"
TARGET="_top"
>сайте Linux Documentation Project</A
>
(и зеркалах).</P
><P
>Последняя версия также лежит на
<A
HREF="http://pobox.com/~aaronc/"
TARGET="_top"
>моем сайте</A
>
в нескольких форматах:</P
><P
>&#13;<P
></P
><UL
><LI
><P
><A
HREF="http://pobox.com/~aaronc/tech/e2-undel/howto.sgml"
TARGET="_top"
>SGML</A
>.
Это исходный текст SGML, написанный с использованием пакета SGML Tools.</P
></LI
><LI
><P
><A
HREF="http://pobox.com/~aaronc/tech/e2-undel/html/"
TARGET="_top"
>HTML</A
>.
Это HTML, автоматически созданный из SGML.</P
></LI
><LI
><P
><A
HREF="http://pobox.com/~aaronc/tech/e2-undel/howto.txt"
TARGET="_top"
>Текст</A
>.
Это простой текст, созданный из SGML.</P
></LI
></UL
>&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN93"
>2. Несколько советов</A
></H1
><P
>Жизненно необходимо помнить, что при восстановлении удаленных файлов Linux не похож на MS-DOS. В MS-DOS (и его внебрачном потомке Window 95) в большинстве случаев довольно легко восстановить файл, так как в комплект поставки "операционной системы" (я употребляю этот термин в широком смысле) входит утилита, автоматизирующая значительную часть процесса. Linux - совсем другой случай.</P
><P
>Итак, правило N 1 (главная заповедь, если хотите):</P
><P
><SPAN
CLASS="QUOTE"
>"<I
CLASS="EMPHASIS"
>ХРАНИТЕ КОПИИ</I
>"</SPAN
></P
><P
>неважно чего. Позаботьтесь об имеющейся у вас информации. Возможно, вы храните переписку, адреса, программы, документы за несколько лет на вашем компьютере. Подумайте о том, как перевернется ваша жизнь, если произойдет непоправимый сбой диска или, не дай бог, к вам в систему проникнет злоумышленник и повредит диски. И это не так уж невероятно - я общался с людьми, оказавшимися в такой ситуации. Я призываю здравомыслящих пользователей Linux пойти и купить устройство резервного копирования, составить приличное расписание копирования данных на него и
<I
CLASS="EMPHASIS"
>строго придерживаться этого</I
>. Я, например, использую запасной диск на второй машине и периодически сбрасываю на него по сети мой домашний каталог. Для дополнительной информации, по составлению расписания резервного копирования, читайте Frisch (1995) (см. раздел
<A
HREF="Ext2fs-Undeletion.html#SEC-CREDITS"
>Разд. 15</A
>).</P
><P
>Что делать, если у вас нет возможности копировать данные?</P
><P
>Попробуйте запретить запись в важные файлы: запрет доступа на запись заставит <TT
CLASS="LITERAL"
>rm</TT
> запрашивать подтверждение перед удалением. (Впрочем, я заметил, что если я удаляю каталог со всеми его подкаталогами командой <TT
CLASS="LITERAL"
>rm -r</TT
>, то на первом или втором запросе подтверждения я прерываю команду и запускаю ее снова уже как <TT
CLASS="LITERAL"
>rm -rf</TT
>.)</P
><P
>Хорошим способом для некоторых файлов может послужить создание ссылки (hard link) на них в скрытом каталоге. Я слышал однажды историю о системном администраторе, который имел привычку случайно затирать
<TT
CLASS="LITERAL"
>/etc/passwd</TT
> (что соответственно приводило систему в нерабочее состояние). Возможный способ исправить это - сделать (пользователем root) что-то типа:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># mkdir /.backup
# ln /etc/passwd /.backup</PRE
>&#13;</P
><P
>Теперь, чтобы удалить полностью содержимое файла, требуются некоторые дополнительные усилия: если вы наберете</P
><P
>&#13;<PRE
CLASS="SCREEN"
># rm /etc/passwd</PRE
>&#13;</P
><P
>тогда</P
><P
>&#13;<PRE
CLASS="SCREEN"
># ln /.backup/passwd /etc</PRE
>&#13;</P
><P
>восстановит его. Конечно, это не спасет в случае перезаписи файла, так что все равно делайте копии.</P
><P
>На файловой системе ext2 можно для защиты использовать атрибуты ext2. Эти
атрибуты устанавливаются командой <TT
CLASS="LITERAL"
>chattr</TT
>.
Есть атрибут `append-only' (только добавление): в файл - с этим атрибутом
можно добавлять данные, но он не может быть удален, и его содержимое не
может быть перезаписано. Если этот атрибут установить на каталог, то файлы
можно изменять, как обычно, но они не могут быть удалены. Атрибут
`append-only' устанавливается командой</P
><P
>&#13;<PRE
CLASS="SCREEN"
>$ chattr +a FILE...</PRE
>&#13;</P
><P
>Есть также атрибут `immutable' - устанавливать или снимать его может только
root. Файл или каталог с этим атрибутом не может быть изменен, удален,
переименован, на него нельзя создать ссылку (hard link). Он устанавливается
следующим образом:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># chattr +i FILE...</PRE
>&#13;</P
><P
>Кроме того, ext2fs поддерживает атрибут `undeletable' (неудаляемый)
(<TT
CLASS="LITERAL"
>+u</TT
> в <TT
CLASS="LITERAL"
>chattr</TT
>).
При удалении файла с этим атрибутом, он реально не удаляется, а перемещается
в "безопасное место", откуда его можно позже удалить. К сожалению, эта
возможность пока еще не реализована; хотя интерес к ее реализации
проявлялся, пока (насколько я знаю) она отсутствует во всех доступных
ядрах.</P
><P
>Есть сторонники того, чтобы сделать <TT
CLASS="LITERAL"
>rm</TT
>
псевдонимом (alias) или функцией для <TT
CLASS="LITERAL"
>rm -i</TT
>
(с этим ключом rm запрашивает подтверждение для
<I
CLASS="EMPHASIS"
>каждого</I
> удаляемого файла). В
<A
HREF="http://www.redhat.com/"
TARGET="_top"
>дистрибутиве Red Hat</A
> это сделано для всех пользователей, включая
root. Лично я не делаю этого, так как не выношу программы, не работающие
без дополнительной поддержки. Кроме того, тут кроется еще одна проблема -
рано или поздно вам придется работать в однопользовательском режиме,
использовать другой shell или даже другой компьютер, где отсутствует ваша
функция <TT
CLASS="LITERAL"
>rm -i</TT
>. Если вы привыкли к
подтверждениям, то легко можете забыть, где вы находитесь, и указать слишком
много файлов для удаления. Таким образом, различные скрипты и программы,
заменяющие <TT
CLASS="LITERAL"
>rm</TT
>, по моему мнению, очень опасны.</P
><P
>Несколько лучшим решением может быть использование пакета, удаляющего файлы
с возможностью восстановления другой командой (не <TT
CLASS="LITERAL"
>rm</TT
>). Для более подробной информации смотрите Peek, et
al (1993) (см. раздел
<A
HREF="Ext2fs-Undeletion.html#SEC-CREDITS"
>Разд. 15</A
>). Минусом этого решения является то, что пользователи могут привыкнуть беззаботно удалять файлы, вместо внимательного подхода к удалению, часто требуемого на большинстве систем Unix.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN139"
>3. Сколько процентов данных я смогу восстановить?</A
></H1
><P
>Это зависит от многих обстоятельств. Одной из трудностей с восстановлением
файлов, на такой высококачественной многозадачной многопользовательской
операционной системе, как Linux, является то, что вы никогда не знаете, что
кто-то хочет записать что-нибудь на диск. Когда операционной системе дается
команда удалить файл, она предполагает, что блоки этого файла могут быть
использованы, если нужно место для нового файла. (Это конкретный пример
общего принципа для Unix-подобных систем: ядро и связанные с ним
инструменты предполагают, что пользователи не идиоты.) В общем случае, чем
более загружена ваша машина, тем меньше у вас шансов восстановить файлы.</P
><P
>На сложность восстановления файлов также может влиять фрагментация диска. Если раздел, содержащий удаленные файлы, сильно фрагментирован, то вам сложно будет восстановить файл целиком.</P
><P
>Если ваша машина, подобно моей, фактически является однопользовательской рабочей станцией, и в момент удаления файлов вы не использовали интенсивно диск, то можете ожидать примерно указанный мною ранее процент. Я восстановил около 94% данных (не текстовых, заметьте). Если вы получите 80 или более процентов, то можете быть вполне  довольны собой.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN144"
>4. Итак, как мне восстановить файл?</A
></H1
><P
>Для восстановления  данных нужно найти их на устройстве с разделом (raw
partition device) и сделать так, чтобы они снова были видны операционной
системе. Для этого есть два способа: первый -  изменить существующую
файловую систему так, что в удаленных inode был снят флаг удаления, после
чего надеяться, что данные волшебным образом окажутся на месте. Другой
способ, намного более безопасный, но медленный - выяснить, где именно в
разделе лежат данные, после чего записать их в новый файл на другой
файловой системе.</P
><P
>До начала восстановления файлов нужно кое-что сделать; смотрите разделы
<A
HREF="Ext2fs-Undeletion.html#SEC-UMOUNT"
>Разд. 5</A
>,
<A
HREF="Ext2fs-Undeletion.html#SEC-PREP-CHG"
>Разд. 6</A
> и
<A
HREF="Ext2fs-Undeletion.html#SEC-PREP-WRT"
>Разд. 7</A
>.
Чтобы узнать, как восстановить файлы, смотрите разделы
<A
HREF="Ext2fs-Undeletion.html#SEC-FINDING"
>Разд. 8</A
>,
<A
HREF="Ext2fs-Undeletion.html#SEC-OBTAIN"
>Разд. 9</A
>,
<A
HREF="Ext2fs-Undeletion.html#SEC-RECOVER"
>Разд. 10</A
> и
<A
HREF="Ext2fs-Undeletion.html#SEC-MODIFY"
>Разд. 11</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-UMOUNT"
>5. Отключение файловой системы</A
></H1
><P
>Независимо от того, какой способ вы выберете, первое, что нужно сделать -
отключить файловую систему, содержащую удаленные файлы. Я настоятельно
рекомендую вам не пытаться работать с подключенной файловой системой.
Отключение файловой системы должно быть произведено, <I
CLASS="EMPHASIS"
>как можно
скорее</I
>, после того, как вы удалили файлы; чем скорее вы это
сделаете, тем меньше шансов, что данные будут перезаписаны.</P
><P
>Простейший способ сделать это (предполагаем, что удаленные файлы находились в файловой системе 
<TT
CLASS="LITERAL"
>/usr</TT
>) - дать команду</P
><P
>&#13;<PRE
CLASS="SCREEN"
># umount /usr</PRE
>&#13;</P
><P
>Если вы хотите оставить доступ к файловой системе <TT
CLASS="LITERAL"
>/usr</TT
>, перемонтируйте ее только для чтения:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># mount -o ro,remount /usr</PRE
>&#13;</P
><P
>Если удаленные файлы находились в корневой файловой системе, то вам понадобится ключ <TT
CLASS="LITERAL"
>-n</TT
> 
для предотвращения попытки mount записать информацию в файл <TT
CLASS="LITERAL"
>/etc/mtab</TT
>:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># mount -n -o ro,remount /</PRE
>&#13;</P
><P
>Возможно, какой-то процесс использует эту файловую систему (что вызовет, при
попытке отключения, ошибку `Resource busy' (ресурс занят)). Есть программа,
посылающая сигналы любому процессу, использующему указанный файл или точку
монтирования - это: <TT
CLASS="LITERAL"
>fuser</TT
>. Для раздела
<TT
CLASS="LITERAL"
>/usr</TT
>
попробуйте следующую команду:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fuser -v -m /usr</PRE
>&#13;</P
><P
>Она выведет список процессов. Предполагая, что ни один из них не является
жизненно необходимым, дайте команду</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fuser -k -v -m /usr</PRE
>&#13;</P
><P
>которая пошлет сигнал <TT
CLASS="LITERAL"
>SIGKILL</TT
> (что гарантировано завершит процесс), или команду</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fuser -k -TERM -v -m /usr</PRE
>&#13;</P
><P
>которая пошлет сигнал SIGTERM (что обычно приводит к нормальному (чистому) завершению работы процесса).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-PREP-CHG"
>6. Подготовка к непосредственному изменению inode</A
></H1
><P
>Хотите мой совет? Не делайте так. Не думаю, что мудро играть с файловой системой на достаточно низком уровне. Недостатком этого способа является и то, что вы гарантировано восстановите лишь первые 12 блоков каждого файла. Поэтому, если ваш файл был длиннее, воспользуйтесь другим способом. (Впрочем, посмотрите раздел
<A
HREF="Ext2fs-Undeletion.html#SEC-EASIER"
>Разд. 12</A
> для дополнительной информации.)</P
><P
>Если вы считаете, что для вас этот способ подходит, то я советую скопировать данные этого раздела в файл на другом разделе, используя обратную петлю:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># cp /dev/hda5 /root/working
# mount -t ext2 -o loop /root/working /mnt</PRE
>&#13;</P
><P
>(Примечание. Устаревшие версии <TT
CLASS="LITERAL"
>mount</TT
> могут не работать с файлами. Если ваш <TT
CLASS="LITERAL"
>mount</TT
> не работает, я настоятельно рекомендую поставить последнюю версию, по крайней мере 2.7, так как очень старые версии имеют серьезные ошибки, связанные с правами доступа).</P
><P
>Использование обратной петли означает, что, даже если вы полностью уничтожите файловую систему, то вам достаточно заново скопировать раздел в файл и начать сначала.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-PREP-WRT"
>7. Подготовка к записи данных в другое место</A
></H1
><P
>Если вы решили воспользоваться этим способом, убедитесь, что у вас имеется раздел, куда вы можете записать новые копии восстанавливаемых файлов. Надеюсь, ваша система имеет несколько разделов: возможно это корневой, <TT
CLASS="LITERAL"
>/usr</TT
> и <TT
CLASS="LITERAL"
>/home</TT
>. Если у вас есть такой выбор, проблем не должно возникнуть: просто создайте на одном из них новый каталог.</P
><P
>Если у вас только один (корневой) раздел, и вы все держите на нем, то дела
обстоят хуже. Может быть у вас найдется раздел MS-DOS или Windows, который
можно использовать? Или в вашем ядре (или в модуле) есть поддержка
RAM-диска (диска в памяти)? Чтобы использовать RAM-диск (ядро должно быть
версии старше 1.3.48),  дайте команды:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># dd if=/dev/zero of=/dev/ram0 bs=1k count=2048
# mke2fs -v -m 0 /dev/ram0 2048
# mount -t ext2 /dev/ram0 /mnt</PRE
>&#13;</P
><P
>Они создадут 2МБ RAM-диск и подключат его к <TT
CLASS="LITERAL"
>/mnt</TT
>.</P
><P
>Небольшое предупреждение: если вы используете <TT
CLASS="LITERAL"
>kerneld</TT
> (или его замену <TT
CLASS="LITERAL"
>kmod</TT
> в ядрах версии 2.2.x и в поздних 2.1.x) для
автоматической загрузки и выгрузки модулей ядра, то не отключайте RAM-диск,
пока не скопируете все файлы на постоянный носитель. Иначе, при отключении
диска, <TT
CLASS="LITERAL"
>kerneld</TT
> предполагает, что он может
выгрузить модуль, а если это происходит, то освободившаяся память может
быть использована другими частями ядра, и вы потеряете все результаты
нескольких часов нудной работы по восстановлению своих данных.</P
><P
>Если у вас есть дисковод Zip, Jazz, LS-120 или что-нибудь подобное, то
возможно он будет хорошим выбором для раздела с восстановленными данными. В
противном случае, вам не останется ничего, кроме флоппи-дисков.</P
><P
>Еще одна вещь, которая вам понадобиться - программа, которая может читать
данные из середины раздела устройства. В крайнем случае, для этого подойдет
<TT
CLASS="LITERAL"
>dd</TT
>, но если вам нужно будет прочитать,
скажем, область с 600МБ по 800МБ, то первые 600МБ все равно будут прочитаны
<TT
CLASS="LITERAL"
>dd</TT
>, хотя и проигнорированы. Это займет
довольно много времени, даже на быстрых дисках. В моем случае, для работы с
разделом была написана специальная программа. Она называется <TT
CLASS="LITERAL"
>fsgrab</TT
>; исходный текст вы можете найти на <A
HREF="http://pobox.com/~aaronc/tech/fsgrab-1.2.tar.gz"
TARGET="_top"
>моем сайте</A
>
или на <A
HREF="http://metalab.unc.edu/pub/Linux/utils/file/"
TARGET="_top"
>Metalab</A
> (и зеркалах). Далее в этом документе предполагается
наличие <TT
CLASS="LITERAL"
>fsgrab</TT
>.</P
><P
>Если размер файлов, подлежащих восстановлению, не превышал 12 блоков (один
блок обычно равен одному килобайту), то <TT
CLASS="LITERAL"
>fsgrab</TT
> вам не понадобится.</P
><P
>Если у вас нет <TT
CLASS="LITERAL"
>fsgrab</TT
>, и вы не хотите
скачивать и собирать его, то можете просто переводить команды для <TT
CLASS="LITERAL"
>fsgrab</TT
> в команды для <TT
CLASS="LITERAL"
>dd</TT
>.
Если команда для <TT
CLASS="LITERAL"
>fsgrab</TT
> выглядит так:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>fsgrab -c <I
CLASS="EMPHASIS"
>count</I
> -s <I
CLASS="EMPHASIS"
>skip</I
> <I
CLASS="EMPHASIS"
>device</I
></PRE
>&#13;</P
><P
>то соответствующая команда для <TT
CLASS="LITERAL"
>dd</TT
> будет выглядеть так:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>dd bs=1k if=<I
CLASS="EMPHASIS"
>device</I
> count=<I
CLASS="EMPHASIS"
>count</I
> skip=<I
CLASS="EMPHASIS"
>skip</I
></PRE
>&#13;</P
><P
>Я должен предупредить, что хотя <TT
CLASS="LITERAL"
>fsgrab</TT
>
нормально работал у меня, я не даю никаких гарантий его нормального функционирования. Он был
написан очень быстро и не очень аккуратно - лишь бы работало. Для
дополнительной информации см раздел `No Warranty' (без гарантии) в файле
<TT
CLASS="LITERAL"
>COPYING</TT
> (GNU General Public Licence).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-FINDING"
>8. Поиск удаленных inodes</A
></H1
><P
>Следующий шаг - выяснить, какие именно inode были удалены. Это можно сделать с помощью <TT
CLASS="LITERAL"
>debugfs</TT
>. Запустите
<TT
CLASS="LITERAL"
>debugfs</TT
>, указав имя устройства с удаленными файлами:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># debugfs /dev/hda5</PRE
>&#13;</P
><P
>Если хотите непосредственно изменять inode, то укажите ключ <TT
CLASS="LITERAL"
>-w</TT
> для разрешения записи в файловую систему:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># debugfs -w /dev/hda5</PRE
>&#13;</P
><P
>Команда <TT
CLASS="LITERAL"
>lsdel</TT
> программы <TT
CLASS="LITERAL"
>debugfs</TT
> предназначена для поиска удаленных inode. При появлении приглашения, введите ее:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  lsdel</PRE
>&#13;</P
><P
>После долгого скрипения диском, вашей любимой программе просмотра текста (переменная <TT
CLASS="LITERAL"
>$PAGER</TT
>) будет передан длинный список, который нужно сохранить. Если вы используете <TT
CLASS="LITERAL"
>less</TT
>, наберите
<TT
CLASS="LITERAL"
>-o</TT
> с именем файла. В противном случае, вам придется перенаправлять вывод. Можно сделать так:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  quit
# echo lsdel | debugfs /dev/hda5 &#62; lsdel.out</PRE
>&#13;</P
><P
>Теперь вам предстоит, основываясь на времени удаления, размере, типе, числовых значениях прав доступа и владельца, определить, какие из удаленных inode вам нужны. Если вам повезет, то вы сможете быстро найти их по времени удаления. Иначе придется очень тщательно копаться в этом списке.</P
><P
>Советую, если есть такая возможность, распечатать список indode, которые вы хотите восстановить. Это сильно упрощает жизнь.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-OBTAIN"
>9. Получение подробной информации об удаленных inode</A
></H1
><P
><TT
CLASS="LITERAL"
>debugfs</TT
> имеет команду <TT
CLASS="LITERAL"
>stat</TT
>, выводящую подробную информацию об inode. Выполните ее для всех inode, подлежащих восстановлению. Например, если вам нужно восстановить inode 148003, наберите:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  stat &#60;148003&#62;
Inode: 148003   Type: regular    Mode:  0644   Flags: 0x0   Version: 1
User:   503   Group:   100   Size: 6065
File ACL: 0    Directory ACL: 0
Links: 0   Blockcount: 12
Fragment:  Address: 0    Number: 0    Size: 0
ctime: 0x31a9a574 -- Mon May 27 13:52:04 1996
atime: 0x31a21dd1 -- Tue May 21 20:47:29 1996
mtime: 0x313bf4d7 -- Tue Mar  5 08:01:27 1996
dtime: 0x31a9a574 -- Mon May 27 13:52:04 1996
BLOCKS:
594810 594811 594814 594815 594816 594817
TOTAL: 6</PRE
>&#13;</P
><P
>Если восстанавливать нужно много, можно автоматизировать эту работу.
Предполагая, что список удаленных inode, сформированный командой <TT
CLASS="LITERAL"
>lsdel</TT
>, находится в файле <TT
CLASS="LITERAL"
>lsdel.out</TT
>, можно сделать так:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># cut -c1-6 lsdel.out | grep "[0-9]" | tr -d " " &#62; inodes</PRE
>&#13;</P
><P
>Новый файл <TT
CLASS="LITERAL"
>inodes</TT
> содержит номера inode,
подлежащих восстановлению, по одной в строке. Он нам пригодится для
следующей команды:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># sed 's/^.*$/stat &#60;\0&#62;/' inodes | debugfs /dev/hda5 &#62; stats</PRE
>&#13;</P
><P
>и файл <TT
CLASS="LITERAL"
>stats</TT
> содержит данные всех команд <TT
CLASS="LITERAL"
>stat</TT
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-RECOVER"
>10. Восстановление блоков данных</A
></H1
><P
>Эта часть может быть очень легкой и довольно сложной, в зависимости от того, занимал ли удаленный файл больше 12 блоков или нет.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN286"
>10.1. Короткие файлы</A
></H2
><P
>Если файл занимал не больше 12 блоков, то все их номера хранятся непосредственно в inode. Вы можете просмотреть их командой
<TT
CLASS="LITERAL"
>stat</TT
>. Более того, <TT
CLASS="LITERAL"
>debugfs</TT
> имеет команду, позволяющую восстановить файл автоматически. Например:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  stat &#60;148003&#62;
Inode: 148003   Type: regular    Mode:  0644   Flags: 0x0   Version: 1
User:   503   Group:   100   Size: 6065
File ACL: 0    Directory ACL: 0
Links: 0   Blockcount: 12
Fragment:  Address: 0    Number: 0    Size: 0
ctime: 0x31a9a574 -- Mon May 27 13:52:04 1996
atime: 0x31a21dd1 -- Tue May 21 20:47:29 1996
mtime: 0x313bf4d7 -- Tue Mar  5 08:01:27 1996
dtime: 0x31a9a574 -- Mon May 27 13:52:04 1996
BLOCKS:
594810 594811 594814 594815 594816 594817
TOTAL: 6</PRE
>&#13;</P
><P
>Файл занимает 6 блоков. Так как 6 меньше 12, даем команду
<TT
CLASS="LITERAL"
>debugfs</TT
> записать файл в новое место, например
<TT
CLASS="LITERAL"
>/mnt/recovered.000</TT
>:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  dump &#60;148003&#62; /mnt/recovered.000</PRE
>&#13;</P
><P
>Также можно это сделать с помощью <TT
CLASS="LITERAL"
>fsgrab</TT
>. Пример:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fsgrab -c 2 -s 594810 /dev/hda5 &#62; /mnt/recovered.000
# fsgrab -c 4 -s 594814 /dev/hda5 &#62;&#62; /mnt/recovered.000</PRE
>&#13;</P
><P
>В обоих случаях (как <TT
CLASS="LITERAL"
>debugfs</TT
>, так и <TT
CLASS="LITERAL"
>fsgrab</TT
>) в конце <TT
CLASS="LITERAL"
>/mnt/recovered.000</TT
> будет мусор. Впрочем, это не так уж важно. Самый простой способ убрать его - использовать значение поля <TT
CLASS="LITERAL"
>Size</TT
> из inode с ключом <TT
CLASS="LITERAL"
>bs</TT
> команды <TT
CLASS="LITERAL"
>dd</TT
>:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># dd count=1 if=/mnt/recovered.000 of=/mnt/resized.000 bs=6065</PRE
>&#13;</P
><P
>Конечно существует вероятность, что один или несколько блоков вашего файла были перезаписаны. Если это так, то вам не повезло - данные этого блока навсегда потеряны.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN312"
>10.2. Длинные файлы</A
></H2
><P
>Сложнее обстоит дело с файлами длиной более 12 блоков. Необходимо пояснить, как устроена файловая система UNIX. Данные файла хранятся в так называемых "блоках". Эти блоки пронумерованы. Для каждого файла также имеется "inode" (от английского information node), где хранится информация о владельце, правах, типе файла и т. п. Также как и блоки, inode пронумерованы (хотя нумерация ведется независимо от блоков). Каталоги файловой системы содержат имя файла и номер inode.</P
><P
>Кроме того, для того, чтобы ядро знало, где искать данные, соответствующие элементу каталога (файлу), в inode следующим образом размещается информация о блоках с данными файла:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Номера первых 12 блоков хранятся непосредственно в inode; их еще иногда называют <I
CLASS="EMPHASIS"
>блоками с прямой адресацией (direct blocks)</I
>.</P
></LI
><LI
><P
>В inode хранится номер блока, в котором хранятся номера еще 256 блоков данных. Иногда его называют <I
CLASS="EMPHASIS"
>блок косвенной адресации (indirect block)</I
>.</P
></LI
><LI
><P
>В inode хранится номер блока, в котором хранятся 256 номеров блоков косвенной адресации. Иногда этот блок называют <I
CLASS="EMPHASIS"
>блоком двойной косвенной адресации (doubly indirect block)</I
>.</P
></LI
><LI
><P
>В inode хранится номер блока, в котором хранятся 256 номеров блоков двойной косвенной адресации. Его называют <I
CLASS="EMPHASIS"
>блоком тройной косвенной адресации (triply indirect block)</I
>.</P
></LI
></UL
>&#13;</P
><P
>Прочтите еще раз: я знаю, что это непросто, но также и очень важно.</P
><P
>Версии ядра до 2.0.36 включительно при удалении файла обнуляют блоки косвенной адресации (а также блоки двойной косвенной адресации и т. д.). Так что если ваш файл был длинной более 12 блоков, нет никакой гарантии, что вы сможете выявить даже номера блоков с данными, не говоря уже о самих данных.</P
><P
>Единственный способ, который я нашел - это предположить, что файл не был фрагментирован; если был, то у вас проблемы. Если же предполагать, что файл не был фрагментирован, то, в зависимости от количества блоков с данными файла, возможно следующее расположение блоков, описывающих местоположение файла:</P
><P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>0 - 12</DT
><DD
><P
>Номера блоков хранятся в inode, как описано выше.</P
></DD
><DT
>13 - 268</DT
><DD
><P
>После блоков с прямой адресацией идет блок косвенной адресации и далее 256 блоков с данными.</P
></DD
><DT
>269 - 65804</DT
><DD
><P
>Как и в прошлом случае, в начале 12 блоков с прямой адресацией, блок косвенной адресации и 256 блоков данных. Далее блок двойной косвенной адресации, за ним 256 групп блоков, состоящих из одного блока косвенной адресации и 256 блоков данных.</P
></DD
><DT
>65805 и более</DT
><DD
><P
>Расположение первых 65804 блоков указано выше. Далее один блок тройной косвенной адресации и 256 повторений групп "двойной косвенной адресации". Каждая такая группа состоит из блока двойной косвенной адресации, за которым идет 256 групп из одного блока косвенной адресации и 256 блоков данных.</P
></DD
></DL
></DIV
></P
><P
>Даже если номера блоков данных правильны, нет никакой гарантии, что данные
в них не перезаписывались. К тому же, чем больше файл, тем меньше шансов,
что он был записан без фрагментации (кроме некоторых особых случаев).</P
><P
>Заметьте, что я предполагал, что размер вашего блока 1024 байта, так как
это стандартное значение. Если ваши блоки больше, некоторые числа,
указанные выше, изменятся. В частности: так как номер блока занимает 4
байта, то количество номеров блоков, которые могут быть размещены в блоке
косвенной адресации равно размер_блока/4. Так что везде, где выше
встречается число 256, меняйте его на размер_блока/4. Количество требуемых
для размещения файла блоков также нужно изменить.</P
><P
>Пример восстановления длинного файла:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  stat &#60;1387&#62;
Inode: 148004   Type: regular    Mode:  0644   Flags: 0x0   Version: 1
User:   503   Group:   100   Size: 1851347
File ACL: 0    Directory ACL: 0
Links: 0   Blockcount: 3616
Fragment:  Address: 0    Number: 0    Size: 0
ctime: 0x31a9a574 -- Mon May 27 13:52:04 1996
atime: 0x31a21dd1 -- Tue May 21 20:47:29 1996
mtime: 0x313bf4d7 -- Tue Mar  5 08:01:27 1996
dtime: 0x31a9a574 -- Mon May 27 13:52:04 1996
BLOCKS:
8314 8315 8316 8317 8318 8319 8320 8321 8322 8323 8324 8325 8326 8583
TOTAL: 14</PRE
>&#13;</P
><P
>В данном случае шансы того, что файл не фрагментирован, довольно велики: первые 12 блоков, перечисленные в inode, (блоки с данными) идут подряд. Начнем с того, что восстановим их:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fsgrab -c 12 -s 8314 /dev/hda5 &#62; /mnt/recovered.001</PRE
>&#13;</P
><P
>Следующий блок указанный в inode (8326) - блок косвенной адресации, который мы можем игнорировать, так как предполагаем, что за ним идут блоки данных (с 8327 по 8582).</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fsgrab -c 256 -s 8327 /dev/hda5 &#62;&#62; /mnt/recovered.001</PRE
>&#13;</P
><P
>Последний блок, указанный в inode имеет номер 8583. Заметьте, если
предположить, что файл не фрагментирован, то пока все нормально: последний
блок данных, записанный нами имеет номер 8582, то есть 8327 + 255. Блок
8583 - блок двойной косвенной адресации, его можно игнорировать. За ним
идут до 256 групп состоящих из блока косвенной адресации (который мы также
игнорируем), и 256 блоков данных. Быстренько выполнив несложные
арифметические подсчеты, выполняем следующие команды (заметьте, что мы
пропускаем блок двойной косвенной адресации 8583 и следующий за ним (как мы
надеемся) блок косвенной адресации 8584 и начинаем с блока 8525):</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fsgrab -c 256 -s 8585 /dev/hda5 &#62;&#62; /mnt/recovered.001
# fsgrab -c 256 -s 8842 /dev/hda5 &#62;&#62; /mnt/recovered.001
# fsgrab -c 256 -s 9099 /dev/hda5 &#62;&#62; /mnt/recovered.001
# fsgrab -c 256 -s 9356 /dev/hda5 &#62;&#62; /mnt/recovered.001
# fsgrab -c 256 -s 9613 /dev/hda5 &#62;&#62; /mnt/recovered.001
# fsgrab -c 256 -s 9870 /dev/hda5 &#62;&#62; /mnt/recovered.001</PRE
>&#13;</P
><P
>Итого мы записали 12 + (7 * 256) блоков, то есть 1804. В соответствие с
результатом команды "stat" число блоков в файле было равно 3616; считается,
что это блоки длиной 512 байт (пережиток с UNIX), поэтому, в
действительности, нам надо 3616/2 = 1808 блоков длиной 1024 байт. То есть,
нам нужно записать еще четыре блока. Последний записанный блок имел номер
10125. Также, как и раньше, пропускаем блок косвенной адресации (номер 10126)
и записываем последние четыре блока:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># fsgrab -c 4 -s 10127 /dev/hda5 &#62;&#62; /mnt/recovered.001</PRE
>&#13;</P
><P
>В результате, если нам повезло, то файл полностью восстановлен.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-MODIFY"
>11. Прямое редактирование inodes</A
></H1
><P
>Этот способ, на первый взгляд, намного проще. Однако, как уже говорилось,
он подходит только для файлов длиной менее 12 блоков.</P
><P
>Для всех inode, подлежащих восстановлению, нужно установить счетчик ссылок в 1 и обнулить время удаления. Это можно сделать командой <TT
CLASS="LITERAL"
>mi</TT
> (modify inode - изменить inode)
утилиты <TT
CLASS="LITERAL"
>debugfs</TT
>. Пример изменения inode 148003:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  mi &#60;148003&#62;
                          Mode    [0100644]
                       User ID    [503]
                      Group ID    [100]
                          Size    [6065]
                 Creation time    [833201524]
             Modification time    [832708049]
                   Access time    [826012887]
                 Deletion time    [833201524] 0
                    Link count    [0] 1
                   Block count    [12]
                    File flags    [0x0]
                     Reserved1    [0]
                      File acl    [0]
                 Directory acl    [0]
              Fragment address    [0]
               Fragment number    [0]
                 Fragment size    [0]
               Direct Block #0    [594810]
               Direct Block #1    [594811]
               Direct Block #2    [594814]
               Direct Block #3    [594815]
               Direct Block #4    [594816]
               Direct Block #5    [594817]
               Direct Block #6    [0]
               Direct Block #7    [0]
               Direct Block #8    [0]
               Direct Block #9    [0]
              Direct Block #10    [0]
              Direct Block #11    [0]
                Indirect Block    [0]
         Double Indirect Block    [0]
         Triple Indirect Block    [0]</PRE
>&#13;</P
><P
>То есть, я обнулил время удаления (deletion time) и увеличил счетчик ссылок (link count). Для остальных полей я просто нажимал Enter. Довольно нудная работа, если нужно восстановить много файлов, но, я думаю, что вы справитесь. Если бы вы хотели чего попроще, то наверное поставили бы графическую "операционную систему" с ее хорошенькой "Корзиной".</P
><P
>Кстати, в предыдущем примере <TT
CLASS="LITERAL"
>mi</TT
> запрашивает значение поля "время создания" (`Creation time'). Обманывает вас! На самом деле вы не можете указать в файловой системе UNIX время создания файла. Поле
<TT
CLASS="LITERAL"
>st_ctime</TT
> структуры <TT
CLASS="LITERAL"
>struct stat</TT
> описывает "время изменения inode", то есть время последней модификации содержимого inode. Все, пожалуй, хватит на сегодня уроков.</P
><P
>Более поздние версии <TT
CLASS="LITERAL"
>debugfs</TT
>, чем та, которую я использую, не включают некоторые поля из вышеуказанного примера (
<TT
CLASS="LITERAL"
>Reserved1</TT
> и (некоторые?) поля fragment).</P
><P
>После окончания модификации всех inode можно выйти из <TT
CLASS="LITERAL"
>debugfs</TT
> и дать команду:</P
><P
>&#13;<PRE
CLASS="SCREEN"
># e2fsck -f /dev/hda5</PRE
>&#13;</P
><P
>Смысл в том, что хотя мы и восстановили файлы, но ни в одном каталоге нет на них ссылок. Утилита <TT
CLASS="LITERAL"
>e2fsck</TT
> определяет это и для каждого файла создает ссылку в каталоге файловой системы
<TT
CLASS="LITERAL"
>/lost+found</TT
>. (То есть, если файловая система обычно монтируется в <TT
CLASS="LITERAL"
>/usr</TT
>, то при следующем монтировании восстановленные файлы будут лежать в
<TT
CLASS="LITERAL"
>/usr/lost+found</TT
>.) Остается лишь определить, какое имя имел тот или иной файл, и поместить его туда, где он находился до удаления.</P
><P
>Во время работы <TT
CLASS="LITERAL"
>e2fsck</TT
> будет задавать вам различные вопросы, касающиеся ремонта файловой системы. Отвечайте "да" (yes) на все вопросы, связанные с "итоговой информацией" (summary information) и с исправленными вами inode. Остальное на ваше усмотрение, хотя, в общем случае, лучше отвечать "да" на все вопросы. По окончании работы <TT
CLASS="LITERAL"
>e2fsck</TT
> можно смонтировать файловую систему.</P
><P
>Вообще говоря, есть альтернатива помещению утилитой <TT
CLASS="LITERAL"
>e2fsck</TT
> файлов в каталог
<TT
CLASS="LITERAL"
>/lost+found</TT
>: вы можете использовать <TT
CLASS="LITERAL"
>debugfs</TT
> для создания ссылки на inode. Для этого, после изменения inode, дайте команду <TT
CLASS="LITERAL"
>link</TT
>:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>debugfs:  link &#60;148003&#62; foo.txt</PRE
>&#13;</P
><P
>Она создаст файл <TT
CLASS="LITERAL"
>foo.txt</TT
> в каталоге, который <TT
CLASS="LITERAL"
>debugfs</TT
> считает текущим. <TT
CLASS="LITERAL"
>foo.txt</TT
> - это ваш файл. Независимо от этого
<TT
CLASS="LITERAL"
>e2fsck</TT
> нужно запустить для исправления итоговой информации и т. п.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-EASIER"
>12. Станет ли легче в будущем?</A
></H1
><P
>Да. Уже сейчас стало проще. Ядра версий 2.0.х обнуляют блоки косвенной адресации, но к ядрам более поздних версий (2.1.х и 2.2.х) это не относится. Я пишу это 2 февраля 1999 г., буквально через несколько дней после выхода в свет ядра версии 2.2.1. Думаю, что через месяц - другой появятся дистрибутивы Linux с этим ядром.</P
><P
>После того, как ограничение, связанное с обнулением блоков косвенной
адресации, будет снято, большинство моих указаний по технике изменения inode
отпадут за ненадобностью. Кроме того, можно будет как использовать команду
<TT
CLASS="LITERAL"
>dump</TT
> утилиты <TT
CLASS="LITERAL"
>debugfs</TT
> для длинных файлов, так и с успехом
пользоваться другими утилитами для восстановления файлов.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN415"
>13. Есть ли какие-нибудь утилиты для автоматизации процесса?</A
></H1
><P
>Есть. К сожалению, при работе с ними проблема с восстановлением блоков косвенной адресации (также, как и при восстановлении файлов вручную) остается. Впрочем, если учесть, что эта проблема вскоре перестанет быть таковой, можно начинать искать такие утилиты.</P
><P
>Я написал на Perl утилиту для упрощения работы с <TT
CLASS="LITERAL"
>fsgrab</TT
> 
и назвал ее <TT
CLASS="LITERAL"
>e2recover</TT
>. Она выполняет большую часть работы по восстановлению файлов с блоками косвенной адресации и, вроде бы, нормально работает, если файлы не были фрагментированы. Кроме того, она корректно выставляет права (если это возможно, то и владельца) и длину восстановленных файлов.</P
><P
>Изначально, я написал <TT
CLASS="LITERAL"
>e2recover</TT
> для будущего полного Howto, поэтому документация по ней появится лишь в нем. Впрочем, если желаете, можете скачать ее с 
<A
HREF="http://pobox.com/~aaronc/tech/e2-undel/"
TARGET="_top"
>моей странички</A
>, а также вскоре с Metalab.</P
><P
>Scott D. Heavner - автор <TT
CLASS="LITERAL"
>lde</TT
>, редактора
дисков Linux (Linux Disk Editor). Эта утилита может быть использована и как
редактор диска, и как замена <TT
CLASS="LITERAL"
>debugfs</TT
> для
файловых систем ext2 и minix, и даже для xia (хотя поддержка xia убрана из
ядер версий 2.1.х и 2.2.х ). Она имеет некоторые полезные возможности для
облегчения восстановления, например, просмотр списка блоков файла и поиск
по диску. Кроме того, в нее включена полезная документация по основам
файловых систем, руководство по восстановлению файлов. <TT
CLASS="LITERAL"
>lde</TT
> версии 2.4 можно найти на <A
HREF="http://metalab.unc.edu/pub/Linux/system/filesystems/lde-2.4.tar.gz"
TARGET="_top"
>Metalab</A
> и зеркалах или на <A
HREF="http://www.geocities.com/CapeCanaveral/Lab/7731/lde.html"
TARGET="_top"
>страничке
автора</A
>.</P
><P
>Еще один вариант предлагается GNU Midnight Commander, <TT
CLASS="LITERAL"
>mc</TT
>. Это полноэкранный менеджер файлов, основанный
AFAIK (насколько я знаю) на программе под MS-DOS, известной как "NC".
<TT
CLASS="LITERAL"
>mc</TT
> поддерживает мышь для консоли и xterm, и
доступ к виртуальным файловым системам, что позволяет, например, войти в
tar архив, как в обычный каталог. Среди прочих виртуальных файловых систем
есть и одна для восстановления файлов с ext2. Звучит удобно, но должен
признаться, что сам я эту программу не использовал - я предпочитаю старый
добрый sh.</P
><P
>Для использования возможности восстановления файлов нужно при настройке
программы перед сборкой указать опцию <TT
CLASS="LITERAL"
>-</TT
><TT
CLASS="LITERAL"
>-with-ext2undel</TT
>. Кроме
того, понадобятся библиотеки из пакета <TT
CLASS="LITERAL"
>e2fsprogs</TT
>. Версия программы, включаемая в <A
HREF="http://www.debian.org/"
TARGET="_top"
>Debian GNU/Linux</A
>, собрана с поддержкой
восстановления, это же относится и к другим  дистрибутивам. После сборки
программы наберите <TT
CLASS="LITERAL"
>cd undel:/dev/hda5</TT
>, и вы
получите "каталог" с удаленными файлами. Как и большинство других утилит
восстановления файлов, mc плохо обрабатывает файлы, содержавшие блоки
косвенной адресации - обычно просто восстанавливаются первые 12 блоков.</P
><P
>Очередная версия может быть найдена на
<A
HREF="ftp://ftp.nuclecu.unam.mx/Midnight/devel/"
TARGET="_top"
>ftp сайте Midnight Commander</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN441"
>14. Отзывы и предложения</A
></H1
><P
>Я планирую обновлять этот документ, если появится что-то интересное, и
найдется свободное время. Это означает, что я совсем не против каких-либо
комментариев от читателей. Можно ли написать понятней? Может быть что-то
как-то можно сделать проще? Или появилась новая утилита, позволяющая
автоматизировать процесс? Ну и все такое. Если у вас есть, что сказать про
этот документ или про <TT
CLASS="LITERAL"
>fsgrab</TT
>, или <TT
CLASS="LITERAL"
>e2recover</TT
>, черкните мне пару строчек на адрес <TT
CLASS="LITERAL"
><A
HREF="mailto:aaronc@pobox.com"
TARGET="_top"
>aaronc@pobox.com</A
></TT
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SEC-CREDITS"
>15. Ссылки и благодарности</A
></H1
><P
><SPAN
CLASS="QUOTE"
>""Если я видел дальше других, то потому, что стоял на плечах гигантов." (Исаак Ньютон)"</SPAN
></P
><P
>Этот Мини-Howto был изначально основан на статье Robin Glover
<TT
CLASS="LITERAL"
><A
HREF="mailto:swrglovr@met.rdg.ac.uk"
TARGET="_top"
>swrglovr@met.rdg.ac.uk</A
></TT
> 
из конференции 
<TT
CLASS="LITERAL"
><A
HREF="news:comp.os.linux.misc"
TARGET="_top"
>comp.os.linux.misc</A
></TT
>.
Хотелось бы поблагодарить его за милостивое разрешение использовать его идеи в этом Мини-Howto.</P
><P
>Хотелось бы также воспользоваться возможностью и еще раз поблагодарить всех, кто написал мне по поводу этого документа.</P
><P
>Кое-какая литература:</P
><P
>&#13;<P
></P
><UL
><LI
><P
><I
CLASS="EMPHASIS"
>Frisch</I
>, фleen (1995), <I
CLASS="EMPHASIS"
>Essential System Administration</I
>, second edition,
O'Reilly and Associates, Inc., ISBN: 1-56592-127-5.&#13;</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>Garfinkel</I
>, Simson, Daniel <I
CLASS="EMPHASIS"
>Weise</I
> and Steven <I
CLASS="EMPHASIS"
>Strassmann</I
>
(1994), <I
CLASS="EMPHASIS"
>The Unix-Haters Handbook</I
>, IDG Books, ISBN: 1-56884-203-1. Большая часть этой книги - это дикие визги тех, кто считает, что 
<I
CLASS="EMPHASIS"
>их</I
> ОС лучше, чем Unix. Остальное практически не представляет интереса, так как в GNU все значительно подробнее и проще. Однако, среди всего этого мусора есть и хорошие вещи: например, рассуждения о том, как проще удалить файл в Unix.&#13;</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>Glover</I
>, Robin (31 Jan 1996), <I
CLASS="EMPHASIS"
>HOW-TO : undelete linux files
(ext2fs/debugfs)</I
>, comp.os.linux.misc Usenet posting.&#13;</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>Peek</I
>, Jerry, Tim <I
CLASS="EMPHASIS"
>O'Reilly</I
>, Mike <I
CLASS="EMPHASIS"
>Loukides</I
> et al (1993),
<I
CLASS="EMPHASIS"
>UNIX Power Tools</I
>, O'Reilly and Associates, Inc./Random House, Inc., ISBN:
0-679-79073-X.  Second edition, 1998.</P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN482"
>16. Права</A
></H1
><P
>Все торговые марки - собственность их уважаемых владельцев. В частности:</P
><P
>&#13;<P
></P
><UL
><LI
><P
><I
CLASS="EMPHASIS"
>MS-DOS</I
> и <I
CLASS="EMPHASIS"
>Windows</I
> - торговые марки
<A
HREF="http://www.microsoft.com/"
TARGET="_top"
>Microsoft</A
>.&#13;</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>UNIX</I
> - торговая марка
<A
HREF="http://www.opengroup.org/"
TARGET="_top"
>Open Group</A
>.&#13;</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>Linux</I
> - торговая марка Linus Torvalds в США и некоторых других странах.</P
></LI
></UL
>&#13;</P
><P
>This document is Copyright й 1997, 1999 Aaron Crane
<TT
CLASS="LITERAL"
><A
HREF="mailto:aaronc@pobox.com"
TARGET="_top"
>aaronc@pobox.com</A
></TT
>.
It may be freely redistributed in its entirety, including the whole of this
copyright notice, but may not be changed without permission from either the
author or the Linux Documentation Project HOWTO Coordinator.  Dispensation
is granted for copying small verbatim portions for the purposes of reviews
or for quoting; in these circumstances, sections may be reproduced in the
presence of an appropriate citation but without this copyright notice.</P
><P
>The author requests but does not require that parties intending to sell copies
of this document, whether on computer-readable or human-readable media, inform
either him or the Linux HOWTO Coordinator of their intentions.</P
><P
>The Linux HOWTO Coordinator is currently Tim Bynum
<TT
CLASS="LITERAL"
><A
HREF="mailto:linux-howto@metalab.unc.edu"
TARGET="_top"
>linux-howto@metalab.unc.edu</A
></TT
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN506"
>17. Авторские права</A
></H1
><P
>Авторские права на русский перевод этого текста принадлежат &copy; 2000 SWSoft Pte Ltd.
Все права зарезервированы.</P
><P
>Этот документ является частью проекта Linux HOWTO.</P
><P
>Авторские права на документы Linux HOWTO принадлежат их авторам, если явно
не указано иное. Документы Linux HOWTO, а также их переводы, могут
быть воспроизведены и распространены полностью или частично на любом
носителе, физическом или электронном, при условии сохранения этой заметки об
авторских правах на всех копиях. Коммерческое распространение разрешается и
поощряется; но, так или иначе, автор текста и автор перевода желали бы знать о
таких дистрибутивах.</P
><P
>Все переводы и производные работы, выполненные по документам Linux HOWTO
должны сопровождаться этой заметкой об авторских правах. Это делается в
целях предотвращения случаев наложения дополнительных ограничений на
распространение документов HOWTO. Исключения могут составить случаи
получения специального разрешения у координатора Linux HOWTO, с которым
можно связаться по адресу приведенному ниже.</P
><P
>Мы бы хотели распространить эту информацию по всем возможным каналам. Но
при этом сохранить авторские права и быть уведомленными о всех планах
распространения HOWTO. Если у вас возникли вопросы, пожалуйста, обратитесь
к координатору проекта Linux HOWTO по электронной почте:
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@metalab.unc.edu"
>linux-howto@metalab.unc.edu</A
>&#62;</TT
> или к координатору русского
перевода Linux HOWTO компании SWSoft Pte Ltd. по адресу
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@asplinux.ru"
>linux-howto@asplinux.ru</A
>&#62;</TT
></P
></DIV
></DIV
></BODY
></HTML
>