<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>PATH HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>PATH HOWTO</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Esa Turtiainen</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>etu@dna.fi</P
></DIV
></DIV
><H3
CLASS="CORPAUTHOR"
> Перевод: <A
HREF="mailto:ave@asp-linux.com"
TARGET="_top"
>Александр Ермолаев</A
>,
 <A
HREF="http://www.asplinux.com"
TARGET="_top"
>SWSoft Pte Ltd.</A
>
 </H3
></DIV
><P
CLASS="PUBDATE"
>Версия 0.4, 15 Ноября 1997<BR></P
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Содержание</B
></DT
><DT
>1. <A
HREF="Path.html#AEN15"
>Введение</A
></DT
><DT
>2. <A
HREF="Path.html#AEN19"
>Copyright</A
></DT
><DT
>3. <A
HREF="Path.html#AEN24"
>Авторские права</A
></DT
><DT
>4. <A
HREF="Path.html#AEN33"
>Общие принципы</A
></DT
><DT
>5. <A
HREF="Path.html#AEN50"
>Процесс Init</A
></DT
><DT
>6. <A
HREF="Path.html#AEN61"
>Процесс Login</A
></DT
><DT
>7. <A
HREF="Path.html#AEN72"
>Оболочки</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="Path.html#AEN76"
>bash</A
></DT
><DT
>7.2. <A
HREF="Path.html#AEN82"
>tcsh</A
></DT
></DL
></DD
><DT
>8. <A
HREF="Path.html#AEN103"
>Изменение идентификатора пользователя</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="Path.html#AEN105"
>su</A
></DT
><DT
>8.2. <A
HREF="Path.html#AEN113"
>sudo</A
></DT
></DL
></DD
><DT
>9. <A
HREF="Path.html#AEN120"
>Сетевые серверы</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="Path.html#AEN124"
>inetd</A
></DT
><DT
>9.2. <A
HREF="Path.html#AEN130"
>rsh</A
></DT
><DT
>9.3. <A
HREF="Path.html#AEN137"
>rlogin</A
></DT
><DT
>9.4. <A
HREF="Path.html#AEN144"
>telnet</A
></DT
><DT
>9.5. <A
HREF="Path.html#AEN147"
>ssh</A
></DT
></DL
></DD
><DT
>10. <A
HREF="Path.html#AEN157"
>XFree86</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="Path.html#AEN159"
>XDM</A
></DT
><DT
>10.2. <A
HREF="Path.html#AEN168"
>xterm -ls</A
></DT
><DT
>10.3. <A
HREF="Path.html#AEN171"
>Window manager</A
></DT
></DL
></DD
><DT
>11. <A
HREF="Path.html#AEN175"
>Команды периодического выполнения cron и at</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="Path.html#AEN177"
>cron</A
></DT
><DT
>11.2. <A
HREF="Path.html#AEN188"
>at</A
></DT
></DL
></DD
><DT
>12. <A
HREF="Path.html#AEN192"
>Некоторые примеры</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="Path.html#AEN194"
>magicfilter</A
></DT
><DT
>12.2. <A
HREF="Path.html#AEN198"
>Печать из X приложений</A
></DT
></DL
></DD
><DT
>13. <A
HREF="Path.html#AEN203"
>По поводу безопасности</A
></DT
><DT
>14. <A
HREF="Path.html#AEN213"
>Как выявлять проблемы?</A
></DT
><DT
>15. <A
HREF="Path.html#AEN224"
>Некоторые стратегии, позволяющие получить одинаковые пути для всех пользователей</A
></DT
><DT
>16. <A
HREF="Path.html#AEN242"
>Благодарности</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN15"
>1. Введение</A
></H1
><P
>Этот документ описывает общие проблемы с переменными окружения Unix / Linux, особенно с переменной PATH. Переменная PATH содержит список каталогов, в которых производится поиск команд. Применимо для дистрибутива Debian Linux 1.3.</P
><P
>Примечание! Этот документ находится в стадии разработки. Пожалуйста, посылайте комментарии и исправления.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN19"
>2. Copyright</A
></H1
><P
>This documentation is free documentation; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.</P
><P
>This documentation is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.</P
><P
>You should have received a copy of the GNU General Public License
along with this documentation; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN24"
>3. Авторские права</A
></H1
><P
>Авторские права на русский перевод этого текста принадлежат &copy; 2000 SWSoft Pte Ltd.
Все права зарезервированы.</P
><P
>Этот документ является частью проекта Linux HOWTO.</P
><P
>Авторские права на документы Linux HOWTO принадлежат их авторам, если явно
не указано иное. Документы Linux HOWTO, а также их переводы, могут
быть воспроизведены и распространены полностью или частично на любом
носителе, физическом или электронном, при условии сохранения этой заметки об
авторских правах на всех копиях. Коммерческое распространение разрешается и
поощряется; но, так или иначе, автор текста и автор перевода желали бы знать о
таких дистрибутивах.</P
><P
>Все переводы и производные работы, выполненные по документам Linux HOWTO,
должны сопровождаться этой заметкой об авторских правах. Это делается в
целях предотвращения случаев наложения дополнительных ограничений на
распространение документов HOWTO. Исключения могут составить случаи
получения специального разрешения у координатора Linux HOWTO, с которым
можно связаться по адресу приведенному ниже.</P
><P
>Мы бы хотели распространить эту информацию по всем возможным каналам. Но
при этом сохранить авторские права и быть уведомленными о всех планах
распространения HOWTO. Если у вас возникли вопросы, пожалуйста, обратитесь
к координатору проекта Linux HOWTO по электронной почте:
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@metalab.unc.edu"
>linux-howto@metalab.unc.edu</A
>&#62;</TT
> или к координатору русского
перевода Linux HOWTO компании SWSoft Pte Ltd. по адресу
<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto@asplinux.ru"
>linux-howto@asplinux.ru</A
>&#62;</TT
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN33"
>4. Общие принципы</A
></H1
><P
>Все процессы в Unix содержат "окружение" (environment). Это список переменных, которые содержат имена и значения, они являются строками и могут содержать большинство символов. Все процессы в Unix имеют родительский процесс - просесс созданный этим процессом называется дочерним. Дочерние процессы наследуют окружение от родительского процесса. Они могут делать некоторые изменения в окружении перед принятием окружения уже их дочерними процессами.</P
><P
>Одна важная переменная окружения - PATH (ПУТЬ), список каталогов, разделенных двоеточием (':'). Эти каталоги просматриваются, чтобы найти команды. Если вы пробуете вызвать команду 'foo', все каталоги из переменной PATH (в указаном порядке) будут просмотрены для выполнения файла 'foo' (с установленными правами на выполнение). Если файл найден, он исполняется.</P
><P
>В этом документе я использую термин 'команда', к которому отношу программы, которые, как предполагается, имеют короткое имя, используя механизм путей.</P
><P
>В Linux для запуска процесса операционная система просматривает каталоги,
записанные в переменной PATH: вы можете использовать механизм путей там,
где пробуете выполнить команду. Если операционная система получает имя
файла, котрый не содержит '/' то просматриваются каталоги из переменной
окружения PATH. Даже если в среде не имеется никакой переменной PATH, по
крайней мере, каталоги /bin и /usr/bin будут просматриваться.</P
><P
>В sh вы используете команду export, чтобы установить окружение, в csh используйте команду setenv. Например:</P
><P
>sh:

<PRE
CLASS="SCREEN"
>PATH=/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:.</PRE
>

csh:

<PRE
CLASS="SCREEN"
>setenv PATH /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:.</PRE
>&#13;</P
><P
>C-программы могут использовать библиотечную функцию setenv() для изменения окружения. Perl содержит окружение в ассоциативном массиве %ENV, вы можете установить PATH так $ENV{PATH}="/bin".</P
><P
>Команда env - основной путь выяснения текущих переменных окружения. Она
может использоваться также, чтобы изменить их.</P
><P
>Более исчерпывающую информацию по основам механизма окружения можно взять из страниц
руководства (man) 'environ', 'execl', 'setenv', или info 'env' и из
документации по вашей оболочке.</P
><P
>Когда Linux загружается, первый процесс, который запускается является init. Это - специальный процесс, потому что не имеет родителя. Однако он первичный для всех процессов. Окружение init останется окружением всех процессов, если он не касаются окружения явно. Большинство процессов изменяют окружение.</P
><P
>Init запускает группу процессов. Файл /etc/inittab сообщает то, какие
процессы система запускает. Эти процессы работают в окружении, прямо
унаследованом от init - например программа 'getty' пишет 'login:' на
консоль. Если вы запускаете соединение PPP, вы должны помнить, что вы
работаете в окружении init. Инициализация системы - это часто сценарий,
который запускается отсюда. В Debian 1.3 скрипт инициализации
/etc/init.d/rc вызывает, в свою очередь, другие сценарии инициализации.</P
><P
>Система содержит много запускаемых серверов (демоны), которые могут
использовать или не использовать окружение, установленное по умолчанию.
Большинство серверов запускается из сценария инициализации, и, таким образом,
имеют окружение от init.</P
><P
>Когда пользователь заходит в систему, на среду действуют назначения,
которые записаны в программу при компиляции, в системный скрипт
инициализации и в пользовательский скрипт инициализации. Это довольно
усложнено, и текущая ситуация не полностью удовлетворительна. Процесс
различается, если пользователь заходит из консоли, XDM или из сети.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN50"
>5. Процесс Init</A
></H1
><P
>Init - родительский процесс для всех остальных процессов системы. Другие
процессы наследуют окружение процесса init и пути, прописанные в init.
Только в редких случаях другие пути не установлены.</P
><P
>'Пути init' зафиксированы в исходниках программы и они выглядят так:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin</PRE
>&#13;</P
><P
>Заметьте, что пути init не содержат /usr/local/bin.</P
><P
>Все программы, которые запускаются из /etc/inittab работают в окружении init, особенно системные скрипты инициализации из /etc/init.d (Debian 1.3).</P
><P
>Все, что запускается из системных сценариев инициализации, имеет окружение
init, как окружение по умолчанию. Например, syslogd, kerneld, pppd (когда
стартует при запуске), gpm, lpd и inetd имеют окружение init, и не
изменяют его.</P
><P
>Группа программ стартует из загрузочного скрипта, и PATH явно установлена в
этом скрипте. Например: atd, sendmail, apache и squid.</P
><P
>Имеются другие программы, которые стартуют из сценариев начальной загрузки, но они заменяют путь полностью. Один такой пример - cron.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN61"
>6. Процесс Login</A
></H1
><P
>В текстовой консоли имеется программа getty, ожидающая вход в систему
пользователя. Она пишет 'login:' и другие сообщения. Работает в окружении
init. Когда пользователь входит в систему, getty вызывает программу
'login'. Эта программа устанавливает пользовательское окружение и вызывает
оболочку.</P
><P
>Программа Login устанавливает пути, определенные в /usr/include/paths.h.
'Пути login' различны для root и других пользователей.</P
><P
>для обычных пользователей (_PATH_DEFPATH):

<PRE
CLASS="SCREEN"
>/usr/local/bin:/usr/bin:/bin:.</PRE
>

для root (_PATH_DEFPATH_ROOT):

<PRE
CLASS="SCREEN"
>/sbin:/bin:/usr/sbin:/usr/bin</PRE
>&#13;</P
><P
>Пути обычных пользователей не содержат пути, содержащие любые sbin каталоги.
Однако, они содержат текущий каталог, '.', который считается опасным для
пользователя root. Даже /usr/local/bin не указан для root.</P
><P
>Пути Login часто переписываются скриптом инициализации оболочки. Однако, возможно
использовать другие программы, записанные в /etc/passwd как оболочки
пользователя. Например, я использовал следующую строку, чтобы запускался PPP,
когда я вхожу в систему, используя специальное имя пользователя. В этом
случае, pppd имеет точный путь входа в систему.</P
><P
>&#13;<PRE
CLASS="SCREEN"
>etu-ppp:viYabVlxPwzDl:1000:1000:Esa Turtiainen, PPP:/:/usr/sbin/pppd</PRE
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN72"
>7. Оболочки</A
></H1
><P
>Часто пользовательские процессы - дочерние процессы оболочки записаны в /etc/passwd для этого пользователя. Файлы инициализации оболочек часто изменяют пути.</P
><P
>В login, названию оболочки предшествует '-', для bash например, написано
'-bash'. Это сигнал системе, что оболочка запускается при входе в
систему. В этом случае, оболочка выполняет инициализационные файлы при
входе в оболочку. Иначе происходит более легкая инициализация.
Дополнительно оболочка проверяет - являются ли команды исходящими из файла
или набираемыми на терминале. Это модифицирует инициализацию оболочки так,
что неинтерактивная оболочка инициализируется совсем слегка, bash, в этом
случае, не выполняет никакой инициализации.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN76"
>7.1. bash</A
></H2
><P
>Как нормальная оболочка, bash просматривает общесистемный файл /etc/profile,
где описано системное окружение и пути, которые могут быть установлены для
пользователей bash. Однако, это не выполняется, когда система
интерпретирует оболочку как не-интерактивную. Наиболее важный случай
находится в rsh, когда удаленная команда выполняется на соседней машине.
/etc/profile не запускается, и пути наследуются от rsh демона.</P
><P
>bash получает аргументы командной строки -login и -i, которые могут быть использованы, чтобы установить оболочку, как оболочку для входа или как интерактивную.</P
><P
>Пользователь может переписать значения, установленные в /etc/profile путем
создания файлов ~/.bash_profile, ~/.bash_login или ~/.profile. Обратите
внимание, что только самый первый из них выполняется - отличается от логики
инициализации csh. ~/.bash_login не выполняется специально для оболочки
входа в систему и если .bash_profile существует, он не выполняется вообще.</P
><P
>Если bash используется с именем sh вместо имени bash, он эмулирует
инициализацию bash: ищет файлы /etc/profile и ~/.profile только для
входных оболочек.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN82"
>7.2. tcsh</A
></H2
><P
>При входе оболочка tcsh исполняет следующие файлы в данной последовательности:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>/etc/csh.cshrc </P
></LI
><LI
><P
>/etc/csh.login </P
></LI
><LI
><P
>&tilde;/.tcshrc</P
></LI
><LI
><P
>&tilde;/.cshrc (если .tcshrc не найден)</P
></LI
><LI
><P
>&tilde;/.history</P
></LI
><LI
><P
>&tilde;/.login</P
></LI
><LI
><P
>&tilde;/.cshdirs</P
></LI
></UL
>&#13;</P
><P
>tcsh может быть скомпилирован так, чтобы выполнять login скрипт до cshrc скрипта. Остерегайтесь!</P
><P
>Не-интерактивные оболочки выполняют только *cshrc скрипты. *login скрипты могут использоваться, чтобы установить путь только однажды во входе в систему.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN103"
>8. Изменение идентификатора пользователя</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN105"
>8.1. su</A
></H2
><P
>Команда su делает переключение на нового пользователя. Если никакое имя пользователя не указано, то используется пользователь root.</P
><P
>Обычно su вызывает подоболочку другого пользователя. С аргументом '-' (более новые синонимы -l или --login) su вызывает оболочку, подобную входной. Однако она не использует программу login, чтобы сделать это, но использует встроенную функцию для 'симуляции' (simulation - термин используемый в исходном тексте) программы login. Итак:</P
><P
>для нормальных пользователей

<PRE
CLASS="SCREEN"
>/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:. </PRE
>

для пользователя root

<PRE
CLASS="SCREEN"
>/sbin:/bin:/usr/sbin:/usr/bin:/usr/bin/X11:/usr/local/sbin:/usr/local/bin</PRE
>&#13;</P
><P
>su также делает много других изменений в среде окружения.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN113"
>8.2. sudo</A
></H2
><P
>Имеется группа команд, которые делают использование команд супер-пользователя более безопасным. Они позволяют лучше регистрироваться в системе, устанавливать ограничения пользователям и использовать индивидуальные пароли. Наиболее широко используется команда sudo.</P
><P
>&#13;<PRE
CLASS="SCREEN"
>$ sudo env</PRE
>&#13;</P
><P
>выполняет команду env как супер-пользователь (если конфигурация позволяет это сделать).</P
><P
>Команда sudo имеет различный подход к обработке путей. Она изменяет пути поиска файлов так, чтобы текущая директория всегда находилась в конце списка. Однако, она не изменяет переменную окружения PATH. Для 'sudo env' и 'env' переменная PATH имеет одинаковые значения. Sudo добавляет только пару переменных среды, подобные SUDO_USER.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN120"
>9. Сетевые серверы</A
></H1
><P
>Большинство сетевых серверов не должно вызвать подпроцессы любого вида. Из соображений безопасности их путь должен быть минимален.</P
><P
>Важное исключение - все сервисы, которые позволяют подключаться к системе
через сеть. Этот раздел описывает окружение в этих случаях. Если команда
выполняется на удаленной машине с помощью rsh, она получает другой path,
чем тот, если команда выполнена с помощью ssh. Подобно, вход в систему с
помощью rlogin, Telnet или ssh различны.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN124"
>9.1. inetd</A
></H2
><P
>Большинство сетевых сервисов не имеют собственного процесса для постоянного
ожидания запросов. Эта работа поручается супер-серверу интернет, называемому
inetd. Inetd слушает все определенные сетевые порты и запускает
соответствующий сервер, когда имеется входящий запрос. Этот режим определен
в /etc/inetd.conf.</P
><P
>inetd стартует из скрипта при запуске системы. Он наследует пути процесса
init. Он не изменяет их, и все серверы стартующие от inetd имеют пути
процесса init. Пример такого сервера imapd, сервер почтового протокола
IMAP.</P
><P
>Другие примеры процессы inetd - telnetd, rlogind, talkd, ftp, popd, многие http серверы и т.д.</P
><P
>Часто использование inetd еще усложняется, при использовании отдельной программы
tcpd для запуска конкретного сервера. Это программа делает
дополнительную проверку безопасности до запуска конкретного приложения. Она
не изменяет пути (не проверено).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN130"
>9.2. rsh</A
></H2
><P
>Демон rsh устанавливает пути из определения _PATH_DEFPATH
(/usr/include/paths.h), этот же путь использует программа login для нормальных
пользователей. Root получит тот же путь, что и нормальный пользователь.</P
><P
>Фактически, rshd выполняет команду, полученную из командной строки:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>shell -c command-line</PRE
>&#13;</P
><P
>и shell, это не login-shell. Желательно, чтобы все оболочки, упомянутые в
/etc/passwd, поддерживали опцию -c.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN137"
>9.3. rlogin</A
></H2
><P
>Rlogin вызывается при входе в систему, чтобы запустить реальную процедуру
входа в систему. Если вы входите с помощью rlogin, то получаете те же самые
пути, что и при обычном входе в систему. Большинство других способов войти
на Linux компьютер не использует login. Обратите внимание на разность с
rsh.</P
><P
>Команда login фактически использует</P
><P
>&#13;<PRE
CLASS="SCREEN"
>login -p -h host-name user-name</PRE
>&#13;</P
><P
>-p сохраняет среду окружения, кроме переменных HOME, PATH, SHELL, TERM,
MAIL и LOGNAME. -h сообщает удаленному хосту имя для регистрации.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN144"
>9.4. telnet</A
></H2
><P
>Telnet является че- то подобным rlogin. Использует программу login и командную строку.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN147"
>9.5. ssh</A
></H2
><P
>ssh имеет собственную установку путей. Он добавляет каталог, где находится
ssh. Часто это означает, что /usr/bin находится в пути дважды:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>/usr/local/bin:/usr/bin:/bin:.:/usr/bin</PRE
>&#13;</P
><P
>Путь не содержит /usr/X11/bin, и оболочка, вызванная командой ssh - не
оболочка входа в систему. Таким образом,</P
><P
>&#13;<PRE
CLASS="SCREEN"
>ssh remotehost xterm</PRE
>&#13;</P
><P
>не работает, и что-либо в /etc/profile или в /etc/csh.cshrc может заменить
это. Вы должны всегда использовать явный путь /usr/bin/X11/xterm.</P
><P
>ssh ищет переменные окружения в форме VAR=VALUE в файле /etc/environment. К
сожалению, это вызывает некоторые проблемы с XFree86.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN157"
>10. XFree86</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN159"
>10.1. XDM</A
></H2
><P
>XDM является наиболее общим способом войти в систему через графический
терминал. Это немного напоминает вход в систему, но внутренне полностью
отличается.</P
><P
>В каталоге /etc/X11/xdm имеются конфигурационные файлы, которые выполняются
на различных фазах входа в систему. Xstartup (и Xstartup_0 специально для
screen 0) содержат команды, запускаемые после входа пользователем в систему
(команды выполняются под root'ом).</P
><P
>Путь, который установлен для пользователей, находится в /etc/X11/xdm/xdm-config. Имеются строки:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>DisplayManager*userPath: /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games 
DisplayManager*systemPath: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11</PRE
>&#13;</P
><P
>Это будет путь по умолчанию для нормальных пользователей и для root соответственно. Это очень важно, что /usr/bin/X11 является доступным для пользователей X. Если пользователь X входит на другую машину, чтобы запустить X приложения, он должен добраться до /usr/bin/X11.</P
><P
>После запуска Xstartup XDM запускает /etc/X11/Xsession, которая работает
с конечным пользователем. Локальная конфигурация, как предполагается, будет
сделана в /etc/environment, это исходит от Xsession, если доступно (Xsession
выполнен с /bin/sh, и, таким ,образом /etc/environment должен быть sh
файлом). Это конфликтует с ssh, предполагающим, что /etc/environment - файл,
содержащий строки вида VAR=VALUE.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN168"
>10.2. xterm -ls</A
></H2
><P
>По умолчанию путь для всех команд, вызываемых из диспетчера X window,
наследуется от XDM. Использование чего-то отличного от этого должно быть
установлено явно. Чтобы запустить эмуляцию терминала с "нормальными" путями,
нужно использовать специальную опцию. В xterm опция -ls (login shell)
должна использоваться, чтобы получить пути определенные в скриптах
инициализации оболочки.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN171"
>10.3. Window manager</A
></H2
><P
>Window manager наследует окружение XDM. Все программы запущеные window manager'ом наследуют окружение window manager'а.</P
><P
>Окружение оболочки пользователя не затрагивает программы, запускаемые из
window manager'а. Например, если программа запускается от 'xterm -ls', она
имеет заданную по умолчанию среду при входе в систему, но если она
запускается из меню, то имеет только окружение window manager'а.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN175"
>11. Команды периодического выполнения cron и at</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN177"
>11.1. cron</A
></H2
><P
>Cron является командой, которая периодически выполняет команды, как
определено в /etc/crontab, и определяемых пользователем crontab'ах. В Debian
1.3 имеется стандартный механизм, чтобы выполнить команды в
/etc/cron.daily, /etc/cron.weekly и /etc/cron.monthly.</P
><P
>Cron стартует с начала загрузки, но это, кажется, изменяет PATH к довольно странному значению:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>/usr/bin:/binn:/sbin:/bin:/usr/sbin:/usr/bin</PRE
>&#13;</P
><P
>ЭТО ВЕРОЯТНО БАГ В CRON. Это путь, где имеется /usr/bin:/bin, написанный без
завершающего нуля! Этот баг есть не во всех системах.</P
><P
>В crontab может находится определение PATH. В Debian 1.3 имеется следующая,
заданная по умолчанию, строка в начале /etc/crontab:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</PRE
>&#13;</P
><P
>Из-за этого PATH программы crond никогда не используется в пользовательских
программах. Все скрипты каталогах в /etc/cron.* получают этот путь по
умолчанию. Этот путь используется, даже если программы выполняются не под
root'ом.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN188"
>11.2. at</A
></H2
><P
>at - команда, которая может использоваться для запуска программы в определенное время.</P
><P
>atd запускается, используя путь по умолчанию. Однако, пользовательские
программы всегда работают в операционной среде, используя команду sh.
Поэтому обычно оболочка изменяет этот путь. Смотрите главу по bash.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN192"
>12. Некоторые примеры</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN194"
>12.1. magicfilter</A
></H2
><P
>magicfilter является общим инструментом, чтобы управлять файлами для
принтера. Он анализирует тип файла, который будет напечатан, и вызывает
скрипт для печати соответствующих файлов. Эти скрипты вызываются от демона
lpd, который стартует из /etc/init.d/lpd, запускающегося от init.
Таким образом путь такой, как и у init. Он не содержит /usr/bin/X11!</P
><P
>Вы можете захотеть поставить на печать PDF файл. Это возможно сделать,
используя /usr/bin/X11/xpdf. Теперь вы не должны забыть вставить полный
путь к каталогу файла, потому что magicfilter не найдет его. Большинство
программ, используемых в magicfilter, не нуждаются в полном пути,
т.к. находятся в /bin или /usr/bin.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN198"
>12.2. Печать из X приложений</A
></H2
><P
>Вы можете использовать переменную окружения PRINTER, показывающую
принтер, который вы используете. Однако, вы можете обратить внимание, что, в
некоторых случаях, в X приложениях эта переменная теряется.</P
><P
>Вы должны помнить, что если X сессия запускается из XDM, window manager
никогда не обрабатывает ваши сценарии для входа. Все X приложения, которые
вы запускаете из xterm, имеют переменную PRINTER. Однако, если то же
самое приложение запускается из меню window manager'а, оно не будет
содержать вашу переменную PRINTER.</P
><P
>В некоторых случаях это может быть наследовано даже в нижних уровнях:
например, программа помощи Netscape может иметь или не иметь
определение переменной PRINTER.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN203"
>13. По поводу безопасности</A
></H1
><P
>Пути представляют иногда большую проблему для безопасности системы. Очень
просто взломать систему, используя некоторые ошибки в установках
путей. Довольно просто запустить трояна, если хакер получает права root или
других пользователей, чтобы исполнять свои программы.</P
><P
>Обычная ошибка раньше состояла в том, что '.' содержалась в путях
root'а. Злобный хакер делал программу 'ls' и держал ее в своем домашнем
каталоге. Если root делал</P
><P
>&#13;<PRE
CLASS="SCREEN"
># cd ~hacker
# ls</PRE
>&#13;</P
><P
>он исполнял хакерскую программу ls.</P
><P
>Косвенно, это может применяться ко всем программам, запущенным от root. Любой
важный демон никогда не должен запускать программы, записанные другим
пользователем. В некоторых системах, /usr/local/bin разрешает содержать
программы менее строгие в отношении безопасности - это только что удалено
из переменной пути пользователя root. Однако, если известно, что некоторый
демон выполняет 'foo', используя пути '/usr/local/bin/:...', то возможно
обмануть демон, чтобы он выполнил '/usr/local/bin/foo', вместо '/bin/foo'
Вероятно любой, кто может записывать в 'usr/local/bin', способен взломать
систему.</P
><P
>Очень важно рассмотреть, в каком порядке каталоги прописаны в путях. Если
/usr/local/bin записан перед /bin - вы рискуете защитой.</P
><P
>В Linux нужно помнить, что определение путей сделано на уровне вызовов операционной системы. Вы можете использовать короткое имя файла, который будет искаться по крайней мере в /bin и /usr/bin - вероятно и в других местах.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN213"
>14. Как выявлять проблемы?</A
></H1
><P
>Основная команда для чтения переменных окружения - /usr/bin/env.</P
><P
>Возможно использовать каталог /proc, чтобы выяснять окружение любой
программы. Первое, вы должны знать номер процесса - используйте команду ps,
чтобы получить его. Например, если номер процесса xterm - 1088, можно
просмотреть его окружение с помощью команды</P
><P
>&#13;<PRE
CLASS="SCREEN"
># more /proc/1088/environ</PRE
>&#13;</P
><P
>Это не работает с демонами, типа xdm. Чтобы обращаться к среде окружения
системных процессов или к другим пользовательским процессам, требуются
права root.</P
><P
>Для отладки Netscape, вы можете создать скрипт /tmp/test:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>$ cat &#62; /tmp/test
#!/bin/sh
/usr/bin/env &#62; /tmp/env
^d
$ chmod +x /tmp/test</PRE
>&#13;</P
><P
>Затем установите вспомогательное приложение, например RealAudio,
audio/x-pn-realaudio, чтобы вызвать программу "/tmp/test". Теперь
попробуйте в вашем браузере пойти по ссылке с RealAudio контентом
(например, http://www.realaudio.com/showcase), Netscape вызовет вашу
программу-куклу, которая сохранит окружение в /tmp/env.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN224"
>15. Некоторые стратегии, позволяющие получить одинаковые пути для всех пользователей</A
></H1
><P
>Наиболее важные установки находятся в глобальных файлах
инициализации: /etc/csh.login для tcsh и /etc/profile для bash.</P
><P
>Исключения - программы, которые не могут получить правильные пути от этих
файлов - это команды ssh, rsh, X window manager (явно не запускает login
shell), ,команды вызываемые inittab, задачи запускаемые cron, демоны,
подобные magic filters запускаемые lprd, WWW CGI скрипты и т.д.</P
><P
>Если пути установлены в /etc/csh.cshrc, то они правильные, даже когда rsh
или ssh выполняют команду на удаленной машине с аккаунтом, использующим
tcsh/csh. Однако, не возможно установить пути, если аккаунт использует
bash/sh.</P
><P
>Возможно комбинировать установку путей в один файл, например, в файл
/etc/environment-common. Теперь пишем:</P
><P
>&#13;<PRE
CLASS="SCREEN"
>${EXPORT}PATH${EQ}/bin:/usr/bin:/sbin:/usr/sbin:/usr/bin/X11:/usr/local/bin:/usr/games:.</PRE
>&#13;</P
><P
>Это можно использовать из /etc/csh.login (для tcsh и csh)</P
><P
>&#13;<PRE
CLASS="SCREEN"
>set EQ=" " set EXPORT="setenv " source /etc/environment-common</PRE
>&#13;</P
><P
>И из /etc/profile (для bash, не работает для обычного sh)</P
><P
>&#13;<PRE
CLASS="SCREEN"
>EQ='=' EXPORT="export " . /etc/environment-common</PRE
>&#13;</P
><P
>И из /etc/environment (для XDM)</P
><P
>&#13;<PRE
CLASS="SCREEN"
>EQ="=" EXPORT="export " . /etc/environment-common</PRE
>&#13;</P
><P
>Такая стратегия, главным образом, работает, но ssh будет выдавать сообщения
об ошибках в /etc/environment (на определения EQ и EXPORT). И еще,
rsh-команды, выполняемые в bash, не будут получать этот путь.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN242"
>16. Благодарности</A
></H1
><P
>Большое расстройство Ari Mujunen было одной из причин, побудивших меня написать
этот документ. Juha Takala дал некоторые ценные комментарии.</P
></DIV
></DIV
></BODY
></HTML
>