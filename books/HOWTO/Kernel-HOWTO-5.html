<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux Kernel HOWTO: Исправление ядра с помощью заплаток</TITLE>
 <LINK HREF="Kernel-HOWTO-6.html" REL=next>
 <LINK HREF="Kernel-HOWTO-4.html" REL=previous>
 <LINK HREF="Kernel-HOWTO.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="Kernel-HOWTO-6.html">Следующий</A>
<A HREF="Kernel-HOWTO-4.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc5">Содержание</A>
<HR>
<H2><A NAME="s5">5. Исправление ядра с помощью заплаток</A></H2>

<H2><A NAME="ss5.1">5.1 Наложение заплаток</A>
</H2>

<P>Накладывающиеся обновления ядра распространяются в виде
заплаток. Например, если у вас версия 1.1.45, и вас оповестили, что выпущен
`<CODE>patch46.gz</CODE>' для него, это означает, что вы можете обновить ядро
до версии 1.1.46 приложив эту заплатку. Вы можете захотеть сначала сделать
резервную копию дерева исходных текстов ядра (сначала `<CODE>make clean</CODE>'
и затем `<CODE>cd /usr/src; tar zcvf old-tree.tar.gz linux</CODE>' создаст для
сжатый архивный файл с резервной копией).
<P>
<P>Так, продолжая пример, приведенный выше, предположим, что у вас файл
`<CODE>patch46.gz</CODE>' расположен в директории <CODE>/usr/src</CODE>. Выполним
<CODE>cd</CODE> в <CODE>/usr/src</CODE>  и выполним `<CODE>zcat patch46.gz | patch
-p0</CODE>' (или `<CODE>patch -p0 &lt; patch46</CODE>' если эта заплатка не
является сжатой). Вы увидите некоторые вещи мелькающие на экране, которые
сообщают вам, что программа пытается приложить куски заплатки на нужные
файлы и информацию о том, удачна данная операция или нет. Обычно этот
процесс идет слишком быстро, чтобы вы могли прочитать и вы можете не быть
уверенными, удачна эта операция или нет, в этом случае вы можете
использовать опцию <CODE>-s</CODE> для программы <CODE>patch</CODE>, которая
заставляет <CODE>patch</CODE> выдавать только сообщение об ошибках (вы не
получите сообщения ``эй, мой компьютер действительно что-то делает!'', но
если вы это предпочитаете..). Для того, чтобы взглянуть на то какие
разделы не прошли гладко, перейдите в директорию <CODE>/usr/src/linux</CODE> и
посмотрите файлы с расширением <CODE>.rej</CODE>. Некоторые версии программы
<CODE>patch</CODE> (старые версии, которые могли быть скомпилированы на более
худших файловых системах) оставляют отклоненные файлы с расширением
<CODE>#</CODE>. вы можете использовать команду `<CODE>find</CODE>' для того
чтобы найти эти файлы:
<P>
<PRE>
    find .  -name '*.rej' -print
</PRE>
<P>эта команда печатает список всех файлов, которые находятся в текущей
директории и ее поддиректориях и имеют расширение <CODE>.rej</CODE> на
стандартный вывод.
<P>
<P>если все прошло правильно, то выполните команды `<CODE>make clean</CODE>',
`<CODE>config</CODE>', и `<CODE>dep</CODE>' как описано в разделах 3 и 4.
<P>
<P>Существует еще несколько опций для команды <CODE>patch</CODE>. Как было
отмечено выше, <CODE>patch -s</CODE> запретит вывод всех сообщений за
исключением сообщений об ошибках. Если вы храните ваше ядро где-то в другом 
месте, отличном от <CODE>/usr/src/linux</CODE>, то выполнение <CODE>patch
-p1</CODE> (в этой директории) правильно выставит заплатку. Другие опции
команды <CODE>patch</CODE> хорошо  описаны в ее справочной странице.
<P>
<H2><A NAME="ss5.2">5.2 Если что-то неправильно</A>
</H2>

<P>(Замечание: этот раздел относится к большинству старых ядер).
<P>
<P>Наиболее частая проблема возникает когда заплатка модифицирует файл,
называемый `<CODE>config.in</CODE>' и  он не выглядит достаточно правильно,
потому-что вы изменили его опции для вашей машины. Это было исправлено, но
эта проблема может возникнуть со старыми выпусками ядра. Для исправления
этой проблемы посмотрите в файл <CODE>config.in.rej</CODE>, и посмотрите что
осталось сделать оригинальной заплатке. Изменения обычно обозначаются
символами `<CODE>+</CODE>' и `<CODE>-</CODE>' в начале строки. Посмотрите строки,
которые окружают эти символы и запомните где установлено `<CODE>y</CODE>' или
`<CODE>n</CODE>'. Теперь отредактируйте файл <CODE>config.in</CODE>, и измените
`<CODE>y</CODE>' на `<CODE>n</CODE>' и `<CODE>n</CODE>' на `<CODE>y</CODE>' где это
нужно. Выполните команду
<P>
<PRE>
    patch -p0 &lt; config.in.rej
</PRE>
<P>и если она выдала, что операция проведена удачно (без ошибок), то вы можете 
продолжать работу выполняя настройку ядра и его компиляцию. Файл
<CODE>config.in.rej</CODE> все равно останется, но вы можете удалить его. 
<P>
<P>если у вас все равно существуют проблемы, то это значит, что вы могли
установить заплатку не с тем номером. Если программа patch сообщает
`<CODE>previously applied patch detected: Assume -R? (обнаружена предыдущая
заплатка: использовать опцию -R?</CODE>', то вы скорее всего пытаетесь
приложить заплатку с номером меньшим, чем номер версии вашего ядра; если вы 
ответите `<CODE>y</CODE>', то программа попытается вернуть ваши исходные тексты 
к предыдущей версии, и скорее всего это вызовет ошибку; поэтому вам
понадобится установить заново все дерево исходных текстов (что может быть
не такой уж плохой идеей).
<P>
<P>Для того чтобы убрать изменения внесенные заплаткой, используйте команду 
`<CODE>patch -R</CODE>' с оригинальной заплаткой.
<P>
<P>Лучше всего в случае, когда заплатки делают что-то неправильно, начать
применять ее с новым деревом исходных текстов (например извлеченным из
одного из файлов <CODE>linux-x.y.z.tar.gz</CODE>), и запустит процесс заново. 
<P>
<H2><A NAME="ss5.3">5.3 Избавляемся от файлов .orig</A>
</H2>

<P>После всего нескольких заплаток у вас накопится куча файлов с
расширением <CODE>.orig</CODE>. Например одно ядро 1.1.51, которое  было
последний раз почищено при версии 1.1.48. Удаление .orig файлов сохранило
примерно половину мегабайта дисковой памяти. 
<PRE>
    find .  -name '*.orig' -exec rm -f {} ';'
</PRE>

эта команда позаботится о вас. Версии программы <CODE>patch</CODE>, которые 
используют знак <CODE>#</CODE> для отклоненных файлов используют знак
тильды <CODE>~</CODE> вместо <CODE>.orig</CODE>.
<P>
<P>Существует лучший способ избавится от <CODE>.orig</CODE> файлов, который
зависит от GNU программы <CODE>xargs</CODE>:
<PRE>
    find .  -name '*.orig' | xargs rm
</PRE>

или ``довольно безопасный, но несколько более многословный'' метод:
<PRE>
    find . -name '*.orig' -print0 | xargs --null rm --
</PRE>
<P>
<H2><A NAME="ss5.4">5.4 Другие заплатки</A>
</H2>

<P>Также существуют другие заплатки (я буду назвать их ``нестандартными''), 
кроме поставляемых Linus. Если вы накладываете такие заплатки, то заплатки
от Linus могут работать неправильно и вы должны будете либо убрать их,
изменить исходные тексты или заплатку, либо установить новое дерево
исходных текстов, или выполнить комбинацию описанных действий. Это может
быть очень расстраивающим, так что если вы не хотите изменять исходные
тексты (с возможно плохим результатом), то удалите нестандартные заплатки
до приложения заплаток полученных от Linus, или просто установите новое
дерево исходных текстов. Затем вы можете посмотреть работают ли
нестандартные заплатки. Если они не работают, то вы либо задержались с
использованием старого ядра, поиграйтесь с исходными текстами или измените
заплатку, либо просто дождитесь выхода новой версии нестандартной
заплатки. 
<P>
<P>Какие существуют заплатки не входящие в стандартный дистрибутив? Вы
вероятно слышали о них. Я использую такую заплатку для того, чтобы курсор
на моей консоли не мигал, я ненавижу мигающие курсоры (Эта заплатка часто
обновляется (или по крайней мере обновлялась) по мере выпуска новых версий
ядра. Для большинства новых устройств драйвера разрабатываются как
загружаемые модули и частота использования нестандартных заплаток
значительно уменьшается.
<P>
<HR>
<A HREF="Kernel-HOWTO-6.html">Следующий</A>
<A HREF="Kernel-HOWTO-4.html">Предыдущий</A>
<A HREF="Kernel-HOWTO.html#toc5">Содержание</A>
</BODY>
</HTML>
