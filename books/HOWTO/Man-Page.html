<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
</head>
<body bgcolor="#FFFFFF">
<center>
  <p><font size=+2><b>LINUX MAN-PAGE-HOWTO</b> </font></p>
  <p>Copyright 1995-2000 by Jens Schweikhardt, email: <a href="mailto:schweikh@noc.dfn.de">&lt;schweikh@noc.dfn.de&gt;</a>
  </p>
  <p>Перевод: <a href="mailto:ave@asp-linux.com">Александр
  Ермолаев</a>, <a href="http://www.asp-linux.com">SWSoft Pte Ltd.</a>
  </p>
  <p><a href="http://www.schweikhardt.net/">http://www.schweikhardt.net/</a></p>
  <p>Информацию относительно <a href="Man-Page.html#copying">условий копирования</a> ищите
    ниже. </p>
</center>
<p>Последнее обновление: Июль 2000. Щелкните здесь, чтобы просмотреть <a href="http://www.schweikhardt.net/man_page_howto.html">последнюю
  версию</a> этого документа. Исправления и комментарии приветствуются!</p>
<p>Этот HOWTO разъясняет вам, что вы должны иметь в виду, если вы собираетесь составить
  страницы руководства (man pages), которые вы хотите сделать доступными по команде
  man. В этом HOWTO, слово &quot;руководство&quot; понимается в качестве
  страниц руководства. </p>
<p><font size=+1><b>Содержание</b></font></p>
<ul>
  <li>0) <a href="Man-Page.html#q0">Некоторые мысли по поводу
    документации</a> </li>
  <li>1) <a href="Man-Page.html#q1">Как дать имя руководству, и где
    его установить? </a></li>
  <li>2) <a href="Man-Page.html#q2">Как должно выглядеть отформатированное руководство?</a>
  </li>
  <li>3) <a href="Man-Page.html#q3">Как задокументировать несколько программ/функций на одной
    странице руководства?</a></li>
  <li>4) <a href="Man-Page.html#q4">Какой макропакет использовать?</a></li>
  <li>5) <a href="Man-Page.html#q5">Какие препроцессоры я могу использовать?</a></li>
  <li>6) <a href="Man-Page.html#q6">Как я должен распространять готовое руководство?</a> </li>
  <li>7) <a href="Man-Page.html#q7">Какие существуют соглашения по шрифтам?</a> </li>
  <li>8) <a href="Man-Page.html#q8">Как сделать руководство
    безупречным?</a> </li>
  
 <li>9) <a href="Man-Page.html#q9">Как получить простое текстовое руководство, без лишних элементов?</a></li>
  <li>10) <a href="Man-Page.html#q10">Как получить руководство в формате PostScript?</a></li>

 <li>11) <a href="Man-Page.html#q11">Как заставить работать 'apropos' и 'whatis'?</a> </li>
  <li>A) <a href="Man-Page.html#copying">Copying conditions</a></li>
</ul>
<p><a name="q0"></a><b><font size=+1>0) Некоторые мысли по поводу
документации</font></b>
</p>
<p>Почему мы пишем документации? Глупый вопрос.
Мы хотим, чтобы другим
  было понятно, как использовать нашу программу, библиотечную функцию или что-то
  еще, написанное или сделанное. Но написание документации - это еще не все. Необходимо,
  чтобы: </p>
<ul>
  <li>документация была доступна. Если она скрыта в
    каком-то нестандартном
    месте, то специальные программы не смогут найти ее - каким образом тогда ее
    использовать? </li>
  <li>документация была точная и аккуратная. Нет ничего более раздражающего,
    чем несогласованность документации и программы. Если это будет
    иметь место, то пользователи
    проклянут вас, будут слать гневные письма и выбросят вашу программу и
    документацию, с твердым намерением никогда не устанавливать что-либо,
    написанное вами. </li>
</ul>
<p>Исторически заведено и всем известно, что документация доступна по команде man(1).
  Этот HOWTO разъясняет, как вам написать руководство, которое будет
корректно обрабатываться
  утилитами для просмотра документации. Наиболее известные из этих утилит - man(1),
  xman(1x), apropos(1), makewhatis(8) и catman(8). Точность и аккуратность информации
  зависит, конечно, только от вас. Но даже в этом отношении вы найдете <a href="Man-Page.html#q8">некоторые
  идеи</a>, которые помогут избежать некоторых общих ошибок. </p>
<p><a name="q1"></a><b><font size=+1>1) Как дать имя
руководству, и где его установить?</font></b></p>
<p>Вам необходимо знать точный механизм, как дать правильное имя
руководству
  и где его правильно установить. Любое руководство должно
находиться
  в определенном разделе, который обозначается определенным символом. Общие разделы
  под Linux и их описания: </p>
<pre>Раздел  Описание
   1    Пользовательские команды, с которых можно начать каждому.
   2    Системные вызовы, т.е. функции обеспечиваемы е ядром.
   3    Процедуры, т.е. библиотечные функции.
   4    Устройства, т.е. специальные файлы в каталоге /dev.
   5    Описания форматов файлов, напр. /etc/passwd.
   6    Игры.
   7    Разное, напр., макро пакеты, соглашения.
   8    Утилиты для системного администрирования, которые могут быть запущены только под root.
   9    Другое (специфичное для Linux) место для размещения документации по ядру.
   n    Новая документация, которая может быть перемещена в соответствующий раздел.
   o    Старая документация, которая может здесь хранится определенное время.
   l    Локальная документация, касающаяся именно этой системы.</pre>
<p>Имя исходного файла руководства состоит из
имени команды, функции или файла,
  дальше сиавится точка и имя раздела. Если вы пишете документацию по формату файла
  'passwd', вы должны дать имя исходному файлу - 'passwd.5'. Здесь
пример
  имени файла, совпадает с названием команды. Представим, что может существовать
библитечная функция 'passwd'. Секционирование - обычный способ разрешить
  противоречия: Описание команды будет найдено в файле 'passwd.1', а описание
выдуманной библиотеки - в файле 'passwd.3'. </p>
<ul>
  <p><font size=-1>Иногда в конце имени файла добавляются дополнительные символы,
    и имя файла выглядит, например, так: 'xterm.1x' или так 'wish.1tk'.
    Это намеренно сделано для того, чтобы показать, что эта документация для программ
    X Window program или для приложений Tk, соответственно. Некоторые программы
    для просмотра страниц руководства могут использовать эту дополнительную информацию.
    Например, xman будет использовать 'xterm(x)' и 'wish(tk)' в списке доступной
    документации. </font></p>
</ul>
<p>Пожалуйста, не используйте разделы n, o и l; согласно стандарту файловой системы
  эти разделы не одобряются. Используйте номера разделов. Остерегайтесь совпадения
  имен с существующими программами, функциями или именами файлов. Это конечно
  плохая идея - написать редактор и назвать его ed, sed (&quot;умный&quot; ed)
  или red (Rocky ed). Удостоверьтесь, что имя вашей программы уникально, тем самым
  вы избежите того, что кто-то ненарочно
выполнит вашу программу или прочитает не
  то руководство. Проверьте базу данных lsm программ перед тем, как
назвать свое творение.
</p>
<p>Теперь мы знаем имя нашего файла. Следующее - мы должны решить, в какой
  каталог установить программу (скажем, когда пользователь запустит команду
  'make install' для вашего пакета) на Linux, все руководства устанавливаются
  в каталоги, упомянутые в переменной MANPATH. Утилиты для работы с документациями
  используют ее, как shell использует PATH для выполнения программ. Фактическиt,
  MANPATH имеет тот же формат, что и PATH. Обе переменные содержат список каталогов,
разделенных двоеточием, &quot;:&quot; (с тем исключением, что MANPATH не содержит
  пустых полей и относительных путей, и имеет только абсолютные пути). Если MANPATH
  не установлена или не экспортируется, по умолчанию будет использоваться содержимое
  каталога /usr/man. Для ускорения поиска в
каталогах, определенных в MANPATH (называемые
  основными каталогами) содержат связку подкаталогов,
названных 'man&lt;s&gt;',
  где &lt;s&gt; - замещает символ (указан выше в таблице). Не все разделы могут
  быть представлены каталогом, потому что нет никаких причин хранить пустой каталог
  'mano'. Однако могут быть каталоги, названые 'cat&lt;s&gt;', 'dvi&lt;s&gt;' и
  'ps&lt;s&gt;', которые содержат документацию, готовую для печати или вывода
  на экран. Об этом позже. Единственный файл, который должен быть в каталоге -
  файл называемый 'whatis'. Цели и создание этого файла будет описано в параграфе
  11). Самый безопасный способ иметь страницы руководства для раздела &lt;s&gt;
  - установка их в правильном месте - в каталоге /usr/man/man&lt;s&gt;. Хороший
  Makefile, однако, позволит пользователю выбрать основной каталог, в зависимости
  от значения переменной MANDIR. Большинство пакетов могут быть настроены с опцией
  --prefix=/what/ever. Страницы руководства будут устанавливаться в основной
  каталог /what/ever/man. Постарайтесь обеспечить
возможность подобного выбора. </p>
<p>С появлением <a href="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/">Linux
  File System Standard</a> (FS-Stnd), вещи стали более сложными. FS-Stnd 1.2 говорит,
  что: </p>
<ul>
  <p>&quot;Для поддержки страниц руководства,
  написанных на разных языках, соответствующие условия должны быть созданы в самой структуре
    /usr/man.&quot; </p>
</ul>
<p>Это достигнуто благодаря тому, что были введены уровни каталогов, для различных языков. Цитата
  из FS-Stnd 1.2: </p>
<ul>
  <p>&quot;Названия каталогов для различных языков в /usr/man основаны на Приложении
    E (POSIX 1003.1), по стандарту которого описывается строка идентификации для
    языков. Строка &lt;locale&gt;: &lt;language&gt;[_&lt;territory&gt;][.&lt;character-set&gt;][,&lt;version&gt;]&quot;</p>
</ul>
<p>(Смотрите FS-Stnd для некоторых общих строк &lt;locale&gt;.) Согласно этим
  принципам, наши страницы руководства
имеются в каталогах /usr/man/&lt;locale&gt;/man[1-9lno].
  Форматированные версии должны быть в /usr/man/&lt;locale&gt;/cat[1-9lno], иначе
  вы сможете обеспечить их только для единственного языка. ОДНАКО, я не рекомендую
  прямо сейчас следовать этой структуре. FS-Stnd 1.2 также позволяет это </p>
<ul>
  <p>&quot;Система, которая использует уникальный язык или кодовую страницу для
    всех руководств может пропускать подстроку &lt;locale&gt; и хранить все руководства
    в каталоге &lt;mandir&gt;. Например, система, в которой используется только
    английские страницы руководства в ASCII коде, могут хранить страницы руководства
    (каталоги man[1-9]) прямо в /usr/man. (Фактически это традиционное местоположение.)&quot;
  </p>
</ul>
<p>Я не думаю, что все утилиты (типа xman, tkman, info и многие другие, которые
  читают руководство) могут справляться с новой структурой. </p>
<p><a name="q2"></a><b><font size=+1>2) Как должно выглядеть отформатированное
  руководство?</font></b> </p>
<p>Позвольте мне привести вам пример. Ниже я объясню его подробнее. Если
вы читаете
  этот документ, как простой текст вам не будут показаны различные шрифты (<b>жирный
  </b>и <i>наклонный</i>). Пожалуйста, обратитесь к параграфу &quot;<a href="Man-Page.html#q7">Какие
  существуют соглашения по шрифтам?</a>&quot; для дальнейших объяснений. Здесь
  приведено руководство по гипотетической программе <tt>foo</tt>. </p>
<pre>FOO(1)                     User Manuals                    FOO(1)



<b>NAME
</b>     foo - frobnicate the bar library

<b>SYNOPSIS
</b>     <b>foo [-bar] [-c</b> <i>config-file</i> <b>]</b> <i>file</i> <b>...

DESCRIPTION
</b>     <b>foo</b>  frobnicates the bar library by tweaking internal symbol
     tables. By default it parses all baz segments and rearranges
     them  in  reverse  order  by time for the <b>xyzzy</b>(1) linker to
     find them. The symdef entry is then compressed using the WBG
     (Whiz-Bang-Gizmo) algorithm.  All files are processed in the
     order specified.

<b>OPTIONS
</b>     -b   Do not write 'busy' to stdout while processing.

     -c config-file
          Use the alternate system wide  <i>config-file</i>  instead  of
          <i>/etc/foo.conf</i>.   This overrides any <b>FOOCONF</b> environment
          variable.

     -a   In addition to the baz segments, also parse the  blurfl
          headers.

     -r   Recursive  mode.  Operates  as fast as lightning at the
          expense of a megabyte of virtual memory.

<b>FILES
</b>     <i>/etc/foo.conf
</i>          The system wide configuration file. See <b>foo</b>(5) for fur-
          ther details.
     <i>~/.foorc
</i>          Per  user  configuration  file.  See <b>foo</b>(5) for further
          details.

<b>ENVIRONMENT
</b>     FOOCONF
          If non-null the full pathname for an  alternate  system
          wide <i>foo.conf</i>.  Overridden by the -c option.

<b>DIAGNOSTICS
</b>     The following diagnostics may be issued on stderr:

     Bad magic number.
          The input file does not look like an archive file.
     Old style baz segments.
          foo  can  only  handle  new  style  baz segments. COBOL
          object libraries are not supported in this version.

<b>BUGS
</b>     The command name should have been chosen more  carefully  to
     reflect its purpose.

<b>AUTHOR
</b>     Jens Schweikhardt <a href="mailto:schweikh@noc.dfn.de">&lt;schweikh@noc.dfn.de&gt;

</a><b>SEE ALSO
</b>     <b>bar</b>(1), <b>foo</b>(5), <b>xyzzy</b>(1)

Linux                Last change: MARCH 1995                    2



</pre>
<p>Здесь пойдут объяснения, как я и обещал. </p>
<p><b>Раздел NAME (НАЗВАНИЕ)</b></p>
<p>...является единственным обязательным полем. Руководства без раздела name также
  бесполезны, как холодильник на северном полюсе. Этот раздел
имеет стандартизированный
  формат, представляющий собой список программ или функции,
разделенных запятыми
  и через тире идет короткое описание возможностей программы или функций. Посредством
  makewhatis(8) содержимое раздела name попадет в файл базы данных whatis. Makewhatis
  является причиной, почему должен существовать раздел name и почему мы должны
  придерживаться описанного формата. В исходном тексте мы увидим следующее</p>
<p>.SH NAME foo \- frobnicate the bar library </p>
<p>\- имеет здесь значение. Обратная косая черта нужна, чтобы показать, что она
  отлична от дефиса, который может появляться в названии команды или в строке
  описания. </p>
<p><b>Раздел SYNOPSIS (СИНТАКСИС)</b> </p>
<p>...предназначен, чтобы дать краткий обзор доступных опций программы. Для функций
  он делит на части два списка: подключаемые файлы и прототипы функций, т.о. программист
  знает число и типы параметров, а также тип возвращаемого значения. </p>
<p><b>Раздел DESCRIPTION (ОПИСАНИЕ)</b></p>
<p>...дает доступное объяснение возможностей программы или функций. Здесь вы выкладываете
  все ваши знания. Приложите все ваши умения, для того, чтобы добиться восхищения
  других, сделав этот раздел надежным и детальным источником информации. Объясните:
  какие используются аргументы, формат файла, алгоритмы и т.п. </p>
<p><b>Раздел OPTIONS (ОПЦИИ)</b></p>
<p>...содержит описание для всех опций, которые влияют на работу программы. Вы
  знали их, не так ли? </p>
<p><b>Раздел FILES (ФАЙЛЫ)</b></p>
<p>...список используемых программ и функций. Например, файлы настройки, автозагружаемые
  файлы, файлы с которыми непосредственно работает программа. Лучше использовать
  полные пути к этим файлам и заставить make изменить пути, если пользователь
  предпочтет другое местоположение для программы: для groff по умолчанию заданный
  префикс - /usr/local, т.о., они ссылаются на /usr/local/lib/groff/*. Однако,
  если вы установите 'make prefix=/opt/gnu', тогда ссылка в руководстве изменится
  на /opt/gnu/lib/groff/* </p>
<p><b>Раздел ENVIRONMENT (СРЕДА)</b></p>
<p>...список всех переменных окружения, которые влияют на вашу программу или функцию.
  Обычно переменные содержат пути, имена файлов или опции по умолчанию. </p>
<p><b>Раздел DIAGNOSTICS (ДИАГНОСТИКА)</b> </p>
<p>...должен дать описание большинству выдаваемых вашей программой сообщений об
  ошибках и способы их исправления. Нет никакой необходимости объяснять сообщения о
  системных ошибках (от perror(3)) или фатальные ошибки (от psignal(3)), поскольку
  они могут появляться при работе любых программ. </p>
<p><b>Раздел BUGS (ОШИБКИ)</b></p>
<p>...в идеале его не должно быть. Если у вас хватит смелости, вы можете описать
  здесь ограничения, известные неудобства в работе с программой, особенности,
  которые другие могут расценивать их как ошибки. Если вы не так смелы, тогда переименуйте
  ее в раздел TO DO ;-) </p>
<p><b>Раздел AUTHOR (АВТОР)</b></p>
<p>...хорош в том случае, когда вы хотите получать сообщения об ошибках в документации
  или в программе. </p>
<p><b>Раздел SEE ALSO (СМ. ТАКЖЕ)</b> </p>
<p>...список (в алфавитном порядке) руководств, которые могут быть связаны с вашим
  руководством. Традиционно - это последний раздел.</p>
<p>Вы можете вставить свои разделы, если они действительно не соответствуют одному
  из описанных разделов. Так как же точно выглядит руководство? Я ожидал этот
  вопрос, здесь вы можете посмотреть источник:</p>
<pre>.\&quot; Process this file with
.\&quot; groff -man -Tascii foo.1
.\&quot;
.TH FOO 1 &quot;MARCH 1995&quot; Linux &quot;User Manuals&quot;
.SH NAME
foo \- frobnicate the bar library
.SH SYNOPSIS
.B foo [-bar] [-c
.I config-file
.B ]
.I file
.B ...
.SH DESCRIPTION
.B foo
frobnicates the bar library by tweaking internal
symbol tables. By default it parses all baz segments
and rearranges them in reverse order by time for the
.BR xyzzy (1)
linker to find them. The symdef entry is then compressed
using the WBG (Whiz-Bang-Gizmo) algorithm.
All files are processed in the order specified.
.SH OPTIONS
.IP -b
Do not write 'busy' to stdout while processing.
.IP &quot;-c config-file&quot;
Use the alternate system wide
.I config-file
instead of
.IR /etc/foo.conf .
This overrides any
.B FOOCONF
environment variable.
.IP -a
In addition to the baz segments, also parse the
blurfl headers.
.IP -r
Recursive mode. Operates as fast as lightning
at the expense of a megabyte of virtual memory.
.SH FILES
.I /etc/foo.conf
.RS
The system wide configuration file. See
.BR foo (5)
for further details.
.RE
.I ~/.foorc
.RS
Per user configuration file. See
.BR foo (5)
for further details.
.SH ENVIRONMENT
.IP FOOCONF
If non-null the full pathname for an alternate system wide
.IR foo.conf .
Overridden by the
.B -c
option.
.SH DIAGNOSTICS
The following diagnostics may be issued on stderr:

Bad magic number.
.RS
The input file does not look like an archive file.
.RE
Old style baz segments.
.RS
.B foo
can only handle new style baz segments. COBOL
object libraries are not supported in this version.
.SH BUGS
The command name should have been chosen more carefully
to reflect its purpose.
.SH AUTHOR
Jens Schweikhardt &lt;schweikh@noc.dfn.de&gt;
.SH &quot;SEE ALSO&quot;
.BR bar (1),
.BR foo (5),
.BR xyzzy (1)

</pre>
<p><a name="q3"></a><b><font size=+1>3) Как задокументировать несколько программ/функций
  на одной странице руководства?</font></b></p>
<p>Многие программы (grep, egrep) и функции (printf, fprintf, ...) описываются
  в одном руководстве. Однако, эти страницы были бы почти бесполезны, если они
  были доступны только под одним названием. Мы не вправе ожидать, что пользователь
  помнит, что руководство по egrep - это фактически руководство по grep. Поэтому
  необходимо иметь руководство доступное под различными именами. Есть несколько
  способов достичь этого: </p>
<ol>
  <li>иметь одинаковые копии для каждого имени. </li>
  <li>связать все руководства жесткими ссылками. </li>
  <li>использовать символьные ссылки на фактическое руководство. </li>
  <li>использовать механизм groff обеспеченный макросом '.so'. </li>
</ol>
<p>Первый способ - трата дискового пространства. Второй способ не рекомендуется,
  потому что интеллектуальные версии программы catman могут сохранять работу в
  зависимости от типа и содержания файла. Жесткие ссылки препятствуют программе
  catman. (цель catman состоит в том, чтобы отформатировать все руководства так,
  чтобы они как можно быстрее отображались на экране.) Третья альтернатива имеет
  небольшой недостаток: вы должны знать, что существуют файловые системы, которые
  не поддерживаю символьные ссылки. В результате этого - Лучшая Вещь (TM) - использовать
  механизм groff. Здесь скажу о том, как это сделать: Если вы хотите
видеть
  страницы руководства доступными под именами 'foo' и 'bar' в разделе 1, тогда поместите
  руководство в файл foo.1 и сделайте файл bar.1 такого типа: </p>
<p>.so man1/foo.1</p>
<p>Важно определить директивную часть 'man1/' также, как имя файла 'foo.1',
потому что
  когда groff будет запущен браузером, он будет иметь базовым каталогом текущий
  рабочий каталог (трк), а groff интерпретирует аргументы относительно трк. </p>
<p><a name="q4"></a><b><font size=+1>4) Какой макропакет использовать?</font></b></p>
<p>Существует множество макропакетов, специально предназначенных для использования
при написании руководств. Обычно они находятся в каталоге макросов groff /usr/lib/groff/tmac.
  Имена файлов <tt>tmac.</tt>&lt;кое-что&gt;, где &lt;кое-что&gt; - аргумент опции
  -m для groff. Groff будет использовать <tt>tmac.</tt>&lt;кое-что&gt;, когда
  он работает с опцией '<tt>-m</tt> &lt;кое-что&gt;'. Часто пробел между '<tt>-m</tt>'
  и '&lt;something&gt;' опускается, и тогда может получиться '<tt>groff -man</tt>',
  когда мы форматируем руководства, используя макрос <tt>tmac.an</tt>. По этой
  причине дано странное название 'tmac.an'. Кроме того, имеется другой популярный
  макрос - <tt>tmac.doc</tt>, который сделан в калифорнийском университете Беркли
  (UCB). Большинство руководств BSD используют его, и он, кажется, сделан (в UCB)
  стандартным для документаций. Макрос <tt>tmac.doc</tt> более гибок, но, увы,
  браузеры для руководств не используют его и всегда вызывают <tt>groff -man</tt>.
  Например, все программы <tt>xman</tt>, я видел, требуют <tt>tmac.doc</tt>. Т.о.,
  для вашей пользы: используйте <tt>tmac.an</tt> -- использование любого другого
  макропакета нежелательно. <tt>tmac.andoc</tt> - псевдомакрос, который
  просматривает источник и затем загружает либо <tt>tmac.an</tt>, либо <tt>tmac.doc</tt>.
  Фактически, любой браузер руководств должен его использовать, но до сих пор не
  все это делают, т.е., лучше использовать старый <tt>tmac.an</tt>. Если, так или
  иначе, вы хотите использовать макрос <tt>tmac.doc</tt>, здесь имеется более
  детальное описание, объясняющее, как им пользоваться: <a href="http://www.bsdi.com/bsdi-man">http://www.bsdi.com/bsdi-man</a>.
  На странице имеется форма для поиска. Введите <tt>mdoc.samples,</tt> и вам будет
  найден <tt>mdoc.samples(7)</tt> - обучающий пример по написанию страниц руководства
  для BSD. </p>
Описание для troff (<i>Troff User's Manual</i>), со всеми объясненными макросами,
доступно в <a href="http://cm.bell-labs.com/sys/doc/troff.html">html</a>, <a href="http://cm.bell-labs.com/sys/doc/troff.ps">PostScript
(ps, 760K)</a> или в <a href="http://cm.bell-labs.com/sys/doc/troff.pdf">Portable
Document Format (pdf, 240K)</a>. AT&T Bell Labs сделали его общедоступным. Не
забудьте проверить <a href="http://www.kohala.com/start/">домашнюю страницу W.
Richard Steven</a> (известный по книге <i>Unix Network Programming</i>, а также
по трилогии <i>TCP/IP Illustrated</i>), который также имеет список ресурсов по
<a href="http://www.kohala.com/start/troff/troff.html">Troff Resources</a>, включающий
tbl, eqn, pic и др.
<p><a name="q5"></a><b><font size=+1>5) Какие препроцессоры я могу использовать?</font></b></p>
<p>Groff идет, с минимум, тремя препроцессорами - tbl, eqn, и pic (на некоторых
  системах они называются - gtbl, geqn и gpic). Их цель - транслировать макрокоманды
  препроцессора и данные для troff. Tbl - табличный препроцессор, eqn - препроцессор
  для выражений и pic - препроцессор изображений. Пожалуйста, обратитесь к руководству,
  за более детальной информацией и описанием возможностей, которые они обеспечивают.
  Чтобы обезопасить себя: не пишите руководства, требующие ЛЮБЫЕ препроцессоры.
  Eqn будет вообще делать ужасный вывод для текстовых устройств, к сожалению,
  в 99% случаев руководства просматриваются на таких устройствах. Например, XAllocColor.3x
  использует несколько формул с экспонентами. Из-за характера таких устройств,
  экспонента будет на той же самой строке, что и основание. N в квадрате - 'N2'.
  Tbl необходимо избегать, потомучто все программы xman, которые я видел, сбоили
  с ним. Xman 3.1.6 использует следующие команды для форматирования руководств,
  напр. signal(7): </p>
<p><tt>gtbl /usr/man/man7/signal.7 | geqn | gtbl | groff -Tascii -man /tmp/xmana01760
  2&gt; /dev/null</tt> </p>
<p>которые разворачивают источник, используя gtbl, gtbl выводит снова в gtbl. 
 В результате получается руководство без вашей таблицы. Я не знаю - это ошибка 
 или особенность, что gtbl подавляет свой собственный вывод или если бы xman был 
 бы &quot;умнее&quot;, он не использовал бы gtbl дважды... Так или иначе, если 
 вы хотите иметь таблицу, форматируйте ее непосредственно в тексте и поместите 
 между строками .nf и .fi, чтобы к ней не применялось форматирование. У вас не 
 будет жирного шрифта или курсива при использовании этого способа, но он позволит 
 вам получить таблицу. Я должен все-таки увидеть руководство, использующее препроцессор 
 pic. Но я не хотел бы этого.</p>
<p><a name="q6"></a><b><font size=+1>6) Как я должен распространять готовое руководство?</font></b></p>
<p>Позвольте мне собрать доводы за (+) и против (-) из нескольких отобранных возможностей:
</p>
<ol>
  <li>Только источник:<br>
    + небольшой дистрибутивный пакет.<br>
    - недоступно на системах без groff. </li>
  <li>Несжатое и форматированное:<br>
    + доступно даже на системах без groff. <br>
    - пользователь не может сгенерировать файлы dvi или postscript. <br>
    - трата дискового пространства. </li>
  <li>Сжатое и форматированное: <br>
    + доступно даже на системах без groff. <br>
    - пользователь не может сгенерировать файлы dvi или postscript.<br>
    - который формат сжатия вы бы использовали? .Z? .z? .gz? Все из них? </li>
  <li>Источник и несжатый и форматированный:<br>
    + доступно даже на системах без groff.<br>
    - большой дистрибутивный пакет.<br>
    - некоторые системы ожидают сжатые отформатированные руководства.<br>
    - избыточная информация для систем с groff. </li>
</ol>
<p>IMHO лучше всего распространять только источник. Аргумент, что он не будет 
 доступен на системах без groff, не имеет значения. Более 500 руководств Linux 
 Documentation Project в виде исходных текстов. Руководства для XFree86 содержатся 
 в виде исходных текстов. Руководства от FSF идут только в виде источника. Фактически, 
 я редко видел дистрибутивы, распространяемые с отформатированными страницами 
 руководства. Если какой-то сисадмин заинтерисован в руководстве, то он сам установит 
 groff. </p>
<p><a name="q7"></a><b><font size=+1>7) Какие существуют соглашения по шрифтам?</font></b></p>
<p>Прежде всего: не используйте напрямую операторы типа \fB \fP и т.п. Используйте 
 макросы, которые принимают аргументы. Таким способом вы избежите обычного сбоя: 
 забыть сменить типа шрифта в конце слова и при наличии других шрифтов продлевает 
 их использование до следующей смены шрифта. Поверьте мне, это случается чаще, 
 чем многие думают. Макрос <tt>tmac.an</tt> обеспечивает следующие типы шрифтов: 
</p>
<ul>
 <p>.B Жирный </p>
 <p>.BI Жирный чередуется с наклонным </p>
 <p>.BR Жирный чередуется с Roman </p>
 <p>.I Наклонный </p>
 <p>.IB Наклонный чередуется сжирным </p>
 <p>.IR Наклонный чередуется с Roman </p>
 <p>.RB Roman чередуется с жирным</p>
 <p>.RI Roman чередуется с наклонным</p>
 <p>.SM Малый (9/10 от нормального размера)</p>
 <p>.SB Малый чередуется с жирным</p>
</ul>
<p>X чередуется с Y, в этом случае, нечетные параметра набраны шрифтом X, а четный 
 - шрифтом Y. Например: </p>
<ul>
 <p>.BI &quot;Arg 1 - жирный, &quot; &quot;Arg 2 - наклонный, &quot; &quot;и жирный,
  &quot; &quot;и наклонный.&quot; </p>
</ul>
<p>Двойные кавычки необходимы, чтобы включить пробелы в аргументы; без них не 
 будет пробелов между чередующимися шрифтами. Фактически, вам будут нужны только 
 макросы для чередующихся шрифтов для того, чтобы при смене шрифта не было незаполненого 
 пространства. Ниже описано то, как использовать различные шрифты: (часть взято 
 из man(7)) </p>
<p>Хотя имеется множество разных соглашений для руководств в мире UNIX, существуют 
 сотни руководств для Linux определяющие наши стандарты: для функций, аргументы 
 всегда записаны наклонным шрифтом, даже в разделе SYNOPSIS, где остальная часть 
 функции выводится жирным шрифтом: </p>
<ul>
  <p>.BI &quot;myfunction(int &quot; argc &quot;, char **&quot; argv ); </p>
</ul>
<p>Имена файлов всегда выводятся наклонным шрифтом, исключая раздел SYNOPSIS, 
 где для них используется жирный шрифт. Т.е., вы должны использовать: </p>
<ul>
  <p>.I /usr/include/stdio.h </p>
</ul>
<p>и </p>
<ul>
  <p>.B #include &lt;stdio.h&gt; </p>
</ul>
<p>Специальные макросы, которые обычно записываются в верхнем регистре, выводятся
 жирным шрифтом: </p>
<ul>
  <p>.B MAXINT </p>
</ul>
<p>В списке кодов ошибок: коды выводятся жирным шрифтом. Этот список обычно использует
 .TP (параграф): </p>
<ul>
  <p>.TP<br>
    .B EBADF<br>
    .I fd is not a valid file descriptor.<br>
    .TP <br>
    .B EINVAL <br>
    .I fd is unsuitable for reading <br>
  </p>
</ul>
<p>Любые ссылки на другие руководства (или на другие темы в данном руководстве)
 выводятся жирным шрифтом. Если дается номер раздела, то он выводится шрифтом
 roman:</p>
<ul>
  <p>.BR man (7)</p>
</ul>
<p>Акронимы смотрятся лучше всего, когда набраны мелким шрифтом. Т.е., я рекомендую:</p>
<ul>
  <p>.SM UNIX </p>
  <p>.SM ASCII</p>
  <p>.SM TAB </p>
  <p>.SM NFS</p>
  <p>.SM LALR(1)</p>
</ul>
<p><a name="q8"></a><b><font size=+1>8) Как мне сделать руководство безупречным?</font></b> 
</p>
<p>Ниже даны некоторые правила, которые обеспечивают надежность, удобочитаемость 
 и &quot;форматируемость&quot; вашей документации.</p>
<ul>
 <li>Сделайте проверку орфографии. </li>
 <li>Протестируйте ваше руководство: Выдает ли groff ошибки, когда форматирует
  ваше руководство? Желательно иметь команду groff в коментариях. Выдает ли команда
  man(1) ошибки, когда вы вызываете 'man ваша_программа'? Правильно ли выглядит
  отформатированная страница? Работают ли xman(1x) и tkman(1tk) с вашим руководством?
  XFree86 3.1 имеет xman 3.1.6 - X11R6, он будет пробовать использовать несжатое
  руководство <br>
  <tt>gzip -c -d &lt; %s &gt; %s <br>
  zcat &lt; %s &gt; %s </tt></li>
 <li>Способен ли makewhatis(8) извлекать описание из раздела NAME? </li>
</ul>
<p><a name="q9"></a><b><font size=+1>9) Как получить простое текстовое руководство, 
 без лишних элементов?</font></b></p>
<p>Взгляните на <tt>col</tt>(1), <tt>col </tt>способен отфильтровывать экранирующие 
 последовательности. Проверьте: </p>
<p><tt>funnyprompt$ groff -t -e -mandoc -Tascii manpage.1 | col -bx &gt; manpage.txt</tt>
</p>
<p>Ключи -t и -e сообщают groff об использовании препроцессоров tbl и eqn. В этом 
 случае будет немного задерживаться вывод для страниц, которым не требуется такая 
 обработка. С другой стороны, отказ от использования -t, когда это требуется, 
 вредит: таблицы будут неправильно отформатированы. Вы можете даже выяснить, какая 
 команда необходима для форматирования страницы:</p>
<p><tt>funnyprompt$ grog /usr/man/man7/signal.7 groff -t -man /usr/man/man7/signal.7
  </tt></p>
<p>&quot;Grog&quot; замещает &quot;GROff Guess&quot;, и делает то, что говорит 
 guess. В этой работе я привожу небольшой скрипт на perl, который удаляет верхние 
 и нижние колонтитулы. Сохраните его под именем strip-headers и выполните chmod 
 755. </p>
<pre>    #!/usr/bin/perl -wn
    #  обработка всего файла:
    undef $/;
    #  удаление верхнего колонтитула:
    s/^\n*.*\n+//;
    #  удаление нижнего колонтитула:
    s/\n+.*\n+$/\n/g;
    #  удаление разрывов страниц:
    s/\n\n+[^ \t].*\n\n+(\S+).*\1\n\n+/\n/g;
    #  сворачивание двух и более пустых строк в одну:
    s/\n{3,}/\n\n/g;
    #  смотрите что осталось...
    print;
</pre>
<p>Используйте скрипт в качестве первого фильтра после команды 'man', поскольку
 он обрабатывает то, что выводится после groff. Например: </p>
<p><tt>funnyprompt$ man bash | strip-headers | col -bx &gt; bash.txt</tt> </p>
<p><a name="q10"></a><b><font size=+1>10) Как получить руководство в формате PostScript?</font></b></p>
<p><tt>funnyprompt$ groff -t -e -mandoc -Tps manpage.1 &gt; manpage.ps</tt> </p>
<p>Отпечатайте или просмотрите это руководство, используя ваш любимый принтер/просмотрщик 
 PostScript. См. <a href="Man-Page.html#q9">вопрос 9)</a> для уточнения опций.</p>
<p><a name="q11"></a><b><font size=+1>11) Как заставить работать 'apropos' и 'whatis'? 
 </font></b></p>
<p>Предположим, что вы задались вопросом - какие компиляторы установлены на вашей 
 системе, и как они могут быть вызваны. Чтобы ответить на первый вопрос, выполните 
 команду:</p>
<p><tt>funnyprompt$ apropos compiler<br>
  </tt>f77 (1) - Fortran 77 compiler <br>
  gcc (1) - GNU C and C++ compiler<br>
  pc (1) - Pascal compiler</p>
<p>Apropos и whatis используются, чтобы дать быстрый ответ, на который имеется 
 информация в руководствах. Обе программы отыскивают файлы, называемые 'whatis', 
 которые могут находиться в любом основном каталоге руководств. Прежде я говорил, 
 файлы whatis содержат строки в каждой из которых содержится запись для любой 
 страницы руководства из соответствующего каталога. Фактически, эта строка берется 
 из раздела NAME (буду точнее: все строки раздела соединены в одну строку, также 
 записано обозначение раздела в круглых скобках после имени руководства). Файлы 
 whatis созданы с помощью программы makewhatis(8). Имеются разные версии программы, 
 поэтому посмотрите руководства для уточнения доступных опций этой программы. 
 Для makewhatis, способного извлекать информацию из раздела NAME, важно, чтобы 
 вы правильно записывали информацию в этот раздел, твердо придерживаясь формата 
 этого раздела, описанного в <a href="Man-Page.html#q2">вопросе 2)</a>. Существуют различия 
 между apropos и whatis. Apropos (эквивалентен <tt>man -k</tt>) занимается поиском 
 запроса в любой части строки, а whatis (<tt>man -f</tt>) ищет только целое слово. 
 Следовательно, '<tt>whatis cc</tt>' сообщит есть ли руководство по cc и ничего 
 не скажет о gcc.</p>
<center>
  <p> Исправления и комментарии приветствуются! </p>
</center>
<P><A NAME="copying"></A><B><FONT SIZE=+1>A) Copying conditions </FONT></B></P>

<P>Copyright 1995-2000 by Jens Schweikhardt <A HREF="mailto:schweikh@noc.dfn.de">&lt;schweikh@noc.dfn.de&gt;</A>
</P>

<P>Voice: ++49 7151 909516</P>

<P>Unless otherwise stated, Linux HOWTO documents are copyrighted by their
respective authors. Linux HOWTO documents may be reproduced and distributed
in whole or in part, in any medium physical or electronic, as long as this
copyright notice is retained on all copies. Commercial redistribution is
allowed and encouraged; however, the author would like to be notified of
any such distributions. All translations, derivative works, or aggregate
works incorporating any Linux HOWTO documents must be covered under this
copyright notice. That is, you may not produce a derivative work from a
HOWTO and impose additional restrictions on its distribution. Exceptions
to these rules may be granted under certain conditions; please contact
the Linux HOWTO coordinator at the address given below. In short, we wish
to promote dissemination of this information through as many channels as
possible. However, we do wish to retain copyright on the HOWTO documents,
and would like to be notified of any plans to redistribute the HOWTOs.
If you have questions, please contact the Linux HOWTO coordinator,
Tim Bynum, at
<A HREF="mailto:linux-howto@sunsite.unc.edu">linux-howto@sunsite.unc.edu</A>
via email. </P>
<hr>
<h3>Авторские права</h3>
<p>Авторские права на русский перевод этого
текста принадлежат © 2000 SWSoft Pte Ltd. Все права
зарезервированы.</p>
<p>Этот документ является частью проекта Linux
HOWTO.</p>
<p>Авторские права на документы Linux HOWTO
принадлежат их авторам, если явно не
указано иное. Документы Linux HOWTO, а также их
переводы, могут быть воспроизведены и
распространены полностью или частично на
любом носителе физическом или электронном,
при условии сохранения этой заметки об
авторских правах на всех копиях.
Коммерческое распространение разрешается
и поощряется; но так или иначе автор текста
и автор перевода желали бы знать о таких
дистрибутивах.</p>
<p>Все переводы и производные работы,
выполненные по документам Linux HOWTO должны
сопровождаться этой заметкой об авторских
правах. Это делается в целях предотвращения
случаев наложения дополнительных
ограничений на распространение документов
HOWTO. Исключения могут составить случаи
получения специального разрешения у
координатора Linux HOWTO с которым можно
связаться по адресу приведенному ниже.</p>
<p>Мы бы хотели распространить эту
информацию по всем возможным каналам. Но
при этом сохранить авторские права и быть
уведомленными о всех планах
распространения HOWTO. Если у вас возникли
вопросы, пожалуйста, обратитесь к
координатору проекта Linux HOWTO по электронной
почте: <tt CLASS="EMAIL">&lt;<a HREF="mailto:linux-howto@metalab.unc.edu">linux-howto@metalab.unc.edu</a>&gt;</tt>,
или к координатору русского перевода Linux HOWTO
компании SWSoft Pte Ltd. по адресу <tt CLASS="EMAIL">&lt;<a HREF="mailto:linux-howto@asplinux.ru">linux-howto@asplinux.ru</a>&gt;</tt></p>
</body>
</html>
