<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<TITLE>Руководство: Как создать домашнюю компьютерную сеть ИНТРАНЕТ</TITLE>
</HEAD>


<!-- The following are instructions to customize this web page -->
<!-- <BASE HREF="http://www.linux.org">  -->


<BODY>
<H1><CENTER>Руководство: Как создать домашнюю компьютерную сеть ИНТРАНЕТ</CENTER></H1>
<H2><CENTER>Автор: Sarma Seetamraju<BR>
    электронный адрес: (<a href="mailto:sarma@usa.net">sarma@usa.net</a>)<br>
Перевод: <a href="mailto:sam@asp-linux.com">Станислав Рогин</a>,
<a href="http://www.asp-linux.com">SWSoft Pte Ltd.</a><BR>
    Дата: Август 1997</CENTER>
</H2>
<H3>Место: убивая время в поезде "Amtrack & Path&quot;, по дороге в пригород Манхэттен.<BR>
На компьютере: ноутбук Magnavox 1991 года 386 SX 16МГц, работающем с linux.<BR>
        (Если после этого вы только заикнетесь, что вот именно на ВАШЕМ компьютере <BR>
         не работает Linux, то я запихаю вам ваш компьютер, угадайте куда .... )<BR>
</h3>
<H4>Перенесено в HTML для: Всех ненормальных людей, которые не могут читать обычный текст.</H4>

<H2>            ВНИМАНИЕ: SOCKS - СВОБОДНО распространяемый комплект под UNIX-системы.
                           Я очень сомневаюсь, что он существует для ДРУГИХ платформ.
                           Если вы хотите, чтобы NETSCAPE продолжал поддерживать SOCKS,
                           то присылайте мне убедительные аргументы в их пользу
                           (с примерами того, как вы использовали SOCKS).
</H2>

<HR>

Этот документ описывает необходимые процедуры для создания сети ИНТРАНЕТ
у вас дома. Далее мы настроим эту сеть так, что на любых компьютерах в ней для доступа в интернет можно будет использовать
обозреватель NETSCAPE.<P>

Сеть, которую мы будем создавать, представляет из себя следующее:
<UL>
        <LI>Несколько (два или больше) компьютеров...
        <LI>ОДИН (ТОЛЬКО ОДИН!) компьютер с установленным Linux
        <LI>Остальные компьютеры - с Win95 или WinNT.
                (Не думаю, что была бы какая-нибудь разница, если бы это были MACintosh).

        <LI>ТОЛЬКО компьютер с LINUX имеет PPP-доступ в интернет. Другие
        машины, конечно, тоже МОГУТ иметь модемы. Но мы их здесь не рассматриваем.

                <LI>Если у вас будет, хотя бы ОДНА машина-клиент с UNIX, то, возможно, вам надлежит
                обратиться к документации по пакету &quot;sockd&quot;, ибо вам придется
                использовать команды &quot;rlogin&quot;, &quot;ftp&quot; и т.п...
                под UNIX-клиентом.  В этом случае данный документ вам не поможет ничем.

        <LI>Протоколом сети будет TCP/IP для ethernet. Никаких netbeui и т.п....
</UL>

<STRONG><EM>К единственному компьютеру с linux мы будем обращаться как к 
&quot;СИСТЕМЕ LINUX&quot;, а остальные компьютеры будем называть 
&quot;ДРУГИЕ МАШИНЫ&quot; или &quot;КЛИЕНТЫ&quot;. 
Компьютер с linux будет также иногда называться 
&quot;СЕРВЕРОМ&quot;.</EM></STRONG>

<HR>

Если вы не понимаете содержание следующего параграфа, то вам надлежит обратиться к разделу <A HREF="Netscape+Proxy.html#NetworkingNovices">ДЛЯ НОВИЧКОВ В ОБЛАСТИ КОМПЬЮТЕРНЫХ 
СЕТЕЙ</A>.  А затем возвращайтесь обратно...<P>


Все последующее описание предполагает, что интерфейсу eth0 сервера назначен адрес IP (с помощью &quot;ifconfig&quot;).<P>

Также данное руководство нисколько не ограничивает вас в применении только протокола PPP (вы свободно можете использовать SLIP, PPTP и т.д.). Адрес IP &quot;ppp0&quot;-порта
абсолютно несущественен. Это описание лишь требует, чтоб хотя бы один такой порт был и нормально работал.<P>

<HR>

<CENTER><U>ПОЧЕМУ МЫ ИСПОЛЬЗУЕМ ТАКУЮ КОНФИГУРАЦИЮ?</U></CENTER>
<UL>
                <LI>Машина с linux используется для связи с внешним миром.
                Только linux-компьютер имеет НАСТОЯЩИЙ адрес IP. (смотри ниже).
                                (смотри далее раздел &quot;Помощь ON-LINE&quot;).
                Компьютер с linux имеет непостоянное PPP-подключение к глобальной сети.

                <LI>Остальные машины в сети имеют "несуществующие", "неправильные" 
                IP-адреса (для внешней сети).

                <LI>Для подключения к интернет можно будет использовать 
                только &quot;ДРУГИЕ КОМПЬЮТЕРЫ&quot; и только с клиентом NETSCAPE,
                а НЕ машину с linux!

                <LI>Мне, например, совсем нет необходимости использовать с &quot;других ПК&quot; программу &quot;telnet&quot;,
                или использовать FTP для прямого доступа в глобальную сеть. Если даже возникнет такая проблема,
                то ее можно решить, используя telnet сначала на машину
                с linux, и далее в глобальную сеть.
</UL>

Мне НЕ хотелось тратить много денег на ПК с linux, который не будет работать в качестве Х-сервер (и вообще запускать какие-либо Х-приложения). Поэтому я приобрел
486Dx/4 100 МГц с шиной PCI (мне не хочется возиться с ISA),
за видеокарту SVGA я уплатил 20$, еще 20$ за NE2000-совместимую сетевую карту,
и еще 20$ на кабели, терминаторы и т.п. (ибо я не знаю, как можно
в организуемой нами сейчас сети использовать концентраторы Ethernet).
<P>
90$ стоила оперативная память (по средней цене 60$ за 16 Мб), и в итоге
мы имеем прекрасно работающую linux-систему всего за 270$. Конечно, не стоит
перегружать нашу систему компьютерами с NT или другими операционными
системами, требующими много ресурсов памяти-винчестеров-процессоров.
Конечно, мой клиентский ПК - Pentium-100 с 32 Мб памяти и двумя винчестерами
(один из которых впоследствии был использован для linux-машины), работает под Win95.<P>
        Машина с linux удобно расположилась на коробке из-под пиццы. Мне 
неохота было тратить еще 50$ на корпус, тем более, что один из моих друзей 
одолжил мне блок питания для ПК.<P>

<HR>

<STRONG><EM>В качестве клиента я выбрал NETSCAPE</EM></STRONG>, так как фактически уже вручную использовать FTP не имеет смысла - это не нужно. Любая уважающая себя компания имеет WWW-сайт, который позволяет использовать навигатор Netscape для доступа к ftp-ресурсам. Конечно, регулярно бывает необходимо попользовать telnet, но можно
пережить начальный заход telnet-ом с машин win95/winNT4.0 на ПК с linux... Далее, я завязан на использовании QuickTime и всяких прочих сетевых аудио-сайтов. А версий подобных вещей для  LINUX пока не существует. Поэтому приходится запускать все эти программы под Netscape на windows-системах. Также LINUX-машина
обрабатывает электронную почту при помощи&quot;sendmail&quot; (помните, что у нас фиксированный адрес IP. Такой постоянный адрес IP хорош ТОЛЬКО для вещей подобных обработке электронной почты. Никакой особой выгоды при серфинге в интернет, работы с telnet и т.п....)<P>

Наконец, мы точно никогда не увидим &quot;Microsoft Internet Explorer&quot; для linux - поэтому я даже и не думаю об использовании Explorer в нашей сети. Также, что-то внутри мне подсказывает, что настроить Explorer было
бы очень НЕПРОСТО, по сравнению с настройкой NETSCAPE на машинах-клиентах (то есть других машинах).

<HR>

<A NAME="ProxyServer"><H3>ПРОКСИ-сервер</H3></A><P>
        Я не даю указаний по установке ПРОКСИ-сервера.
                Главное - установить пакет &quot;socks&quot; под машину с LINUX,
с помощью которого NETSCAPE на остальных машинах сможет использовать интернет.

NETSCAPE (насколько я знаю) сейчас ЕДИНСТВЕННАЯ программа для НЕ-UNIX машин,
которая поддерживает SOCKS.

<HR>

<A NAME="InternetAddresses"><H3>Адреса ИНТЕРНЕТ</H3></A><P>
  Если у вас уже есть сеть на TCP/IP, то уже ДОЛЖНЫ быть ПО МЕНЬШЕЙ МЕРЕ два IP-адреса для компьютеров (один для LINUX-машины и другой для машины-клиента, или даже еще больше IP-адресов - если у вас более чем одна
клиентская машина).<P>
        О том, как назначить IP-адреса в TCP/IP сети ВСЕМ вашим компьютерам, читайте в других Руководствах.  (ОСОБЕННО, ЕСЛИ У ВАС НЕТ зарегистрированного ИНТЕРНЕТ-домена).<P>
        Я создал сеть с адресами 10.0.1.x для одной машины LINUX и одной машины с Win95. Им соответственно были назначены адреса 10.0.1.1 и 10.0.1.2. Адрес 10.0.1.1 - это IP-адрес порта ETHERNET (eth0) на LINUX-машине. Порт ppp0 имеет другой адрес IP (который [как мне повезло] имеет фиксированный адрес IP). ЭТОТ IP несущественен в данном описании, а также не упоминается, в целях безопасности.<P>

На другом конце моего PPP-соединения стоит университетский сервер с фиксированным доменным именем.<P>

На машине с linux стоит модем и с помощью CRONTAB - он автоматически подключается к интернет в определенное время. Также (при необходимости) я
могу подключиться к интернет вручную.<P>

Если вы подключаетесь к интернет через системы ON-LINE, то смотрите следующий раздел...

<HR>

<A NAME="OnLineServices"><H3>Системы ON-LINE</H3></A><P>
 Если вы подключаетесь к интернет через ON-LINE системы, такие как AOL, Compuserve, Sprynet, Netcom и т.д..., то тогда у вас может и НЕ БЫТЬ фиксированного IP-адреса. Это доставит немного неудобств, но, тем не менее, ваша интрАнет-сеть будет связана с внешним миром. Если вы мне не верите, то прошу - дочитайте руководство до конца... и поверьте....

<HR>

<A NAME="SomeBackgroundInfo"><H3>Несколько отступлений</H3></A><P>
(Для тех, кто по природе таков, как я, и кому интересно, что же тут происходит...).  Остальные могут пропустить этот раздел....

<OL>
<LI>  ... так как у нас имеется ТОЛЬКО одна сеть ethernet, вам НЕТ необходимости обеспечивать маршрутизацию внутри сети.  Возможно, вы уже вручную назначили IP-адреса ВСЕМ вашим компьютерам ( 10.0.1.1, 10.0.1.2 ) в /etc/hosts. Если вы это сделали, то вы, наверняка, очень умный человек. Так делать в домашней сети из двух или трех компьютеров - все равно, что использовать
  бульдозер, вместо обеденной ложки...

<LI>  В идеальном случае, желательно, чтобы ВСЕ IP-пакеты с клиентских машин шли на LINUX, который затем их бы правильно перенаправлял. Тут проблема может быть только в том, что такой компьютер легко подвергается хакерским атакам, ибо, если LINUX-машина обеспечивает маршрутизацию, то у вас НЕТ "firewall" или "proxy" или еще чего-то подобного.
  Следуя данному руководству, мы непреднамеренно! создаем
  &quot;firewall&quot;, во время попытки дать навигатору NETSCAPE доступ в интернет с клиентских машин.<P>
        Единственная проблема с такой &quot;маршрутизацией&quot; с linux-машины состоит в том, что клиенты ДОЛЖНЫ в действительности ПОСЫЛАТЬ ВСЕ пакеты на linux, неважно, на какой адрес эти пакеты идут. В таком случае с Win95 и WinNT можно использовать ТОЛЬКО &quot;proxy сервер&quot; ("Руководство" о работе с ним мне еще предстоит написать).

<LI>  ЕСЛИ вы свободно работаете с разнообразными утилитами, то вы наверняка
           слышали о пакете &quot;term&quot;.  Он был разработан для простого конфигурирования
сетей, будучи &quot;простым&quot; пользователем, а НЕ администратором (ROOT/ADMIN) -
и на сервере, и на клиентских машинах.  Подобную логику действий можно распространить и на использование NETSCAPE
на клиентских машинах. Ведь, в принципе, легко всего лишь ДАТЬ навигатору доступ в интернет, а
остальные возможности (FTP, TELNET) не реализовывать.

<LI> Если вы считаете, что ДОСТАТОЧНО дать доступ навигатору Netscape в интернет
           и НЕ разрешать использовать telnet / ftp с машин-клиентов, то вы сущий
           динозавр. Проснитесь, мистер-мисс Rip Van Winkle.

<LI> (ТЕХНИЧЕСКОЕ) Использование возможности вручную назначать (&quot;поименованно&quot;) IP-адреса, которая должна было быть незадействована (как упоминалось выше)
           будет использоваться для поддержки NETSCAPE (так, чтобы адреса типа http:/www.sex.org
могли быть нормально доступны с машин-клиентов).

<LI>  (ТЕХНИЧЕСКОЕ) Вам придется ПЕРЕСОБРАТЬ ядро LINUX для отключения пересылки IP-пакетов (IP forwarding). Позже я попробую пересобрать у себя ядро с включенной данной опцией,
и пакеты &quot;socks&quot; будут работать (а я полагаю, что так и будет).  Если
все будет нормально, то тогда вы точно увидите новую версию данного документа.
        (Что это означает - то, что тогда вы сможете использовать основную версию своего ядра,
установленную программой инсталляции).

<LI> Вам будет необходим доступ АДМИНИСТРАТОРА (ROOT) к linux-машине :-)
           так как будет необходимо скачать пакет "socks" и ОТКОМПИЛИРОВАТЬ его.
           Он НЕ будет сразу нормально компилироваться, ибо MAKE-файл в пакете поставки поврежден.

<LI> (ТЕХНИЧЕСКОЕ) Будьте готовы подредактировать файл socks.c, для закомментирования
           ВСЕГО двух строк, которые помещают в файл журналов (/var/adm) информацию
о каждой пересылке данных через socks. Например: простая страничка на WWW.CNN.COM
имеет по меньшей мере 10 картинок и около 5 отдельных текстовых объектов.  Для каждого из
них вы получите строку в файле журнала.  Лично мой файл журналов переполняется.  И мне это совсем НЕ нравится.  Хотя, возможно, вы об этом и не думаете.

<LI> Пакет "sockd" необходим ТОЛЬКО для машин-КЛИЕНТОВ.  ВСЕ приложения на
        LINUX-машине НЕ НУЖДАЮТСЯ в этом пакете, или еще в чем-то для доступа в
        интернет, ибо наша LINUX-машина подключается к интернет напрямую,
        используя PPP.
</OL>

<HR>

<A NAME="PreparingYourLinuxMachine"><H3>ПОДГОТАВЛИВАЕМ LINUX-КОМПЬЮТЕР</H3></A><P>
Читайте "Руководство по использованию Сети" на <TT>/usr/doc/faq/howto</TT>   на вашей linux-машине (если у вас стоит slakware-версия), или отправляйтесь на <TT>www.linux.org</TT> и там читайте это
же руководство (NET-HOW-TO) там...<P>

Теперь вам необходимо скачать и скомпилировать пакет socks.
Перед этим НЕОБХОДИМО ПРОЧИТАТЬ инструкции по установке и настройке домашней сети.
Но, в принципе, можно читать и ЭТО описание :-) .<P>

В сопроводительном документе к пакету будет много написано о том, как настроить UNIX-клиенты.  Особенно для &quot;rlogin&quot; &quot;telnet&quot; &quot;ftp&quot; и т.п....  Если у вас нет UNIX-клиентов, то после компиляции пакета SOCKS прочтите ДАННОЕ руководство сначала, так
как необходимо будет использовать SOCKS немного не так, как написано в руководстве к пакету.<P>

Я поместил tar-архив в каталог <TT>/usr/local/ProxyServer</TT>, распаковал, создав каталог &quot;sockd4.2b&quot;, внутри
которого и лежит файл для компиляции (&quot;Makefile&quot;). Как уже упоминалось выше, необходимо немного помучиться, чтобы успешно скомпилировать
данный MAKEFILE.<P>

<HR>
        <CENTER>Для вашего удобства в <A HREF="Netscape+Proxy.html#SockdMakefile">КОНЦЕ</A> данного руководства приведен мой MAKEFILE.<P>
                Надо надеяться, что вам придется поменять в нем только строку #9.</CENTER>
<HR>

Итак, затем я переместил содержимое нового "sockd"-каталога на один уровень вверх,
поменял содержание строки # 9 и запустил компиляцию по новой -- на этот раз успешно. На этом &quot;починку&quot; нашего MAKEFILE считаем оконченной.

<HR>

<A NAME="SettingUpSockd"><H3>Настройка sockd</H3></A><P>
В каталоге sockd вы найдете исполняемый файл &quot;sockd&quot;.<P>

<PRE>
Как только вы закончите компиляцию, <EM>СКОПИРУЙТЕ следующие файлы в </EM> <TT>/usr/local/etc</TT>
(Они ДОЛЖНЫ быть в том же каталоге sockd)
        sockd                   (Исполняемый файл, т.н. демон)
        sockd.conf              (файл конфигурации)
        sockd.route             (файл конфигурации)
        socks.conf              (файл конфигурации)

# ### создайте сслыку с названием &quot;socks&quot;, которая указывает на &quot;sockd&quot; в том-же каталоге.
# cd /usr/local/etc
# ln -s sockd socks
</PRE>

Далее отредактируйте эти три файла конфигурации так, чтобы их содержимое соответствовало нижеприведенным примерам (это мои настройки для сети из двух компьютеров, состоящей из LINUX-&quot;сервера&quot;  и Win95/WinNT машины-клиента).

<HR>

<A NAME="MySockdConfFile"><H3>Мой файл sockd.conf</H3></A>
<PRE>
<NOBR>
permit  10.0.1.2    0.0.0.0
deny    0.0.0.0 0.0.0.0 : /usr/ucb/finger @%A | /usr/ucb/mail -s 'SOCKD: rejected -- from %u@%A to host %Z (service %S)' root
#BAD_ID: /usr/ucb/finger @%A | /usr/ucb/mail -s '%U pretends to be %u on host %A' root@%A root
#NO_IDENTD: /usr/ucb/mail -s 'Please run identd on %A' %u@%A root@%A
#[EOF]
</NOBR>
</PRE>

<STRONG>ПРИМЕЧАНИЕ</STRONG>:   10.0.1.2 - это IP-адрес моей Win95/WinNT-машины-клиента.  Этот файл sockd.conf ДОЛЖЕН присутствовать на сервере LINUX (в моем случае, порту ethernet сервера LINUX был назначен IP-адрес = 10.0.1.1)<P>

<STRONG>ПРИМЕЧАНИЕ</STRONG>:    Пакет "sockd" необходим ТОЛЬКО для машин-КЛИЕНТОВ. ВСЕ приложения на LINUX-машине НЕ НУЖДАЮТСЯ в этом пакете, либо еще в чем-то, для доступа в интернет, ибо наша LINUX-машина подключается к интернет напрямую, используя PPP.<P>
 
<HR>

<A NAME="MySocdRouteFile"><H3>Мой файл sockd.route</H3></A>
<PRE>
#! NoShell 
10.0.1.1        10.0.1.0        255.255.255.0
#[EOF]
</PRE>

<STRONG>ПРИМЕЧАНИЕ</STRONG>: Первый IP-адрес - это адрес ПОРТА eth0 сервера LINUX.  Второй номер - это НЕ АДРЕС IP -- это адрес СЕТИ (для простоты, последний из четырех номеров IP-адреса должен быть НУЛЕМ).

<HR>

<A NAME="SocksConfFile"><H3>Мой файл socks.conf</H3></A>

<PRE>
direct  127.0.0.1       255.255.255.255
direct  10.0.1.1        255.255.255.255
direct  10.0.1.2        255.255.255.255
sockd   @=199.99.99.99  10.0.1.1 0.0.0.0
</PRE>

<HR>
<HR>
<HR>

<A NAME="ConfigureLinuxMachine"><H3>Настройка LINUX-компьютера</H3></A>

<UL>
<LI><STRONG>Шаг # 1:</STRONG>  Проверьте, не используете ли вы &quot;named&quot;.  Если вы пользуетесь этим - то на свой страх и риск.  Если вы не очень хорошо знаете методику работы с DNS, то вы, возможно, не сможете применить содержимое этого документа для ваших нужд.
<LI><STRONG>Шаг # 2:</STRONG>  Скопируйте файл &quot;named.boot&quot;, приведенный ниже, на ваш компьютер.
<LI><STRONG>Шаг # 3:</STRONG>  Скопируйте файл &quot;root.cache&quot;, приведенный ниже, на ваш компьютер (следуйте инструкции к этому файлу).
</UL>

<HR>

<A NAME="hostconfFile"><H3>Файл /etc/host.conf</H3></A>

ВСЕ программы, запускаемые на компьютере с LINUX БУДУТ (и вы не сможете помешать этому) использовать resolver,
настройки которого находятся в файле /etc/host.conf<P>

Вы должны быть уверены, что НИ ОДНА из этих программ никогда не получит доступа к демону &quot;named&quot; на ЭТОЙ САМОЙ машине с linux.  Для этого мы определим для
сервиса имен (то есть программ, преобразующих www.cnn.com в числовой IP-адрес), что они ДОЛЖНЫ проверять сначала файл
/etc/hosts, и только затем проверять сервера DNS, указанные в файле /etc/resolv.conf<P>

Как это сделать? Просто! Проверьте, что содержимое в файла /etc/host.conf написано следующее:<P>
<PRE>
                order hosts, bind
                multi on
</PRE>
Если там что-то другое, удалите все (конечно, если вы ОЧЕНЬ много знаете о DNS и &quot;named&quot;, то тогда вы сделаете по своему).<P>

Причина, по которой я настаиваю на недопуске программ LINUX-машины к собственному &quot;named&quot;-серверу, состоит в том, что это просто не нужно.  А по моему опыту подобные &quot;ненужности&quot;, выглядящие технически и программно безопасными, могут рано или поздно причинить много неприятностей...<P>

Сервер linux отлично делает свою работу по подсоединению к internet через PPP (или тот тип связи, что присутствует у вас)   Мы дополнительно устанавливаем пакет &quot;sockd&quot; и &quot;named&quot;-демон для машин-клиентов.  И давайте больше не будем напрягать LINUX-систему.

<HR>

Вам НЕ НАДО менять файлы <TT>&quot;/etc/gateways&quot;   или   &quot;/etc/hosts&quot;  или &quot;hosts.allow&quot;   или &quot;hosts.deny&quot;</TT> для того, чтобы заставить работать socks.<P>

Не меняйте никакие файлы до тех пор, пока кто-либо не предложит что-то поменять...<P>

Я также полагаю, что вы корректно настроили &quot;resolv.conf&quot;, чтобы ваш LINUX-сервер имел доступ к internet и DNS (на &quot;другом конце&quot; соединения PPP).  Мой пример файла resolv.conf вы можете увидеть в самом конце данного руководства.<P>

<PRE><STRONG>
                ************************************************
                                ПРЕДУПРЕЖДЕНИЕ
                ************************************************
                 Для вашей собственной безопасности, я предлагаю
                менять настройки вашей системы linux только через
                системную программу конфигурации (т.е., например,
                во время установки linux на ваш компьютер)
                *************************************************
</STRONG></PRE>

<HR>

<A NAME="NamedBootFile"><H3>Мой файл named.boot</H3></A>
<PRE>
        ;    загрузочный файл для сервера имен
        forwarders 128.112.129.111
        directory /etc
        cache      .       root.cache
        primary    1.0.10.in-addr.arpa   named_DNS_for_inTi_xwk
                                         ^^^^^^^^^^^^^^^^^^^^^^
</PRE>

ПРИМЕЧАНИЕ: строка # 2 содержит IP-адрес сервера DNS сети, к которой подключается ваша LINUX-машина, используя PPP (или ему
подобную связь).

<H3>*** КАК найти этот IP-адрес ****</H3>

ЛЕГКО!   в командной строке наберите &quot;nslookup&quot;.  В выданном ответе БУДЕТ указан этот адрес IP.  (После того, как вы запишете IP-адрес сервера DNS, выйдите из &quot;nslookup&quot;, нажав клавиши &LT;CTL-D&GT;).<P>

<STRONG>ПРИМЕЧАНИЕ</STRONG>:  ПОСЛЕДНЯЯ строка содержит <STRONG>имя файла</STRONG>, называемого &quot;named_DNS_for_inTi_xwk', который ДОЛЖЕН быть в каталоге &quot;/etc&quot;.  Содержание этого файла приводится ниже (вообще-то, вы можете придумать ему более интересное название :-)   )

<HR>

<A NAME="namedDNSforIntiFile"><H3>Мой файл &quot;named_DNS_for_inTi_xwk&quot;</H3></A>
<PRE>
@               IN      SOA     10.0.1.0 hostmaster.10.0.1.0 (
                                1       ; Серийный
                                28800   ; Обновление
                                7200    ; Повтор
                                604800  ; Окончание
                                86400)  ; Минимальное TTL
                        NS      10.0.1.1
1                       PTR     MyLinuxMachine
</PRE>

<STRONG> ПРИМЕЧАНИЕ</STRONG>: Последняя строка (начинающая с 1) содержит имя &quot;MyLinuxMachine&quot;. Замените его строкой из /etc/HOSTNAME.

<STRONG> ПРИМЕЧАНИЕ</STRONG>: Также, если вы уж зашли настолько далеко, то поменяйте &quot;10.0.1.1&quot; на адрес порта eth0 вашей LINUX-машины, и замените &quot;10.0.1.0&quot; на сетевой адрес этого порта.&nbsp;

<STRONG> <br>
 ПРИМЕЧАНИЕ</STRONG>: Лично я до сих пор не понимаю всех вещей из вышеописанных файлов.  Для удовлетворения вашего любопытства вам придется изучить много документации по демону NAMED.

<HR>

<A NAME="RootCacheFile"><H3>Мой файл root.cache</H3></A><P>
<EM>
Для создания этого файла внимательно читайте руководство по настройке сетей (NET-HOW-TO) и сопровождающую документацию к пакету socks.<P>
Эти инструкции ОЧЕНЬ просты...<P>
Все, что мне надо было сделать, это запустить команду, указанную там, а полученную информацию перенаправить в файл и назвать его <TT>&quot;/etc/root.cache&quot;</TT><P>
</EM>

<PRE>
; &lt;&lt;&gt;&gt; DiG 2.1 &lt;&lt;&gt;&gt; ns 
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 6
;; flags: qr rd ra; Ques: 1, Ans: 9, Auth: 0, Addit: 9
;; QUESTIONS:
;;      ., type = NS, class = IN

;; ANSWERS:
.       137030  NS      C.ROOT-SERVERS.NET.
.       137030  NS      D.ROOT-SERVERS.NET.
.       137030  NS      E.ROOT-SERVERS.NET.
.       137030  NS      I.ROOT-SERVERS.NET.
.       137030  NS      F.ROOT-SERVERS.NET.
.       137030  NS      G.ROOT-SERVERS.NET.
.       137030  NS      A.ROOT-SERVERS.NET.
.       137030  NS      H.ROOT-SERVERS.NET.
.       137030  NS      B.ROOT-SERVERS.NET.

;; ADDITIONAL RECORDS:
C.ROOT-SERVERS.NET.     410161  A       192.33.4.12
D.ROOT-SERVERS.NET.     410161  A       128.8.10.90
E.ROOT-SERVERS.NET.     410161  A       192.203.230.10
I.ROOT-SERVERS.NET.     167767  A       192.36.148.17
F.ROOT-SERVERS.NET.     410161  A       192.5.5.241
G.ROOT-SERVERS.NET.     410161  A       192.112.36.4
A.ROOT-SERVERS.NET.     410161  A       198.41.0.4
B.ROOT-SERVERS.NET.     410161  A       128.9.0.107
H.ROOT-SERVERS.NET.     410161  A       128.63.2.53

;; Total query time: 334 msec
;; FROM: svathyam to SERVER: default -- 128.112.129.111
;; WHEN: Sat Sep 28 21:38:04 1996
;; MSG SIZE  sent: 17  rcvd: 312
</PRE>

<HR>

<A NAME="EtcServicesFile"><H3>Добавьте это в /etc/services</H3></A><P>

(добавьте единственную строку начинающуюся с &quot;socks&quot;...)
<PRE>
# services      This file describes the various services that are
#               available from the TCP/IP subsystem.  It should be
#               consulted instead of using the numbers in the ARPA
#               include files, or, worse, just guessing them.
# Version:      @(#)/etc/services       3.02    02/21/93
# Author:       Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>

... &amp;LT;lines delete&amp;GT;

socks           1080/tcp                        # sarma: Sep.15.96: Получено из файла ~sockd/include/socks.h

... &amp;LT;lines delete&amp;GT;

# End of services.
</PRE>


<STRONG>ПРИМЕЧАНИЕ</STRONG>: по-моему, эта строка считывается ТОЛЬКО демоном "inetd".  Она указывает inetd включить программу &quot;socks&quot; для всех tcp-соединений  к порту # 1080.

<HR>

<A NAME="INETD.CONFfile"><H3>Добавьте это в файл /etc/inetd.conf</H3></A>

<PRE>
        # Я всего-лишь следую инструкциям из руководства к ~sockd/doc/sockd.1 ...
        socks   stream  tcp     nowait  root    /usr/local/etc/socks
</PRE>

<UL>
<LI>ПРИМЕЧАНИЕ: Убедитесь, что путь /usr/local/etc есть по умолчанию в переменной PATH системы.
<LI>ПРИМЕЧАНИЕ: Для более подробных инструкций читайте файлы документации к пакету SOCKD.
<LI>ПРИМЕЧАНИЕ: Как следует из названия файла, он указывает демону &quot;inetd&quot;, где тот может найти программу &quot;socks&quot;, и какие параметры необходимо постоянно ей передавать и т.п....
</UL>

<HR>
<HR>
<HR>

<A NAME="LetsGetStarted"><H3>НУ ЧТО, НАЧНЕМ РАБОТУ!</H3></A>

Теперь перезагрузим вашу систему (если вы знаете как, то можете просто послать "HUP" демонам).  Ваш LINUX-сервер готов к работе.<P>

Исполните <TT>&quot;tail -f /var/adm/messages&quot;  и одновременно &quot;tail -f /var/adm/syslog&quot;</TT> и попытайтесь присоединиться к интернет навигатором NETSCAPE с машины-клиента.<P>

        Теперь давайте настроим навигатор Netscape на машинах-клиентах...

<HR>

<A NAME="ConfiguringNetscapeClient"><H3><CENTER>Настройка клиента NETSCAPE 3.0</CENTER></H3></A>

<CENTER>Это ДОЛЖНО быть сделано ТОЛЬКО на машинах-клиентах!<BR>
НЕ НАДО пытаться делать все это на сервере LINUX.</CENTER><P>

<UL>
<LI>Вызовите меню &quot;настройки (options)&quot; в Netscape-навигаторе.
<LI>Выберите &quot;Настройки Сети (Network Preferences)&quot;.
<LI>Вы ДОЛЖНЫ увидеть диалоговый экран (новое окно) с &quot;КНОПКАМИ&quot; (либо пунктами меню)...
<LI>Одна из этих &quot;кнопок&quot; будет обозначена &quot;ПРОКСИ (PROXIES)&quot;
<LI>Нажмите эту кнопку (выберите пункт меню).
<LI>Вы должны увидеть кнопку, обозначенную &quot;ручная
  настройка прокси (manual proxy configuration)&quot;, с еще одной кнопкой рядом.
<LI>Нажмите на эту кнопку для открытия еще одного диалогового окна.
<LI>В одном из вхождений в появившемся окне вам будет показано...
</UL>

<PRE>
        --------- --------------------------              --------
        | socks | |                        |              | 1080 |
        --------- --------------------------              --------
</PRE>

Это указывает на то, что netscape уже знает о наличии socks.  Все, что вам необходимо сделать, это указать NETSCAPE, где именно запускается демон socks.<P>

Введите <STRONG><TT>IP-адрес порта eth0</TT></STRONG> сервера linux в <U>среднее поле</U>, показанное выше...<P>

Сохраните эти настройки и продолжайте работу... !!<P>

<HR>
<HR>
<HR>

<A NAME="NetworkingNovices"><H3>ДЛЯ НОВИЧКОВ В ОБЛАСТИ КОМПЬЮТЕРНЫХ СЕТЕЙ</H3></A>

        Если вы уже использовали компьютеры с Win95 или WinNT для соединения к интернет через PPP, то этот документ НИЧЕМ вам не поможет.  Зачем загружать вас использованием linux для соединения с интернет, когда вы и так уже сделали это через PPP-соединение на машине-клиенте?<P>

        Если вы НЕ можете соединиться с интернет через сервер LINUX, то прекратите чтение этого руководства и ищите другие руководства по настройке LINUX-машин для PPP-соединения к интернет.<P>

Я надеюсь, что вы знаете концепцию IP-адресации. Вкратце, все IP-адреса имеют &quot;мнемоническое&quot; название (типа www.cnn.com) и числовое, типа &quot;198.20.186.4&quot;.  Если вы указываете адрес вида &quot;www.cnn.com&quot;, то кто-то должен ПОМОЧЬ вашему компьютеру
конвертировать эту строку в числовой формат.<P>

        Почему числовой формат? Потому, что числовой формат гораздо эффективнее - он сообщает каждому компьютеру, КАК переслать информационный пакет другому компьютеру, с которым ОН ХОЧЕТ УСТАНОВИТЬ СВЯЗЬ.<P>

        Поэтому, когда вы пишете &quot;www.cnn.com&quot; в окне адреса NETSCAPE-навигатора, UNIX-компьютер вызывает &quot;DNS-сервер&quot;, который
    преобразует эту строку (название) в числа, понятные вашему компьютеру.  Далее ваш ПК использует эту числовую версию IP-адреса для СОЕДИНЕНИЯ с www.cnn.com и покажет вам их последние новости.<P>

В итоге, дела обстоят так: для использования интернет вам нужен DNS-сервер.  Данный документ содержит инструкции о том, как заставить ваш
компьютер СВЯЗАТЬСЯ с соседним DNS-сервером.<P>

Ваш LINUX-сервер ДОЛЖЕН иметь все нижеперечисленное:
<OL>
<LI>    Модем, через который вы можете *** НАПРЯМУЮ *** подключаться к ИНТЕРНЕТ
<LI>    Сетевую ethernet-карту, к которой подключен сетевой кабель (к которому подключены машины-клиенты...)
<LI>    Работающее PPP соединение.
<LI>    ПРАВИЛЬНУЮ информацию о DNS сервере (используйте nslookup --- если эта программа выдает ерунду, то прекратите читать это руководство.  Вы НЕ МОЖЕТЕ нормально продолжать работу...)
<LI>    Навигатор Netscape 2.0 или более поздние версии на ваших машинах-клиентах.
</OL>

Под &quot;модемом&quot; здесь и далее имеется ввиду обращение к порту &quot;ppp0&quot;.  Под словом &quot;порт&quot; тут подразумевается нечто, похожее на &quot;Морской Порт&quot;.  Наш модем (или PPP порт) позволяет вам &quot;исследовать мир&quot; (отправиться в &quot;путешествие&quot; от будничных берегов) :-)<P>

Сетевая &quot;ethernet карта&quot; - это ваш &quot;eth0&quot; порт.  Этот ethernet-&quot;порт&quot; позволяет вам исследовать сеть ethernet, к которой он присоединен.<P>Ваша машина-клиент
подсоединена к LINUX-серверу через сетевой кабель, то есть ВСЕ, что ваша машина-клиент пошлет серверу, достигнет linux ТОЛЬКО ЧЕРЕЗ
порт &quot;eth0&quot;.   ВСЕ, что внешний мир присылает вашему LINUX-серверу, придет на него ТОЛЬКО через порт ppp0.  ПОЭТОМУ очень важно, чтобы эти два порта имели &quot;РАЗНЫЕ АДРЕСА&quot;.<P>

Проще говоря, если вы УЖЕ успешно соединились с внешним миром через PPP, то вы уже НЕПРЕДНАМЕРЕННО (или намеренно 8-) ) назначили числовой IP-адрес PPP-порту вашей linux-машины.<P>

<HR>

<A NAME="SockdMakefile"><H3>MAKEFILE для компиляции sockd</H3></a><A>

<PRE>
        SHELL=/bin/bash
        #SOCKS=-DSOCKS
        # или
        SOCKS=-Dconnect=Rconnect -Dgetsockname=Rgetsockname -Dlisten=Rlisten -Daccept=Raccept -Drcmd=Rrcmd -Dbind=Rbind -Dselect=Rselect
        CFLAGS=&quot;$(SOCKS)&quot;
        
        # Если ваша система не имеет отпределенных PWD, то определите их тут:
        PWD=&quot;/usr/local/ProxyServer/socks42b&quot;
        # Это должна быть данный (текущий) каталог.
        
        # Если ваша система уже имеет getcwd(), но не имеет getwd(), то раскомментируйте следующую строку:
        #GETCWD=-DGETCWD
        
        # Определите FASCIST, если вы хотите, чтобы ftp (rftp) отслеживала в файле логов все переданные файлы
        #FASCIST=-DFASCIST
        
        # Определите RCMD и SUPPORT_RCMD, если вы хотите поддерживать Rrcmd, что необходимо
        # для SOCKSified rlogin, rsh, и rcp.
        RCMD=Rrcmd.o
        SUPPORT_RCMD=-DSUPPORT_RCMD
        
        # Определите FOR_PS, если ваша система не SYSV а вы хотите, чтобы команда
        # 'ps' показывала некоторую информацию об активности sockd.
        FOR_PS=-DFOR_PS
        
        # Определите SHORTENED_RBIND для того, чтобы Rbind() брал точно такие-же 
        # параметры, как и простой bind(), т.е. без дополнительного параметра 'remhost'
        SHORTENED_RBIND=-DSHORTENED_RBIND
        
        # флаги оптимизации для cc
        #OPTIMIZE=-g
        OPTIMIZE=-O6 -fomit-frame-pointer -pipe -m486
        # Будьте аккуратны с флагами OPTIMIZE. Например, известно, что SC2.0.1 от SunPro,
        # выдает некорректный код если используестя флаг -O.
        
        # Каталог, в который устанавливаются руководства
        MAN_DEST_DIR = /usr/local/man
        
        # Каталог, в который устанавливается пакет сервера SOCKS 
        SERVER_BIN_DIR = /usr/local/ProxyServer
        ## По умолчанию здесь было /usr/local/etc 
        
        # Каталог, в который устанавливается программа-клиент
        CLIENTS_BIN_DIR = /usr/local/ProxyServer
        ## По умолчанию здесь было /usr/local/bin

        # LINUX должен использовать
        CC=gcc
        RANLIB=ranlib
        RESOLV_LIB=
        #OTHER_CFLAGS=-traditional -DLINUX  $(GETCWD) $(FASCIST) $(SHORTENED_RBIND) -DCOMPAT 
        OTHER_CFLAGS=-DLINUX  $(GETCWD) $(FASCIST) $(SHORTENED_RBIND) -DCOMPAT 
        OS=linux
        INSTALL=install
        GETPASS=getpass.o

        # Не забудьте включить -Dindex=strchr -Drindex=strrchr в OTHER_CFLAGS, если 
        # вы не имеете index() и rindex() (Sys-V camp)
        
        # &lt;&lt;&lt;----------------
        
        # Сервер Internet Whois ; в данном случае nic.ddn.mil.
        WHOIS_SERVER= WHOIS_SERVER=-DWHOIS_SERVER\'=\&quot;rs.internic.net\&quot;\'
        
        SOCKS_LIB=$(PWD)/lib/libsocks.a
        IDENT_LIB=$(PWD)/libident/libident.a
        
        all: LIB LIBIDENT server clients
        
        server: LIB LIBIDENT
                (cd sockd; $(MAKE) CC=&quot;$(CC)&quot; RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; \
                        OPTIMIZE=&quot;$(OPTIMIZE)&quot; \
                        SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; SUPPORT_RCMD=&quot;$(SUPPORT_RCMD)&quot; \
                        IDENT_LIB=&quot;$(IDENT_LIB)&quot; \
                        OTHER_CFLAGS=&quot;$(OTHER_CFLAGS) $(FOR_PS)&quot;)
                
        clients: RFINGER RFTP RTELNET
        
        LIB:
                (cd lib; $(MAKE) CC=&quot;$(CC)&quot; GETPASS=&quot;$(GETPASS)&quot; \
                        OPTIMIZE=&quot;$(OPTIMIZE)&quot; \
                        RCMD=&quot;$(RCMD)&quot; SUPPORT_RCMD=&quot;$(SUPPORT_RCMD)&quot; \
                        OTHER_CFLAGS=&quot;$(OTHER_CFLAGS) &quot; RANLIB=&quot;$(RANLIB)&quot;)
        
        LIBIDENT:
                (cd libident; $(MAKE) CC=&quot;$(CC)&quot; OTHER_CFLAGS=&quot;$(OTHER_CFLAGS)&quot; \
                        OPTIMIZE=&quot;$(OPTIMIZE)&quot; RANLIB=&quot;$(RANLIB)&quot;)
        
        RFINGER: LIB
        # This also build rwhois
                (cd rfinger; $(MAKE) CC=&quot;$(CC)&quot; $(WHOIS_SERVER) \
                        OPTIMIZE=&quot;$(OPTIMIZE)&quot; SOCKS=&quot;$(SOCKS)&quot; \
                        RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; \
                        OTHER_CFLAGS=&quot;$(OTHER_CFLAGS) &quot;)
        
        RTELNET: LIB
                (cd rtelnet; $(MAKE) CC=&quot;$(CC)&quot; OS=&quot;$(OS)&quot; SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; \
                        OPTIMIZE=&quot;$(OPTIMIZE)&quot; SOCKS=&quot;$(SOCKS)&quot; \
                        RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; OTHER_CFLAGS=&quot;$(OTHER_CFLAGS)&quot;)
        
        RFTP: LIB
                (cd rftp; $(MAKE) CC=&quot;$(CC)&quot; SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; \
                        OPTIMIZE=&quot;$(OPTIMIZE)&quot; SOCKS=&quot;$(SOCKS)&quot; \
                        RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; OTHER_CFLAGS=&quot;$(OTHER_CFLAGS)&quot;)
        
        install.server:
                (cd sockd; $(MAKE) INSTALL=&quot;$(INSTALL)&quot; MAN_DEST_DIR=&quot;$(MAN_DEST_DIR)&quot; \
                        SERVER_BIN_DIR=&quot;$(SERVER_BIN_DIR)&quot; install install.man)
        
        install.clients: install.man
                for i in rfinger rftp rtelnet; do \
                        (cd $$i ; $(MAKE) INSTALL=&quot;$(INSTALL)&quot; \
                                CLIENTS_BIN_DIR=&quot;$(CLIENTS_BIN_DIR)&quot; \
                                install) done
        install.man:
                (cd doc; $(MAKE) INSTALL=&quot;$(INSTALL)&quot; MAN_DEST_DIR=&quot;$(MAN_DEST_DIR)&quot; \
                        install)
        
        clean:
                for i in lib libident sockd rfinger rftp rtelnet ; do \
                        ( cd $$i ; $(MAKE) clean) done
</PRE>

        
<HR>

</a>

<A NAME="ppponScript"><H3>Скрипт установления PPP-соединения</H3></A>

ПРИМЕЧАНИЕ: Этот скрипт приведен здесь только как пример.  Если вы будете использовать этот файл, то вам не гарантировано успешное соединение с интернет.

<PRE>
        #!/bin/csh
        #
        #       ppp-on
        #
        #       Установка соединения PPP
        
        set LOCKDIR=/var/spool/uucp
        set DEVICE=cua3
        
        set OUR_IP_ADDR=128.000.111.222
        
        if ( -f $LOCKDIR/LCK..$DEVICE ) then
            echo 'PPP device is locked'
            exit 1
        endif
        
        route del default
        # Только для случая, если внутренняя сеть (etherNetwork) работает....
        #       если она НЕАКТИВНА, то вышеуказанные команды абсолютно безопасны...
        route ## Чтобы показать, что исполнение команд прошло успешно...
        
        /usr/lib/ppp/fix-cua $DEVICE
        
            unalias pushd
            unalias popd
            pushd /usr/lib/ppp
            # stty 19200 -tostop
        
            # Ниже закомментированы строки программы по умолчанию ...
            # if chat -l LCK..$DEVICE ABORT &quot;NO CARRIER&quot; ABORT BUSY &quot;&quot; ATZ OK ATs50=255s111=0DT$PHONE CONNECT &quot;&quot; ogin: $USER ssword: \\q$PASSWORD
            echo $cwd
            ls -l ./comserv.dip
            dip ./comserv.dip       ## I removed the -v (DEBUG&amp;VERBOSE) option to 'dip'.
            set dip_status=$status
            # echo the return value of dip is $dip_status
            # echo значение переменной dip есть $dip_status
        
            if $dip_status == '0' then
                # Now please wait for 10 seconds, while the link is being auto-verified by dip.
                echo 'About to fork-off pppd (after a delay of 10 secs)...'
                echo 'Запуск в параллельном режиме pppd (после задержки в 10 секунд)...'
                date
                echo 'If you see any error msgs below, then we are having SERIOUS problems...'
                echo 'Если вы увидите далее какие-либо сообщения об ошибках, то у нас СЕРЬЕЗНЫЕ проблемы...'
                sleep 10
                pppd -detach crtscts defaultroute domain remote.princeton.edu mru 1005 mtu 1005 $OUR_IP_ADDR{}: /dev/$DEVICE 38400 &amp;
                ###### нам не нужно исполнять ЭТО (есть предыдущие строки...)    &lt; /dev/$DEVICE &gt; /dev/$DEVICE ) &amp;
                #    Демон pppd запущен в параллельном режиме.  Видите &quot;&amp;&quot; в КОНЦЕ предыдущей строки...
                # Использую опцию &quot;locl&quot;, мы требуем чтобы каталог /var/spool/uucp был тем самым
                #    каталогом, в котором создавались LOCKS...
                echo 'Now wait another 10 seconds, before I auto-verify internet connection.'
                echo 'Ждем 10 секунд перед проверкой соединения с интернет.'
                sleep 10
                cat ~root/@utils/.line
                ping -v -c 5 genius.eng.wayne.edu
                cat ~root/@utils/.line
                traceroute physics.iisc.ernet.in &gt;&amp;! /tmp/$$
                                                cat  /tmp/$$
                                                \rm -f /tmp/$$
                cat ~root/@utils/.line
                exit 0
            else
                echo 'PPP setup failed'
                exit 1
            endif
            popd
        # [EoF]
</PRE>

<HR>

<A NAME="ComservDipScript"><H3>Скрипт comserv.dip </a> <A NAME="ppponScript">установления PPP-соединения</A>

</H3><A><P>

ПРИМЕЧАНИЕ: Этот скрипт приведен здесь только как пример.  Если вы будете использовать этот файл, то вам не гарантировано успешное соединение с интернет. Данный сценарий вызывается из "Скрипта PPP-подключения", приведенном выше...

<PRE>
        #******************************** comserv.dip ********************************
        #
        # Скрипт соединения SLIP ........
        # коды ВОЗВРАТА этого скрипта при запуске &quot;dip&quot;:
        #  0 - все нормально.
        #  1 - небольшие ошибки при инициализации модема.
        #  2 - ошибка при исполнении команды &quot;dial&quot;.
        #  3 - Хоть команда DIAL и выполнена успешно, этот скрипт не смог распознать
        #      САМЫЙ ПЕРВЫЙ ответ от другого модема. То есть было попытка связаться
        #      заново, хоть ничего ошибочного для скрипта не произошло.
        #  4 - Модемы прекрасно могут установить соединение.  Но удаленный сервер
        #      ПОМЕНЯЛ синтакс или последовательности при обмене данными,
        #      т.е. исходящие от удаленного сервера строки приходят
        #      частично. Возможно, поменялось программное обеспечение на сервере, тогда
        #      и может произойти такая ошибка. РЕШЕНИЕ!!! Соединитесь вручную и запишите
        #      себе строки, показываемые при соединении, содержащие &amp;
        #      Затем перепишите данный скрипт.
        # 10 - хотя и дозвон, и обмен данными между модемами прошли успешно,
        #      установить PPP-соединение не удалось
        ############################################################################
        main:
        redial:
          # Установка серийного порта и скорости.
          port cua3
          speed 38400
          # term
          get $mtu 1005
          # Сброс модема и линии.
          reset
          # Без исполнения предыдущего сброса, НИЧЕГО дальше работать не будет!
          # Инициализация модема и дозвон на comserv.
          # send ATQ0V1E1X4L1S0 0 \r
          # wait OK 5
          send ATZ\r
          wait OK 5
          if $errlvl != 0 goto error
          # send ATTQ0V1E1X4S0=0&amp;C1\r
          # wait OK 5
          # if $errlvl != 0 goto error
          ## For Dial Tone use :- send AT&amp;D2\r
          send AT&amp;DP\r
          wait OK 5
          if $errlvl != 0 goto error
          # send ATS10=1\r
          # wait OK 5
          # if $errlvl != 0 goto error
          print if the line is busy, the dial command will realize that after 30 secs ONLY.
          print если линия занята, то команда dial определит это ТОЛЬКО через 30 секунд.
          dial 258-0000   30
          print Return value of DIAL is $errlvl
          print Значение переменной DIAL есть $errlvl
          if $errlvl == 1 goto Continue1
          if $errlvl == 3 goto busy
          print unknown error with DIAL command in &quot;dip&quot; script.
          print неизвестная ошибка с командой DIAL в скрипте &quot;dip&quot;.
          quit 2 # ошибка при исполнении команды &quot;dial&quot;...
        busy:
          print telephone number is busy... Continue (1) or terminate (2)?
          print телефонная линия занята... Продолжить (1) или отменить (2)?
          get $input ask
          if $input == 1 goto redial
          print You have requested to cancel PPP.  Quitting...
          print Вы решили отменить PPP.  Завершаем работу...
          quit 10 # конец работы...
        Continue1:
          # wait V32 30
          # wait CONNECT 10
          # if $errlvl != 0 print Couldn't detect a CONNECT
          # if $errlvl != 0 goto connect_fail
          # print CONNECT was detected...
          # print определен CONNECT...
          # Мы соединились.  Начинаем входить в систему.
        login:
          sleep 3
          # send \r\r
          wait Username: 20
          if $errlvl != 0 goto error2
          send USERID\r
          wait Password: 5
          if $errlvl != 0 goto error2
          send __Password+_::\r\r
          wait comserv&gt; 15
          # print Reached Comserv prompt...
          # print Достигли Comserv...
          if $errlvl != 0 goto error2
        slipon:
          send ppp\r
          wait PPP_STARTED 25
          if $errlvl != 0 goto error2
          print CONNECTION completed...
          print Завершен сеанс СВЯЗИ...
          mode ppp
          exit 0
        error:
          print Total failure to interact with MODEM!!!
          print Глобальная ошибка при обращении к МОДЕМУ!!!
          quit 1 # ошибки при инициализации модема и т.п....
        connect_fail:
          print Couldnt detect a &quot;CONNECT 14400&quot; kind of string after dial in...
          print Не могу найти строку типа &quot;CONNECT 14400&quot; после дозвона...
          quit 3
        error2:
          print Modems could nicely link up.  But remote server HAS CHANGED syntax/ interaction sequence...
          print Модемы прекрасно могут установить соединение.  Но удаленный сервер ПОМЕНЯЛ синтакс или последовательность при обмене данными...
          quit 4 # ошибки при инициализации модема и т.п....
        #=================================== EOF ===================================
</PRE>

</a>
<hr>
<h2>Авторские права</h2>
<p>Авторские права на русский перевод этого
текста принадлежат © 2000 SWSoft Pte Ltd. Все права
зарезервированы.</p>
<p>Этот документ является частью проекта Linux
HOWTO.</p>
<p>Авторские права на документы Linux HOWTO
принадлежат их авторам, если явно не
указано иное. Документы Linux HOWTO, а также их
переводы, могут быть воспроизведены и
распространены полностью или частично на
любом носителе, физическом или электронном,
при условии сохранения этой заметки об
авторских правах на всех копиях.
Коммерческое распространение разрешается
и поощряется; но, так или иначе, автор текста
и автор перевода желали бы знать о таких
дистрибутивах.</p>
<p>Все переводы и производные работы,
выполненные по документам Linux HOWTO, должны
сопровождаться этой заметкой об авторских
правах. Это делается в целях предотвращения
случаев наложения дополнительных
ограничений на распространение документов
HOWTO. Исключения могут составить случаи
получения специального разрешения у
координатора Linux HOWTO, с которым можно
связаться по адресу приведенному ниже.</p>
<p>Мы бы хотели распространить эту
информацию по всем возможным каналам. Но
при этом сохранить авторские права и быть
уведомленными о всех планах
распространения HOWTO. Если у вас возникли
вопросы, пожалуйста, обратитесь к
координатору проекта Linux HOWTO по электронной
почте: <tt CLASS="EMAIL">&lt;<a HREF="mailto:linux-howto@metalab.unc.edu">linux-howto@metalab.unc.edu</a>&gt;</tt>
или к координатору русского перевода Linux HOWTO
компании SWSoft Pte Ltd. по адресу <tt CLASS="EMAIL">&lt;<a HREF="mailto:linux-howto@asplinux.ru">linux-howto@asplinux.ru</a>&gt;</tt></p>
<p>&nbsp;

</BODY>
</HTML>
