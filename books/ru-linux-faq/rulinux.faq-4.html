<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.20">
 <TITLE> RU.LINUX Frequently Asked Questions: Системное администрирование </TITLE>
 <LINK HREF="rulinux.faq-5.html" REL=next>
 <LINK HREF="rulinux.faq-3.html" REL=previous>
 <LINK HREF="rulinux.faq.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="rulinux.faq-5.html">Next</A>
<A HREF="rulinux.faq-3.html">Previous</A>
<A HREF="rulinux.faq.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4.</A> <A HREF="rulinux.faq.html#toc4">Системное администрирование </A></H2>

<P> </P>
<H2><A NAME="ss4.1">4.1</A> <A HREF="rulinux.faq.html#toc4.1">А какие бывают версии ядра Линукса ?  А почему при апгрейде/компиляции ядра у меня #$@#$#@%@#$%@#$?  А что такое девелопмент-ядра и вообще, почему говорят, что новая версия ядра - 2.2.x вышла вчера, когда я месяц назад скачал 2.3.какую-то ?  Каким ядром лучше пользоваться ?</A>
</H2>

<P> 
(Alex Kanavin, адрес выше, 
<A HREF="mailto:alexm@hsys.msk.ru">Alexey Mahotkin</A>)</P>
<P>Начнем с официальной серии ядер, выпускаемых непосредственно Линусом 
Торвальдсом. Прежде всего, надо разобраться, что такое стабильные и 
нестабильные ядра (stable и development) и как они нумеруются. Пусть имеется 
ядро версии a.b.c
<UL>
<LI>a - это основной номер версии. Меняется он раз в несколько лет, как правило,
когда нестабильная серия с очень существенными изменениями становится 
стабильной.</LI>
<LI>b - это patchlevel. Именно он определяет, является ли данное ядро стабильным
или нет. Если он четный - ядро стабильное, если нечетный - нестабильное.
Числа a и b в виде a.b называется серией ядер.</LI>
<LI>с - это sublevel. Он определяет номер ядра в серии.</LI>
</UL>
</P>
<P>Официальные ядра в виде исходных текстов можно скачать 
с 
<A HREF="ftp://ftp.kernel.org">ftp://ftp.kernel.org</A> и его многочисленных мирроров (российский: 
<A HREF="ftp://ftp.ru.kernel.org">ftp://ftp.ru.kernel.org</A>, но им лучше не пользоваться, так как он
не миррорит .bz2, если вам нужен именно российский миррор, то попробуйте 
<A HREF="ftp://ftp.rmt.ru/">ftp://ftp.rmt.ru/</A>, 
<A HREF="ftp://ftp.chg.ru/Mirrors/ftp.kernel.org/">ftp://ftp.chg.ru/Mirrors/ftp.kernel.org/</A> или 
<A HREF="http://ftp.chg.ru/Mirrors/ftp.kernel.org/">http://ftp.chg.ru/Mirrors/ftp.kernel.org/</A>).</P>
<P>[пользуясь случаем, хочу передать сообщение для 
<A HREF="ftp://ftp.chg.ru">ftp://ftp.chg.ru</A>
, 
<A HREF="ftp://ftp.ru.kernel.olg">ftp://ftp.ru.kernel.olg</A> и других официальных россйских 
мирроров: если уж вы миррорите, например, 
redhat, то делайте это целиком и каждый день, а не раз в месяц кусочками. 
А то апдейты у вас появляются через месяц после того, как они были выложены
на  ftp.redhat.com, да и то - только к последней версии. Ну и кому нужен
такой  "официальный" mirror? Взялись быть зеркалом - делайте это как следует,
не можете - откажитесь.]</P>
<P>Кроме полных исходных текстов ядра там же можно найти патчи - значительно
меньшие по размеру файлы, позволяющие превратить исходники версии a.b.c в
исходники версии a.b.c+1 c помощью команды patch. Эти же патчи ходят по 
файлэхе <B>usyslnx</B>.</P>
<P>Стабильные ядра предназначены для широкого использования и проблемы при 
их использовании или компиляции встречаются нечасто. Как правило в
стабильных  сериях от версии к версии только исправляются ошибки и
добавляются драйвера, не требующие изменений в самом ядре и хорошо себя 
зарекомендовавшие. Стабильные ядра можно безбоязненно обновлять, не
трогая прочий софт - если вы остаетесь в рамках одной серии, проблем
возникнуть не должно. (По крайней мере в теории, на практике, возможно,
придется вернуться к старому ядру и подождать выхода еще одной версии.)
Новые версии выходят нечасто - примерно раз в месяц, и реже. </P>
<P>Нестабильные ядра, наоборот, не предназначены для использования 
массами. Это полигон для тестирования множества разнообразных возможностей, 
только появившихся и еще не готовых для использования никем, кроме их 
собственных разработчиков и людей, чье хобби - забавляться с нестабильными 
ядрами. Здесь от версии к версии может меняться очень многое и правильную 
работу никто не обещает (впрочем, то же относится и к стабильным ядрам, но 
в менее "жестком" смысле). При их использовании нужно быть готовым ко всему. 
Прежде всего к тому, что ядро просто не скомпилируется. Потом оно может не
загрузиться, зависать, портить файловую систему и вообще всячески глючить.
Кроме того, может начать глючить софт, взаимодействующий с ядром напрямую.
Нестабильные ядра выходят гораздо чаще стабильных - иногда несколько новых 
ядер в неделю.</P>
<P>Как нестабильная серия становится стабильной и наоборот ? Очень просто:
в какой-то момент Linus Torvalds объявляет т.н. feature freeze, после
чего к включению  в нестабильное ядро принимаются только исправления
ошибок (bugfix). Через  некоторое время очередной версии присваивается
номер не a.b.c+1, а a.b+1.0 или a+1.0.0 - так появляется новая стабильная 
серия, вокруг чего масс-медиа  устраивают большую шумиху :) Еще через 
некоторое время выпуск версий в предыдущей стабильной серии прекращается и 
происходит т.н. fork или разветвление - одновременно с очередным стабильным 
ядром появляется нестабильное, отличающееся от первого только номером версии.</P>
<P>Заметьте, что термины "стабильный" и "нестабильный" в чем-то условны.
Понятно, что "нестабильное" ядро 2.3.128 за несколько минут до его
превращения в стабильное ядро 2.4.0 по определению стабильно, а стабильное
ядро 2.2.xxx, в котором обнаружена фатальная ошибка распределения памяти --
опять же по определению нестабильно.  В общем, сами понимать должны, не
маленькие.</P>
<P>В силу открытости процесса разработки ядра Linux существует несколько
побочных ветвей развития.  Одной из основных таких ветвей являются ядра
серии -ac, которые выпускает Алан Кокс -- один из основных разработчиков
Линукса.  Во-первых, серия -ac служит своеобразным буфером, в котором
тестируются некоторые новые драйвера, возможности, etc. перед тем, как
этот, уже оттестированный, драйвер будет отправлен Линусу.  Во-вторых, в
ядрах -ac имеется определенный набор вещей, которые не устраивают Линуса,
но устраивают Алана и к тому же достаточно популярны.</P>
<P>Существуют также еще несколько менее важных (хотя ваше мнение по этому
вопросу может отличаться) побочных веток: например, International Kernel
Patch с поддержкой сильной криптографии, devfs-patch с поддержкой файловой
системы /dev, раньше была отдельная поддержка ISDN, ну и так далее и тому
подобное).  Кроме того, многие производители дистрибутивов распространяют
ядро с определенными патчами, которые они считают необходимыми и которые
лучше вписываются в инфраструктуру дистрибутива).</P>
<P>Каким же ядром все-таки пользоваться?  Простейший ответ: тем, которое
входит в используемый вами дистрибутив.  Этот ответ приемлем для
большинства пользователей Линукса.  Если же вы оказались в ситуации, когда,
например, нужное вам железо поддерживается только в каком-то патче, который
не вошел ни в одну из основных ветвей, значит, вам придется брать исходники
оригинального ядра, патчи, которые использовали создатели дистрибутива,
патчи, которые необходимы лично вам, прикладывать все эти патчи друг к
другу, компилировать и устанавливать ядро вручную (ну, или создать свой
собственный пакет на основе дистрибутивного).  Вам также придется
отслеживать выход новых версий патча, контактировать с его автором,
сражаться с его глюками и прилагать всяческие усилия к тому, чтобы оный
патч, наконец, приобрел официальный статус. </P>
<P>Возможны и другие варианты, при которых может потребоваться пересборка, 
наиболее очевидный - вы столкнулись с ошибкой в ядре, которая исправлена в
более свежей версии. В этом случае стоит сперва выяснить, не выложил ли 
производитель вашего дистрибутива исправленное ядро на свой ftp сервер,
в то же место, где лежат прочие обновления. Такое ядро доступно в форме пакета
(rpm или deb), пригодного к  непосредственной установке пакетным менеджером, 
либо в дистрибутиве имеется система автоматического обновления пакетов.</P>
<P>Если же вам просто хочется поставить более свежую версию ядра или пересобрать 
ядро без всякой причины ("убрать лишние драйвера", "изучить процесс сборки" и т.п. 
причинами не считаются ;-), рекомендуется серьезно подумать, прежде чем 
приступать к действиям. Не стоит чинить то, что не сломано. Объем трафика 
ru.linux, посвященный проблемам при пересборке ядра весьма велик и не надо 
еще больше его увеличивать :-). Однако обновления ядра от производителя 
все-таки устанавливать рекомендуется в любом случае :-)</P>
<P>Итак, вы решили самостоятельно скомпилировать/установить ядро. Если оно
development - очень рекомендуется подписаться на список рассылки 
linux-kernel. В любом случае желательно просматривать глазами патчи
перед  установкой (особенно на предмет добавления новых опций и
изменений в каталоге  Documentation). Еще крайне рекомендуется оставлять
старое ядро и делать в lilo отдельный target типа oldlinux, на него
показывающий. При смене стабильной серии на более новую стабильную надо 
прочесть Documentation/Changes - как минимум. А лучше - все из этого 
каталога, что  относится к вашему железу и софту.</P>
<H2><A NAME="ss4.2">4.2</A> <A HREF="rulinux.faq.html#toc4.2">Как произвести компиляцию ядра? Это заложено в установках линукса или здесь есть какие хитрости?</A>
</H2>

<P>
<PRE>
cd /usr/src/linux
</PRE>

Опции, с которыми компилируется ядро (тип процессора, драйверы
которые нужно включить (возможно в виде модулей) и еще сотни других вещей),
задаются в файле /usr/src/linux/.config. Так вот, желательно не создавать его
самому с нуля (особенно, если вы собираете ядро первый/второй/третий раз в 
жизни или наложили патч на исходники из которых уже что-то компилировали), 
а взять за основу .config с которым было собрано старое, работающее ядро.
При этом вам прежде всего надо выдать команду make oldconfig - она 
используется, когда есть .config от _другой_ (обычно, более старой)
версии ядра, и нужно просто получить точно такой же для текущей 
(возможно, ответив на пару вопросов о тех фичах, которых в старом не было), 
не отвечая заново на все три сотни вопросов.
Затем выдайте make menuconfig и исправьте те опции, ради которых вы 
собственно и решили пересобрать ядро.</P>
<P>Если вы используете Red Hat и хотите воспользоваться теми .config, c помощью 
которых были собраны ядра в этом дистрибутиве, то возьмите их из 
kernel-sources-*.i386.rpm/usr/src/linux/configs/</P>
<P>Затем:
<PRE>
make dep
make clean
make zImage (make bzImage для ядер версий &gt; 2.2)
make modules
</PRE>

Если у вас раньше стояла эта же версия ядра, то удалите старые
модули от этого ядра (/lib/modules/версия).
<PRE>
make modules_install
</PRE>

/usr/src/linux/arch/i386/boot/(b)zImage - и есть свежесобранное ядро. Его 
теперь можно поинсталировать на место старого. Хотя лучше сначала 
попробовать, работает ли оно. Нужно добавить в lilo.conf еще один выбор - 
например, linux.test, - который берет ядро прямо из 
/usr/src/linux/arch/i386/boot/zImage. </P>
<P>(
<A HREF="mailto:nnlx@nn.kiev.ua">Valentin Nechayev</A>)</P>
<P>Я пpедлагаю дpугой метод - пpовеpен только для Red Hat'а.
<PRE>
cd /usr/src/linux-нужная_веpсия
vi Makefile и заменить extraversion на свой - напpимеp,
EXTRAVERSION = -vasya1
</PRE>

после этого все то же самое, но
<OL>
<LI> make modules_install поставится в свой отдельный каталог</LI>
<LI> установка (пpавильная!) ядpа в /boot сделается сама чеpез make install</LI>
<LI> это работает только с ядрами 2.2.x (у 2.0 просто нет параметра 
EXTRAVERSION) и, по крайней мере теоретически, может "сломать" чей-нибудь 
автоконфигуратор, рассчитывающий на n.n.nn по uname -r.</LI>
</OL>

(Alexander Pevzner, 2:5020/59.9) </P>
<P>Тем, кто отважился на сборку ядра лично под себя, советуем обратить 
внимание на следующие факты:
<UL>
<LI>В начале ядерного Makefile (/usr/src/linux/Makefile) есть переменная
EXTRAVERSION. Используя ее можно получать ядра одной и той же версии,
но с названиями, отличающимися суффиксом (напр, 2.2.12-20 и 2.2.12-vasya).
Это хорошо, поскольку позволяет сохранить экземпляр ядра, который
заведомо умеет грузиться. Родное ядро, с которым ставилась система,
лучше сохранить на случай всяких неприятностей. Hадо только не
забыть добавить дополнительную запись в /etc/lilo.conf (достаточно
иметь всего 2 записи: на родное ядро и на свежесобранное).</LI>
<LI>В редхате в /usr/src/linux  правильно  работает make install и
make modules_install. Ядро и модули копируются в нужное место и
правильно настраиваются символические линки. Причем, что приятно,
это относится не только к ядрам, полученным в виде .src.rpm, но
и если просто взять ядро с ftp.kernel.org, все заработает.
(эту правильную установку осуществляет редхатовский скрипт /sbin/installkernel, 
входящий в пакет с фирменным ядром редхата, поэтому перед make install 
желательно убедиться в наличии этого скрипта (Alex Kanavin).) 
EXTRAVERSION в этих ядрах по дефолту не выставлено, поэтому ядро
будет получаться под именем навроде 2.2.13 (конечно, EXTRAVERSION
при желании можно выставить)</LI>
<LI> Когда ядро собирается в дереве, в котором уже собиралось ядро,
очень  рекомендуется после make *config сказать make clean.
Во всяком случае, если какие-то части ядра были переселены в
модули или обратно, надо делать это _обязательно_, иначе есть
шанс собрать неправильное (не работающее) ядро.</LI>
</UL>
</P>
<H2><A NAME="ss4.3">4.3</A> <A HREF="rulinux.faq.html#toc4.3">Как изменить максимальное количество открытых файлов?</A>
</H2>

<P>В ядрах 2.2.10 и более новых:
<PRE>
echo 30000 > /proc/sys/fs/file-max
echo 30000 > /proc/sys/fs/inode-max
</PRE>

и сделать ulimit -n 2000 перед запуском нужного демона. Цифры
подбираются под задачу.</P>
<P>(Yuriy Kaminsky 2:5020/517.21)</P>
<P>И не забыть, что если программа использует select, то будет
большой-большой облом. Вплоть до затирания стека и падения (at least
glibc-2.0 - см. /usr/include/gnu/types.h - и иже с ним; исправления
<PRE>
#define __FD_SETSIZE    1024
</PRE>

на нужное число и пересборки  всех  приложений и  библиотек , которые могут
заюзать select для дескрипторов выше 1024 будет достаточно [т.е.,
скажем, если X'овому приложению нужно открывать более 1024 файлов, то
необходимо  пересобирать Xlib и Xt как минимум]; ах, да, саму libc
пересобирать, вроде, не нужно).</P>
<H2><A NAME="ss4.4">4.4</A> <A HREF="rulinux.faq.html#toc4.4">Подскажите, pls, www/ftp где можно получить доку по администрированию Linux'а.</A>
</H2>

<P>
<A HREF="http://www.linuxdoc.org">http://www.linuxdoc.org</A>
Hа русском языке - посмотрите на 
<A HREF="http://linux-ve.chat.ru">http://linux-ve.chat.ru</A></P>
<H2><A NAME="ss4.5">4.5</A> <A HREF="rulinux.faq.html#toc4.5">Q/A: development site для libc, binutils, ld.so </A>
</H2>

<P>
<A HREF="ftp://ftp.yggdrasil.com/private/hjl">ftp://ftp.yggdrasil.com/private/hjl</A> - если кому-то понадобилась 
тухлятина. В
частности, именно там надо искать libc5 последних версий) Сейчас все это
лежит на 
<A HREF="ftp://ftp.kernel.org/pub/linux/software/">ftp://ftp.kernel.org/pub/linux/software/</A> и его 
локальных миррорах. (
<A HREF="ftp://ftp.ru.kernel.org">ftp://ftp.ru.kernel.org</A> не миррорит
.bz2 (на 20% меньше gz, многое из каталога linux/kernel/people в .gz не 
выкладывается), поэтому вместо 
<A HREF="ftp://ftp.ru.kernel.org">ftp://ftp.ru.kernel.org</A>  лучше пользоваться 
<A HREF="ftp://ftp.rmt.ru">ftp://ftp.rmt.ru</A> или 
<A HREF="http://ftp.filesearch.ru">http://ftp.filesearch.ru</A>)</P>
<H2><A NAME="ss4.6">4.6</A> <A HREF="rulinux.faq.html#toc4.6">Как загружается система?</A>
</H2>

<P>Очень коротко, подробнее можно прочесть в вышеназванных источниках:
ядро монтирует корневую файловую систему, и запускает первый процесс init, 
разыскав его исполняемый файл в нескольких стандартных местах. Этот процесс
читает свой конфигурационный файл /etc/inittab (man inittab) и запускает 
все остальные процессы согласно инструкциям из этого файла. Обычно в inittab 
прописывается запуск процессов *getty, управляющих терминалами, виртуальными 
консолями и последовательными линиями (то есть именно *getty ответственны за 
запуск login (сравнивающий имя и пароль, указанные пользователем, с тем, что
прописано в /etc/passwd и в случае успеха запускающий соотв. shell), 
pppd, ifcico и т.д., что именно запускается и в каком случае - зависит от 
конкретного getty). Для виртуальных консолей обычно используется mingetty,
для модемов - mgetty.</P>
<P>Кроме того, здесь же прописываются скрипты, запускающиеся на различных т.н. 
"уровнях выполнения", из которых в свою очередь запускаются все остальные 
системные сервисы, осуществляется настройка сети, проверка файловой системы 
и т.д. Существует два подхода к организации этих уровней и скриптов: BSD и 
SysV. Оба они описаны в книжке Э. Немет (см. выше), а про SysV можно еще 
прочесть на 
<A HREF="http://www.sensi.org/~alec/unix/redhat/sysv-init.html">http://www.sensi.org/~alec/unix/redhat/sysv-init.html</A>.</P>
<H2><A NAME="ss4.7">4.7</A> <A HREF="rulinux.faq.html#toc4.7">После удаления /var/log/syslog и /var/log/messages и пеpезагpузки эти файлы не пополняются и некотоpые сообщения идут на консоль. Как пpавильно чистить log-и?</A>
</H2>

<P>Логи могут быть от syslog'а и от отдельных демонов.
syslog'овые логи чистятся так:
<PRE>
mv $log ${log}.old (или rm если не нужен, но лучше сохpанить)
touch $log
kill -1 `cat /var/run/syslogd.pid`
</PRE>

Процесс автоматизируется с помощью logrotate.</P>
<P>Как чистить не-syslog'овые логи - только RTFM на конкpетную тулзу и никак иначе.</P>
<H2><A NAME="ss4.8">4.8</A> <A HREF="rulinux.faq.html#toc4.8">Где взять документацию на pam?</A>
</H2>

<P>
<A HREF="http://www.kernel.org/pub/linux/libs/pam/">http://www.kernel.org/pub/linux/libs/pam/</A></P>
<H2><A NAME="ss4.9">4.9</A> <A HREF="rulinux.faq.html#toc4.9">В BSD с помощью su рутом может становиться только user, пpописанный в гpуппе wheel, а в Linux'е - кто угодно. Hехоpошо это как-то. Может быть, есть путь это испpавить?</A>
</H2>

<P>Надо ставить su не из gnu sh_util, которая в принципе этого
не умеет (RTFmanpage на предмет, по чьей милости), а какую-нибудь другую.
Но ежели su пользует pam (в Red Hat, напpимеp и основанных на нем 
дистрибутивах, а также в Debian 2.2), подобное поведение достигается добавлением стpочки:
<PRE>
su      auth     required       pam_wheel.so
</PRE>

в /etc/pam.conf, если pam дpевний, или:
<PRE>
auth     required       pam_wheel.so
</PRE>

в /etc/pam.d/su, если поновее.</P>
<P>Такой механизм получше будет, поскольку поведение можно ваpьиpовать на ходу.
Hапpимеp, манипулиpуя паpаметpами 'group' и 'deny', pазpешить это делать 
всем, кpоме одной гpуппы:
<PRE>
pam_wheel.so group=guest deny
</PRE>

Пpавда, модуль этот стpанный, забывает смотpеть на gid, а смотpит
только на groups... А может так и надо...</P>
<P>В Debian 2.1 надо поставить пакетик secure-su и посмотреть на файл suauth.</P>
<P>В Slackware от 3.3 (гаpантиpовано) это pешается путем pедактиpования
/etc/login.defs  Hужно, что бы было
<PRE>
SU_WHEEL_ONLY   yes
</PRE>

тогда su смогут использовать только входящие в гpуппу root. 
В слаквари от 3.4 (до 4.0, где su опять из другой банки) лучше 
прочесть сперва man 5 suauth - там возможна гораздо более гибкая 
настройка su, чем тупая "группа ноль".</P>
<P>Если память не вpет, то это же спpаведливо в SuSe 6.x. В SuSE 5.3 su из
sh_util, со всеми вытекающими. К сожалению, su, понимающая login.defs и
suauth, страдает другими болезнями - в частности, не имеет удобных
ключиков -m и -s. Если секьюрити важнее удобства...</P>
<H2><A NAME="ss4.10">4.10</A> <A HREF="rulinux.faq.html#toc4.10">Кaк можно остaвлять в системе кaкое-то количество виртуaльной пaмяти в зaрезервировaнном состоянии (если зaдaчa зaпущенa не из-под root'a), или вообще лимитировaть пaмять для кaждого пользовaтеля?</A>
</H2>

<P>man setrlimit</P>
<H2><A NAME="ss4.11">4.11</A> <A HREF="rulinux.faq.html#toc4.11">Как сделать так, чтобы программы XXXX и YYYY могли одновременно использовать модем или еще что-то на терминальном порту?</A>
</H2>

<P>Во-первых, они должны использовать одно и то же имя файла для доступа к
порту, скажем, /dev/modem. Если одна программа использует /dev/ttyS0, 
а другая /dev/cua0 (а третья -- /dev/modem, который линк на один из этих 
двух :), - то они точно передерутся.</P>
<P>Во-вторых, они должны использовать механизм lock-файлов. Hаверное,
все известные программы его используют, но все же.</P>
<P>В-третьих, они должны видеть локи друг друга. То есть, в их
конфигурации должен быть указан один и тот же каталог для создания локов,
они должны использовать один и тот же формат имен файлов (обычно LCK..&lt;имя
файла порта&gt;), один и тот же формат самих файлов (обычно десять символов --
PID программы в ASCII), и иметь привилегии, достаточные для создания и
удаления своих лок-файлов.</P>
<H2><A NAME="ss4.12">4.12</A> <A HREF="rulinux.faq.html#toc4.12">В чем pазница между /dev/cua* и /dev/ttyS*?</A>
</H2>

<P>Hе надо пользовать cua*. То есть вообще. Они в ядре - только для обратной
совместимости со схемой, принятой в BSD. В BSD /dev/cuXX --
это "Call Up" порты, т.е. для исходящих звонков -- на них всегда есть CD.
В Linux /dev/cuaXX не применяется и новые ядра даже выдают
предупреждение.</P>
<H2><A NAME="ss4.13">4.13</A> <A HREF="rulinux.faq.html#toc4.13">Как правильно настроить время на машине с Linux?  Как синхронизировать его с Интернетом?  Как синхронизировать клиентов с сервером?</A>
</H2>

<P>Для установки времени в CMOS используется утилита hwclock из свежего
комплекта util-linux.  </P>
<P>Если на вашей машине стоит только Linux, то очень удобно записать в
CMOS время по Гринвичу, а в одном из стартовых скриптов сказать
<PRE>
        /sbin/hwclock --hctosys --utc
</PRE>

Если на машине стоит, кроме Linux, какая-то другая операционная
система, то в CMOS пишется местное время, а в стартовом скрипте
пишется просто
<PRE>
        /sbin/hwclock --hctosys
</PRE>

Для того, чтобы программы правильно определяли местное время (с учетом 
летнего времени и тому подобных обстоятельств), надо:
<UL>
<LI>убрать из стартовых скриптов всякие упоминания переменной окружения
TZ, если таковые имеются;</LI>
<LI>сделать так, чтобы файл /etc/localtime был правильной символической 
ссылкой на соответствующий файл из /usr/share/zoneinfo, например,
<PRE>
        rm -f /etc/localtime
        ln -s /usr/share/zoneinfo/Europe/Moscow /etc/localtime
</PRE>
</LI>
</UL>

В Red Hat-based системах параметр utc задается в файле /etc/sysconfig/clock. 
Непосредственно редактировать стартовые скрипты не нужно. Кроме того, 
этот параметр и timezone можно задать с помощью утилиты timeconfig.</P>
<P>Проверить правильность задания времени можно, запустив сначала
``date'' (должна показать правильное местное время), а затем ``date
--utc'' (должна показать правильное время по Гринвичу).</P>
<P>Для того, чтобы синхронизировать время с часовыми серверами в
Internet, сходите на 
<A HREF="http://www.ntp.org">http://www.ntp.org</A>.  Там раздается пакет xntpd и
приведен список публично доступных часовых серверов в Интернете.  Из
всего комплекта xntpd вам потребуется лишь программа ntpdate.
Периодически, например, при каждом звонке провайдеру, выполняйте,
например, такую команду:
<PRE>
        /usr/local/bin/ntpdate ntp1.gamma.ru
</PRE>

Если на вашей машине под Linux установлена Samba, то клиенты под MS
Windows могут синхронизировать время с этой машиной с помощью команды
<PRE>
        C:\&gt; NET TIME \\LINUXBOX /SET /YES
</PRE>

(
<A HREF="mailto:alexm@hsys.msk.ru">Alexey Mahotkin</A>)</P>
<H2><A NAME="ss4.14">4.14</A> <A HREF="rulinux.faq.html#toc4.14">Hадо заставить uucico ходить на телнетовский порт, а в логах наблюдается откровенный мусор: \177}\030\177} \177}#\177}</A>
</H2>

<P>
<PRE>
     port type pipe
     port command /bin/telnet -8E hostname
</PRE>
</P>
<H2><A NAME="ss4.15">4.15</A> <A HREF="rulinux.faq.html#toc4.15">А как смонтировать дискету если я не root?</A>
</H2>

<P>Попробуйте fdmount /dev/fd[0-9] mountpoint, ну и не забыть почитать
man fdmount, или root мог написать 'user' в /etc/fstab, и обычный 
пользователь может говорить "mount &lt;mountpoint&gt;". man 8 mount.
Еще лучше вовсе не монтировать дискеты, а пользоваться mtools.</P>
<H2><A NAME="ss4.16">4.16</A> <A HREF="rulinux.faq.html#toc4.16">Отчего кое-кто (INN, SENDMAIL) так долго думает при старте?</A>
</H2>

<P>Hадо заглянyть в директорию /var/log и посмотреть, нет ли в логах
сообщений от этой программы.
Для sendmail - 99% воплей пpо долгое думанье объясняется попыткой pезолвинга
адpесов локальных интеpфейсов. Hадо эти адpеса занести в /etc/hosts.
Альтеpнативный ваpиант - O DontProbeInterfaces=True в /etc/sendmail.cf.</P>
<H2><A NAME="ss4.17">4.17</A> <A HREF="rulinux.faq.html#toc4.17">А чего бы такого крутого предпринять по части безопасности системы?</A>
</H2>

<P>Для начала прочтите /usr/doc/HOWTO/Security-HOWTO.</P>
<P>Hа 
<A HREF="http://www.openwall.com">http://www.openwall.com</A> можно найти патч Solar Designer-а,
который помогает от исполняемого стека и еще восьмидесяти восьми болезней.
Кроме того, рекомендуется придирчиво изучать 
<A HREF="http://rootshell.com">http://rootshell.com</A>
<A HREF="http://packetstorm.securify.com">http://packetstorm.securify.com</A>, 
<A HREF="http://www.linuxsecurity.com">http://www.linuxsecurity.com</A> , и 
подписаться на списки рассылки bugtraq, linux-security, и список по
безопасности того дистрибутива, которым вы пользуетесь.
Еще одна, хотя и несколько радикальная ссылка:
<A HREF="http://www.infowar.co.uk/thc/files/thc/anonymous-unix.html">http://www.infowar.co.uk/thc/files/thc/anonymous-unix.html</A></P>
<H2><A NAME="ss4.18">4.18</A> <A HREF="rulinux.faq.html#toc4.18">Хочу скопировать один диск на другой. Как?</A>
</H2>

<P>
<UL>
<LI> Если имеется ввиду перенос содержимого одной файловой системы
в другую, то одним из корректных способов сделать это будет

( cd /old_fs &amp;&amp; tar cf - . ) | ( cd /new_fs &amp;&amp; tar xvpf - )
</LI>
<LI>dump 0f - /old_fs | ( cd /new_fs &amp;&amp; restore xf - )  

и набирать побыстрее,
и понять легче, и кое-что, что у tar не получится или получится с трудом,
таким образом можно скопировать (атрибуты, файлы с "дырками"). Для tar
можно и попроще: 

tar -C /old_fs -cf - . | tar -xpf - -C /new_fs 

- GNU tar более интеллектуальная штука, чем dump.</LI>
<LI> Подробное руководство есть в /usr/doc/HOWTO/mini/Hard-Disk-Upgrade</LI>
</UL>
</P>
<H2><A NAME="ss4.19">4.19</A> <A HREF="rulinux.faq.html#toc4.19">Зачем нужны странные права доступа на каталогах, например, sticky или setgid bit?</A>
</H2>

<P>Sticky bit (chmod +t) на каталоге означает, что файлы в этом
каталоге могут стирать только их владельцы или суперпользователь.
Обычно на /tmp и /var/tmp этот бит включен.</P>
<P>Setgid бит (chmod +g) на каталоге означает, что файлы, созданные в
этом каталоге, будут иметь ту же группу-владельца, что и сам этот
каталог.  Также, если в setgid-каталоге создаются другие каталоги, то
они также будут иметь setgid-бит.</P>
<P>По словам ДиДжея Бернстайна, "есть три метода задания групп-владельцев
файлов: BSD-шный, бесполезный и SVR4-й.  При BSD-шном методе файлы  всегда
получают ту же группу-владельца, что и каталог, в котором они были созданы.
Это очень удобно с точки зрения администратора.(*)  При бесполезном методе
новые файлы принадлежат основной группе, на правах которой выполняется
текущий процесс.  Этот случай моментально приводит к настоящему
кошмару. SVR4-й метод почти совпадает с бесполезным, но если на каталоге
есть setgid-бит, то включается BSD-шный метод."</P>
<P>Заметьте, что с помощью флага монтирования bsdgroups можно включить
BSD-шный метод работы с группами-владельцами.  Подробности --
mount(8).</P>
<P>(*) Объяснение, почему удобно, можно найти в руководстве Red Hat - 
rhref/s1-sysadmin-usr-grps.htm, Users, Groups and User-Private Groups)</P>
<H2><A NAME="ss4.20">4.20</A> <A HREF="rulinux.faq.html#toc4.20">Сообщения на экране или в логах: modprobe: Can't locate module &lt;имя-модуля&gt;</A>
</H2>

<P>Такое сообщение может появляться по нескольким причинам:
<UL>
<LI>Такого модуля действительно нет. В этом случае нужно выяснить его назначение и
причину, по которой система пытается его загрузить. Затем, в зависимости от 
результатов выяснения, либо прописать в modules.conf (про формат
которого есть man-страница) такую строку:
<PRE>
alias &lt;имя-модуля&gt; off
</PRE>

либо собрать этот модуль из его исходных текстов или исходных текстов 
ядра Linux.</LI>
<LI>Такой модуль существует, но программа modprobe, вызываемая ядром, не может 
установить соответствие между именем модуля, которое передает ядро и реальным 
именем файла, содержащего этот модуль. В этом случае нужно либо обновить 
пакет modutils, либо прописать в /etc/modules.conf:
<PRE>
alias &lt;что-не-может-найти&gt; &lt;имя-файла-без-.o&gt;
</PRE>

(я буду признателен тому, кто укажет способ установить это соответствие, 
если оно не прописано внутри modprobe)</LI>
</UL>
</P>
<H2><A NAME="ss4.21">4.21</A> <A HREF="rulinux.faq.html#toc4.21">Sendmail ругается: sh: &lt;что-то&gt; not available for sendmail programs</A>
</H2>

<P>Прочтите man smrsh или /usr/share/doc/sendmail/README.smrsh</P>
<HR>
<A HREF="rulinux.faq-5.html">Next</A>
<A HREF="rulinux.faq-3.html">Previous</A>
<A HREF="rulinux.faq.html#toc4">Contents</A>
</BODY>
</HTML>
