<HTML>
<HEAD>
<TITLE>Применение GNU make</TITLE>
</HEAD>
<BODY>

<?php include("/home/maxcom/linux_html/books/head.php3") ?>

<H2> Применение GNU make </H2>

<P>Создание данного текста не имело своей целью дать полное описание работы
команды <EM>make</EM> и призвано всего лишь познакомить читателя с наиболее
простым применением этой утилиты для автоматизации некоторых действий,
сопутствующих программированию в операционной системе <B>UNIX</B>.</P>

<HR>

<P>Создание программы частенько начинается с маленького однофайлового проекта.
Проходит некоторое время и проект, как снежный ком, начинает обрастать
файлами, заголовками, подключаемыми библиотеками, требуемыми опциями
компиляции... и для его сборки становится уже недостаточным сказать "<EM>gcc
-o file file.c</EM>". Когда же, через пару дней, однажды набранная магическая
строчка, содержащая все необходимые для сборки проекта параметры компилятора,
таинственно исчезает в недрах истории вашего командного интерпретатора,
рождается естественное желание увековечить свои знания в виде, к примеру, шелл
скрипта.  Затем, возможно, захочется сделать этот скрипт управляемым
параметрами, чтобы его можно было использовать для разных целей... Однако,
чудо юникса состоит в том, что если вам что-то понадобилось, значит кто-нибудь
это уже сделал, и пришло время вспомнить о существовании команды
<EM>make</EM>.</P>

<P>Рассмотрим несложную программу на <B>C</B>. Пусть программа <B>prog</B>
состоит из пары файлов кода <B>main.c</B> и <B>supp.c</B> и используемого в
каждом из них файла заголовков <B>defs.h</B>. Соответственно, для создания
prog необходимо из пар (<B>main.c defs.h</B>) и (<B>supp.c defs.h</B>) создать
объектные файлы <B>main.o</B> и <B>supp.o</B>, а затем слинковать их в
<B>prog</B>. При сборке вручную, выйдет что-то вроде:</P>

<BLOCKQUOTE><CODE>
<PRE>
cc -c main.c defs.h
cc -c supp.c defs.h
cc -o prog main.o supp.o
</PRE>
</CODE></BLOCKQUOTE>

<P>Если мы в последствии изменим <B>defs.h</B>, нам понадобится полная
перекомпиляция, а если изменим supp.c, то повторную компиляцию <B>main.о</B>
можно и не выполнять.  Казалось бы, если для каждого файла, который мы должны
получить в процессе компиляции указать, на основе каких файлов и с помощью
какой команды он создается, то пригодилась бы программа, которая во-первых,
собирает из этой информации правильную последовательность команд для получения
требуемых результирующих файлов и, во-вторых, инициирует создание требуемого
файла только в случае, если такого файла не существует, или он старше, чем
файлы от которых он зависит. Это именно то, что делает команда <EM>make</EM>!
Всю информацию о проекте <EM>make</EM> черпает из файла <EM>Makefile</EM>,
который обычно находится в том же каталоге, что и исходные файлы проекта.</P>

<P>Простейший <EM>Makefile</EM> состоит из синтаксических конструкций всего
двух типов: <EM>целей</EM> и <EM>макроопределений</EM>.</P>

<P>Цель в <EM>Makefile</EM> - это файл(ы), построение которого предполагается
в процессе компиляции проекта. Описание цели состоит из трех частей: имени
цели, списка зависимостей и списка команд интерпретатора sh, требуемых для
построения цели.  Имя цели - непустой список файлов, которые предполагается
создать.  Список зависимостей - список файлов, из которых строится цель.  Имя
цели и список зависимостей составляют заголовок цели, записываются в одну
строку и разделяются двоеточием. Список команд записывается со следующей
строки, причем все команды начинаются с обязательного символа табуляции.
Возможна многострочная запись заголовка или команд через применение символа
"\" для экранирования конца строки. При вызове команды <EM>make</EM>, если ее
аргументом явно не указана цель, будет обрабатываться первая найденная в
<EM>Makefile</EM> цель, имя которой не начинается с символа ".".  Примером для
простого <EM>Makefile</EM> может послужить уже упоминавшаяся программа
prog:</P>

<BLOCKQUOTE><CODE>
<PRE>
prog: main.o supp.o
	cc -o prog main.o supp.o
main.o supp.o: defs.h
</PRE>
</CODE></BLOCKQUOTE>

<P>В прведенном примере можно заметить ряд особенностей: в имени второй цели
указаны два файла и для этой же цели не указана команда компиляции, кроме
того, нигде явно не указана зависимость объектных файлов от
"<B>*.c</B>"-файлов. Дело в том, что команда <EM>make</EM> имеет
предопределенные правила для получения файлов с определенными суффиксами. Так,
для цели - объектного файла (суффикс "<B>.o</B>") при обнаружении
соответствующего файла с суффиксом "<B>.c</B>", будет вызван компилятор "<B>сс
-с</B>" с указанием в параметрах этого "<B>.c</B>"-файла и всех файлов -
зависимостей. Более того, в этом случае явно не указанные "<B>.c</B>"-файлы
<EM>make</EM> самостоятельно внесет в список зависимостей и будет реагировать
их изменение так же, как и для явно указанных зависимостей. Впрочем, ничто не 
мешает указать для данной цели альтернативную команду компиляции.</P>

<P>Вы вероятно заметили, что в приведенном <EM>Makefile</EM> одни и те же
объектные файлы перечисляются несколько раз. А что, если к ним добавится еще
один? Для упрощения таких ситуаций <EM>make</EM> поддерживает
макроопределения.</P>

<P>Макроопределение имеет вид "<B>ПЕРЕМЕННАЯ = ЗНАЧЕНИЕ</B>". <B>ЗНАЧЕНИЕ</B>
может являться произвольной последовательностью символов, включая пробелы и
обращения к значениям уже определенных переменных. В дальнейшем, в любом месте
<EM>Makefile</EM>, где встретится обращение к переменной-макроопределению,
вместо нее будет подставлено ее текущее значение. Обращение к значению
переменной в любом месте <EM>Makefile</EM> выглядит как <B>$(ПЕРЕМЕННАЯ)</B>
(скобки обязательны, если имя переменной длиннее одного символа). Значение еще
не определенных переменных - пустая строка.  С учетом сказанного, можно
преобразовать наш <EM>Makefile</EM>:</P>

<BLOCKQUOTE><CODE>
<PRE>
OBJS = main.o supp.o
prog: $(OBJS)
	cc -o prog $(OBJS)
$(OBJS): defs.h
</PRE>
</CODE></BLOCKQUOTE>

<P>Теперь предположим, что к проекту добавился второй заголовочный файл
<B>supp.h</B>, который включается только в <B>supp.c</B>. Тогда
<EM>Makefile</EM> увеличится еще на одну строчку:</P>

<BLOCKQUOTE><CODE>
<PRE>
supp.o: supp.h
</PRE>
</CODE></BLOCKQUOTE>

<P>Таким образом, один целевой файла может указываться в нескольких целях. При
этом полный список зависимостей для файла будет составлен из списков
зависимостей всех целей, в которых он участвует, однако создание файла будет
производиться только один раз.</P>

<P>В нашем примере мы группировали <EM>цели</EM> по принципу <EM>общих
зависимостей</EM>, однако существует и альтернативный способ - группировать
<EM>зависимости</EM> по <EM>одной цели</EM>.  В этом случае <EM>Makefile</EM>
будет выглядеть немного иначе, однако его суть не изменится.</P>

<BLOCKQUOTE><CODE>
<PRE>
OBJS = main.o supp.o
prog: $(OBJS)
	cc -o prog $(OBJS)
main.o: defs.h
supp.o: defs.h supp.h
</PRE>
</CODE></BLOCKQUOTE>

<P>Обычно <EM>Makefile</EM> пишется так, чтобы простой запуск <EM>make</EM>
приводил к компиляции проекта, однако, помимо компиляции, <EM>Makefile</EM>
может использоваться и для выполнения других вспомогательных действий,
напрямую не связанных с созданием каких-либо файлов. К таким действиям
относится очистка проекта от всех результатов компиляции, или вызов процедуры
инсталляции проекта в системе. Для выполнения подобных действий в
<EM>Makefile</EM> могут быть указаны дополнительные цели, обращение к которым
будет осуществляться указанием их имени аргументом вызова <EM>make</EM>
(например, "<B>make install</B>").  Подобные вспомогательные цели носят
название <EM>фальшивых</EM>, что связанно с отсутствием в проекте файлов,
соответствующих их именам. <EM>Фальшивая</EM> цель может содержать список
зависимостей и должна содержать список команд для исполнения. Поскольку
<EM>фальшивая</EM> цель не имеет соответствующего файла в проекте, при
<EM>каждом</EM> обращении к ней <EM>make</EM> будет пытаться ее построить.
Однако, возможно возникновение конфликтной ситуации, когда в каталоге проекта
окажется файл с именем, соответствующим имени <EM>фальшивой</EM> цели. Если
для данного имени не определены файловые зависимости, он будет всегда
считаться актуальным (up to date) и цель выполняться не будет. Для
предотвращения таких ситуаций <EM>make</EM> поддерживает "встроенную"
переменную "<B>.PHONY</B>", которой можно присвоить список имен целей, которые
всегда должны считаться <EM>фальшивыми</EM>.</P>

<P>Теперь можно привести пример полного <EM>Makefile</EM>, пригодного для
работы с проектом prog и принять во внимание некоторые часто применяемые
приемы:</P>

<BLOCKQUOTE><CODE>
<PRE>
OBJS = main.o supp.o
BINS = prog
PREFIX = /usr/local

INSTALL = install
INSOPTS = -s -m 755 -o 0 -g 0
CC = gcc
.PHONY = all clean install

all: $(BINS)

prog: $(OBJS)
	$(CC) -o prog $(OBJS)

main.o: defs.h

supp.o: defs.h supp.h

clean:
	rm -f $(BINS)
	rm -f $(OBJS)
	rm -f *~
	
install: all
	for $i in $(BINS) ; do \
	 $(INSTALL) $(INSOPTS) $$i $(PREFIX)/bin ; \
	done
</PRE>
</CODE></BLOCKQUOTE>

<P>Итак, у нас появились три <EM>фальшивых</EM> цели: <B>all</B>, <B>clean</B>
и <B>install</B>. Цель <B>all</B> обычно используется как псевдоним для сборки
сложного проекта, содержащего несколько результирующих файлов (исполняемых,
разделяемых библиотек, страниц документации и т.п.). Цель <B>clean</B>
используется для полной очистки каталога проекта от результатов компиляции и
"мусора" - резервных файлов, создаваемых текстовыми редакторами (они обычно
заканчиваются символом "<B>~</B>"). Цель <B>install</B> используется для
инсталляции проекта в операционной системе (приведенный пример расчитан на
установку только исполняемых файлов). Следует отметить повсеместное
использование макроопределений - помимо всего, этот прием повышает
читабельность. Обратите также внимание на определение переменной <B>$(CC)</B>
- это встроенная переменная <EM>make</EM> и она неявно "сработает" и при
компиляции объектных файлов.</P>

<P>Изложенный материал охватывает далеко не все способности <EM>make</EM>.
Например, в тексте <EM>Makefile</EM> можно применять команды условного
выполнения и разнообразные функции для манипуляции со строками. <EM>Make</EM>
поддерживает большой набор встроенных переменных, а также
<EM>метапеременные</EM>, принимающие разные значения в зависимости от
контекста применения. Например, <B>$*</B> соответствует имени целевого файла
без суффиксов, а <B>$^</B> - полному списку зависимостей для данной цели.</P>

<P>В заключение наиболее пытливых читателей можно отослать к описанию
<EM>make</EM> в формате <EM>info</EM>.</P>
<HR>
<P>Версия 1.1.1</P>
<P>Ваши комментарии по поводу данного опуса, а также сообщения об обнаруженных
неточностях буду рад получить по адресу:
<a href=mailto:Dmitry_Chernyak@p6.f474.n5030.z2.fidonet.org>
Dmitry_Chernyak@p6.f474.n5030.z2.fidonet.org</a></P>
Дмитрий Черняк.

</BODY>
</HTML>

