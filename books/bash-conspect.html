<HTML>
<HEAD>
<TITLE>
bash-conspect
</TITLE>
<META NAME="subject" CONTENT="BASH">
<META NAME="keywords" CONTENT="shell bash script scripting programming
unix gnu sh шелл реферат сценарий конспект compendium">
<LINK REL=stylesheet TYPE="text/css"
      HREF="bash-conspect.css"
      TITLE="grgconsp">
</HEAD>
<BODY bgcolor="white">
<?php include("/home/maxcom/linux_html/books/head.php3") ?>
<H1>
BASH конспект
</H1>
<P>
Дата создания: 16.12.97
</P>

<P>
Источники:
</P>
<OL>

<LI>
bash man page
</LI>
<LI>
/gnu/docs/bash1147/document/featu_*.htm (bash features overview)
</LI>
<LI>
/gnudocs/sh-util1.12/doc/sh_ut?.htm (sh-utils documentation)
</LI>
<LI>
news://comp.unix.shell/faq.shell? (shells FAQ)
</LI>
<LI>
news://comp.unix.shell/bash.faq (bash FAQ)
</LI>
<LI>
csh.whynot (
Tom Christiansen
. Cch Programming Considered Harmful)
</LI>
</OL>

<H1>
ЗАМЕЧАНИЯ ОБ ЭТОМ ДОКУМЕНТЕ
</H1>
<H2>
<P>
В помощь читающим цветную версию
</P>
</H2>
<P>
<STRONG>
<EM>
(в данный момент форматирование документа не завершено;
скоро все будет выглядеть чуть более прилично; :) )
</EM>
</STRONG>
</P>
<P>
Примеры, в которых метаобозначения типа [[команда 1]] или [[аргументы]]
нужно заменить конкретными названиями, набраны </P>
<SPAN CLASS="EXAMPLE0">
<DIR><PRE>
темно-синим цветом.
</PRE></DIR>
</SPAN>
<P>
Примеры отдельных команд или скриптов, готовых к выполнению as is, набраны
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
коричневым цветом.
</PRE></DIR>
</SPAN>
<P>
Если при выполнении скриптов на экран выводятся какие-то результаты, то
эти результаты набраны </P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
бирюзовым цветом.
</PRE></DIR>
</SPAN>
<H2>
<P>
другие особенности
</P>
</H2>
<P>
Мне не удалось подобрать адекватных терминов (однословных) для
перевода слов [[expansion]] и [[shell]], и далее по тексту для избежания
[[несклоняемости]] вместо английских слов используются слова [[экспансия]]
и [[шелл]] (то же самое можно сказать о [[баше]]). Если вы борец за
чистоту русского языка, можете смотреть на фразы
типа [[система сообщает шеллу]] как на [[система сообщает shell'у]],
но лично мне использование русских падежных окончаний после слов,
записанных латинскими буквами, нравится еще меньше, чем введение
варварских неологизмов.
</P>
<P>
Если у вас есть какие-то идеи, напишите, пожалуйста,
по адресу grg@philol.msu.ru
</P>
<H2>
<P>
ЕЩЕ НЕ ОПИСАНЫ:
</P>
<UL>
</H2>

<LI>
filename generation when using output redirection (command &gt;a*)
</LI>
<LI>
test -o optname/s1 == s2/s1 &lt; s2/s1 &gt; s2/-nt/-ot/-ef/-O/-G/-S
</LI>

<LI>
История команд и команды истории (раздел начат);
</LI>

<LI>
READLINE library functions
</LI>
</UL>

<H1>
<P>
BASH
И ЕГО МЕСТО СРЕДИ ДРУГИХ
SHELLS
</P>
</H1>

<P>
BOURNE_SHELL=sh, {ba,k,z}sh
</P>
<P>
C_SHELL={c,tc}sh
</P>
<P>
OTHER_SHELL=rc ssh
</P>

<P>
Различия между bash и sh (а также особенности новейшей версии bash)
описаны в конце документа.
</P>
<H1>
ЗАПУСК BASH И ВЫХОД ИЗ НЕГО. КОНФИГУРАЦИОННЫЕ ФАЙЛЫ
</H1>
<P>
Чтобы запустить какой-то скрипт на исполнение, пишут
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
bash filename
</PRE></DIR>
</SPAN>
<P>
Если нужно выполнить встроенную команду, надо писать
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
bash -c 'command'
</PRE></DIR>
</SPAN>
<H2>
<P>
При запуске
login-shell
</P>
</H2>
<P>
Для всех пользователей: если есть файл

/etc/profile

, выполнить его.
</P>
<P>
Для данного пользователя: выполнить первый из существующих файлов:

~/.bash_profile, ~/.bash_login

или

~/.profile (~&nbsp;--&nbsp;

директория пользователя)
</P>
<H2>
<P>
При выходе из
login-shell
</P>
</H2>
<P>
Выполняется

~/.bash_logout

, если есть.
</P>
<H2>
<P>
При запуске
non-login shell:
</P>
</H2>
<P>
Интерактивный -- выполнить

~/.bashrc.
</P>

<P>
Неинтерактивный -- исполнить файлы с именами

$BASH_ENV

и

$ENV
</P>

<H1>
<P>
УСТРОЙСТВО КОМАНДНОЙ СТРОКИ
</P>
</H1>
Под "командой" далее будет пониматься или отдельная команда, например:
<SPAN CLASS=EXAMPLE>
<DIR><PRE>
ls
</PRE></DIR>
</SPAN>
<P>
-- или так называемый конвеер (pipeline) -- последовательность двух
или более
команд, в которой станартный вывод предшествующей команды передаются на
стандартный ввод последующей:
<SPAN CLASS=EXAMPLE>
<DIR><PRE>
ls | more
</PRE></DIR>
</SPAN>
<P>
В bash синтаксис pipeline несколько расширен по сравнению с sh, и имеет
следующий вид:
</P>
<SPAN CLASS=EXAMPLE>
<DIR><PRE>
[time [-p] ] [ ! ] command [ | command2 ... ]
</PRE></DIR>
</SPAN>
<P>
-- где в факультативную часть входит "time" -- зарезервированное слово,
используемое для измерения времени, затраченного на выполнение команды,
а также "!" -- знак отрицания, меняющий код завершения команды на
противоположный.
<P>
Обычно pipeline находится на одной строке. Если требуется разместить
ее на нескольких строках, несколько строк можно объединять в одну
логическую
строку, используя знак переноса "\". На одной строке можно записывать
несколько команд, разделяя их специальными знаками (см. ниже).
</P>

<P>
Командная строка может состоять из одной или нескольких команд
(точнее, pipelines).  Для группирования команд применяются следующие
символы:
</P>
<H2>
символы  ";" и "&amp;" -- выполнение нескольких команд
</H2>
Выполнить обе команды:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
команда1; команда2  # последовательное выполнение
команда1& команда2  # параллельное выполнение
</PRE></DIR>
</SPAN>
<P>
Символ ";" используется для последовательного выполнения нескольких
команд:
после завершения одной команды начинается выполение другой. Если вместо
";" используется "&amp;", то команда, сопровождаемая этим знаком,
выполняется
в фоновом режиме, а выполнение следующей команды начинается немедленно,
и, таким образом, две или более команд выполняются параллельно.
<P>
Note that wherever you see a `;' in the description of a command's syntax,
it may be replaced indiscriminately with one or more newlines.
</P>
<H2>
Символы "&amp;&amp;" и "||"  -- условное выполнение команд
</H2>
<P>
Выполнить команду1, и если она выполнилась удачно, выполнить команду2:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
команда1 &amp;&amp; команда2
</PRE></DIR>
</SPAN>
<P>
Выполнить команду1, и если она выполнилась неудачно, выполнить команду2:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
команда1 || команда2
</PRE></DIR>
</SPAN>
<P>
Как известно, каждая команда возвращает некоторый код завершения,
по которому можно судить об "успешности" выполнения. Если на командную
строку смотреть как на логическое выражение, значение которого
требуется вычислить, где отдельные команды -- переменные, принимающие
значение "истина" или "ложь", то знаки "&amp;&amp;"
и "||" можно рассматривать как операции логического И и ИЛИ. Отсюда
понятна
и логика действия этих связок в командой строке: если первая
из двух команд, соединенных связкой И, возвращает "ложь", то результат
всего выражения -- заведомо "ложь", поэтому вторая команда не выполняется;
аналогично, если первая из двух команд, соединенных связкой ИЛИ, первая
выполнилась успешно, то уже известно, что результат всего выражения --
"истина", и вторая команда не выполняется.
</P>
<P>
В отличие от подобных операций в Си, связки "||" и "&amp;&amp;" в
bash имеют
<B>одинаковый приоритет</B>, то есть выражение "A || B &amp;&amp; C"
аналогично
"(A || B) &amp;&amp; C", но не "A || (B &amp;&amp; C)". Для изменения
приоритета (порядка выполнения) можно использовать круглые или фигурные
скобки
(см. ниже)
</P>
<H2>
<P>
символы {} -- группирование команд в один pipeline
</P>
</H2>
<P>
Чтобы сделать перенаправление ввода-вывода для нескольких команд, вместо
</P>
<SPAN CLASS=EXAMPLE0>
<DIR><PRE>
"cmd1 &gt;a; cmd2 &gt;&gt;a"
</PRE></DIR>
</SPAN>
<P>
-- можно писать
</P>
<SPAN CLASS=EXAMPLE0>
<DIR><PRE>
"{ cmd1 ; cmd2; } &gt;a"
</PRE></DIR>
</SPAN>

<H2>
символы ( )
</H2>
<P>
( ) -- команды, после выполнения которых сделанные ими изменения
environment vars восстанавливаются
</P>
<P>
Напр. строка:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
a="global"; (a="local"; echo now a is $a); echo and now $a
</PRE></DIR>
</SPAN>
<P>
выведет:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
now a is local
and now global
</PRE></DIR>
</SPAN>
<P>
И фигурные, и круглые скобки можно использовать для группирования команд
с целью изменения порядка выполнения команд со связками "||" и
"&amp;&amp;".
<H2>
Проверка значения арифметического выражения с помощью (( ))
</H2>
<P>
Выражение, заключенное в двойные круглые скобки, будет вычислено
по правилам вычисления арифметических выражений, действующих,
кроме данного случая, еще и для конструкции $(()) и команды let.
После вычисления выражения команда считается выполненной успешно
(и возвращается код 0) в том случае, если результат отличен от нуля,
и неуспешно в случае равенства результата нулю.
</P>
<H2>
символ  !
</H2>
<P>
<SPAN CLASS=EXAMPLE0>
<DIR><PRE>
! команда
</PRE></DIR>
</SPAN>
-- отрицание: ставится перед командой для отрицания кода ее выхода
</P>
<H1>
<P>
ЭКСПАНСИЯ
</P>
</H1>
<P>
Экспансия -- процесс анализа командной строки с целью нахождения в
ней специальных обозначений (выражений) и подстановки на их место
соответствующих значений.
</P>
<P>
Если надо посмотреть результат экспансии набранной в данный момент строки,
можно нажать

M-C-e (Esc,&nbsp;Ctrl-e)

, а затем можно вернуть на место прежнюю строку через

undo (Ctrl-"-").
</P>

<P>
Порядок экспансии таков:
</P>
<H2>
<P>
1. {}-экспансия
 (bash specific)
</P>
</H2>
<P>
Создает преамбулы и постамбулы

:
</P>
<P>
{prefix1,prefix2,...}radix{suffix1,suffix2,...}
</P>

<P>
Напр. создать структуру директорий:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
mkdir /usr/{bin,lib,libexec,local,share{,/man,/doc,/misc,/locale},X11R6{,/bin,/lib,/man,/share}}
</PRE></DIR>
</SPAN>
<P>
создаст:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
/usr/lib
/usr/libexec
/usr/local
/usr/share
/usr/share
/usr/share/man
/usr/share/doc
/usr/share/misc
/usr/share/locale
/usr/X11R6
/usr/X11R6/bin
/usr/X11R6/lib
/usr/X11R6/man
/usr/X11R6/share
</PRE></DIR>
</SPAN>
<H2>
<P>
2. ~-экспансия
</P>
</H2>
<P>
~/ -- директория текущего пользователя
</P>
<P>
~user1/ -- директория пользователя

user1
</P>
<P>
~+ -- $PWD
</P>
<P>
~- -- $OLDPWD
</P>

<H2>
3. $-экспансия
</H2>

<P>
${n} -- Если цифр больше одной, номер  параметра надо брать в {}
<P>
${n:-default} -- если параметр или переменная пусты, подставить default
<P>
${var:=default} -- только для переменных: если переменная пуста, присвоить
ей default и подставить это значение
<P>
${n:?message} -- если пусто, выдать сообщение message и прекратить работу
<a name=emptyvalue>
<P>
${n:+value} -- если пусто, оставить пустым, а иначе подставить value;
аналог в Си: 'flag ? string : ""'
<P>
$# -- количество аргументов, в отличие от Си $0 не считается
<P>
${#n} -- длина параметра или переменной
<P>
${n#pattern} отрезать начало, совпадающее с паттерн (shortest matching)
<P>
${n##pattern} отрезать начало, совпадающее с паттерн (longest matching)
<P>
${n%pattern} отрезать конец, совпадающий с паттерн (shortest matching)
<P>
${n%%pattern} отрезать конец, совпадающий с паттерн (longest matching)

<P>
Пример:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
set $1="--file=a.txt"
echo ${1#--file=}
</PRE></DIR>
</SPAN>
<P>
выведет
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
a.txt
</PRE></DIR>
</SPAN>

<P>
$*, $@
</P>
<DIR><PRE>

<P>
Если надо при передаче всех аргументов сохранить исходные кавычки,



используется "$@" (именно в двойных кавычках!).



А "$*" передают все аргументы как один, тоже в кавычках.



Без кавычек $* $@ эквивалентны и не годятся для передачи



аргументов в кавычках.
</P>
</PRE></DIR>
<P>
$? -- код выхода последней команды, в т. ч. встроенной (cp. DOS errorlevel)
</P>

<P>
$$ -- PID, очень полезно для создания временных файлов с уникальными
именами:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
tmpfile1=tmp1$$
tmpfile2=tmp2$$
</PRE></DIR>
</SPAN>
<P>
$!    ???
</P>

<P>
Expands to the process ID of the most recently executed background
(asynchronous) command.
</P>

<P>
$_    Последний аргумент предыдущей команды.
</P>

<P>
$-

Флаги для команды

set.
</P>

<a name="backquotes">
<H2>
<P>
4. командная подстановка
</P>
</H2>
<P>
$( ) и ` ` (обратные кавычки). Заменяются на вывод команды без символов новой строки
</P>
<P>
`команда`
</P>
<P>
-- старый стиль, обрабатываются внутренние

backslashes

. чтобы сделать вложение, внутри надо писать:
</P>
<P>
&#9;`команда1 \`команда2\``
</P>
<P>
$(команда)
</P>
<P>
-- новый стиль

 (bash specific)

, все

,

 что внутри

,

 без обработки рассматривается как команда. Чтобы сделать вложение,
 надо писать:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
$(command1 $(command2))
</PRE></DIR>
</SPAN>
<H2>
<P>
5. арифметическая подстановка
</P>
</H2>

<P>
$((

)) или $[

 ]
</P>

<P>
Есть, среди прочих, операции &lt;&lt; и &gt;&gt;
</P>
<P>
Переменные можно использовать как с "

$"

, так и без.
</P>
<P>
Есть все виды присваивания:
</P>
<DIR><PRE>

<P>
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
</P>
</PRE></DIR>

<P>
Понимает префиксы 0 и 0x.
</P>

<P>
n

# -- префикс, указывающий любую [позиционную] систему счисления
</P>
<H2>
<P>
6. подстановка процесса
 (bash specific)
</P>
</H2>
<P>
Возможна на системах, поддерживающих

named pipelines(FIFOs)
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE0">
&gt;(команды)
</PRE></DIR>
</SPAN>

<P>
-- отправить вывод команды в некоторый файл и передать имя этого файла как
аргумент другой команде.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
&lt;(команды)
</PRE></DIR>
</SPAN>

<P>
--

отправить вывод команд в файл и подставить имя этого файла
</P>
<P>
Пример. Сравнить выводы программ

newprogram

и

oldprogram:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
diff &lt;(newprogram) &lt;(oldprogram)
</PRE></DIR>
</SPAN>
<P>
Еще пример. Загрузить вывод команды

ls

в редактор

vi:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
vi &lt;(ls)
</PRE></DIR>
</SPAN>
<P>
Следует заметить, что выполнение именно этой команды соответствует
ожиданиям, тогда как команда:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
ls | vi
</PRE></DIR>
</SPAN>

<P>
--

приведет или к сообщению об ошибке, или к другим неожиданным последствиям.
</P>
<H2>
<P>
7. разбиение на слова
</P>
<P>
8. path-экспансия
</P>
</H2>
<P>
Обрабатывает ?, *,  [

list

] и [^

list

] в именах файлов
</P>

<P>
* --

все файлы, кроме начинающихся на "."
</P>
<P>
.* -- файлы, начинающиеся на "."
</P>
<P>
Чтобы сделать шаблон, которому бы соответствовали все файлы, в том числе
начинающиеся на ".", но исключая файлы "." и ".."
, надо использовать сразу три шаблона:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
.[^.]*  .??*  *
</PRE></DIR>
</SPAN>

<P>
--

потому что:
</P>
<UL>
<LI>
".[^.]*" включает все файлы с одной точкой в начале (но не с двумя),
в именах которых на втором месте не стоит "."
</LI>
<LI>
".??" включает все файлы, состоящие из точки и еще двух знаков, что
позволит исключить файл ".."
</LI>
<LI>
"*" включает все файлы, не начинающиеся с "."
</LI>
</UL>
<H2>
<P>
9. удаление кавычек
</P>
</H2>
<P>
В конце экспансии все кавычки, кроме экранированных (

\")

 удаляются
</P>
<H1>
Кавычки и экранирование специальных символов
</H1>
<H2>
Метасимволы и их экранирование
</H2>
<P>
Метасимволы -- это специальные символы, выполняющие роль разделителей слов
(таких, как аргументы командной строки и названия команд). Некоторые
метасимволы
играют также роль знаков препинания. К метасимволам относятся знаки:
<dir>
  <table>
		<tr>
		<td>|</td>
		<td>&amp;</td>
		<td>;</td>
		<td>( )</td>
		<td>< ></td>
		<td>пробел</td>
		<td>табулятор</td>
		</tr>
	</table>
</dir>
<P>
Иногда требуется включить метасимвол в состав слова, избежав его
использования
в качестве разделителя слов. Для этого перед метасимволом ставится
обратная косая
черта, которая и означает, что непосредственно следующий за ней
специальный символ
должен быть лишен своего специального значения и воспринят
"буквально". Операция
постановки косой черты назвается экранированием. Примеры будут приведены
далее,
после рассмотрения еще двух способов включения специальных символов в
состав слов.
<H2>
Двойные и одинарные кавычки.
</H2>
<H2>
Другие виды кавычек
</H2>
<P>
Для записи управляющих символов с помощью эскейп-последовательностей,
используется
следующая конструкция:
</P>
<SPAN CLASS="EXAMPLE0">
<DIR><PRE>
$'escape-sequence'
</PRE></DIR>
</SPAN>
<P>
Например:
</P>
<SPAN CLASS="EXAMPLE">
<DIR><PRE>
echo Backspaces inserted in this string will remove a whole$'\b\b\b\b\b'
word
</PRE></DIR>
</SPAN>
</P>

<H1>
ПЕРЕНАПРАВЛЕНИЕ
</P>
</H1>
<P>
Самые интересные сведения о перенаправлении, изложенные ниже, взяты из [[

csh.whynot]].

Этот документ слишком интересен и информативен для того, чтобы полностью
пересказывать его здесь, поэтому ниже приводятся лишь некоторые сведения.
</P>
<P>
Можно запретить перенаправление вывода "&gt;" в уже существующий
файл(см. про переменную

noglobber

), но "&gt;|" работает всегда&#9;
</P>
<P>
При нескольких перенаправлениях существенен порядок:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
&#9;command 2&gt;&amp;1 1&gt;a.txt
</PRE></DIR>
</SPAN>
<P>
перенаправит

sdderr

 на

stdout

, а

stdout

 на a.txt, а вот
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
&#9;command 1&gt;a.txt 2&gt;&amp;1
</PRE></DIR>
</SPAN>

<P>
--

перенаправит и то и другое в a.txt, так как во время обработки
2&gt;&amp;1 /

dev

/fd1 будет уже перенаправлен.
</P>
<P>
Мощные возможности для [[динамического]] перенаправления внутри скрипта
дает команда

exec

 (см.). Собственно запуск процесса

exec

при данном применении не осуществляется, поэтому опишем это применение
здесь.
</P>
<H2>
<P>
перенаправление "здесь документы"
</P>
</H2>
<P>
Пример из

news://comp.unix.shell:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
#!/bin/bash
ftp -n &lt;&lt; EOF
<BR>
open somehost.somedomain
user Anonymous aaa@bbb.com
<BR>
cd /pub/upload
<BR>
put /home/me/myfile.txt
<BR>
quit
<BR>
EOF
</PRE></DIR>
</SPAN>
<P>
Опция -

n

 В этом скрипте заставляет

ftp

не спрашивать имя пользователя и пароль, предоставляя возможность
воспользоваться командой user в следующей форме:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
user&nbsp;USER_NAME&nbsp;PASSWORD
</PRE></DIR>
</SPAN>
<H2>
<P>
динамическое перенаправление
</P>
</H2>
<P>
Если аргумент для команды

exec

не указан, но указаны символы перенаправления,

exec

устанавливает эти перенаправления, и выполнение текущего скрипта
продолжается. Таким образом достигается [[динамическое]] перенаправление:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
#!/bin/bash
echo
Эта строка выводится на экран
exec &gt;file.txt
echo
А эта строка в файл
echo И эта в файл
</PRE></DIR>
</SPAN>

<P>
--

выведет на экран только одну строку, а две других запишет в

file.txt
</P>

<H2>
<P>
дескрипторы
</P>
</H2>
<H3>
открытие новых дескрипторов
</H3>
<P>
Кроме возможности дублировать существующие дескрипторы (0, 1,
2) другими, также уже существующими, (напр. 2 &gt;&amp;1) или
перенаправлять существующие дескрипторы в файл (напр. 1&gt;log.txt),
имеется возможность открывать новые, прежде закрытые дескрипторы с
номерами 3 и более.
</P>
<P>
В следующем примере сначала создается (с применением перенаправления
here documents]]) файл os.txt, затем с этим файлом связывается дескриптор
4, из файла читается одна строка и записывается в файл, связанный с
дескриптором 3 ( docname.txt):
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
#!/bin/bash
#создать файл-пример для последующего чтения
cat &lt;&lt; EOF &gt;os.txt
ОПЕРАЦИОННЫЕ СИСТЕМЫ
UNIX
DOS
OS/2
Windows NT
EOF
echo Открываем дескрипторы 3 и 4
exec 3&gt;docname.txt
exec 4&lt;os.txt
echo Читаем одну строку через дескриптор 4
read d &lt;&amp;4
echo Записываем строку через дескриптор 3
echo $d &gt;&amp;3
</PRE></DIR>
</SPAN>

<P>
-- запишет в файл docname.txt строку [[ОПЕРАЦИОННЫЕ СИСТЕМЫ]].
</P>
<H3>
восстановление перенаправленных дескрипторов
</H3>
<P>
Если требуется перенаправить ввод или вывод временно, а затем отменить
это перенаправление, информацию, ассоциируемую перераправляемую с
дескриптором, можно запомнить в одном из неиспользуемых дескрипторов,
а затем восстановить его. Следующий пример представляет собой
усовершенствование одного из примеров, данных выше:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
#!/bin/bash
echo Эта строка выводится на экран
# запомнить дескриптор 1 в дескрипторе 3, а 1 перенапавить в file.txt:
exec 3&gt;&amp;1 1&gt;file.txt
echo А эта строка в файл
echo И эта в файл
# восстановить предыдущее значение дескриптора 1:
exec 1&gt;&amp;3
echo Эта строка опять на экран
</PRE></DIR>
</SPAN>

<P>
--

выведет:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
Эта строка выводится на экран
Эта строка опять на экран
</PRE></DIR>
</SPAN>

<P>
--

а две другие строки запишет в файл

file.txt
</P>

<P>
Известно, как передать через

pipe

и

stdout,

и

stderr:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE0">
command1 2&gt;&amp;1 | command2
</PRE></DIR>
</SPAN>
<P>
А вот как можно передать информацию со

stderr

программы через pipe другой программе, оставив при этом

stdout:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE0">
command1 3&gt;&amp;1 2&gt;&amp;1 1&gt;&amp;3 | command2
</PRE></DIR>
</SPAN>
<P>
Здесь

stdout (1)

запоминается в дескрипторе

3,

затем

stderr (2)

перенаправляется в

stdout (1),

а сам

stdout

перенаправляется в 3 (запомненное значение дескриптора 1). Поскольку через

pipe

передается только информация, выводимая через дескриптор 1, дескриптор 3
(которому ранее было присвоено значение

stdout

) останется нетронутым.
</P>
<P>
Вот пример из [[

csh.whynot]]

, иллюстрирующий этот прием:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
grep yyy xxx 3&gt;&amp;1 2&gt;&amp;1 1&gt;&amp;3 3&gt;&amp;- | sed
s/file/foobar/
</PRE></DIR>
</SPAN>

<P>
--

 выведет:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
grep: xxx: No such foobar or directory (ENOENT)
</PRE></DIR>
</SPAN>
<H3>
закрытие дескриптора
</H3>
<P>
Закрытие дескриптора осуществляется дублированием его псевдодескриптором "

&amp;-":
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
#!/bin/bash
exec 1&gt;&amp;-
echo
Этот текст никто не увидит
</PRE></DIR>
</SPAN>
<H1>
<P>
КОМАНДЫ
 ИЗ НАБОРА
SHELL-UTILS
</P>
</H1>
<P>
Некоторые из перечисленных здесь команд обычно являются одновременно
внешними командами из набора

SHELL-UTILS

и встроенными командами

bash.
</P>

<P>
Подробное описание команд из этого набора см. в документации к

GNU SHELL-UTILS.
</P>

<H2>
<P>
команды
echo, pwd, test
</P>
</H2>
<P>
Внешние команды, echo, pwd и test дублируют встроенные команды bash
и немного от них отличаются. Например, встроенная команда
BASH echo не воспринимает
escape- последовательности как таковые, если не указать специальную опцию
"-e".
</P>

<P>
То есть, если написать 'echo "message1\nmessage2"', bash не заменит "\n"
на новую строку, а просто выведет эти символы на экран. Внешняя же команда
echo всегда обрабатывает escape- последовательности и не требует ключа
"-e".
</P>

<P>
Чтобы вызвать внешнюю команду вместо встроенной, нужно или указать путь,
например "/bin/echo" вместо "echo", или запретить использование некоторой
внутренней команды ( enable -n echo) , и тогда bash будет искать внешнюю.
</P>
<P>
Проверить, дублируется ли некоторая внутренняя команда внешней, можно
с помощью " type -a команда".
</P>
<H2>
<P>
let
</P>
</H2>
<P>
Вычисляет арифметическое выражение и возвращает 0, если оно не равно
нулю, и не-0 -- иначе. Среди прочих операций есть присваивание (=)
можно присваивать значение переменной. В этом случае имя переменной
должно быть без префикса "$", в прочих случаях можно и с "$" и без него.
</P>
<H2>
<P>

[ ], test &amp; /usr/bin/test
</P>
</H2>
<P>
Проверяет истинность условия (тестирует условие).
</P>
<P>
Существует в виде как встроенной, так и внешней команды. Если вместо
слова test используются квадратные скобки, они обязательно должны быть
отделены от аргументов пробелом, потому что на самом деле "["&nbsp;≈ это
название команды, а " ]"&nbsp;≈ обязательный последний аргумент этой
команды.
</P>
<P>
Можно комбинировать и отрицать условия:
</P>
<P>
[ условие1 - a условие2 ] Логическое И
</P>
<P>
[ условие1 - o условие2 ] Логическое ИЛИ
</P>
<P>
[ ! условие ] Логическое НЕ
</P>
<P>
Основные тесты:
</P>

<P>
-t [ fd ] истина, если file descriptor fd (по умолчанию 0) не
перенаправлен
</P>
<P>
Напр. '! - t 0 ' -- осуществляется ли ввод с клавиатуры
</P>
<P>
Файлы:
</P>
<P>
-e file Истина, если существует
</P>

<P>
-s file Истина, если имеет ненулевой размер
</P>
<P>
Пустая директория также может иметь ненулевой размер. Поэтому проверять,
пуста ли директория, надо примерно так (пример из comp.unix.shell):
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
dir=${1:-.} # for a standalone script
set -- $dir/.??* $dir/.[!.] $dir/*
case $#$* in
  "3$dir/.??* $dir/.[!.] $dir/*")
    echo empty ;;
  *)
    echo not empty ;;
esac
</PRE></DIR>
</SPAN>

<P>
-d file Директория
</P>

<P>
-f file Обычный файл (не директория)
</P>

<P>
file1 -ot file2 Старее (older than)
</P>
<P>
file1 -nt file2 Новее (newer than)
</P>

<P>
Строки:
</P>

<P>
-z string Пустая
</P>

<P>
-n string Не пустая
</P>

<P>
string1 = string2
</P>
<P>
string1 != string2
</P>

<P>
Числа:
</P>

<P>
arg1 -eq arg2 Равно
</P>
<P>
также -ne, -lt, -le, -gt, -ge
</P>
<P>
(not equal, less than, less or equal, greater than etc.)
</P>

<H2>
<P>
expr (внешняя команда)
</P>
</H2>
<P>
Выводит результат выражения
</P>
<P>
A == B
</P>
<P>
A + B
</P>
<P>
A &amp;&amp; B
</P>
<P>
A || B
</P>
<P>
length string
</P>
<P>
substr string index length
</P>
<P>
match string regexp

или

string : regexp
</P>

<P>
Выводит номер символа, с которого начинается совпадение. Если в
выражении есть "\(\)", вместо номера печатается часть строки, совпавшая
с выражением в скобках.
</P>
<P>
В отличие от test, expr обычно не является встроенной командой, а
имеется только в exe- файле.
<STRONG>
Часто лучше не использовать!
</STRONG>
Может замедлить выполнение скрипта в десятки раз. Везде, где это возможно,
лучше применять test или let.
</P>
<P>
Например, вместо:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
expr $i + 1 == $n &amp;&amp; break
</PRE></DIR>
</SPAN>
<P>
лучше писать:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
let i+1==n &amp;&amp; break
</PRE></DIR>
</SPAN>
<P>
или:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
[ $[$i+1] = "$n" ] &amp;&amp; break
</PRE></DIR>
</SPAN>
<H2>
<P>
tee
</P>
</H2>
<P>
Название английской буквы " T". T-shaped pipe splitter.
</P>

<P>
Перенаправляет вывод стразу во много мест (файлов)
</P>
<P>
Ключ " -a" заставляет дополнять существующие файлы, а не затирать.
</P>
<H2>
date
</H2>
<P>
Команда date не является командой bash, а входит в набор
SHELL-UTILS. Однако
представляется нелишним описать ее здесь, ввиду ее исключительной
полезности
для некоторых задач, традиционно решаемых написанием shell-скриптов,
а также
потому, что по причине обилия возможностей она имеет довольно
нетривиальный
синтаксис. Кроме описания, ниже будут даны примеры решения практических
задач, связанным с обращением к данным о дате и времени, которые взяты
из сообщений в comp.unix.shell
</P>
<P>
К сожалению, помимо сложного синтаксиса работу с date затрудняет еще и то,
что разные реализации date могут иметь опции с одинаковым названием и
совершенно разными функциями. Приводимые ниже примеры тестировались
на /bin/date из FreeBSD 2.2.5. В некоторых случаях в примерах указаны
также отличия этой реализации от date из набора GNU SHELL-UTILS
</P>
<P>
Формат вывода даты задается например так
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
date +%d.%m.%y
</PRE></DIR>
</SPAN>
<P>
Ключ -v (-d в GNU date) позволяет напечатать не сегодняшнюю дату, а,
например,
завтрашнюю:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
date -v +1d	  # /bin/date
date -d "+1 day"  # то же для GNU date
</PRE></DIR>
</SPAN>
<P>
или какая была месяц назад
:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
date -v -1m	    # /bin/date
date -d "-1 month"  # GNU date
</PRE></DIR>
</SPAN>
<P>
Вот такая команда, записанная в скрипте /etc/daily будет копировать
каждый день выпуск сегодняшних новостей newsDDMMYY.txt в файл
newstoday.txt:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
cp `date +news%d%m%y.txt` newstoday.txt
</PRE></DIR>
</SPAN>
<H2>
<P>
Работа с именами файлов: basename, dirname, pathchk
</P>
</H2>

<P>
basename -- имя файла без пути; если в качестве второго документа задать
расширение, оно тоже отрезается
</P>
<P>
dirname --
пусть к файлу без самого имени файла
</P>
<P>
pathchk -- проверить, допустимо ли имя файла или пути в данной системе
</P>
<P>
Внимание! Так же как при работе с expr (см.) и другими внешними
командами, следует избегать частого применения данных утилит по причине
замедления ими работы. dirname и basename без каких либо трудностей
можно реализовать с помощью операций над переменными. В следующем
примере определяются функции dirname и basename, идентичные по своему
поведению одноименным утилитам dirname и basename, и демонстрируется их
применение:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
basename()
{
  local name="${1##*/}"
  echo "${name%$2}"
}

dirname()
{
  local dir="${1%${1##*/}}"
  [ "${dir:=./}" != "/" ] &amp;&amp; dir="${dir%?}"
  echo "$dir"
}

fullpath=${1:-/dir/file.ext}
name=`basename "$fullpath"`
dir=`dirname "$fullpath"`
echo "file '$name' is located in $dir"
</PRE></DIR>
</SPAN>
<P>
-- выведет:
</P
<SPAN EXAMPLE2>
<DIR><PRE>
file 'file.ext' is located in /dir
</PRE></DIR>
</SPAN>
<P>
Для того чтобы всегда вызывать эти функции вместо соответствующих внешних
утилит, можно переименовать их в basename и dirname и записать в отдельный
файл, например path.sh, а в файлы с использующими эти функции скрипты,
добавить ". path.sh" (см. команду "." и source).
</P>
<P>
Полезными могут также оказаться функции для определения расширения имени
файла (назовем ее ext) и имени файла без расширения (namename):
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
function ext
{
  local name=${1##*/}
  local name0="${name%.*}"
  local ext=${name0:+${name#$name0}}
  echo "${ext:-.}"
}

function namename
{
  local name=${1##*/}
  local name0="${name%.*}"
  echo "${name0:-$name}"
}
</PRE></DIR>
</SPAN>
<P>
Обратите внимание на то, что ни одна из показанных выше функций не
вызывает других функций из этого же набора, хотя, например, dirname
могла бы вызвать basename и отрезать от полного пути полученное из
basename значение, однако такой вызов не осуществляется из соображений
оптимизации скорости работы этих функций.
</P>
<H2>
Другие внешние команды
</H2>

<P>
true
</P>
<P>
false
</P>
<P>
yes
</P>
<P>
printf
</P>
<P>
tty -- чем является стандартный ввод (tty / not tty)
</P>
<P>
sleep -- заснуть на столько-то секунд
</P>
<P>
nohup --
запуск программы, продолжающей работать после
logoff
</P>
<P>
&nbsp;
</P>
<UL>
<H3>
Информация о пользователях:
</H3>
<P>
id, logname, whoami, groups, users, who
</P>
<P>
&nbsp;
</P>
<H3>
Информация о системе:
</H3>
<P>
uname, hostname
</P>
<H1>
<P>
ENVIRONMENT
И АТРИБУТЫ БАША
</P>
</H1>
<P>
Environment&nbsp;≈ массив переменных, который наследуется вызываемыми
башем программами. Это не все переменные, а только те, которые унаследовал
сам баш, и те созданные в баше переменные, которым был присвоен признак
"экспортируемых".
</P>
<P>
Атрибуты баша, или флаги, включают особые режимы функционирования баша.
Устанавливаются командой set (см.).
</P>
<H2>
export
</H2>
<P>
Команда export и используется добавления переменных к environment.
</P>
<P>
Переменные, созданные в баше, не входят автоматически в
environment (массив переменных, наследуемый запускаемыми
программами). Однако это можно изменить с помощью команды
set (см.).
</P>
<P>
Экспортировать можно как переменные, так и функции (-f).
</P>
<P>
В принципе, команда export не нужна, так как вместо нее можно использовать
declare&nbsp;-x.
</P>
<P>
Чтобы изъять переменную из environment, нужно использовать
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
export -n var
</PRE></DIR>
</SPAN>
<H2>
declare, typeset
</H2>
<P>
typeset -- устаревшее, но разрешенное название declare. Используйте это
название, если хотите обеспечить с совместимоть с Korn shell.
</P>
<P>
Без аргументов выводит значения всех переменных. Если вызвана таким
образом из скрипта, ведет себя довольно странно: сначала выводит
текст скрипта, предшествующий команде set, затем все переменные, а
затем&nbsp;≈ текст скрипта, следующий за командой.
</P>
<P>
Если нет аргументов, но указаны опции, выводит определения переменных,
имеющих такие опции, а именно:
</P>
<DIR><PRE>
-a -- массивы
<P>
-f -- функции
</P>
<P>
-i -- целые числа
</P>
<P>
-r -- только для чтения
</P>
<P>
-x --
экспортируемые
</P>
</PRE></DIR>
<P>
Если есть аргументы, то создаются переменные с указанными опциями или
изменяются опции существующих. Если опция указана со знаком "
+" вместо "-", она удаляется. Переменным попутно можно присвоить значения.
</P>
<P>
Пример:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
declare -irx MAGIC_NUMBER=666
</PRE></DIR>
</SPAN>
<P>
-- создает переменную MAGIC_NUMBER, которую нельзя изменять, которая
всегда будет рассматриваться как целое число и которая автоматически
добавляется к
environment
, как если бы была выполнена команда
export.
Кроме того, переменной присваивается значение.
</P>
<P>
Экспортировать и делать только для чтения можно не только переменные, но
и функции (-f).
</P>
<P>
Внутри функций declare создает локальные переменные, аналогично local. В
ksh (и в нек. реализациях sh?), не имеющем команды local, для создания
локальных переменных можно использовать синоним declare typeset.
</P>

<P>
Опция опция -p показывает атрибуты переменной или всех переменных,
если переменная не указана.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
declare -r
</PRE></DIR>
</SPAN>
<P>
выведет что-нибудь вроде:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
declare -ri EUID="42"
declare -ri PPID="1"
declare -ri UID="42"
</PRE></DIR>
</SPAN>
<P>
-- однако просто declare выведет переменные без указания их признаков.
Зато:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
export -p
</PRE></DIR>
</SPAN>
<P>
работает так, как можно было бы ожидать от declare -p
</P>

<H2>
<P>
readonly
</P>
</H2>
<P>
Делает переменную или функцию (-f) read only или выводит список таких
переменных (-p) . Аналогичную вещь делает 'declare -r', так что эта
команда лишняя.
</P>
<H2>
<P>
unset
</P>
</H2>
<P>
Отменяет определение переменной или функции (-f).
</P>

<H2>
<P>
set
</P>
</H2>
<P>
Опции, переданные set , устанавливают атрибуты самого баша. Если вместо
"-" перед атрибутом идет "+", атрибут сбрасывается. Если есть аргументы,
set присваивает их позиционным параметрам $1, $2 и т. д.
</P>
<P>
Без опций и аргументов выводит все переменные. Если вызвана таким
образом из скрипта, ведет себя довольно странно, как и команда declare
(см.).
</P>
<P>
Атрибуты могут задаваться в короткой или длинной форме. В длинной
форме&nbsp;≈ через опцию -o. Опция -o без параметров выводит значения
всех атрибутов:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
set -o
</PRE></DIR>
</SPAN>
<P>
выведет что-нибудь вроде:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
allexport	on
braceexpand	on
emacs		on
errexit		off
histexpand	on
ignoreeof	off
interactive-comments	on
monitor		off
noclobber	off
noexec		off
noglob		off
nohash		off
nounset		off
physical	off
posix		off
privileged	off
verbose		off
vi		off
xtrace		off
</PRE></DIR>
</SPAN>
<P>
Интересные атрибуты:
</P>

<P>
emacs (нет короткого названия) -- расширенные возможности
редактирования. В интерактивных шеллах установлена по умолчанию.
</P>

<P>
vi (нет короткого названия) -- возможности редактирования, аналогичные
командам vi
</P>
<P>
a (allexport) -- автоматический экспорт всех переменных
</P>

<P>
e (errexit) -- прекращать работу, если команда, не входящая в группу,
или группа команд возвратила ненулевое значение. При прекращении работы
не выдается никаких сообщений.
</P>

<P>
f (noglob) -- запрещает обрабатывать маски (*, ? и т. д.).
</P>
<P>
h (hashall) -- запоминать пути к выполненным командам (по умолчанию)
</P>

<P>
n (noexec) -- не выполнять команды, только проверить их правильность
</P>

<P>
v (verbose) -- аналог echo on в ДОС
</P>

<P>
x (xtrace) -- расширенный аналог verbose
</P>
<P>
n (nounset) -- рассматривать использование неопределенной переменной как
ошибку
</P>

<P>
C (noclobber) -- см. про переменную noclobber
</P>
<P>
P (physical) -- при смене текущей директории на линк, делать именем
текущей директории не имя линка, а имя физической директории.
</P>

<P>
"--" -- если за этим ничего не следует, unset позиционные параметры.
</P>
<H1>
<P>
ВСТРОЕННЫЕ КОМАНДЫ (SHELL BUILTINS)
</P>
</H1>
<H2>
<P>
команда ":" (двоеточие)
</P>
</H2>
<P>
Осуществляет анализ командной строки, но не выполняет ее.
Всегда завершается успешно.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
#!/bin/bash
: $[a=2*2]
echo "a=$a"
</PRE></DIR>
</SPAN>
<P>
-- выведет:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE2">
a=4
</PRE></DIR>
</SPAN>
<P>
Значение переменной $a было присвоено в результате [[побочного эффекта]]
анализа, выполненного командой ":".
</P>
<H2>
<P>
source
или "."  (точка)
</P>
</H2>
<P>
Выполняет команды из указанного файла в текущем баше, без запуска нового,
как если бы содержимое файла набиралось на клавиатуре. Это позволяет,
в отличие от выполнения скрипта, запомнить изменения в environment,
определения функций и прозвищ. Используя эту команду, в программу
можно включать "библиотечные" функции, определенные в других файлах.
</P>
<H2>
<P>
enable
</P>
</H2>
<P>
Запрещает (-n) или снова разрешает применение встроенной команды.
</P>
<P>
Когда запрещается, то вместо встроенной команды ищется файл, если
его нет -- ошибка
</P>
<H2>
<P>
exec
</P>
</H2>
<P>
Если имеется аргумент, заменяет текущий процесс (bash) на выполняемую
команду, и к башу возврата уже не происходит:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
PerlProgram $scriptname &amp;&amp; exec perl $scriptname
</PRE></DIR>
</SPAN>
<P>
Если аргумент не указан, но указаны символы перенаправления, exec
устанавливает эти перенаправления, и выполнение текущего скрипта
продолжается. Подробнее см. [[Перенаправление]] </P>
<P>
Таким образом достигается [[динамическое]] перенаправление.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
echo Эта строка выводится на экран
exec &gt;file.txt
echo А эта строка в файл
echo И эта в файл
</PRE></DIR>
</SPAN>
<P>
Более того, можно открывать для ввода или вывода новые дескрипторы:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
# создать файл-пример для последующего чтения
cat &lt;&lt; EOF &gt;user.rsp
29.06.77
30.01.85
EOF
exec 3&gt;file.log
exec 4&lt;user.rsp
echo Вводим дату через дескриптор 4
read d &lt;&amp;4
echo Дата получена и будет записана через дескриптор 3
echo $d &gt;&amp;3
</PRE></DIR>
</SPAN>
<H2>
<P>
getopts
</P>
</H2>

<P>
getopts названия-опций переменная [ альтернативные-аргументы ]
</P>

<P>
Действует аналогично Си-функции getopt . Названия опций состоят из
букв, соответствующих опциям. Если опция требует аргумент, после буквы
ставится двоеточие.
</P>
<P>
Понимает "--" и дальше опции не смотрит Ни фига не понимает длинные    .
опции (--опция)							       .
</P>
<P>
! Если есть альтернативные аргументы, то анализируют их, а не $1-$n
</P>

<P>
Если опция имеет аргумент, он помещается в OPTARG.
</P>
<P>
OPTIND сначала равен 1, затем гетопт его увеличивает. Если надо
запустить гетопт снова, надо снова присвоить единицу.
</P>
<P>
После первого неудачного гетопта ($? не равен 0) $OPTIND равен номеру
первого аргумента, не являющегося опцией, если такой есть ($OPTIND
&lt;= $#). Чтобы обработать этот и последующие аргументы, нельзя писать
${$OPTIND}, поскольку номер параметра обязан быть константой. Вместо
этого нужно сделать
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
shift $[$OPTIND-1]
</PRE></DIR>
</SPAN>
<P>
и обращаться к $1 и т. д. </P>
<P>
Если ошибочная опция, в переменной присваивается "?", и выдается
сообщение об ошибке. Чтобы запретить вывод сообщений, надо или OPTERR=0
(по умолчанию 1), или первый символ в названиях опций ":".
</P>
<P>
Пример:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
while getopts "qhe:v" arg
do
  echo "Opt: $arg ${OPTARG:+($OPTARG)}"
  case $arg in
    q) quiet=1;; # установить quiet mode
    h) echo Using: $0 [-q] [-h] [-e scriptfile] FILES...;
       exit;;
    e) scriptfile=OPTARG;; # задать файл с программой
  esac
done
shift $[$OPTIND-1]
while [ -n "$1" ]
do
  echo Processing file $1...
  # разные действия...
  shift
done
</PRE></DIR>
</SPAN>
<H2>
<P>
hash
</P>
</H2>
<P>
Показывает таблицу запомненных расположений команд. Можно стереть (-r),
вопрос только в том, зачем то и другое.
</P>
<H2>
<P>
pushd, popd, dirs
</P>
</H2>

<P>
dirs выводит стек запомненных директорий
</P>

<P>
popd удаляет или последнюю запомненную, или такую-то по счету сверху
стека (+0..n) или снизу (-0..n).
</P>
<H2>
<P>
type
</P>
</H2>
<P>
Похожа на команду which.
</P>

<P>
Информация о том, как проинтерпретировалась бы команда, будь
она набрана в командной строке: Полное имя файла или сообщение
типа 'shell builtin' или 'aliased to...'.
</P>

<P>
можно только тип ( -t): file, builtin, alias, keyword
</P>

<P>
Можно вывести все альтернативы ( -a ), например
type -a ls" вернет "/bin/ls и ls is aliased to `gnuls --color=tty'"
</P>

<H2>
<P>
ulimit
</P>
</H2>
<P>
Показывает или устанавливает ограничения на что-либо. Можно показать все
ограничения (-a)
</P>

<H2>
<P>
umask
</P>
</H2>
<P>
Атрибуты, с которыми создаются файлы данного пользователя. Без
параметров показывает текущие в виде числа или букв (- S)
</P>

<H2>
<P>
alias, unalias
</P>
</H2>
<P>
создают и удаляют прозвища
</P>
<H1>
<P>
ИСТОРИЯ КОМАНД И КОМАНДЫ ИСТОРИИ
</P>
</H1>
<H3>
history
</H3>
<P>
Показывает всю историю, или последние n команд.
</P>
<H3>
символ	!
</H3>
<P>
!! -- Предыдущая команда
</P>

<P>
!-n -- энная с конца команда
</P>

<P>
!n -- энная с начала команда
</P>
<P>
!строка -- одна из последних команд, начинающаяся строкой
</P>
<P>
!?строка -- -"- содержащая строку
</P>

<P>
&nbsp;
</P>

<P>
^строка1^строка2 -- последняя команда, в которой строка1 заменена
на строку2
</P>
<P>
команды fc и многие другие, пока лень разбираться.
</P>
<H1>
<P>
ПЕРЕМЕННЫЕ
</P>
</H1>
<H2>
<P>
PS1, PS2, PS3, PS4, PROMPT_COMMAND
</P>
</H2>
<P>
Подсказки, по умолчанию:
</P>

<P>
PS1 "bash\$"
</P>

<P>
Если пусто ([ -z "$PS1" ]) , шелл не интерактивный.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
[ -n "$PS1" ] &amp;&amp; echo interactive || echo batch job
</PRE></DIR>
</SPAN>
<P>
PS2 "&gt;" -- запрос продолжения ввода
</P>
<P>
PS3 "" -- подсказка при read
</P>

<P>
PS4 "+" -- команда, выполненная в режиме трассировки (set -x)
</P>

<P>
PROMPT_COMMAND -- команда, выполняемая всякий раз перед показом PS1
</P>
<P>
Есть динамически вычисляемые escape-последовательности:
</P>

<P>
\w -- текущий каталог (полный путь)
</P>
<P>
\W -- текущий подкаталог, без пути к нему
</P>

<P>
\u -- user
</P>
<P>
\h -- host
</P>

<P>
\$ -- "$" для обычного пользователя и "#" для root
</P>
<P>
и т. д.
</P>
<H2>
<P>
Другие
</P>
</H2>

<P>
RANDOM
</P>
<P>
PWD
</P>
<P>
OLDPWD
</P>

<P>
REPLY -- см. read и select
</P>

<P>
BASH -- путь к текущему башу
</P>
<P>
SHLVL -- номер копии баша ?
</P>
<P>
SECONDS -- сколько секунд запущен баш
</P>
<P>
LINENO -- номер строки в текущем скрипт-файле или функции
</P>

<P>
BASH_VERSION -- версия баша
</P>
<P>
HOSTTYPE -- тип машины, напр.: "PCAT" (IBM PC AT), "i586"
</P>
<P>
OSTYPE -- тип операционной системы, напр.: "MSDOS", "linux",
"freebsd2.2.5"
</P>

<P>
MAIL -- файл, в который приходит почта, если не задано, что-нибудь
вроде
</P>
<SPAN CLASS="EXAMPLE0">
<DIR><PRE>
/var/mail/user
</PRE></DIR>
</SPAN>
<P>
MAILCHECK -- через сколько секунд проверять почту, по умолчанию 60
</P>
<H2>
<P>
OPTARG, OPTIND, OPTERR
</P>
</H2>
<P>
Результаты последнего getopts (см.)
</P>

<H2>
<P>
булевые
</P>
</H2>

<P>
nolinks -- если установлена, превращать symlinks в настоящие файлы
</P>

<P>
noclobber
</P>

<P>
выдавать ошибку при попытке перенаправить ("&gt;") в существующий файл,
но можно использовать "&gt;|"
</P>
<P>
И другие...
</P>
<H1>
<P>
ОПЕРАТОРЫ
</P>
</H1>
<H2>
<P>
другие
</P>
</H2>

<P>
until test-commands; do consequent-commands; done
</P>
<P>
while test-commands; do consequent-commands; done
</P>

<a name="if">
<H2>
if
</H2>
<DIR><PRE>
<SPAN CLASS="EXAMPLE0">
if test-commands; then
  consequent-commands;
[elif more-test-commands; then
  more-consequents;]
[else alternate-consequents;]
fi
</PRE></DIR>
</SPAN>
<P>
Вместо if можно также использовать символы группирования команд "
&amp;&amp;" и " ||":
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
[ -e config.txt ] &amp;&amp; echo configuring... || echo no config
</PRE></DIR>
</SPAN>
<H2>
<P>
for
</P>
</H2>

<P>
for name [in words ...]; do commands; done
</P>

<P>
Пример.
</P>
<P>
Склеить текстовые файлы в один, указав для каждого файла его название:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
echo "{directory $PWD}" &gt; texts.lst
for fn in *.txt
do
  echo "{file $fn}" &gt;&gt; texts.lst
  cat $fn &gt;&gt; texts.lst
done
</PRE></DIR>
</SPAN>
<P>
Если "in ..." не указано, проходит по всем параметрам (т. е. in&nbsp;"$@")
</P>
<P>
Пример.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
for fn # список не указан, подразумевается "$@"
do
  echo Processing file $fn...
  # разные действия...
done
</PRE></DIR>
</SPAN>
<H2>
<P>
select, read
</P>
</H2>
<P>
Делает меню для выбора:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
select a in strings;
do if [ -n "$a" ] # строка непуста только при допустимом выборе
   then echo $a eto klass
   break
else
   echo $REPLY eto ne otvet  # то что было введено сохраняется в $REPLY
fi;
done
</PRE></DIR>
</SPAN>

<P>
read без аргументов тоже запоминает строку в REPLY
</P>
<H2>
case
</H2>

<SPAN CLASS="EXAMPLE0">
<DIR><PRE>
case слово in
 [значение [| значение]...) команды;;]...
esac
</PRE></DIR>
</SPAN>
<P>
значение может содержать ?  и *
</P>
<P>
Пример.
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
for name in a.gz b.tar c.zip d.txt /kernel
do
  echo -n "$name: "
  case $name in
    /kernel) echo "Ядро";;
    *.txt) echo "Текстовый файл";;
    *.gz|*.tar|*.zip) echo "Архив";;
    *.c) echo "Программа на Си";;
    *.cc|*.C|*.cpp|*.cx) echo "Программа на C++";;
    *) echo "А это еще что?";;
  esac
done
</PRE></DIR>
</SPAN>
<H1>
<P>
ФУНКЦИИ
</P>
</H1>
<P>
Да, есть такие.
</P>
<P>
Синтаксис вызова функции такой же, как у скрипта. Как и скрипт, функция
может иметь аргументы, и, аналогично скрипту, обращаться к ним через
${n}. Функция не может обращаться к аргументам командной строки скрипта,
в файле которого она сама находится, так как ${n} показывает на ее
собственные аргументы.
</P>
<P>
Может возвращать значение через return. Отсутствие значения или всего
оператора return эквивалентно наличию return 0.
</P>

<H2>
<P>
function, return
</P>
</H2>
<P>
Пример:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
function Warning()
{
  echo "Warning: $1"
  echo "continue(y/n)?"
  read answer
  if [ o"$answer" != o"y" ]; then
  &#9;return 1	# 1 Значит "ошибка, ложь"!!!
  else
       return 0  # 0 -- Удачное завершение, истина!!!
  fi
}
if Warning "the string is empty!"; then
&#9;echo OK;
else
&#9;echo Operation aborted
fi
</PRE></DIR>
</SPAN>
<P>
Если поместить некоторую функцию А в теле функции Б, то реально А
будет определена только после вызова Б. Но после этого А будет видна
глобально, если в конце Б не сделать unset.
</P>

<H2>
<P>
local
</P>
</H2>
<P>
объявляет локальные переменные внутри функций, и может сразу задать им
значение
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
local a
local b=kuku
</PRE></DIR>
</SPAN>
<a name="#FAQ">
<H1>
<P>
ИОО: Иногда отвечаемые ответы
</P>
</H1>
<H2>
<P>
shells FAQ
</P>
</H2>
<P>
Источник: faq.shell из comp.unix.shell
</P>

<P>
В источнике 79 ответов, разбитых на 7 разделов. Полезные ответы, имеющие
отношение к башу, приводятся ниже.
</P>
<H3>
1.2 Что значит "{некоторое странное название команды}"
</H3>

<P>
cat = "catenate"
</P>
<P>
awk = "Aho, Weinberger and Kernighan"
</P>
<P>
grep = "Global Regular Expression Print" (аналог команды ed "g/re/p")
</P>
<P>
fgrep = "Fixed GREP"; fgrep searches for fixed strings only.
</P>
<P>
Perl = "Pathologically Eclectic Rubbish Lister"
</P>
<P>
Unics (Unix) = "UNiplexed Information and Computing System"
</P>
<P>
gecos = "General Electric Comprehensive Operating Supervisor"
</P>
<P>
biff = "BIFF"
<BLOCKQUOTE>
  &#147;... This command, which turns on asynchronous mail notification,
  was actually named after a dog at Berkeley.&#148;
</BLOCKQUOTE>
</P>
<P>
rc (напр. ".bashrc" или "/etc/rc") = "RunCom"
</P>
<P>
&nbsp;
</P>
<H3>
2.5 Как считать со стандартного ввода один символ
</H3>
<P>
Используя команды dd и stty:
</P>
<DIR><PRE>

<SPAN CLASS="EXAMPLE">
stty -icanon
echo -n "Enter a character: "
readchar=`dd if=/dev/tty bs=1 count=1 2&gt;/dev/null`
echo "Thank you for typing a $readchar ."
stty icanon
</PRE></DIR>
</SPAN>
<P>
Про dd см. в документации к SHELL-UTILS
</P>
<H3>
2.6 Как переименовать все файлы *.html в *.htm
</H3>
<P>
мой ответ:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
find -name '*.html' | while read a; do mv $a ${a%.html}.htm; done
</PRE></DIR>
</SPAN>
<H3>
2.12 Как обратиться к параметру номер i , если i не константа, а
переменная?
</H3>
<P>
Можно подумать, что это легко и можно написать ${$i}, но это не
сработает, и вам напишут bad substitution.
</P>
<ul>
<li> Примечание. Начиная с bash 2.0 можно использовать конструкцию ${!i}. 
</ul>

<P>
Зато можно вот так:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
eval "param=\${$i}"
echo "Parameter number $i is $param"
</PRE></DIR>
</SPAN>

<P>
А вот программа, которая выводит все свои параметры в обратном порядке,
(C) 1997 ГС:
</P>
<DIR><PRE>
<SPAN CLASS="EXAMPLE">
i=$#
while let i
do
  eval "echo \${$i}"
  i=$[i-1]
done
</PRE></DIR>
</SPAN>
<H2>
<P>
BASH FAQ
</P>
</H2>
<P>
Источник: bash.faq из comp.unix.shell
</P>
<H3>
Последняя версия
BASH
</H3>
<P>
Самая последняя версия bash -- 2.01. Она почти не отличается от 2.0,
зато довольно сильно отличается от версии 1.14.7, предшествующей 2.0.
</P>
<P>
Новые возможности по сравнению с 1.14.7:
</P>
<UL>
<LI>
зарезервированное слово time для вычисления времени выполнения программы
</LI>
<LI>
одномерные массивы
</LI>
<LI>
новые виды экспансии:

${param:length:offset}, ${param/pat/replace-to}
</LI>

<LI>
новые команды disown и shopt
</LI>

<LI>
новые виды кавычек для locale-specific translations, обозначения $'...' и
$"...".
</LI>
<LI>
ссылки на переменные: {$! param_name } будет вычислена переменная с
именем, хранящимся в $ param_name (в старом для этого нужен eval)
</LI>
</UL>
<H3>
Чем BASH отличается от SH
</H3>
<P>
В SH отсутствуют следующие возможности BASH:
</P>
<UL>

<LI>
новые возможности BASH 2.0 (см. выше)
</LI>

<LI>
long named options (для вызова bash)
</LI>

<LI>
отрицание !
</LI>
<LI>
слово function (по слухам, в некоторых реализациях sh это слово есть)
</LI>
<LI>
команда select
</LI>

<LI>
обращение к параметрам больше девятого ${10}
</LI>

<LI>
длина параметра ${#param}, "редактирование" ${var#str}, ${var%str}
</LI>

<LI>
нет переменных: BASH, BASH_VERSION, BASH_VERSINFO, UID, EUID,
<STRONG>
REPLY
</STRONG>
, TIMEFORMAT, PPID,
<STRONG>
PWD
</STRONG>
, OLDPWD, SHLVL,
<STRONG>
RANDOM
</STRONG>
, SECONDS, LINENO, HISTCMD,
<STRONG>
HOSTTYPE
</STRONG>
,
<STRONG>
OSTYPE
</STRONG>
, MACHTYPE,
<STRONG>
HOSTNAME
</STRONG>
,
<STRONG>
ENV
</STRONG>
,
<STRONG>
PS3
</STRONG>
,
<STRONG>
PS4
</STRONG>
, DIRSTACK, PIPESTATUS, HISTSIZE, HISTFILE, HISTFILESIZE, HISTCONTROL,
HISTIGNORE, GLOBIGNORE, PROMPT_COMMAND, FCEDIT, FIGNORE, IGNOREEOF,
INPUTRC, SHELLOPTS,
<STRONG>
OPTERR
</STRONG>
, HOSTFILE, TMOUT, histchars, auto_resume
</LI>

<LI>
перенаправление

&lt;&gt;, &amp;&gt;, &gt;|
</LI>

<LI>
echo -e (в некоторых реализациях имеется), hash -p (то же), type -apt,
</LI>

<LI>
test -o optname/s1 == s2/s1 &lt; s2/s1 &gt; s2/-nt/-ot/-ef/-O/-G/-S
</LI>

<LI>
разные конфигурационные файлы для интерактивного или неинтерактивного
сеанса: ~/. bashrc и $ENV соотв .
</LI>

<LI>
функции и переменные с одинаковыми именами
</LI>

<LI>
{ }- экспансия: {префиксы}корень{суффиксы}
</LI>
<LI>
обозначение ~ (имеется в некоторых реализациях)
</LI>
<LI>
let (в некоторых реализациях есть команда с таким же именем, но
отличающимся поведением)
</LI>

<LI>
$((expr)) -- только $[] или вообще нет ?
</LI>
<LI>
вместо $(...) только `...`
</LI>

<LI>
подстановки процессов &gt;(cmd) &lt;(cmd)
</LI>
<LI>
alias и unalias (имеются в некоторых реализациях)
</LI>
<LI>
local (в некоторых реализациях есть команда с таким же именем, но
отличающимся поведением)
</LI>
<LI>
история команд (в некоторых реализациях)
</LI>
<LI>
команды command, builtin, declare, typeset, dirs, enable, help, logout,
popd, pushd
</LI>
<LI>
экспортируемые функции
</LI>

<LI>
filename generation when using output redirection (command &gt;a*)
</LI>
</UL>
<hr>
16.12.1997-23.09.1998, <a href="http://www.linux.org.ru/~grg/">Григорий Строкин</a> (<a href="mailto:grg@philol.msu.ru">grg@philol.msu.ru</a>)
</BODY>
</HTML>
